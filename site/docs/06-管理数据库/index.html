
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="贝格迈思数据库使用手册">
      
      
      
      
        <link rel="prev" href="../05-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/">
      
      
        <link rel="next" href="../07-%E5%90%91%E9%87%8F%E7%89%B9%E6%80%A7/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.4.6">
    
    
      
        <title>管理数据库 - 手册</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.35e1ed30.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.356b1318.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Ubuntu";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="mo" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="手册" class="md-header__button md-logo" aria-label="手册" data-md-component="logo">
      
  <img src="../../assets/new-logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            手册
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              管理数据库
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/aminerdocs/docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="手册" class="md-nav__button md-logo" aria-label="手册" data-md-component="logo">
      
  <img src="../../assets/new-logo.png" alt="logo">

    </a>
    手册
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/aminerdocs/docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../01-AISQL%E7%AE%80%E4%BB%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AiSQL简介
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    快速上手
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            快速上手
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    快速安装部署
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/SQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SQL基本操作
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/BCQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BCQL基本操作
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%88%9B%E5%BB%BAJava%E7%A4%BA%E4%BE%8B%E5%BA%94%E7%94%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    创建Java示例应用程序
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    应用开发
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            应用开发
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    构建应用
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            构建应用
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/JAVA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Java
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Go/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Go
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Python/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Python
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Node.js/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Node.js
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C%2B%2B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C%23/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C#
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Ruby/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Ruby
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Rust/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Rust
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/PHP/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PHP
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%85%A8%E5%B1%80%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    构建全局应用程序
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    构建多云应用程序
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            构建多云应用程序
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    概述
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../04-%E9%83%A8%E7%BD%B2%E9%9B%86%E7%BE%A4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    部署集群
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../05-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数据迁移
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    管理数据库
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    管理数据库
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    集群管理与监控
  </a>
  
    <nav class="md-nav" aria-label="集群管理与监控">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    安装部署
  </a>
  
    <nav class="md-nav" aria-label="安装部署">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    资源管理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    添加主机
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    集群管理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    参数配置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    任务状态
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    监控告警
  </a>
  
    <nav class="md-nav" aria-label="监控告警">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    集群总览
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    集群监控
  </a>
  
    <nav class="md-nav" aria-label="集群监控">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    集群信息
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    慢查询分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql" class="md-nav__link">
    SQL分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    日志分析
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    集群告警
  </a>
  
    <nav class="md-nav" aria-label="集群告警">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    告警列表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    接收人设置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    规则设置
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    系统与安全
  </a>
  
    <nav class="md-nav" aria-label="系统与安全">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    操作审计
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    通知服务器设置
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    权限管理
  </a>
  
    <nav class="md-nav" aria-label="权限管理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    用户管理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    角色管理
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    管理工具
  </a>
  
    <nav class="md-nav" aria-label="管理工具">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sql_1" class="md-nav__link">
    SQL客户端
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jupyterlab" class="md-nav__link">
    JupyterLab
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    应用
  </a>
  
    <nav class="md-nav" aria-label="应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#brightgpt" class="md-nav__link">
    BrightGPT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    图文检索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#brightbi" class="md-nav__link">
    BrightBI
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    更改集群配置
  </a>
  
    <nav class="md-nav" aria-label="更改集群配置">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    示例场景
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    配置新机器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mserver" class="md-nav__link">
    启动MServer服务器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbserver" class="md-nav__link">
    启动DBServer服务器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    执行数据移动
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mserver_1" class="md-nav__link">
    mserver法定人数变更
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbserver-mserver" class="md-nav__link">
    更新 DBServer 上的mserver地址
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    清理
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    诊断报告
  </a>
  
    <nav class="md-nav" aria-label="诊断报告">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    收集的数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    收集的指标示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    配置诊断收集
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    安全权限
  </a>
  
    <nav class="md-nav" aria-label="安全权限">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    安全检查清单
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    启用认证
  </a>
  
    <nav class="md-nav" aria-label="启用认证">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    启用用户认证
  </a>
  
    <nav class="md-nav" aria-label="启用用户认证">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    默认用户和密码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql" class="md-nav__link">
    启用BSQL身份验证
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    创建登录配置文件
  </a>
  
    <nav class="md-nav" aria-label="创建登录配置文件">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    启用登录配置文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    管理登录配置文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    查看登录配置文件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    配置客户端认证
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    认证方式
  </a>
  
    <nav class="md-nav" aria-label="认证方式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    密码认证
  </a>
  
    <nav class="md-nav" aria-label="密码认证">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb" class="md-nav__link">
    BMDB数据库密码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    密码认证方式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scram-sha-256" class="md-nav__link">
    启用 SCRAM-SHA-256 身份验证
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scram-sha-256_1" class="md-nav__link">
    创建使用 SCRAM-SHA-256 密码身份验证的集群
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#md5scram-sha-256" class="md-nav__link">
    对现有的MD5密码进行迁移至SCRAM-SHA-256
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    重置用户密码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ldap" class="md-nav__link">
    LDAP认证
  </a>
  
    <nav class="md-nav" aria-label="LDAP认证">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    简单绑定模式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    搜索+绑定模式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    配置示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    基于主机的认证
  </a>
  
    <nav class="md-nav" aria-label="基于主机的认证">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_hbaconf" class="md-nav__link">
    bsql_hba.conf 文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    记录字段
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    信任认证
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    基于角色的访问控制
  </a>
  
    <nav class="md-nav" aria-label="基于角色的访问控制">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    概述
  </a>
  
    <nav class="md-nav" aria-label="概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    角色
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    资源
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_63" class="md-nav__link">
    权限
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_64" class="md-nav__link">
    管理用户和角色
  </a>
  
    <nav class="md-nav" aria-label="管理用户和角色">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_65" class="md-nav__link">
    创建角色
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_66" class="md-nav__link">
    授予角色
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_67" class="md-nav__link">
    创建角色层次结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_68" class="md-nav__link">
    列出角色
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_69" class="md-nav__link">
    撤销角色
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_70" class="md-nav__link">
    删除角色
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_71" class="md-nav__link">
    授权
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_72" class="md-nav__link">
    行级安全机制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_73" class="md-nav__link">
    列级安全机制
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_74" class="md-nav__link">
    传输加密
  </a>
  
    <nav class="md-nav" aria-label="传输加密">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_75" class="md-nav__link">
    创建服务器证书
  </a>
  
    <nav class="md-nav" aria-label="创建服务器证书">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_76" class="md-nav__link">
    创建服务器证书
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_77" class="md-nav__link">
    生成根证书文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_78" class="md-nav__link">
    将根证书复制到各个节点目录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_79" class="md-nav__link">
    为每个节点生成密钥和证书文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_80" class="md-nav__link">
    将配置文件复制到节点
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_81" class="md-nav__link">
    启用服务器之间的加密
  </a>
  
    <nav class="md-nav" aria-label="启用服务器之间的加密">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_82" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mserverdbserver" class="md-nav__link">
    配置MServer和DBServer节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mservers" class="md-nav__link">
    启动 MServers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbserver_1" class="md-nav__link">
    启动 DBServer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_83" class="md-nav__link">
    连接到集群
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_84" class="md-nav__link">
    启用客户端到服务端的加密
  </a>
  
    <nav class="md-nav" aria-label="启用客户端到服务端的加密">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_85" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbserver_2" class="md-nav__link">
    配置DBServer节点
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_86" class="md-nav__link">
    连接到集群
  </a>
  
    <nav class="md-nav" aria-label="连接到集群">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_87" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bmdb_1" class="md-nav__link">
    连接到BMDB集群
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tls" class="md-nav__link">
    TLS和认证
  </a>
  
    <nav class="md-nav" aria-label="TLS和认证">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_88" class="md-nav__link">
    示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_89" class="md-nav__link">
    静态加密
  </a>
  
    <nav class="md-nav" aria-label="静态加密">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_90" class="md-nav__link">
    启用加密
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_91" class="md-nav__link">
    轮换新钥匙
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_92" class="md-nav__link">
    禁用加密
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_93" class="md-nav__link">
    列级加密
  </a>
  
    <nav class="md-nav" aria-label="列级加密">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_94" class="md-nav__link">
    对称加密
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_95" class="md-nav__link">
    非对称加密
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_96" class="md-nav__link">
    审计
  </a>
  
    <nav class="md-nav" aria-label="审计">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_97" class="md-nav__link">
    跟踪语句
  </a>
  
    <nav class="md-nav" aria-label="跟踪语句">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_98" class="md-nav__link">
    设置日志记录选项
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_99" class="md-nav__link">
    查看日志
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_100" class="md-nav__link">
    会话示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_101" class="md-nav__link">
    下一步
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_102" class="md-nav__link">
    配置审计日志
  </a>
  
    <nav class="md-nav" aria-label="配置审计日志">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_103" class="md-nav__link">
    启用审核日志记录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_104" class="md-nav__link">
    自定义审核日志记录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_105" class="md-nav__link">
    示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_106" class="md-nav__link">
    会话级审计日志
  </a>
  
    <nav class="md-nav" aria-label="会话级审计日志">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_107" class="md-nav__link">
    会话级示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_108" class="md-nav__link">
    对象级审计日志
  </a>
  
    <nav class="md-nav" aria-label="对象级审计日志">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_109" class="md-nav__link">
    对象级示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_110" class="md-nav__link">
    备份恢复
  </a>
  
    <nav class="md-nav" aria-label="备份恢复">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_111" class="md-nav__link">
    备份和还原
  </a>
  
    <nav class="md-nav" aria-label="备份和还原">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_112" class="md-nav__link">
    导出和导入
  </a>
  
    <nav class="md-nav" aria-label="导出和导入">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_113" class="md-nav__link">
    导出单个数据库
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_114" class="md-nav__link">
    导出单个表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_115" class="md-nav__link">
    导出所有数据库
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_116" class="md-nav__link">
    导入
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_117" class="md-nav__link">
    分布式快照
  </a>
  
    <nav class="md-nav" aria-label="分布式快照">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_118" class="md-nav__link">
    创建快照
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_119" class="md-nav__link">
    删除快照
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_120" class="md-nav__link">
    恢复快照
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_121" class="md-nav__link">
    将快照移至外部存储
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_122" class="md-nav__link">
    从外部存储恢复快照
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#point-in-time-recovery" class="md-nav__link">
    Point-in-time recovery
  </a>
  
    <nav class="md-nav" aria-label="Point-in-time recovery">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_123" class="md-nav__link">
    怎么运行的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pitr" class="md-nav__link">
    启用和禁用 PITR
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_124" class="md-nav__link">
    恢复到某个时间点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_125" class="md-nav__link">
    局限性
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_126" class="md-nav__link">
    时间点回复
  </a>
  
    <nav class="md-nav" aria-label="时间点回复">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_1" class="md-nav__link">
    BSQL
  </a>
  
    <nav class="md-nav" aria-label="BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#universe" class="md-nav__link">
    设置universe
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_127" class="md-nav__link">
    撤消数据更改
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_128" class="md-nav__link">
    撤消元数据更改
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_129" class="md-nav__link">
    监控指标
  </a>
  
    <nav class="md-nav" aria-label="监控指标">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_130" class="md-nav__link">
    指标
  </a>
  
    <nav class="md-nav" aria-label="指标">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_131" class="md-nav__link">
    吞吐量和时延
  </a>
  
    <nav class="md-nav" aria-label="吞吐量和时延">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_2" class="md-nav__link">
    BSQL查询处理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iops" class="md-nav__link">
    数据库 IOPS（读取和写入）
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_132" class="md-nav__link">
    连接数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_133" class="md-nav__link">
    缓存和存储
  </a>
  
    <nav class="md-nav" aria-label="缓存和存储">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#iops_1" class="md-nav__link">
    存储层IOPS
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_134" class="md-nav__link">
    块缓存
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_135" class="md-nav__link">
    布隆过滤器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sst" class="md-nav__link">
    SST 文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_136" class="md-nav__link">
    压实
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#memtable" class="md-nav__link">
    Memtable
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#wal" class="md-nav__link">
    预写日志记录 (WAL)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#raft" class="md-nav__link">
    Raft
  </a>
  
    <nav class="md-nav" aria-label="Raft">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#raft_1" class="md-nav__link">
    Raft 操作、吞吐量和延迟
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_137" class="md-nav__link">
    时钟偏差
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_138" class="md-nav__link">
    远程引导
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mserver_2" class="md-nav__link">
    MServer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_139" class="md-nav__link">
    复制
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_140" class="md-nav__link">
    问题排查
  </a>
  
    <nav class="md-nav" aria-label="问题排查">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_141" class="md-nav__link">
    集群级别故障排除
  </a>
  
    <nav class="md-nav" aria-label="集群级别故障排除">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcql-api" class="md-nav__link">
    BCQL API 连接问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#yedis-api" class="md-nav__link">
    YEDIS API连接问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbservermserver" class="md-nav__link">
    恢复失败的DBServer和MServer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbserver_3" class="md-nav__link">
    更换出现故障的 DBServer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mserver_3" class="md-nav__link">
    更换发生故障的 MServer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_142" class="md-nav__link">
    手动远程引导失败的对等点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbserver_4" class="md-nav__link">
    从崩溃循环中恢复 DBServer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_143" class="md-nav__link">
    性能问题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_144" class="md-nav__link">
    节点级别故障排除
  </a>
  
    <nav class="md-nav" aria-label="节点级别故障排除">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb_2" class="md-nav__link">
    检查 BMDB服务器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bmdb_3" class="md-nav__link">
    检查 BMDB日志
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_145" class="md-nav__link">
    检查系统统计数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_146" class="md-nav__link">
    恢复故障磁盘
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_147" class="md-nav__link">
    磁盘已满问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_148" class="md-nav__link">
    常见错误消息
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_149" class="md-nav__link">
    性能调优
  </a>
  
    <nav class="md-nav" aria-label="性能调优">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_150" class="md-nav__link">
    引言
  </a>
  
    <nav class="md-nav" aria-label="引言">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_151" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql_3" class="md-nav__link">
    BSQL的调整
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_152" class="md-nav__link">
    性能调整工具
  </a>
  
    <nav class="md-nav" aria-label="性能调整工具">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_153" class="md-nav__link">
    查找慢查询
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_154" class="md-nav__link">
    查看实时查询
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#copy" class="md-nav__link">
    查看COPY操作状态
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#explain" class="md-nav__link">
    使用EXPLAIN查看计划
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_155" class="md-nav__link">
    高级工具
  </a>
  
    <nav class="md-nav" aria-label="高级工具">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_156" class="md-nav__link">
    记录慢查询
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_157" class="md-nav__link">
    使用提示计划
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_158" class="md-nav__link">
    收集查询统计信息
  </a>
  
    <nav class="md-nav" aria-label="收集查询统计信息">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_159" class="md-nav__link">
    配置参数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_160" class="md-nav__link">
    示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_161" class="md-nav__link">
    重置统计信息
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_162" class="md-nav__link">
    查看实时查询
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_163" class="md-nav__link">
    查看已终止的查询
  </a>
  
    <nav class="md-nav" aria-label="查看已终止的查询">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_164" class="md-nav__link">
    示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_165" class="md-nav__link">
    局限性
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_166" class="md-nav__link">
    查看复制状态
  </a>
  
    <nav class="md-nav" aria-label="查看复制状态">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb_4" class="md-nav__link">
    BMDB特定的更改
  </a>
  
    <nav class="md-nav" aria-label="BMDB特定的更改">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tuples_processed" class="md-nav__link">
    tuples_processed定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bm_status" class="md-nav__link">
    bm_status新列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#copy_1" class="md-nav__link">
    COPY 命令信息
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_167" class="md-nav__link">
    示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_168" class="md-nav__link">
    查看索引创建状态
  </a>
  
    <nav class="md-nav" aria-label="查看索引创建状态">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb_5" class="md-nav__link">
    BMDB特定的更改
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_169" class="md-nav__link">
    示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_170" class="md-nav__link">
    查询计划
  </a>
  
    <nav class="md-nav" aria-label="查询计划">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#explain_1" class="md-nav__link">
    EXPLAIN语句
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_171" class="md-nav__link">
    生产环境的例子
  </a>
  
    <nav class="md-nav" aria-label="生产环境的例子">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#select-count" class="md-nav__link">
    使用索引优化SELECT COUNT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#select" class="md-nav__link">
    通过更改表排序优化SELECT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#select_1" class="md-nav__link">
    使用索引优化SELECT
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql_4" class="md-nav__link">
    优化BSQL查询
  </a>
  
    <nav class="md-nav" aria-label="优化BSQL查询">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pg_hint_plan" class="md-nav__link">
    配置pg_hint_plan
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_172" class="md-nav__link">
    编写提示计划
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_hint_plan_1" class="md-nav__link">
    使用pg_hint_plan
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_173" class="md-nav__link">
    高可用
  </a>
  
    <nav class="md-nav" aria-label="高可用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_174" class="md-nav__link">
    节点、可用区和区域级故障容灾
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_175" class="md-nav__link">
    事务高可用
  </a>
  
    <nav class="md-nav" aria-label="事务高可用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_176" class="md-nav__link">
    前置条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    场景1：事务执行语句之前节点发生故障
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    场景2：事务执行语句后节点发生故障
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    场景3：客户端连接的节点故障
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_177" class="md-nav__link">
    高扩展性
  </a>
  
    <nav class="md-nav" aria-label="高扩展性">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sharding-and-rebalancing" class="md-nav__link">
    分片和再平衡（Sharding and Rebalancing）
  </a>
  
    <nav class="md-nav" aria-label="分片和再平衡（Sharding and Rebalancing）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_178" class="md-nav__link">
    初始集群设置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_179" class="md-nav__link">
    添加更多数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tile" class="md-nav__link">
    Tile分裂
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_180" class="md-nav__link">
    再平衡
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_181" class="md-nav__link">
    完全横向扩展
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_182" class="md-nav__link">
    节点扩容
  </a>
  
    <nav class="md-nav" aria-label="节点扩容">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_183" class="md-nav__link">
    初始设置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_184" class="md-nav__link">
    复制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_185" class="md-nav__link">
    更换领导者
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_186" class="md-nav__link">
    修复过度复制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_187" class="md-nav__link">
    重新平衡追随者
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_188" class="md-nav__link">
    完全横向扩展的集群
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_189" class="md-nav__link">
    负载均衡
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scaling-reads" class="md-nav__link">
    Scaling reads
  </a>
  
    <nav class="md-nav" aria-label="Scaling reads">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_190" class="md-nav__link">
    读取数据如何运作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sysbench" class="md-nav__link">
    Sysbench下的工作负载展示
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scaling-writes" class="md-nav__link">
    Scaling writes
  </a>
  
    <nav class="md-nav" aria-label="Scaling writes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_191" class="md-nav__link">
    写作如何工作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sysbench_1" class="md-nav__link">
    Sysbench下的工作负载展示
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scaling-transactions" class="md-nav__link">
    Scaling transactions
  </a>
  
    <nav class="md-nav" aria-label="Scaling transactions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oltp" class="md-nav__link">
    OLTP 基准
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tpc-c" class="md-nav__link">
    TPC-C 结果
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#large-datasets" class="md-nav__link">
    Large datasets
  </a>
  
    <nav class="md-nav" aria-label="Large datasets">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_192" class="md-nav__link">
    配置和数据大小
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_193" class="md-nav__link">
    数据加载
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#read-heavy-workload" class="md-nav__link">
    Read-heavy workload
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#write-heavy-workload" class="md-nav__link">
    Write-heavy workload
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scale-out-a-universe" class="md-nav__link">
    Scale out a universe
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_194" class="md-nav__link">
    多区域部署
  </a>
  
    <nav class="md-nav" aria-label="多区域部署">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#3_1" class="md-nav__link">
    3区域部署（节点之间数据同步复制）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_195" class="md-nav__link">
    行级数据地理分布
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#xdcr-2" class="md-nav__link">
    xDCR (2个区域异步复制)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_196" class="md-nav__link">
    读副本
  </a>
  
    <nav class="md-nav" aria-label="读副本">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_5" class="md-nav__link">
    BSQL
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_197" class="md-nav__link">
    变更数据捕获
  </a>
  
    <nav class="md-nav" aria-label="变更数据捕获">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_198" class="md-nav__link">
    概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bmdbdb-debezium" class="md-nav__link">
    用于 BMDBDB 的 Debezium 连接器
  </a>
  
    <nav class="md-nav" aria-label="用于 BMDBDB 的 Debezium 连接器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_199" class="md-nav__link">
    概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_200" class="md-nav__link">
    连接器的工作原理
  </a>
  
    <nav class="md-nav" aria-label="连接器的工作原理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_201" class="md-nav__link">
    安全
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_202" class="md-nav__link">
    快照
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_203" class="md-nav__link">
    流式更改
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_204" class="md-nav__link">
    主题名称
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_205" class="md-nav__link">
    元信息
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_206" class="md-nav__link">
    事务元数据
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_207" class="md-nav__link">
    数据更改事件
  </a>
  
    <nav class="md-nav" aria-label="数据更改事件">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_208" class="md-nav__link">
    更改事件键
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_209" class="md-nav__link">
    更改事件值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_210" class="md-nav__link">
    创建事件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_211" class="md-nav__link">
    更新事件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_212" class="md-nav__link">
    删除事件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_213" class="md-nav__link">
    数据类型映射
  </a>
  
    <nav class="md-nav" aria-label="数据类型映射">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_214" class="md-nav__link">
    默认值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_215" class="md-nav__link">
    基本类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_216" class="md-nav__link">
    时间类型
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_217" class="md-nav__link">
    升级部署
  </a>
  
    <nav class="md-nav" aria-label="升级部署">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb_6" class="md-nav__link">
    安装新版本的 BMDB
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mservers_1" class="md-nav__link">
    升级MServers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbservers" class="md-nav__link">
    升级DBServers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#autoflags" class="md-nav__link">
    升级AutoFlags
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql_6" class="md-nav__link">
    升级BSQL系统目录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#xdcr" class="md-nav__link">
    升级和 xDCR
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../07-%E5%90%91%E9%87%8F%E7%89%B9%E6%80%A7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    向量特性
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../08-AI%E7%89%B9%E6%80%A7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AI特性
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    参考
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            参考
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.1-%E6%9E%B6%E6%9E%84/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    架构
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.2-CLIs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CLIs
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.3-%E9%85%8D%E7%BD%AE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    配置
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.4-BSQL/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BSQL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.5-BCQL/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BCQL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    集群管理与监控
  </a>
  
    <nav class="md-nav" aria-label="集群管理与监控">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    安装部署
  </a>
  
    <nav class="md-nav" aria-label="安装部署">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    资源管理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    添加主机
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    集群管理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    参数配置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    任务状态
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    监控告警
  </a>
  
    <nav class="md-nav" aria-label="监控告警">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    集群总览
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    集群监控
  </a>
  
    <nav class="md-nav" aria-label="集群监控">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    集群信息
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    慢查询分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql" class="md-nav__link">
    SQL分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    日志分析
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    集群告警
  </a>
  
    <nav class="md-nav" aria-label="集群告警">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    告警列表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    接收人设置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    规则设置
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    系统与安全
  </a>
  
    <nav class="md-nav" aria-label="系统与安全">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    操作审计
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    通知服务器设置
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    权限管理
  </a>
  
    <nav class="md-nav" aria-label="权限管理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    用户管理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    角色管理
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    管理工具
  </a>
  
    <nav class="md-nav" aria-label="管理工具">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sql_1" class="md-nav__link">
    SQL客户端
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jupyterlab" class="md-nav__link">
    JupyterLab
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    应用
  </a>
  
    <nav class="md-nav" aria-label="应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#brightgpt" class="md-nav__link">
    BrightGPT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    图文检索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#brightbi" class="md-nav__link">
    BrightBI
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    更改集群配置
  </a>
  
    <nav class="md-nav" aria-label="更改集群配置">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    示例场景
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    配置新机器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mserver" class="md-nav__link">
    启动MServer服务器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbserver" class="md-nav__link">
    启动DBServer服务器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    执行数据移动
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mserver_1" class="md-nav__link">
    mserver法定人数变更
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbserver-mserver" class="md-nav__link">
    更新 DBServer 上的mserver地址
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    清理
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    诊断报告
  </a>
  
    <nav class="md-nav" aria-label="诊断报告">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    收集的数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    收集的指标示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    配置诊断收集
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    安全权限
  </a>
  
    <nav class="md-nav" aria-label="安全权限">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    安全检查清单
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    启用认证
  </a>
  
    <nav class="md-nav" aria-label="启用认证">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    启用用户认证
  </a>
  
    <nav class="md-nav" aria-label="启用用户认证">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    默认用户和密码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql" class="md-nav__link">
    启用BSQL身份验证
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    创建登录配置文件
  </a>
  
    <nav class="md-nav" aria-label="创建登录配置文件">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    启用登录配置文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    管理登录配置文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    查看登录配置文件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    配置客户端认证
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    认证方式
  </a>
  
    <nav class="md-nav" aria-label="认证方式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    密码认证
  </a>
  
    <nav class="md-nav" aria-label="密码认证">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb" class="md-nav__link">
    BMDB数据库密码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    密码认证方式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scram-sha-256" class="md-nav__link">
    启用 SCRAM-SHA-256 身份验证
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scram-sha-256_1" class="md-nav__link">
    创建使用 SCRAM-SHA-256 密码身份验证的集群
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#md5scram-sha-256" class="md-nav__link">
    对现有的MD5密码进行迁移至SCRAM-SHA-256
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    重置用户密码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ldap" class="md-nav__link">
    LDAP认证
  </a>
  
    <nav class="md-nav" aria-label="LDAP认证">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    简单绑定模式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    搜索+绑定模式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    配置示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    基于主机的认证
  </a>
  
    <nav class="md-nav" aria-label="基于主机的认证">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_hbaconf" class="md-nav__link">
    bsql_hba.conf 文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    记录字段
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    信任认证
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    基于角色的访问控制
  </a>
  
    <nav class="md-nav" aria-label="基于角色的访问控制">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    概述
  </a>
  
    <nav class="md-nav" aria-label="概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    角色
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    资源
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_63" class="md-nav__link">
    权限
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_64" class="md-nav__link">
    管理用户和角色
  </a>
  
    <nav class="md-nav" aria-label="管理用户和角色">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_65" class="md-nav__link">
    创建角色
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_66" class="md-nav__link">
    授予角色
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_67" class="md-nav__link">
    创建角色层次结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_68" class="md-nav__link">
    列出角色
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_69" class="md-nav__link">
    撤销角色
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_70" class="md-nav__link">
    删除角色
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_71" class="md-nav__link">
    授权
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_72" class="md-nav__link">
    行级安全机制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_73" class="md-nav__link">
    列级安全机制
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_74" class="md-nav__link">
    传输加密
  </a>
  
    <nav class="md-nav" aria-label="传输加密">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_75" class="md-nav__link">
    创建服务器证书
  </a>
  
    <nav class="md-nav" aria-label="创建服务器证书">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_76" class="md-nav__link">
    创建服务器证书
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_77" class="md-nav__link">
    生成根证书文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_78" class="md-nav__link">
    将根证书复制到各个节点目录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_79" class="md-nav__link">
    为每个节点生成密钥和证书文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_80" class="md-nav__link">
    将配置文件复制到节点
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_81" class="md-nav__link">
    启用服务器之间的加密
  </a>
  
    <nav class="md-nav" aria-label="启用服务器之间的加密">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_82" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mserverdbserver" class="md-nav__link">
    配置MServer和DBServer节点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mservers" class="md-nav__link">
    启动 MServers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbserver_1" class="md-nav__link">
    启动 DBServer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_83" class="md-nav__link">
    连接到集群
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_84" class="md-nav__link">
    启用客户端到服务端的加密
  </a>
  
    <nav class="md-nav" aria-label="启用客户端到服务端的加密">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_85" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbserver_2" class="md-nav__link">
    配置DBServer节点
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_86" class="md-nav__link">
    连接到集群
  </a>
  
    <nav class="md-nav" aria-label="连接到集群">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_87" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bmdb_1" class="md-nav__link">
    连接到BMDB集群
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tls" class="md-nav__link">
    TLS和认证
  </a>
  
    <nav class="md-nav" aria-label="TLS和认证">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_88" class="md-nav__link">
    示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_89" class="md-nav__link">
    静态加密
  </a>
  
    <nav class="md-nav" aria-label="静态加密">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_90" class="md-nav__link">
    启用加密
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_91" class="md-nav__link">
    轮换新钥匙
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_92" class="md-nav__link">
    禁用加密
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_93" class="md-nav__link">
    列级加密
  </a>
  
    <nav class="md-nav" aria-label="列级加密">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_94" class="md-nav__link">
    对称加密
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_95" class="md-nav__link">
    非对称加密
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_96" class="md-nav__link">
    审计
  </a>
  
    <nav class="md-nav" aria-label="审计">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_97" class="md-nav__link">
    跟踪语句
  </a>
  
    <nav class="md-nav" aria-label="跟踪语句">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_98" class="md-nav__link">
    设置日志记录选项
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_99" class="md-nav__link">
    查看日志
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_100" class="md-nav__link">
    会话示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_101" class="md-nav__link">
    下一步
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_102" class="md-nav__link">
    配置审计日志
  </a>
  
    <nav class="md-nav" aria-label="配置审计日志">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_103" class="md-nav__link">
    启用审核日志记录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_104" class="md-nav__link">
    自定义审核日志记录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_105" class="md-nav__link">
    示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_106" class="md-nav__link">
    会话级审计日志
  </a>
  
    <nav class="md-nav" aria-label="会话级审计日志">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_107" class="md-nav__link">
    会话级示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_108" class="md-nav__link">
    对象级审计日志
  </a>
  
    <nav class="md-nav" aria-label="对象级审计日志">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_109" class="md-nav__link">
    对象级示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_110" class="md-nav__link">
    备份恢复
  </a>
  
    <nav class="md-nav" aria-label="备份恢复">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_111" class="md-nav__link">
    备份和还原
  </a>
  
    <nav class="md-nav" aria-label="备份和还原">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_112" class="md-nav__link">
    导出和导入
  </a>
  
    <nav class="md-nav" aria-label="导出和导入">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_113" class="md-nav__link">
    导出单个数据库
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_114" class="md-nav__link">
    导出单个表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_115" class="md-nav__link">
    导出所有数据库
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_116" class="md-nav__link">
    导入
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_117" class="md-nav__link">
    分布式快照
  </a>
  
    <nav class="md-nav" aria-label="分布式快照">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_118" class="md-nav__link">
    创建快照
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_119" class="md-nav__link">
    删除快照
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_120" class="md-nav__link">
    恢复快照
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_121" class="md-nav__link">
    将快照移至外部存储
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_122" class="md-nav__link">
    从外部存储恢复快照
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#point-in-time-recovery" class="md-nav__link">
    Point-in-time recovery
  </a>
  
    <nav class="md-nav" aria-label="Point-in-time recovery">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_123" class="md-nav__link">
    怎么运行的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pitr" class="md-nav__link">
    启用和禁用 PITR
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_124" class="md-nav__link">
    恢复到某个时间点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_125" class="md-nav__link">
    局限性
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_126" class="md-nav__link">
    时间点回复
  </a>
  
    <nav class="md-nav" aria-label="时间点回复">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_1" class="md-nav__link">
    BSQL
  </a>
  
    <nav class="md-nav" aria-label="BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#universe" class="md-nav__link">
    设置universe
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_127" class="md-nav__link">
    撤消数据更改
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_128" class="md-nav__link">
    撤消元数据更改
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_129" class="md-nav__link">
    监控指标
  </a>
  
    <nav class="md-nav" aria-label="监控指标">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_130" class="md-nav__link">
    指标
  </a>
  
    <nav class="md-nav" aria-label="指标">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_131" class="md-nav__link">
    吞吐量和时延
  </a>
  
    <nav class="md-nav" aria-label="吞吐量和时延">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_2" class="md-nav__link">
    BSQL查询处理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iops" class="md-nav__link">
    数据库 IOPS（读取和写入）
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_132" class="md-nav__link">
    连接数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_133" class="md-nav__link">
    缓存和存储
  </a>
  
    <nav class="md-nav" aria-label="缓存和存储">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#iops_1" class="md-nav__link">
    存储层IOPS
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_134" class="md-nav__link">
    块缓存
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_135" class="md-nav__link">
    布隆过滤器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sst" class="md-nav__link">
    SST 文件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_136" class="md-nav__link">
    压实
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#memtable" class="md-nav__link">
    Memtable
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#wal" class="md-nav__link">
    预写日志记录 (WAL)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#raft" class="md-nav__link">
    Raft
  </a>
  
    <nav class="md-nav" aria-label="Raft">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#raft_1" class="md-nav__link">
    Raft 操作、吞吐量和延迟
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_137" class="md-nav__link">
    时钟偏差
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_138" class="md-nav__link">
    远程引导
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mserver_2" class="md-nav__link">
    MServer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_139" class="md-nav__link">
    复制
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_140" class="md-nav__link">
    问题排查
  </a>
  
    <nav class="md-nav" aria-label="问题排查">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_141" class="md-nav__link">
    集群级别故障排除
  </a>
  
    <nav class="md-nav" aria-label="集群级别故障排除">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcql-api" class="md-nav__link">
    BCQL API 连接问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#yedis-api" class="md-nav__link">
    YEDIS API连接问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbservermserver" class="md-nav__link">
    恢复失败的DBServer和MServer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbserver_3" class="md-nav__link">
    更换出现故障的 DBServer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mserver_3" class="md-nav__link">
    更换发生故障的 MServer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_142" class="md-nav__link">
    手动远程引导失败的对等点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbserver_4" class="md-nav__link">
    从崩溃循环中恢复 DBServer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_143" class="md-nav__link">
    性能问题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_144" class="md-nav__link">
    节点级别故障排除
  </a>
  
    <nav class="md-nav" aria-label="节点级别故障排除">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb_2" class="md-nav__link">
    检查 BMDB服务器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bmdb_3" class="md-nav__link">
    检查 BMDB日志
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_145" class="md-nav__link">
    检查系统统计数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_146" class="md-nav__link">
    恢复故障磁盘
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_147" class="md-nav__link">
    磁盘已满问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_148" class="md-nav__link">
    常见错误消息
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_149" class="md-nav__link">
    性能调优
  </a>
  
    <nav class="md-nav" aria-label="性能调优">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_150" class="md-nav__link">
    引言
  </a>
  
    <nav class="md-nav" aria-label="引言">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_151" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql_3" class="md-nav__link">
    BSQL的调整
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_152" class="md-nav__link">
    性能调整工具
  </a>
  
    <nav class="md-nav" aria-label="性能调整工具">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_153" class="md-nav__link">
    查找慢查询
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_154" class="md-nav__link">
    查看实时查询
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#copy" class="md-nav__link">
    查看COPY操作状态
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#explain" class="md-nav__link">
    使用EXPLAIN查看计划
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_155" class="md-nav__link">
    高级工具
  </a>
  
    <nav class="md-nav" aria-label="高级工具">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_156" class="md-nav__link">
    记录慢查询
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_157" class="md-nav__link">
    使用提示计划
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_158" class="md-nav__link">
    收集查询统计信息
  </a>
  
    <nav class="md-nav" aria-label="收集查询统计信息">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_159" class="md-nav__link">
    配置参数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_160" class="md-nav__link">
    示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_161" class="md-nav__link">
    重置统计信息
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_162" class="md-nav__link">
    查看实时查询
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_163" class="md-nav__link">
    查看已终止的查询
  </a>
  
    <nav class="md-nav" aria-label="查看已终止的查询">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_164" class="md-nav__link">
    示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_165" class="md-nav__link">
    局限性
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_166" class="md-nav__link">
    查看复制状态
  </a>
  
    <nav class="md-nav" aria-label="查看复制状态">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb_4" class="md-nav__link">
    BMDB特定的更改
  </a>
  
    <nav class="md-nav" aria-label="BMDB特定的更改">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tuples_processed" class="md-nav__link">
    tuples_processed定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bm_status" class="md-nav__link">
    bm_status新列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#copy_1" class="md-nav__link">
    COPY 命令信息
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_167" class="md-nav__link">
    示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_168" class="md-nav__link">
    查看索引创建状态
  </a>
  
    <nav class="md-nav" aria-label="查看索引创建状态">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb_5" class="md-nav__link">
    BMDB特定的更改
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_169" class="md-nav__link">
    示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_170" class="md-nav__link">
    查询计划
  </a>
  
    <nav class="md-nav" aria-label="查询计划">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#explain_1" class="md-nav__link">
    EXPLAIN语句
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_171" class="md-nav__link">
    生产环境的例子
  </a>
  
    <nav class="md-nav" aria-label="生产环境的例子">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#select-count" class="md-nav__link">
    使用索引优化SELECT COUNT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#select" class="md-nav__link">
    通过更改表排序优化SELECT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#select_1" class="md-nav__link">
    使用索引优化SELECT
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql_4" class="md-nav__link">
    优化BSQL查询
  </a>
  
    <nav class="md-nav" aria-label="优化BSQL查询">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pg_hint_plan" class="md-nav__link">
    配置pg_hint_plan
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_172" class="md-nav__link">
    编写提示计划
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_hint_plan_1" class="md-nav__link">
    使用pg_hint_plan
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_173" class="md-nav__link">
    高可用
  </a>
  
    <nav class="md-nav" aria-label="高可用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_174" class="md-nav__link">
    节点、可用区和区域级故障容灾
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_175" class="md-nav__link">
    事务高可用
  </a>
  
    <nav class="md-nav" aria-label="事务高可用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_176" class="md-nav__link">
    前置条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    场景1：事务执行语句之前节点发生故障
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    场景2：事务执行语句后节点发生故障
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    场景3：客户端连接的节点故障
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_177" class="md-nav__link">
    高扩展性
  </a>
  
    <nav class="md-nav" aria-label="高扩展性">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sharding-and-rebalancing" class="md-nav__link">
    分片和再平衡（Sharding and Rebalancing）
  </a>
  
    <nav class="md-nav" aria-label="分片和再平衡（Sharding and Rebalancing）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_178" class="md-nav__link">
    初始集群设置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_179" class="md-nav__link">
    添加更多数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tile" class="md-nav__link">
    Tile分裂
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_180" class="md-nav__link">
    再平衡
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_181" class="md-nav__link">
    完全横向扩展
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_182" class="md-nav__link">
    节点扩容
  </a>
  
    <nav class="md-nav" aria-label="节点扩容">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_183" class="md-nav__link">
    初始设置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_184" class="md-nav__link">
    复制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_185" class="md-nav__link">
    更换领导者
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_186" class="md-nav__link">
    修复过度复制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_187" class="md-nav__link">
    重新平衡追随者
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_188" class="md-nav__link">
    完全横向扩展的集群
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_189" class="md-nav__link">
    负载均衡
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scaling-reads" class="md-nav__link">
    Scaling reads
  </a>
  
    <nav class="md-nav" aria-label="Scaling reads">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_190" class="md-nav__link">
    读取数据如何运作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sysbench" class="md-nav__link">
    Sysbench下的工作负载展示
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scaling-writes" class="md-nav__link">
    Scaling writes
  </a>
  
    <nav class="md-nav" aria-label="Scaling writes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_191" class="md-nav__link">
    写作如何工作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sysbench_1" class="md-nav__link">
    Sysbench下的工作负载展示
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scaling-transactions" class="md-nav__link">
    Scaling transactions
  </a>
  
    <nav class="md-nav" aria-label="Scaling transactions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#oltp" class="md-nav__link">
    OLTP 基准
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tpc-c" class="md-nav__link">
    TPC-C 结果
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#large-datasets" class="md-nav__link">
    Large datasets
  </a>
  
    <nav class="md-nav" aria-label="Large datasets">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_192" class="md-nav__link">
    配置和数据大小
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_193" class="md-nav__link">
    数据加载
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#read-heavy-workload" class="md-nav__link">
    Read-heavy workload
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#write-heavy-workload" class="md-nav__link">
    Write-heavy workload
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scale-out-a-universe" class="md-nav__link">
    Scale out a universe
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_194" class="md-nav__link">
    多区域部署
  </a>
  
    <nav class="md-nav" aria-label="多区域部署">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#3_1" class="md-nav__link">
    3区域部署（节点之间数据同步复制）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_195" class="md-nav__link">
    行级数据地理分布
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#xdcr-2" class="md-nav__link">
    xDCR (2个区域异步复制)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_196" class="md-nav__link">
    读副本
  </a>
  
    <nav class="md-nav" aria-label="读副本">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_5" class="md-nav__link">
    BSQL
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_197" class="md-nav__link">
    变更数据捕获
  </a>
  
    <nav class="md-nav" aria-label="变更数据捕获">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_198" class="md-nav__link">
    概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bmdbdb-debezium" class="md-nav__link">
    用于 BMDBDB 的 Debezium 连接器
  </a>
  
    <nav class="md-nav" aria-label="用于 BMDBDB 的 Debezium 连接器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_199" class="md-nav__link">
    概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_200" class="md-nav__link">
    连接器的工作原理
  </a>
  
    <nav class="md-nav" aria-label="连接器的工作原理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_201" class="md-nav__link">
    安全
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_202" class="md-nav__link">
    快照
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_203" class="md-nav__link">
    流式更改
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_204" class="md-nav__link">
    主题名称
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_205" class="md-nav__link">
    元信息
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_206" class="md-nav__link">
    事务元数据
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_207" class="md-nav__link">
    数据更改事件
  </a>
  
    <nav class="md-nav" aria-label="数据更改事件">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_208" class="md-nav__link">
    更改事件键
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_209" class="md-nav__link">
    更改事件值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_210" class="md-nav__link">
    创建事件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_211" class="md-nav__link">
    更新事件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_212" class="md-nav__link">
    删除事件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_213" class="md-nav__link">
    数据类型映射
  </a>
  
    <nav class="md-nav" aria-label="数据类型映射">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_214" class="md-nav__link">
    默认值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_215" class="md-nav__link">
    基本类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_216" class="md-nav__link">
    时间类型
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_217" class="md-nav__link">
    升级部署
  </a>
  
    <nav class="md-nav" aria-label="升级部署">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb_6" class="md-nav__link">
    安装新版本的 BMDB
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mservers_1" class="md-nav__link">
    升级MServers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbservers" class="md-nav__link">
    升级DBServers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#autoflags" class="md-nav__link">
    升级AutoFlags
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql_6" class="md-nav__link">
    升级BSQL系统目录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#xdcr" class="md-nav__link">
    升级和 xDCR
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="_1"><strong>管理数据库</strong></h1>
<h2 id="_2"><strong>集群管理与监控</strong></h2>
<p>BrightStudio明睿智能数据管理平台，以AiSQL数据库为核心，实现一站式、可视化的管理，专用于管理和监控企业级数据库环境及数据， 提供全面的数据库安装、管理、监控、运维、安全、数据分析、自动化等功能，帮助企业提高数据库运维及数据智能效率和可靠性，具体如下：
<strong>安装部署</strong>：支持数据库的安装、配置、备份、恢复、升级、迁移、监控、优化等功能。
<strong>监控告警</strong>：实时监控数据库的性能、资源使用情况、故障等，并提供报警和通知功能。
<strong>系统与安全</strong>：提供数据库的数据加密、审计等功能，保障数据安全。
<strong>权限管理</strong>：提供项目的访问控制、权限管理。
<strong>管理工具</strong>：支持数据库的自动化运维，如自动化备份、自动化恢复、自动化升级等，提高运维效率。
<strong>应用</strong>：支持数据库的数据查询、报表生成、数据挖掘等功能，帮助企业进行数据分析和决策。</p>
<h3 id="_3"><strong>安装部署</strong></h3>
<p>用于完成集群的资源管理，安装部署和参数控制。</p>
<h4 id="_4"><strong>资源管理</strong></h4>
<p>对主机资源进行创建、扩容、缩容、重启、停止、删除管理。</p>
<p>1.添加主机
根据提供的IP和账户密码，添加对应的主机，用于后续创建集群，扩容集群等需要主机资源的时候进行分配。</p>
<p>2.删除主机
对未分配的主机，可以进行删除。</p>
<h4 id="_5"><strong>添加主机</strong></h4>
<p>根据提供的IP和账户密码，添加对应的主机，用于后续创建集群，扩容集群等需要主机资源的时候进行分配。
<img alt="" src="./media/chapter6/1.png" /></p>
<h4 id="_6"><strong>集群管理</strong></h4>
<p>对集群资源进行创建、扩容、缩容、重启、停止、删除管理。
1.集群创建：创建集群，可手动选择需要部署的机器，也可以自动分配部署的机器，且节点数量必须大于等于复制因子。若出现创建失败，可能是网络出现问题或者是端口已被占用等情况，若出现失败的情况，可删除重新创建。
2.集群扩容：集群扩容需要选择要扩容多少节点，以及节点需要加载的服务。如扩容失败，可能是资源不足或网络错误导致。 若是资源不足，可以选择继续导入主机；若是网络问题，可检查网络状态后重试。具体错误信息请查看工作流信息。
3.集群缩容：集群缩容需要选择要卸载多少节点，以及节点需要卸载的服务。如缩容失败，可能是网络错误导致，可检查网络状态后重试。具体错误信息请查看工作流信息。
4.集群重启：集群重启会先将集群停止，然后再进行启动。如果出现重启后失败的情况，可能存在网络错误，可检查网络状态后重试。
5.集群停止：集群停止会直接停止进程，若出现停止后失败的情况，可能存在网络错误，可检查网络状态后重试。
6.集群删除：集群删除会将集群信息全部删除，包括但不限于集群的进程，回收集群所拥有的机器，删除集群机器中的资源。若出现停止后失败的情况，可能存在网络错误，可检查网络状态后重试。
<img alt="" src="./media/chapter6/2.png" /></p>
<h4 id="_7"><strong>参数配置</strong></h4>
<p>参数配置用于复制和管理参数组。参数组用于定义集群的参数值，在创建集群时需要选择参数组。
1.参数组的编辑: 编辑参数组中的某些参数值。
2.参数组的复制: 基于该参数组创建一个新的参数组。
3.参数组的删除: 删除某个参数组。
<img alt="" src="./media/chapter6/3.png" /></p>
<h4 id="_8"><strong>任务状态</strong></h4>
<p>用于查看每个任务的状态（例如新增主机，创建集群等），关联资源类型表示这是一个针对主机的操作，还是一个针对集群的操作，关联资源ID表示操作资源的ID值，如果是主机类型，则为主机的ID，如果是集群类型，则为集群的ID。
1任务列表：用于查看每个任务的状态（例如新增主机，创建集群等），关联资源类型表示这是一个针对主机的操作，还是一个针对集群的操作，关联资源ID表示操作资源的ID值，如果是主机类型，则为主机的ID，如果是集群类型，则为集群的ID。
2.点击任务记录前的加号，查看任务每个步骤的执行情况。
3.点击具体步骤的名称，查看步骤执行的返回信息。
<img alt="" src="./media/chapter6/4.png" /></p>
<h3 id="_9"><strong>监控告警</strong></h3>
<h4 id="_10"><strong>集群总览</strong></h4>
<p>集群信息页面包括实例和主机信息。
<img alt="" src="./media/chapter6/5.png" /></p>
<h4 id="_11"><strong>集群监控</strong></h4>
<h5 id="_12"><strong>集群信息</strong></h5>
<p>该页面是对整个系统的一个概览，显示集群状况和集群总数。对每个集群，显示监控状态、状态、集群ID、创建时间、存储容量、更新时间、数据库版本、复制因子、节点数量及节点IP。
实例列表
<img alt="" src="./media/chapter6/6.png" /></p>
<p>下面介绍右侧两个按钮的作用
1.图表按钮
点进对应实例的图表，将详细展示记录实例各项数据的时间图表，该部分内容由grafana嵌入而来。可以通过用上面的时间范围来选择展示的对应时间范围数据。 
<img alt="" src="./media/chapter6/7.png" />
2.参数按钮
参数按钮，将指向老版的BrightDB监控。
<img alt="" src="./media/chapter6/8.png" /></p>
<p>主机列表
记录主机的详细信息，点击右侧图表按钮可以看见主机的资源历史使用记录。
<img alt="" src="./media/chapter6/9.png" /></p>
<h5 id="_13"><strong>慢查询分析</strong></h5>
<p>该页面会筛选出时间超过指定耗时(默认1s)的SQL语句,。来源于日志抓取程序，用户可自行选择是否开启日志抓取程序来获取相关页面数据。需要注意的是，开启日志抓取程序有可能会影响到BrightDB数据库的性能，而且会导致日志增长速度加快，请用户自行选择！
<img alt="" src="./media/chapter6/10.png" /></p>
<h5 id="sql"><strong>SQL分析</strong></h5>
<p>该页面记录了所有非事务的语句，默认显示30分钟内数据。来源于日志抓取程序，用户可自行选择是否开启日志抓取程序来获取相关页面数据。需要注意的是，开启日志抓取程序有可能会影响到BrightDB数据库的性能，而且会导致日志增长速度加快，请用户自行选择！
<img alt="" src="./media/chapter6/11.png" /></p>
<h5 id="_14"><strong>日志分析</strong></h5>
<p>该页面记录DBserver和MServer的日志，程序出现意外可以尝试从这里进行分析。来源于日志抓取程序，用户可自行选择是否开启日志抓取程序来获取相关页面数据。需要注意的是，开启日志抓取程序有可能会影响到BrightDB数据库的性能，而且会导致日志增长速度加快，请用户自行选择！
<img alt="" src="./media/chapter6/12.png" />
1.分析页面
慢查询分析页面、SQL分析页面、日志分析页面的数据都来源于日志抓取程序，用户可自行选择是否开启日志抓取程序来获取相关页面数据。需要注意的是，开启日志抓取程序有可能会影响到BrightDB数据库的性能，而且会导致日志增长速度加快，请用户自行选择！</p>
<p>2.SQL分析、慢查询分析，对应fluentbit的配置文件fluent-bit.conf的以下内容。</p>
<div class="highlight"><pre><span></span><code> [INPUT]  
      name                tail  
      path                /root/biginsights-data/node-1/disk-1/bi-data/tserver/logs/postgresql*.log  
      Buffer_Max_Size     5M  
      Buffer_Chunk_Size   1M  
      tag                 pglog  
      multiline.parser    multiline-pglog  
      Rotate_Wait         30  
      db                  /var/lib/fluentbit/pg.db  

[OUTPUT]  
      name  http  
      match pglog  
      host  127.0.0.1  
      port  9050  
      uri   /sql/write  
      format json  
      Workers 0  
      net.keepalive on
</code></pre></div>
<p>3.日志分析页面对应fluent-bit.conf的以下内容 </p>
<p><div class="highlight"><pre><span></span><code> [INPUT]  
        name                tail  
        path                /root/biginsights-data/node-1/disk-1/bi-data/tserver/logs/bi-tserve.*ERROR.*,/root/biginsights-data/node-1/disk-1/bi-data/tserver/logs/bi-tserver.*WARNING.*  
        tag                 glog  
        Rotate_Wait         30  
        db                  /var/lib/fluentbit/logs.db  
        Path_Key            logName  

[OUTPUT]  
    name  http  
    match glog  
    host  127.0.0.1  
    port  9050  
    uri   /log/write  
    format json
</code></pre></div>
用户可自行选择抓取哪部分内容，不需要的部分注释掉即可</p>
<h4 id="_15"><strong>集群告警</strong></h4>
<p>支持通过邮件、钉钉等方式发送报警通知。</p>
<h5 id="_16"><strong>告警列表</strong></h5>
<p>告警列表记录了prometheus的组件alertmanager发送的警报，用户可以翻找该列表查看告警信息，默认显示30分钟内的告警信息。 
<img alt="" src="./media/chapter6/13.png" /></p>
<h5 id="_17"><strong>接收人设置</strong></h5>
<p>该页面可以选择将告警信息发送给对应的接收人，目前支持邮件和钉钉告警两种方式。
<img alt="" src="./media/chapter6/14.png" /></p>
<h5 id="_18"><strong>规则设置</strong></h5>
<p>该页面预置了数个模板，大部分是针对主机资源的告警。 
<img alt="" src="./media/chapter6/15.png" /><img alt="" src="./media/chapter6/16.png" />
<img alt="" src="./media/chapter6/17.png" /></p>
<p>添加钉钉机器人的流程：</p>
<p>1.创建钉钉群组，打开群设置
<img alt="" src="./media/chapter6/18.png" /></p>
<p>2.添加自定义机器人
<img alt="" src="./media/chapter6/19.png" />
3.设置安全参数 目前支持两种方式，一是ip字段，一是自定义关键字的方式 </p>
<p>4.自定义关键字
添加关键字"告警"，使得消息能通过钉钉验证
<img alt="" src="./media/chapter6/20.png" />
5.IP地址
用户需要将prometheus服务所在机器的ip填入。
<img alt="" src="./media/chapter6/21.png" />
6.获取token地址
设置成功后就可以获得web机器人的地址
<img alt="" src="./media/chapter6/22.png" /></p>
<p>7.将该webhook复制到接收人页面即可
<img alt="" src="./media/chapter6/23.png" />
8.测试 可以试着将CPU的上限调高，如果钉钉能收到如下消息，则代表测试成功
<img alt="" src="./media/chapter6/24.png" /></p>
<h3 id="_19"><strong>系统与安全</strong></h3>
<h4 id="_20"><strong>操作审计</strong></h4>
<p>显示Bright Studio系统自身的操作日志，支持灵活的过滤和查找功能。 
<img alt="" src="./media/chapter6/25.png" /></p>
<h4 id="_21"><strong>通知服务器设置</strong></h4>
<p>通过配置邮件服务器和邮箱，在对集群进行监控并产生告警时，可以将告警通过邮件发送给接收人。
<img alt="" src="./media/chapter6/26.png" /></p>
<h3 id="_22"><strong>权限管理</strong></h3>
<p>负责Bright Studio系统本身权限的管理，包括用户管理和角色管理。</p>
<h4 id="_23"><strong>用户管理</strong></h4>
<p>支持项目的用户。如新增、编辑、删除、查看用户列表、查看用户权限、给用户分配角色、重置用户密码等。
1.新增用户：增加一个用户账户。
<img alt="" src="./media/chapter6/27.png" />
2.编辑用户：编辑已有用户的账户信息。 
<img alt="" src="./media/chapter6/28.png" />
3.删除用户：删除已有用户的账户信息。
<img alt="" src="./media/chapter6/29.png" />
4.查看用户列表：显示所有用户的列表。
<img alt="" src="./media/chapter6/30.png" />
5.查看用户权限：查看用户的所有权限。 
<img alt="" src="./media/chapter6/31.png" />
6.给用户分配角色：用户可绑定多个角色，每个角色所拥有的权限用户都拥有，且对于同一权限，取所有角色中的最高权限。
<img alt="" src="./media/chapter6/32.png" />
7.重置用户密码：将用户密码重置成与登录账号的值相同。 
<img alt="" src="./media/chapter6/33.png" /></p>
<h4 id="_24"><strong>角色管理</strong></h4>
<p>支持项目的角色控制。如创建角色、给角色分配权限、删除角色等。
1.创建角色：创建一个新角色，新创建的角色默认无任何权限。
<img alt="" src="./media/chapter6/34.png" />
2.给角色分配权限：显示所有角色的列表。
<img alt="" src="./media/chapter6/35.png" />
3.角色列表：为角色分配权限，所有绑定了该角色的用户都会拥有该角色所拥有的权限。
<img alt="" src="./media/chapter6/36.png" />
4.删除角色：将角色进行删除，若有用户绑定了此角色，也会将此进行解绑，删除角色时请确认绑定了该角色的用户在删除后的权限是否符合自己的需求。
<img alt="" src="./media/chapter6/37.png" /></p>
<h3 id="_25"><strong>管理工具</strong></h3>
<h4 id="sql_1"><strong>SQL客户端</strong></h4>
<p>集成的第三方postgres sql客户端pgweb。
<img alt="" src="./media/chapter6/38.png" /></p>
<h4 id="jupyterlab"><strong>JupyterLab</strong></h4>
<p>是一个基于浏览器的交互式开发环境，支持运行 Jupyter 笔记本、编辑代码和文本文件，以及进行数据分析和可视化，适用于 Python 等多种编程语言。
<img alt="" src="./media/chapter6/39.png" /></p>
<h3 id="_26"><strong>应用</strong></h3>
<h4 id="brightgpt"><strong>BrightGPT</strong></h4>
<p>通过数据库关键字提取来达到自动对话。
<img alt="" src="./media/chapter6/40.png" /></p>
<h4 id="_27"><strong>图文检索</strong></h4>
<p>支持数据库关键向量信息，返回相应的结果。
<img alt="" src="./media/chapter6/41.png" /></p>
<h4 id="brightbi"><strong>BrightBI</strong></h4>
<p>能够连接多种数据源、提供丰富的可视化图表，支持自定义仪表盘，帮助用户轻松探索和呈现数据。
<img alt="" src="./media/chapter6/42.png" /></p>
<h2 id="_28"><strong>更改集群配置</strong></h2>
<p>将 BMDB 集群迁移到一组新节点。
有时，您可能需要将部署在一组节点上的 BMDB Universe 移动到另一组完全不同的节点。 需要进行此类集群更改的一些场景是：</p>
<ul>
<li>更改实例或机器类型。</li>
<li>定期更新实例映像（例如 AWS 中的 AMI 补充）。</li>
<li>迁移到一组不同的可用区、区域或数据中心。</li>
</ul>
<p>本页介绍如何更改集群的配置，包括设置新服务器、从旧服务器移动数据以及关闭旧服务器。 本教程假设您熟悉 BMDB 架构。</p>
<h3 id="_29"><strong>示例场景</strong></h3>
<p>假设以下是 Universe 的初始设置：</p>
<ul>
<li>六个节点：node1、node2、node3、node4、node5 和 node6，每个节点代表机器/VM 的 IP 地址。</li>
<li>复制因子 (RF) 为 3。</li>
<li>节点node1、node2和node3是三个MServer节点。</li>
<li>所有六个节点都运行 DBServer。</li>
</ul>
<p>您将转向以下配置：</p>
<ul>
<li>六个不同的节点：node7、node8、node9、node10、node11 和 node12。</li>
<li>复制因子 (RF) 为 3。</li>
<li>节点node7、node8和node9将是三个mserver节点.。</li>
<li>所有六个节点都运行 DBServer。</li>
<li>原来的六个节点node1、node2、node3、node4、node5、node6将不再属于这个宇宙。</li>
</ul>
<h3 id="_30"><strong>先决条件</strong></h3>
<p><strong>1.确保Universe处于健康状态</strong>
为了确保您不会在持续失败的情况下无意中导致任何进一步的复制不足，请验证以下内容：</p>
<ul>
<li>所有 MServer 服务器都在运行并且能够相互通信。 这可以通过检查主 UI（位于 http://node1:10000/）进行验证，并确保 mservers 选项卡显示所有三个，其中一个位于 RAFT 角色的 LEADER 中。</li>
<li>所有 DBServer 服务器都在运行并向主领导者发出心跳。 这可以通过检查主 UI（位于 http://node1:10000/tile-servers）来验证，其中列出了所有处于 ALIVE 状态的 Tile 服务器。</li>
</ul>
<p><strong>2.确保新机器准备就绪</strong>
启动一组新的虚拟机或服务器（例如，使用新的 AMI），其 IP 地址为节点 7、节点 8、节点 9、节点 10、节点 11 和节点 12。</p>
<h3 id="_31"><strong>配置新机器</strong></h3>
<p>执行以下操作来配置六台新机器：</p>
<ul>
<li>按照系统配置说明进行系统设置。</li>
<li>在每台新机器上安装 BMDB 软件。</li>
</ul>
<h3 id="mserver"><strong>启动MServer服务器</strong></h3>
<p>运行以下命令在新主节点node7、node8和node9上启动新的MServer服务器。</p>
<div class="highlight"><pre><span></span><code>~/mserver/bin/mserver                \
    --fs_data_dirs &lt;data directories&gt; \
    &gt;&amp; /mnt/d0/mserver.out &amp;
</code></pre></div>
<p>注：不要为这些新主设备设置 mserver_addresses 参数。 当未设置 mserver_addresses 时，主服务器开始运行，而不加入任何现有的主仲裁。 这些节点将在稍后的步骤中添加到主仲裁中。</p>
<p>有关更多参数和选项，请参阅启动主服务器。</p>
<h3 id="dbserver"><strong>启动DBServer服务器</strong></h3>
<p>运行以下命令在所有新节点node7、node8、node9、node10、node11 和node12 上启动dbserver 服务器。</p>
<div class="highlight"><pre><span></span><code>export MSERVERS=node1:11000,node2:11000,node3:11000,node7:11000,node8:11000,node9:11000
~/dbserver/bin/dbserver              \
    --dbserver_mserver_addrs $MSERVERS   \
    --fs_data_dirs &lt;data directories&gt; \
    &gt;&amp; /mnt/d0/dbserver.out &amp;
</code></pre></div>
<p>有关更多参数和选项，请参阅启动 dbserver 服务器。</p>
<p>注：dbserver_mserver_addrs 参数还包括新的 mserver IP 地址，这样即使在旧的 mserver 从 mserver 仲裁中删除后，它们也可以保持心跳/向新的 mserver 报告。</p>
<p>现在 DBServer 服务器正在运行，验证所有 12 个 DBServer（六个旧的和六个新的）是否都向主领导发送心跳。 转至 http://node1:10000/tile-servers 确认 12 台服务器的状态为 ALIVE。</p>
<h3 id="_32"><strong>执行数据移动</strong></h3>
<p>现在可以移动该集群上的数据。 首先，将旧的Tile服务器列入黑名单，将数据从它们移至新的Tile服务器组中。</p>
<p>可以从旧主节点之一运行以下命令。 您可以先将六台旧DBServer列入黑名单：</p>
<div class="highlight"><pre><span></span><code>export MSERVERS=node1:11000,node2:11000,node3:11000
~/mserver/bin/bm-admin -mserver_addresses $MSERVERS change_blacklist ADD node1:21000 node2:21000 node3:21000 node4:21000 node5:21000 node6:21000
</code></pre></div>
<p>验证黑名单信息是否类似于以下内容：</p>
<div class="highlight"><pre><span></span><code>~/mserver/bin/bm-admin -mserver_addresses $MSERVERS get_universe_config
Config:
version: 5
server_blacklist {
  hosts {
    host: &quot;node1&quot;
    port: 21000
  }
  hosts {
    host: &quot;node2&quot;
    port: 21000
  }
  ...
  ...
  hosts {
    host: &quot;node6&quot;
    port: 21000
  }
}
</code></pre></div>
<p>接下来，等待数据移动完成。 您可以通过运行以下命令来检查完成百分比：</p>
<div class="highlight"><pre><span></span><code>~/mserver/bin/bm-admin -mserver_addresses $MSERVERS get_load_move_completion
Percent complete = 66.6
</code></pre></div>
<p>在前面的示例中，数据移动已完成 66.6%。 定期重新运行此命令，直到返回值达到 100。</p>
<p>注：此数据移动所需的时间取决于以下因素：</p>
<ul>
<li>Tile/表数量</li>
<li>每块Tile的大小</li>
<li>磁盘/SSD 传输速度</li>
<li>新节点和现有节点之间的网络带宽</li>
</ul>
<h3 id="mserver_1"><strong>mserver法定人数变更</strong></h3>
<p>现在将mserver仲裁从旧的mserver集（节点 1、节点 2 和节点 3）移动到新的mserver集（节点 7、节点 8 和节点 9）。 为此，请按顺序添加一个新mserver，然后删除一个mserver，直到删除所有旧mserver。 这可以从新mserver之一运行。</p>
<p>ADD_SERVER 命令添加新的 mserver，REMOVE_SERVER 命令从 mserver 仲裁中删除旧的 mserver。 每执行一步后，请检查主 UI 上的 MServer 状态（位于 http://node7:10000）。</p>
<p>注：如果通过以下步骤在命令行上报告任何错误日志，请检查主 UI，因为该错误可能是过渡性的，可以忽略。</p>
<div class="highlight"><pre><span></span><code>export MSERVERS=node1:11000,node2:11000,node3:11000,node7:11000,node8:11000,node9:11000
~/mserver/bin/bm-admin -mserver_addresses $MSERVERS change_mserver_config ADD_SERVER node7 11000
~/mserver/bin/bm-admin -mserver_addresses $MSERVERS change_mserver_config REMOVE_SERVER node1 11000
~/mserver/bin/bm-admin -mserver_addresses $MSERVERS change_mserver_config ADD_SERVER node8 11000
~/mserver/bin/bm-admin -mserver_addresses $MSERVERS change_mserver_config REMOVE_SERVER node2 11000
~/mserver/bin/bm-admin -mserver_addresses $MSERVERS change_mserver_config ADD_SERVER node9 11000
~/mserver/bin/bm-admin -mserver_addresses $MSERVERS change_mserver_config REMOVE_SERVER node3 11000
</code></pre></div>
<p>现在确保mserver领导者是新的主节点之一，如下所示：</p>
<div class="highlight"><pre><span></span><code>$ export MSERVERS=node7:11000,node8:11000,node9:11000
$ ~/mserver/bin/bm-admin -mserver_addresses $MSERVERS list_all_mservers
</code></pre></div>
<div class="highlight"><pre><span></span><code>MSERVER UUID         RPC Host/Port          State      Role
...                   node8:11000           ALIVE     FOLLOWER
...                   node9:11000           ALIVE     FOLLOWER
...                   node7:11000           ALIVE     LEADER
</code></pre></div>
<p>并在 http://node7:10000/ 上确认同样的情况，mservers 列表中的主 IP 地址集只是三个新的 IP 地址。</p>
<p>在新的 MServer UI 页面上，确保所有新的 Tile 服务器都向 mserver Leader 报告并分配 Tile 负载。 例如，http://node7:10000/tile-servers 应显示六个新 DBServer 上的负载。 旧的DBServer可能处于DEAD状态。</p>
<h3 id="dbserver-mserver"><strong>更新 DBServer 上的mserver地址</strong></h3>
<p>所有新 DBServer 的 dbserver_mserver_addrs 参数需要设置为三个新主 IP 的列表：node7:11000、node8:11000、node9:11000，以供将来使用。</p>
<p>提示:如果 dbserver 服务器重新启动，则需要更新主地址。</p>
<h3 id="_33"><strong>清理</strong></h3>
<p>旧节点不再是Universe的一部分，可以关闭。 旧的 DBServer 终止后，您可以使用以下命令从主配置中清除黑名单：</p>
<div class="highlight"><pre><span></span><code>~/mserver/bin/bm-admin -mserver_addresses $MSERVERS change_blacklist REMOVE node1:21000 node2:21000 node3:21000 node4:21000 node5:21000 node6:21000
</code></pre></div>
<p>提示:清理黑名单服务器将有助于重新使用旧的 IP，以防它们被回收。</p>
<p>确保以下命令没有返回 server_blacklist 条目：</p>
<div class="highlight"><pre><span></span><code>~/mserver/bin/bm-admin -mserver_addresses $MSERVERS get_universe_config
</code></pre></div>
<h2 id="_34"><strong>诊断报告</strong></h2>
<p>默认情况下，每次创建新集群时以及此后每小时，MServer 和 DBServer 节点都会向 bigmath 诊断服务报告集群诊断信息。</p>
<p>不会收集或报告 BMDB 中存储的数据或个人身份信息。</p>
<h3 id="_35"><strong>收集的数据</strong></h3>
<p>收集的数据取决于收集级别。 要更改收集级别，请参阅配置诊断收集。</p>
<p><strong>1.收集等级：低</strong>
收集以下数据：</p>
<ul>
<li>收集时间</li>
<li>集群 uuid</li>
<li>节点 uuid</li>
<li>节点类型（dbserver 或 mserver）</li>
<li>MServer数量（mserver 进程）</li>
<li>Tile 服务器数量（dbserver 进程）</li>
<li>表格数量</li>
<li>Tile数量</li>
<li>集群配置（gflags）</li>
<li>主机名（对于运行 mserver 和 dbserver 进程的每个节点）</li>
<li>用户名（对于运行 mserver 和 dbserver 进程的每个节点）</li>
</ul>
<p><strong>2.收集等级：中[默认]</strong>
除了低级数据外，还收集以下数据：</p>
<ul>
<li>性能指标</li>
<li>RPC 指标</li>
</ul>
<p><strong>3.收藏等级：高</strong>
与中等水平相同。 不会为此级别收集任何额外信息。 将来可能会使用此级别来收集其他诊断信息，例如错误日志。</p>
<h3 id="_36"><strong>收集的指标示例</strong></h3>
<p>以下是收集的有效负载的示例：</p>
<div class="highlight"><pre><span></span><code>[
    {
        &quot;type&quot;: &quot;tile&quot;,
        &quot;id&quot;: &quot;eca8b3cfb2ee4eca94dde519634e1e38&quot;,
        &quot;attributes&quot;: {
            &quot;partition&quot;: &quot;hash_split: [16380, 19110)&quot;,
            &quot;table_name&quot;: &quot;redis&quot;,
            &quot;table_id&quot;: &quot;82f5f7ab81a44923b5f544fbd0664afe&quot;
        },
        &quot;metrics&quot;: [
            {
                &quot;name&quot;: &quot;log_reader_bytes_read&quot;,
                &quot;value&quot;: 0
            },
            {
                &quot;name&quot;: &quot;log_reader_entries_read&quot;,
                &quot;value&quot;: 0
            },
            {
                &quot;name&quot;: &quot;log_reader_read_batch_latency&quot;,
                &quot;total_count&quot;: 0,
                &quot;min&quot;: 0,
                &quot;mean&quot;: 0,
                &quot;percentile_75&quot;: 0,
                &quot;percentile_95&quot;: 0,
                &quot;percentile_99&quot;: 0,
                &quot;percentile_99_9&quot;: 0,
                &quot;percentile_99_99&quot;: 0,
                &quot;max&quot;: 0,
                &quot;total_sum&quot;: 0
            }
        ]
    }
]
</code></pre></div>
<p><strong>收集的 RPC 示例</strong></p>
<div class="highlight"><pre><span></span><code>{
    &quot;inbound_connections&quot;: [
        {
            &quot;remote_ip&quot;: &quot;10.150.0.20:41134&quot;,
            &quot;state&quot;: &quot;OPEN&quot;,
            &quot;remote_user_credentials&quot;: &quot;{real_user=bigmath, eff_user=}&quot;,
            &quot;processed_call_count&quot;: 2456
        },
        {
            &quot;remote_ip&quot;: &quot;10.150.0.20:54141&quot;,
            &quot;state&quot;: &quot;OPEN&quot;,
            &quot;remote_user_credentials&quot;: &quot;{real_user=bigmath, eff_user=}&quot;,
            &quot;processed_call_count&quot;: 2471
        }
    ]
}
</code></pre></div>
<h3 id="_37"><strong>配置诊断收集</strong></h3>
<p>您可以在启动 MServer 和 DBServer 节点时添加以下配置标志来配置 BMDB 的诊断报告行为。</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>callhome_collection_level</td>
<td>medium</td>
<td>收集级别，可能值为低、中或高</td>
</tr>
<tr>
<td>callhome_interval_secs</td>
<td>3600</td>
<td>收集间隔（以秒为单位）</td>
</tr>
<tr>
<td>callhome_url</td>
<td>http://diagnostics.bigmath.com</td>
<td>报告诊断信息的端点。</td>
</tr>
<tr>
<td>callhome_enabled</td>
<td>true</td>
<td>控制是否收集和报告诊断信息。 设置为 false 以禁用收集。</td>
</tr>
</tbody>
</table>
<h2 id="_38"><strong>安全权限</strong></h2>
<p>BMDB安全框架如下图：
<img alt="" src="./media/chapter6/43.png" /></p>
<h3 id="_39"><strong>安全检查清单</strong></h3>
<p><strong>1.启用身份验证</strong>
身份验证要求所有客户端在连接到 BMDB 集群之前提供有效的凭据。BMDB 在 MServer 系统表中内部存储身份验证凭据。客户端可用的身份验证机制取决于 BSQL、BCQL 和 YEDIS API 支持和公开的内容。</p>
<p>有关更多信息，请参阅 BMDB 中的身份验证。</p>
<p><strong>2.配置基于角色的访问控制</strong>
可以修改角色以根据用户或应用程序需要执行的数据库操作授予它们仅必要的权限。通常，首先创建一个管理员角色，然后管理员创建额外的用户角色。</p>
<p>有关更多信息，请参阅 BMDB 中的基于角色的访问控制。</p>
<p><strong>3.以专用用户身份运行</strong>
使用专用的操作系统用户帐户运行 MServer 和 DBServer 服务。确保该专用用户帐户具有访问数据驱动器的权限，但没有不必要的权限。</p>
<p><strong>4.限制网络暴露</strong>
<strong>（1）限制机器和端口访问</strong>
确保 BMDB 在可信任的网络环境中运行，其中：</p>
<ul>
<li>运行 BMDB 服务的服务器只能由运行应用程序和数据库管理员的服务器直接访问。</li>
<li>只有运行应用程序的服务器可以连接到 RPC 端口上的 BMDB 服务。其他人的访问权限应被拒绝。</li>
</ul>
<p><strong>（2）RPC 绑定接口</strong>
限制 BMDB 实例监听传入连接的接口。在启动 mserver 和 dbserver 时使用 --rpc_bind_addresses 选项指定所需的接口。不要绑定到回环地址。有关使用这些选项的更多信息，请参阅管理参考。</p>
<p><strong>（3）公共云的提示</strong></p>
<ul>
<li>如果可能，请不要为运行 BMDB 的节点分配公共 IP 地址。应用程序可以通过私有 IP 地址连接到 BMDB。</li>
<li>在亚马逊网络服务（AWS）中，将 BMDB 集群运行在一个单独的虚拟专用网络（VPC）中，并仅与需要数据库访问的 VPC 进行对等连接，例如运行应用程序的 VPC。</li>
<li>将分配给数据库服务器的安全组设置为非常严格。确保它们在必要的端口上可以相互通信，并仅将客户端可访问端口公开给所需的服务器集。请参阅 BMDB 端口列表。</li>
</ul>
<p><strong>5.启用传输加密</strong>
TLS 加密可确保服务器之间的网络通信安全。您可以配置 BMDB 使用 TLS 加密集群内部和客户端与服务器之间的网络通信。您应该在 BMDB 集群和客户端中启用传输加密，以确保在网络上传输的数据的隐私和完整性。</p>
<p>有关更多信息，请参阅 BMDB 中的传输加密。</p>
<p><strong>6.启用静态加密</strong>
静态加密可确保静态存储在磁盘上的数据受到保护。您可以配置 BMDB 使用自动生成的对称密钥执行集群范围的加密。</p>
<p>有关更多信息，请参阅 BMDB 中的静态加密。</p>
<h3 id="_40"><strong>启用认证</strong></h3>
<p>在 BSQL 和 BCQL 中启用用户身份验证需要在服务器启动时设置适当的标志：</p>
<ul>
<li>在 BSQL 中使用 --bsql_enable_auth=true</li>
<li>在 BCQL 中使用 --use_cassandra_authentication=true</li>
</ul>
<p>在 BSQL 中，通过设置 --bsql_hba_conf_csv 标志，可以进一步对客户端身份验证进行细粒度控制。您可以根据 IP 地址、身份验证方法和使用 TLS（也称为 SSL）证书定义对本地主机和远程客户端的访问规则。</p>
<h4 id="_41"><strong>启用用户认证</strong></h4>
<p>BSQL身份验证是基于角色的，用于验证BSQL用户的身份是否真实。在BMDB中，用户、组和角色是使用角色创建的。通常，具有登录权限的角色称为用户，而组是可以有多个成员用户的角色。</p>
<p>用户、角色和组允许管理员验证特定用户或角色是否被授权创建、访问、更改或删除数据库，或管理用户和角色。</p>
<p>身份验证验证用户的身份，而授权确定已验证用户的数据库访问权限。</p>
<p>授权是基于角色的访问控制管理过程。对于BSQL，启用身份验证将自动启用授权和基于角色的访问控制（RBAC）模型来确定访问权限。使用GRANT、REVOKE、CREATE ROLE、ALTER ROLE和DROP ROLE来管理权限。</p>
<p>用户和角色可以具有超级用户、非超级用户和登录权限，并且用户拥有的角色用于确定可用的访问权限。管理员可以使用CREATE ROLE语句（或其别名CREATE USER）创建用户和角色。创建用户和角色后，使用ALTER ROLE和DROP ROLE语句来更改或删除用户和角色。</p>
<h5 id="_42"><strong>默认用户和密码</strong></h5>
<p>启动BMDB群集时，使用名为bigmath的默认用户启动MServer和DBServer服务，然后将该用户连接到名为bigmath的默认数据库。</p>
<p>启用BSQL身份验证后，所有用户（包括bigmath）都需要密码才能登录BMDB数据库。默认的bigmath用户具有默认密码bigmath，当启用BSQL身份验证时，该用户可以登录BMDB。</p>
<h5 id="bsql"><strong>启用BSQL身份验证</strong></h5>
<p><strong>1.启动本地群集</strong>
要在本地的BMDB群集中启用BSQL身份验证，请在bm-ctl start命令中添加--bsql_enable_auth标志，如下所示：</p>
<div class="highlight"><pre><span></span><code>$ ./bin/bm-ctl start --bsql_enable_auth=true
</code></pre></div>
<p><strong>2.启动DBServer服务</strong>
要在可部署的BMDB群集中启用BSQL身份验证，您需要使用--bsql_enable_auth标志启动dbserver服务。您的命令应类似于以下内容：</p>
<div class="highlight"><pre><span></span><code>./bin/dbserver
--dbserver_mserver_addrs &lt;mserver addresses&gt;
--fs_data_dirs &lt;data directories&gt;
--bsql_enable_auth=true \

&gt;&amp; /home/centos/disk1/dbserver.out &amp;
</code></pre></div>
<p>您还可以通过将--bsql_enable_auth=true添加到DBServer配置文件（dbserver.conf）中来启用BSQL身份验证。有关更多信息，请参阅启动DBServers。</p>
<p><strong>3.打开BSQL shell（sqlsh）</strong>
启用身份验证的BMDB群集默认使用bigmath作为管理员用户和bigmath作为默认数据库。您可以通过从BMDB主目录运行以下sqlsh命令连接到群集并使用BSQL shell：</p>
<div class="highlight"><pre><span></span><code>$ ./bin/sqlsh -U bigmath
</code></pre></div>
<p>然后，您将被提示输入密码。成功登录后，您应该看到以下输出：</p>
<div class="highlight"><pre><span></span><code>sqlsh (11.2-BM-2.7.0.0-b0)
Type &quot;help&quot; for help.

bigmath=#
</code></pre></div>
<p><strong>4.常见的用户授权任务</strong>
常见的用户授权任务如下。有关授权的更详细信息，请参阅基于角色的访问控制。</p>
<p>有关配置身份验证的信息，请参阅身份验证。</p>
<p><strong>（1）创建用户</strong>
要添加新用户，请运行CREATE ROLE语句或其别名CREATE USER语句。用户是被授予LOGIN权限的角色。使用SUPERUSER选项创建的角色除了LOGIN权限外还具有对数据库的完全访问权限。超级用户可以在任何数据库资源上运行所有BSQL语句。</p>
<p>默认情况下，创建角色不会授予LOGIN或SUPERUSER权限，这些权限需要显式授予。</p>
<p><strong>创建普通用户</strong>
要添加一个名为john的新普通用户（非超级用户权限），并设置密码为PasswdForJohn，并授予他LOGIN权限，请运行以下CREATE ROLE命令。</p>
<div class="highlight"><pre><span></span><code>bigmath=# CREATE ROLE john WITH LOGIN PASSWORD &#39;PasswdForJohn&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE ROLE
</code></pre></div>
<p>要验证刚刚创建的用户账户，可以运行如下查询：</p>
<div class="highlight"><pre><span></span><code>bigmath=# SELECT rolname, rolsuper, rolcanlogin FROM pg_roles;
</code></pre></div>
<p>您应该看到以下输出。</p>
<div class="highlight"><pre><span></span><code>          rolname          | rolsuper | rolcanlogin
---------------------------+----------+-------------
 postgres                  | t        | t
 pg_monitor                | f        | f
 pg_read_all_settings      | f        | f
 pg_read_all_stats         | f        | f
 pg_stat_scan_tables       | f        | f
 pg_signal_backend         | f        | f
 pg_read_server_files      | f        | f
 pg_write_server_files     | f        | f
 pg_execute_server_program | f        | f
 bm_extension              | f        | f
 bm_fdw                    | f        | f
 bigmath                  | t        | t
 john                      | f        | t
(11 rows)
</code></pre></div>
<p><strong>创建具有SUPERUSER权限的用户</strong>
SUPERUSER权限应仅授予有限数量的用户。应用程序通常不应使用具有超级用户权限的帐户访问数据库。</p>
<p>只有具有SUPERUSER权限的角色才能创建具有SUPERUSER权限的新角色，或将其授予现有角色。</p>
<p>要创建具有LOGIN和SUPERUSER权限的超级用户admin，请使用具有超级用户权限的账户运行以下命令：</p>
<div class="highlight"><pre><span></span><code>bigmath=# CREATE ROLE admin WITH LOGIN SUPERUSER PASSWORD &#39;PasswdForAdmin&#39;;
</code></pre></div>
<p>要验证刚刚创建的admin账户，请运行以下查询：</p>
<div class="highlight"><pre><span></span><code>bigmath=# SELECT rolname, rolsuper, rolcanlogin FROM pg_roles;
</code></pre></div>
<p>您应该看到类似以下的表输出：</p>
<div class="highlight"><pre><span></span><code>      rolname          | rolsuper | rolcanlogin
---------------------------+----------+-------------
postgres | t | t
...
bigmath | t | t
john | f | t
admin | t | t
(12 rows)
</code></pre></div>
<p>（要查看pg_roles表中的所有可用信息，请运行SELECT * from pg_roles。）</p>
<p>在这个表中，您可以看到postgres、admin和bigmath用户可以登录并具有SUPERUSER状态。</p>
<p>作为一个更简单的替代方法，您可以运行\du元命令以以更简单的格式查看此信息：</p>
<div class="highlight"><pre><span></span><code>bigmath=# \du
</code></pre></div>
<div class="highlight"><pre><span></span><code>                               List of roles
Role name | Attributes | Member of
-----------+------------------------------------------------------------+-----------
admin | Superuser | {}
john | | {}
postgres | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
bigmath | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
</code></pre></div>
<p>具有SUPERUSER状态的用户在每个角色的属性列表中显示"Superuser"。</p>
<p><strong>（2）使用非默认凭据进行连接</strong>
您可以按以下方式连接到启用身份验证的群集：</p>
<div class="highlight"><pre><span></span><code>$ sqlsh -U &lt;username&gt;
</code></pre></div>
<p>然后会提示您输入密码。</p>
<p>例如，要使用您创建的用户john的凭据登录，您可以运行以下命令，并在提示时输入密码：</p>
<div class="highlight"><pre><span></span><code>$ sqlsh -U john
</code></pre></div>
<p><strong>（3）编辑用户账户</strong>
您可以使用ALTER ROLE命令编辑现有用户账户。执行更改的角色必须具有足够的权限来修改目标角色。</p>
<p><strong>更改用户密码</strong>
要更改john的密码，请输入以下命令：</p>
<div class="highlight"><pre><span></span><code>bigmath=# ALTER ROLE john PASSWORD &#39;new-password&#39;;
</code></pre></div>
<p><strong>授予和撤销超级用户权限</strong>
要验证john不是超级用户，请使用以下SELECT语句：</p>
<div class="highlight"><pre><span></span><code>bigmath=# SELECT rolname, rolsuper, rolcanlogin FROM pg_roles WHERE rolname=&#39;john&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>rolname | rolsuper | rolcanlogin
---------+----------+-------------
John   | f       | t
(1 row)
</code></pre></div>
<p>要将超级用户权限授予john，请以超级用户身份登录并运行以下ALTER ROLE命令：</p>
<div class="highlight"><pre><span></span><code>bigmath=# ALTER ROLE john SUPERUSER;
</code></pre></div>
<p>通过运行\du命令验证john现在是超级用户。</p>
<div class="highlight"><pre><span></span><code>bigmath=# \du
</code></pre></div>
<div class="highlight"><pre><span></span><code>                               List of roles
Role name | Attributes | Member of
-------------+------------------------------------------------------------+-----------
Admin   | Superuser | {}
john     | Superuser | {}
postgres  | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
bigmath | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
</code></pre></div>
<p>注意
在BMDB（就像在PostgreSQL中一样），超级用户状态包括以下所有属性：CREATEROLE（"Create role"）、CREATEDB（"Create DB"）、REPLICATION（"Replication"）和BYPASSRLS（"Bypass RLS"）。无论这些属性是否显示，所有超级用户都具有这些属性。</p>
<p>类似地，您可以通过运行以下命令来撤销超级用户权限：</p>
<div class="highlight"><pre><span></span><code>bigmath=# ALTER ROLE john WITH NOSUPERUSER;
</code></pre></div>
<p><strong>（4）启用和禁用登录权限</strong>
要验证john是否可以登录到数据库，请执行以下操作：</p>
<div class="highlight"><pre><span></span><code>bigmath=# SELECT rolname, rolcanlogin FROM pg_roles WHERE rolname=&#39;john&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>rolname | rolcanlogin
---------+-------------
John   | t
(1 rows)
</code></pre></div>
<p>要禁用john的登录权限，请运行以下命令：</p>
<div class="highlight"><pre><span></span><code>bigmath=# ALTER ROLE john WITH NOLOGIN;
</code></pre></div>
<p>您可以按如下方式进行验证：</p>
<div class="highlight"><pre><span></span><code>bigmath=# SELECT rolname, rolcanlogin FROM pg_roles WHERE rolname=&#39;john&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>rolname | rolcanlogin
---------+-------------
john | f
(1 row)
</code></pre></div>
<p>现在尝试使用sqlsh登录为john将失败：</p>
<div class="highlight"><pre><span></span><code>$ ./bin/sqlsh -U john
</code></pre></div>
<p>在输入正确的密码后，您会看到以下消息：</p>
<div class="highlight"><pre><span></span><code>Password for user john:
sqlsh: FATAL: role &quot;john&quot; is not permitted to log in
</code></pre></div>
<p>要重新启用john的登录权限，请运行以下命令。</p>
<div class="highlight"><pre><span></span><code>bigmath=# ALTER ROLE john WITH LOGIN;
</code></pre></div>
<p><strong>（5）删除用户</strong>
您可以使用DROP ROLE语句删除用户。</p>
<p>例如，要删除用户john，请以超级用户身份运行以下命令：</p>
<div class="highlight"><pre><span></span><code>bigmath=# DROP ROLE john;
</code></pre></div>
<p>要验证john角色是否已删除，请运行\du命令：</p>
<div class="highlight"><pre><span></span><code>bigmath=# \du
</code></pre></div>
<div class="highlight"><pre><span></span><code>                               List of roles
Role name | Attributes | Member of
-----------+------------------------------------------------------------+-----------
admin | Superuser | {}
postgres | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
bigmath | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
</code></pre></div>
<h4 id="_43"><strong>创建登录配置文件</strong></h4>
<p>在 BSQL 中创建和配置登录配置文件
使用登录配置文件防止暴力破解。</p>
<p>为增强数据库的安全性，您可以启用登录配置文件，以在指定的登录尝试次数后锁定账户，从而防止暴力破解攻击。</p>
<p>启用登录配置文件后，具有超级用户权限的数据库管理员可以创建登录配置文件，并将角色分配给这些配置文件。</p>
<p>角色没有默认配置文件；如果您希望策略适用于所有用户，则必须显式地将所有具有登录权限的角色分配给配置文件。</p>
<p>在创建配置文件时，您必须指定在该配置文件关联的账户被锁定之前允许的失败尝试次数。</p>
<p>每次在登录过程中进行身份验证失败时，失败尝试次数就会增加一次。如果失败尝试次数等于预设限制，那么账户将被锁定。例如，如果限制为3，用户在第三次失败尝试后将被锁定。</p>
<p>如果身份验证成功，或者管理员解锁了被锁定的账户，失败尝试次数将重置为0。</p>
<h5 id="_44"><strong>启用登录配置文件</strong></h5>
<p><strong>1.启动本地集群</strong>
要在本地的BMDB集群中启用登录配置文件，您需要在bm-ctl start命令的--dbserver_flags标志中包含DBServer --bsql_enable_profile标志，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl start --dbserver_flags=&quot;bsql_enable_profile=true&quot;
</code></pre></div>
<p><strong>启动DBServer服务</strong>
要在可部署的BMDB集群中启用登录配置文件，您需要使用--bsql_enable_profile标志启动DBServer服务。您的命令应该类似于以下内容：</p>
<div class="highlight"><pre><span></span><code>./bin/dbserver \
  --dbserver_mserver_addrs &lt;主节点地址&gt; \
  --fs_data_dirs &lt;数据目录&gt; \
  --bsql_enable_auth=true \
  --bsql_enable_profile=true \
  &gt;&amp; /home/centos/disk1/dbserver.out &amp;
</code></pre></div>
<p>您还可以通过在DBServer配置文件（dbserver.conf）中添加--bsql_enable_profile=true来启用BSQL登录配置文件。</p>
<p>如需更多信息，请参考"Start DBServers"文档。</p>
<h5 id="_45"><strong>管理登录配置文件</strong></h5>
<p>启用配置文件后，您可以使用以下命令管理登录配置文件：
CREATE PROFILE
DROP PROFILE
ALTER ROLE</p>
<p>只有超级用户才能创建或删除配置文件，并将配置文件分配给角色。</p>
<p><strong>1.创建和删除配置文件</strong>
要创建配置文件，请执行以下操作：</p>
<div class="highlight"><pre><span></span><code>CREATE PROFILE myprofile LIMIT
  FAILED_LOGIN_ATTEMPTS &lt;number&gt;;
  [PASSWORD_LOCK_TIME &lt;days&gt;];
</code></pre></div>
<p>您可以按如下方式删除配置文件：</p>
<div class="highlight"><pre><span></span><code>DROP PROFILE myprofile;
</code></pre></div>
<p><strong>2.分配角色给配置文件：</strong>
使用ALTER ROLE命令将角色分配给特定的配置文件。例如：</p>
<div class="highlight"><pre><span></span><code>ALTER ROLE myuser PROFILE myprofile;
</code></pre></div>
<p>此命令将名为"myuser"的角色与名为"myprofile"的配置文件关联起来。</p>
<p>使用ALTER ROLE命令将角色从配置文件中移除。例如：</p>
<div class="highlight"><pre><span></span><code>ALTER ROLE myuser NOPROFILE;
</code></pre></div>
<p>此命令将角色"myuser"与任何配置文件的关联解除。</p>
<p><strong>3.锁定和解锁角色：</strong>
使用以下命令解锁已被锁定的角色：</p>
<div class="highlight"><pre><span></span><code>ALTER ROLE myuser ACCOUNT UNLOCK;
</code></pre></div>
<p>使用以下命令将角色锁定，使其无法登录：</p>
<div class="highlight"><pre><span></span><code>ALTER ROLE myuser ACCOUNT LOCK;
</code></pre></div>
<p><strong>4.从完全锁定中恢复：</strong>
如果您锁定包括管理员角色在内的所有角色，则必须在禁用 --bsql_enable_profile 标志的情况下重新启动集群。</p>
<p>虽然禁用登录配置文件允许用户重新登录，但您将无法更改任何配置文件信息，因为禁用配置文件标志时无法运行配置文件命令。</p>
<p>要重新启用帐户，请执行以下操作：
（1）在未启用配置文件的情况下重新启动集群。
（2）创建一个新的超级用户。
（3）在启用配置文件的情况下重新启动集群。
（4）以新超级用户身份连接并发出配置文件命令来解锁帐户。</p>
<h5 id="_46"><strong>查看登录配置文件</strong></h5>
<p>pg_bm_profile 表列出了配置文件及其属性。</p>
<p>要查看配置文件，请执行以下语句：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM pg_bm_profile;
</code></pre></div>
<p>输出如下：</p>
<div class="highlight"><pre><span></span><code>  prfname  | prfmaxfailedloginattempts | prfpasswordlocktime 
-----------+---------------------------+---------------------
 myprofile |                         3 |                   0
(1 row)
</code></pre></div>
<p>以下是对列及其值的描述：
对于pg_bm_profile表：</p>
<table>
<thead>
<tr>
<th><strong>COLUMN</strong></th>
<th><strong>TYPE</strong></th>
<th><strong>DESCRIPTION</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>prfname</td>
<td>name</td>
<td>配置文件的名称。必须是唯一的。</td>
</tr>
<tr>
<td>prfmaxfailedloginattempts</td>
<td>int</td>
<td>允许的最大失败登录尝试次数。</td>
</tr>
<tr>
<td>prfpasswordlocktime</td>
<td>int</td>
<td>锁定账户的时间间隔（以秒为单位）。NULL表示角色将被无限期锁定。</td>
</tr>
</tbody>
</table>
<p>对于pg_bm_role_profile表：</p>
<table>
<thead>
<tr>
<th><strong>COLUMN</strong></th>
<th><strong>TYPE</strong></th>
<th><strong>DEFAULT</strong></th>
<th><strong>DESCRIPTION</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>rolprfrole</td>
<td>OID</td>
<td></td>
<td>PG_ROLE表中行的OID。</td>
</tr>
<tr>
<td>rolprfprofile</td>
<td>OID</td>
<td></td>
<td>PROFILE表中行的OID。</td>
</tr>
<tr>
<td>rolprfstatus</td>
<td>char</td>
<td>o</td>
<td>账户的状态，可能的取值如下：o (OPEN)：允许登录。t (LOCKED(TIMED))：锁定一段时间，持续时间由rolprflockeduntil中存储的时间戳确定。（注意，不支持定时锁定。）l (LOCKED)：无限期锁定，只能由管理员解锁。</td>
</tr>
<tr>
<td>rolprffailedloginattempts</td>
<td>int</td>
<td>0</td>
<td>角色的失败登录尝试次数。</td>
</tr>
<tr>
<td>rolprflockeduntil</td>
<td>timestamptz</td>
<td>Null</td>
<td>如果rolprfstatus为t，则表示角色被锁定的持续时间。否则，该值为NULL且不使用。</td>
</tr>
</tbody>
</table>
<h4 id="_47"><strong>配置客户端认证</strong></h4>
<p>在BSQL中配置客户端身份验证
在BMDB中，针对BSQL的客户端身份验证是由DBServer的--bsql_hba_conf_csv配置标志来管理的，它的工作方式类似于PostgreSQL中的pg_hba.conf文件。</p>
<p>--bsql_hba_conf_csv配置标志的值包括指定允许的连接类型、用户、客户端IP地址和身份验证方法的记录。</p>
<p>BMDB的bsql_hba.conf文件中的记录是基于--bsql_hba_conf_csv配置标志中包含的值自动生成的。</p>
<p>例如，使用以下--bsql_hba_conf_csv配置标志启动DBServer将为所有用户启用信任身份验证：</p>
<div class="highlight"><pre><span></span><code>--bsql_hba_conf_csv=&#39;host all all 0.0.0.0/0 trust, host all all ::0/0 trust&#39;
</code></pre></div>
<p>要显示bsql_hba.conf文件中的当前值，可以运行以下SHOW语句以获取文件位置：</p>
<div class="highlight"><pre><span></span><code>bigmath=# SHOW hba_file;
</code></pre></div>
<p>输出将显示bsql_hba.conf文件的位置，然后您可以查看该文件。以下是bsql_hba.conf文件内容的示例：</p>
<div class="highlight"><pre><span></span><code># This is an autogenerated file, do not edit manually!
host all all 0.0.0.0/0 trust
host all all ::0/0 trust
</code></pre></div>
<p>请注意，这是一个自动生成的文件，不要手动编辑。</p>
<p>要了解更多信息，请参考BMDB的主机基于身份验证文档。</p>
<h3 id="_48"><strong>认证方式</strong></h3>
<p>身份验证是数据库服务器建立客户端身份的过程，并通过扩展确定是否允许客户端应用程序（或运行客户端应用程序的用户）使用所请求的数据库用户名进行连接。 BMDB 提供了多种不同的客户端身份验证方法。 可以根据（客户端）主机地址、数据库和用户来选择用于验证特定客户端连接的方法。</p>
<h4 id="_49"><strong>密码认证</strong></h4>
<p>默认情况下，密码身份验证处于禁用状态，允许用户和客户端轻松连接到 BMDB 并与之交互。 对于生产集群，密码身份验证对于最大限度地提高安全性非常重要。 密码身份验证方法的工作原理类似，但不同之处在于用户密码在服务器上的存储方式以及客户端提供的密码如何通过连接发送。</p>
<h5 id="bmdb"><strong>BMDB数据库密码</strong></h5>
<p>BMDB 数据库密码与操作系统密码是分开的。 每个数据库用户的密码存储在 pg_authid 系统目录中。</p>
<p>可以使用以下方式管理数据库密码：</p>
<ul>
<li>BSQL API：创建角色和更改角色</li>
<li>sqlsh 元命令：\password</li>
</ul>
<p>无论何时使用 CREATE ROLE 或 ALTER ROLE 设置密码，passwordcheck 扩展都可用于强制执行强密码。 passwordcheck 仅适用于以纯文本形式提供的密码。 有关更多信息，请参阅 PostgreSQL 密码检查文档。</p>
<h5 id="_50"><strong>密码认证方式</strong></h5>
<p>BMDB 支持以下密码验证方法。</p>
<p><strong>1.MD5</strong>
MD5 方法 (md5) 可防止密码嗅探，并避免以纯文本形式将密码存储在服务器上，但如果攻击者从服务器或客户端获取密码哈希（通过嗅探、中间人或通过其他方式），则无法提供保护。 蛮力）。 MD5是BMDB集群的默认密码加密。</p>
<p>MD5 哈希算法不被认为能够安全地抵御确定的攻击。 一些安全风险包括：</p>
<ul>
<li>如果某人有权访问有效的用户名/密码组合或其 MD5 样式的哈希值，他们就可以使用相同的用户名和密码登录到该用户所在的任何集群。</li>
<li>每次使用 MD5 身份验证方法时，“共享秘密”都会通过线路有效共享。</li>
</ul>
<p>2.SCRAM-SHA-256
SCRAM-SHA-256 方法 (scram-sh-256) 执行 SCRAM-SHA-256 身份验证，如 RFC 7677 中所述。这种质询-响应方案可防止在不受信任的连接上进行密码嗅探，并支持以最安全的方式将密码存储在 BMDB 集群上。 可用加密散列形式。 此处实现的 SCRAM-SHA-256 方法在 SASL 身份验证（PostgreSQL 文档）中有更详细的解释。 这是可用的最安全的密码身份验证，并且大多数 BSQL API 客户端驱动程序都支持。</p>
<ul>
<li>允许两方验证他们都知道某个秘密，而无需交换该秘密。</li>
<li>SCRAM-SHA-256 加密使用 SASL 身份验证机制流程来限制暴力攻击和嗅探带来的安全风险。</li>
</ul>
<h5 id="scram-sha-256"><strong>启用 SCRAM-SHA-256 身份验证</strong></h5>
<p>要在BMDB中启用SCRAM-SHA-256身份验证，请按照以下步骤操作：</p>
<p>1.将密码加密方法更改为SCRAM-SHA-256，通过向DBServer配置中添加--bsql_pg_conf_csv标志。该标志允许您指定额外的PostgreSQL配置设置。将password_encryption的值设置为scram-sha-256。例如：</p>
<div class="highlight"><pre><span></span><code>--bsql_pg_conf_csv=&quot;password_encryption=scram-sha-256&quot;
</code></pre></div>
<p>或者在dbserver.conf文件中添加以下行：</p>
<div class="highlight"><pre><span></span><code>--bsql_pg_conf_csv=password_encryption=scram-sha-256
</code></pre></div>
<p>2.指定基于主机的身份验证规则，通过添加--bsql_hba_conf_csv标志到DBServer配置中。该标志允许您定义规则，确定使用的身份验证方法。例如，以下示例将默认的trust规则修改为使用SCRAM-SHA-256身份验证：
--bsql_hba_conf_csv='host all all 0.0.0.0/0 scram-sha-256,host all all ::0/0 scram-sha-256'</p>
<p>或者在dbserver.conf文件中添加以下行：
--bsql_hba_conf_csv=host all all 0.0.0.0/0 scram-sha-256,host all all ::0/0 scram-sha-256</p>
<p>通过使用--bsql_hba_conf_csv标志指定适合您安全需求的规则，可以进一步详细配置基于主机的认证规则。</p>
<h5 id="scram-sha-256_1"><strong>创建使用 SCRAM-SHA-256 密码身份验证的集群</strong></h5>
<p>要在新的BMDB集群中使用SCRAM-SHA-256密码身份验证，请按照以下步骤操作：</p>
<p>1.在DBServer配置文件（flagfile）中添加以下两行：</p>
<div class="highlight"><pre><span></span><code>--bsql_pg_conf_csv=password_encryption=scram-sha-256
--bsql_hba_conf_csv=host all all 0.0.0.0/0 md5,host all all ::0/0 md5,host all all 0.0.0.0/0 scram-sha-256,host all all ::0/0 scram-sha-256
</code></pre></div>
<ul>
<li>第一行将您的BMDB集群启动，并将密码加密设置为使用SCRAM-SHA-256加密所有新密码。</li>
<li>上述的bsql_hba_conf_csv标志指定了一些规则，允许使用MD5和SCRAM-SHA-256现有密码连接到数据库。</li>
</ul>
<p>2.启动BMDB集群。</p>
<p>3.打开BSQL shell（sqlsh），指定bigmath用户并提示输入密码：</p>
<div class="highlight"><pre><span></span><code>$ ./sqlsh -U bigmath -W
</code></pre></div>
<p>当提示输入密码时，输入bigmath密码（默认为bigmath）。您应该能够成功登录并看到类似以下的响应：</p>
<div class="highlight"><pre><span></span><code>sqlsh (11.2-BM-2.3.3.0-b0)
Type &quot;help&quot; for help.

bigmath=#
</code></pre></div>
<p>4.更改bigmath用户的密码为SCRAM-SHA-256密码。</p>
<p>您可以使用ALTER ROLE语句或sqlsh的\password元命令来更改密码。新密码将使用SCRAM-SHA-256哈希算法进行加密。在以下示例中，使用\password元命令来更改密码：</p>
<div class="highlight"><pre><span></span><code>\password
</code></pre></div>
<p>您将被提示两次输入新密码，然后返回到BSQL shell提示符。</p>
<div class="highlight"><pre><span></span><code>Enter new password:
Enter it again:
bigmath=#
</code></pre></div>
<p>5.停止BMDB集群。</p>
<p>6.从--bsql_hba_conf_csv标志中删除MD5规则。</p>
<p>在flagfile中，更新后的标志应如下所示：</p>
<div class="highlight"><pre><span></span><code>--bsql_hba_conf_csv=host all all 0.0.0.0/0 scram-sha-256,host all all ::0/0 scram-sha-256
</code></pre></div>
<p>7.重新启动BMDB集群。</p>
<p>8.打开BSQL shell并登录，指定bigmath用户和密码提示：</p>
<div class="highlight"><pre><span></span><code>$ ./sqlsh -U bigmath -W
</code></pre></div>
<p>当提示时，使用更改后的bigmath用户密码进行登录。任何新创建的用户或角色都将使用SCRAM-SHA-256进行加密。对主机和数据库的访问受到您在DBServer --bsql_hba_conf_csv配置标志中指定的规则的限制。</p>
<h5 id="md5scram-sha-256"><strong>对现有的MD5密码进行迁移至SCRAM-SHA-256</strong></h5>
<p>当您在已存在具有用户和角色（使用MD5密码）的BMDB集群上启用SCRAM-SHA-256身份验证时，需要注意以下几点：</p>
<ul>
<li>所有新密码或更改的密码将使用SCRAM-SHA-256哈希算法进行加密。</li>
<li>所有现有密码都是使用MD5哈希算法进行加密的。</li>
</ul>
<p>由于所有现有密码都必须更改，您可以通过在--bsql_hba_conf_csv设置中保留规则，允许MD5密码和SCRAM-SHA-256密码同时有效，直到所有密码都已迁移到SCRAM-SHA-256。有关示例，请参见上述的“创建使用SCRAM-SHA-256密码身份验证的集群”。</p>
<p>如果您按照类似的方法处理现有集群，可以增强集群安全性，跟踪和迁移密码，然后在所有密码更新后删除较弱的MD5规则。</p>
<h5 id="_51"><strong>重置用户密码</strong></h5>
<p>在PostgreSQL中，如果管理员密码丢失或更改为未知值，可以更改pg_hba.conf文件以允许管理员不需要密码就可以访问数据库。这是一个静态文件，用于控制客户端身份验证。 要重置postgres用户的密码，请更改配置文件中的参数，重新启动数据库，然后以无密码的postgres身份登录，并重置密码。
BMDB中，使用稍微不同的实现方式。BMDB有一个类似于PostgreSQL的bsql_hba.conf文件。然而，与PostgreSQL不同的是，文件的内容是通过dbserver启动时的--bsql_hba_conf_csv配置标志动态生成的。</p>
<p>要更改bsql_hba.conf文件以允许管理员无密码访问，请使用以下--bsql_hba_conf_csv配置标志重新启动dbserver：</p>
<div class="highlight"><pre><span></span><code>--bsql_hba_conf_csv=host all bigmath 0.0.0.0/0 trust,host all all 0.0.0.0/0 md5,host all bigmath ::0/0 trust,host all all ::0/0 md5
</code></pre></div>
<p>重新启动dbserver后，对于除bigmath用户之外的所有用户，将强制进行密码身份验证。现在，您可以无需密码连接：</p>
<div class="highlight"><pre><span></span><code>$ ./bin/sqlsh
</code></pre></div>
<p>然后，更新用户的密码为新的所需密码：</p>
<div class="highlight"><pre><span></span><code>ALTER ROLE bigmath WITH PASSWORD &#39;new-password&#39;;
</code></pre></div>
<p>撤销配置并重新启动dbserver，以再次为bigmath用户启用密码身份验证。</p>
<h4 id="ldap"><strong>LDAP认证</strong></h4>
<p>LDAP 验证方法与密码方法类似，只不过它使用 LDAP 来验证密码。 因此，在使用 LDAP 进行身份验证之前，用户必须已存在于数据库中（并且具有适当的权限）。</p>
<p>通过使用 --bsql_hba_conf_csv 标志设置 LDAP 配置，可以在 BMDB 集群中启用 LDAP 身份验证。</p>
<p>BMDB 支持简单绑定和搜索+绑定模式进行 LDAP 身份验证。</p>
<h5 id="_52"><strong>简单绑定模式</strong></h5>
<p>在简单绑定模式下，DBServer 绑定到以“前缀用户名后缀”格式构造的专有名称（“DN”）。 以下是使用简单绑定模式的示例：</p>
<div class="highlight"><pre><span></span><code>--bsql_hba_conf_csv=&#39;host all bigmath 127.0.0.1/0 password,&quot;host all all 0.0.0.0/0 ldap ldapserver=ldap.bigmath.com ldapprefix=&quot;&quot;uid=&quot;&quot; ldapsuffix=&quot;&quot;, ou=DBAs, dc=example, dc=com&quot;&quot; ldapport=389&quot;&#39;
</code></pre></div>
<p><strong>配置</strong>
简单绑定模式支持以下配置：</p>
<table>
<thead>
<tr>
<th>T-SERVER标志</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ldapserver</td>
<td>(empty)</td>
<td>要连接的 LDAP 服务器的名称或 IP 地址。 用空格分隔服务器。</td>
</tr>
<tr>
<td>ldapport</td>
<td>389</td>
<td>LDAP 服务器上要连接的端口号。</td>
</tr>
<tr>
<td>ldapscheme</td>
<td>(empty)</td>
<td>设置为 ldaps 以使用 LDAPS。 这是通过 SSL 使用 LDAP 的非标准方式，某些 LDAP 服务器实现支持这种方式。 另请参阅 ldaptls 选项以获取替代方案。</td>
</tr>
<tr>
<td>ldaptls</td>
<td>0</td>
<td>设置为 1 以使 PostgreSQL 和 LDAP 服务器之间的连接使用 TLS 加密。</td>
</tr>
<tr>
<td>ldapprefix</td>
<td>(empty)</td>
<td>形成用于绑定到 LDAP 服务器的 DN 时要添加到用户名前面的字符串。</td>
</tr>
<tr>
<td>ldapsuffix</td>
<td>(empty)</td>
<td>形成用于绑定到 LDAP 服务器的 DN 时要附加到用户名的字符串。</td>
</tr>
</tbody>
</table>
<h5 id="_53"><strong>搜索+绑定模式</strong></h5>
<p>在搜索+绑定模式下，bm-dbserver 使用 ldapbinddn 和 ldapbindpasswd 指定的固定用户名和密码绑定到 LDAP 目录，并对尝试登录数据库的用户执行搜索。 当找到用户后，服务器会断开连接，并通过客户端指定的密码以该用户的身份重新绑定到目录，以验证登录是否正确。 此模式常用于其他软件中的 LDAP 认证方案。</p>
<p>为了搜索 LDAP 目录，如果 DBServer 上没有配置固定的用户名和密码，则会尝试匿名绑定该目录。 搜索在 ldapbasedn 的子树上执行，并尝试与 ldapsearchattribute 中指定的属性进行精确匹配。</p>
<p>以下是搜索+绑定模式的示例：</p>
<div class="highlight"><pre><span></span><code>--bsql_hba_conf_csv=&#39;host all bigmath 127.0.0.1/0 password,&quot;host all all 0.0.0.0/0  ldap ldapserver=ldap.bigmath.com ldapbasedn=&quot;&quot;dc=bigmath, dc=com&quot;&quot; ldapsearchattribute=uid&quot;&#39;
</code></pre></div>
<p><strong>配置</strong>
搜索+绑定模式支持以下配置：</p>
<table>
<thead>
<tr>
<th>T-SERVER标志</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ldapserver</td>
<td>(empty)</td>
<td>要连接的 LDAP 服务器的名称或 IP 地址。 用空格分隔服务器。</td>
</tr>
<tr>
<td>ldapport</td>
<td>389</td>
<td>LDAP 服务器上要连接的端口号。</td>
</tr>
<tr>
<td>ldapscheme</td>
<td>(empty)</td>
<td>设置为 ldaps 以使用 LDAPS。 这是通过 SSL 使用 LDAP 的非标准方式，某些 LDAP 服务器实现支持这种方式。 另请参阅 ldaptls 选项以获取替代方案。</td>
</tr>
<tr>
<td>ldaptls</td>
<td>0</td>
<td>设置为 1 以使 PostgreSQL 和 LDAP 服务器之间的连接使用 TLS 加密。</td>
</tr>
<tr>
<td>ldapbasedn</td>
<td>(empty)</td>
<td>指定开始用户名搜索的基目录</td>
</tr>
<tr>
<td>ldapbinddn</td>
<td>(empty)</td>
<td>指定进行搜索+绑定身份验证时执行初始搜索的用户名</td>
</tr>
<tr>
<td>ldapbindpasswd</td>
<td>(empty)</td>
<td>执行搜索+绑定身份验证时用于执行初始搜索的用户名密码</td>
</tr>
<tr>
<td>ldapsearchattribute</td>
<td>uid</td>
<td>进行搜索+绑定身份验证时与搜索中的用户名进行匹配的属性。 如果未指定属性，则使用 uid 属性。</td>
</tr>
<tr>
<td>ldapsearchfilter</td>
<td>(empty)</td>
<td>进行搜索+绑定身份验证时使用的搜索过滤器。</td>
</tr>
<tr>
<td>ldapurl</td>
<td>(empty)</td>
<td>RFC 4516 LDAP URL。 这是以更紧凑和标准的形式编写 LDAP 选项的另一种方法。</td>
</tr>
</tbody>
</table>
<h5 id="_54"><strong>配置示例</strong></h5>
<p>要在新的 BMDB 集群上使用 LDAP 密码身份验证，请执行以下步骤：</p>
<p>1.使用 --bsql_hba_conf_csv 配置标志启动 BMDB 集群，以在 DBServer 上启用 LDAP 身份验证。</p>
<p>使用以下配置启动集群：</p>
<div class="highlight"><pre><span></span><code>--bsql_hba_conf_csv=&#39;host all bigmath 127.0.0.1/0 password,&quot;host all all 0.0.0.0/0 ldap ldapserver=ldap.forumsys.com ldapprefix=&quot;&quot;uid=&quot;&quot; ldapsuffix=&quot;&quot;, dc=example, dc=com&quot;&quot; ldapport=389&quot;&#39;
</code></pre></div>
<p>注：此示例配置使用在线 LDAP 测试服务器来设置 BMDB 的 LDAP 身份验证。</p>
<p>为了方便起见，配置使用两个基于主机的身份验证规则：</p>
<ul>
<li>第一条规则host all bigmath 127.0.0.1/0 password，允许通过密码身份验证从本地主机 (127.0.0.1) 访问管理员用户 (bigmath)。 这允许管理员登录并为 LDAP 用户设置角色（和权限）。</li>
<li>第二条规则使用带有基于 uid 的用户名 (ldapprefix) 和定义域组件的后缀 (dc) 的简单绑定，为所有其他用户/主机对配置 LDAP 身份验证。</li>
</ul>
<p>2.启动指定 bigmath 用户的 BSQL shell (sqlsh)，并在出现提示时输入密码（默认为 bigmath）。</p>
<div class="highlight"><pre><span></span><code>$ ./sqlsh -U bigmath -W
</code></pre></div>
<div class="highlight"><pre><span></span><code>sqlsh (11.2-BM-2.3.3.0-b0)
Type &quot;help&quot; for help.

bigmath=#
</code></pre></div>
<p>3.要显示 bsql_hba.conf 文件中的当前值，请运行以下 SHOW 语句来获取文件位置：</p>
<div class="highlight"><pre><span></span><code>bigmath=# SHOW hba_file;
</code></pre></div>
<div class="highlight"><pre><span></span><code>                     hba_file
-------------------------------------------------------
 /Users/bigmath/bigmath-data/node-1/disk-1/pg_data/bsql_hba.conf
(1 row)
</code></pre></div>
<p>4.查看文件。 bsql_hba.conf 文件应具有以下配置：</p>
<div class="highlight"><pre><span></span><code># This is an autogenerated file, do not edit manually!
host all bigmath 127.0.0.1/0 trust
host all all      0.0.0.0/0  ldap ldapserver=ldap.forumsys.com ldapprefix=&quot;uid=&quot; ldapsuffix=&quot;, dc=example, dc=com&quot; ldapport=389
</code></pre></div>
<p>5.为 LDAP 用户配置数据库角色。 以下命令为测试 LDAP 服务器支持的用户 riemann 创建角色：</p>
<div class="highlight"><pre><span></span><code>bigmath=# CREATE ROLE riemann WITH LOGIN;
bigmath=# GRANT ALL ON DATABASE bigmath TO riemann;
</code></pre></div>
<p>使用 LDAP 身份验证进行连接。</p>
<p>使用在线 LDAP 测试服务器页面中指定的 riemann LDAP 用户和密码通过 sqlsh 进行连接。</p>
<div class="highlight"><pre><span></span><code>$ ./sqlsh -U riemann -W
</code></pre></div>
<p>您可以通过运行以下命令来确认当前用户：</p>
<div class="highlight"><pre><span></span><code>bigmath=# SELECT current_user;
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_user
--------------
 riemann
(1 row)
</code></pre></div>
<h4 id="_55"><strong>基于主机的认证</strong></h4>
<p>BMDB 基于主机的 BSQL 身份验证管理本地主机、远程主机和客户端的访问控制。 使用基于主机的身份验证，您可以根据 IP 地址、身份验证方法和 TLS（又名 SSL）证书的使用来定义访问本地主机和远程客户端的规则。</p>
<p>默认的 BMDB Listen_addresses 设置仅接受来自本地主机的连接。 要允许远程连接，您必须将客户端身份验证记录添加到 DBServer --bsql_hba_conf_csv 配置标志。 该标志的工作方式与 PostgreSQL 中的 pg_hba.conf 文件类似。 这些值包括指定允许的连接类型、用户、客户端 IP 地址和身份验证方法的记录。 这些记录存储在自动生成的 BMDB bsql_hba.conf 文件中。</p>
<p>当收到连接请求时，BMDB 会执行以下操作：
1.连续搜索 bsql_hba.conf 记录，直到找到具有匹配连接类型、客户端地址、请求的数据库和用户名的第一条记录。
2.根据匹配记录进行身份验证。
3.如果连接请求中提供的信息与预期内容匹配，则允许访问。 如果身份验证失败，则不会评估后续记录并拒绝访问。</p>
<p>--bsql_hba_conf_csv 标志在集群启动时读取。 如果您在活动集群上编辑该文件，则需要重新启动 dbserver 进程才能使更改生效。</p>
<p><strong>重要的：对 --bsql_hba_conf_csv 的更改应应用于滚动升级和重新启动中的所有 dbserver 服务器，确保所有 DBServer 不会同时停止。</strong></p>
<p>系统视图 pg_hba_file_rules 有助于预先测试对 --bsql_hba_conf_csv 标志的更改，或者在该标志没有达到预期效果时诊断问题。 视图中具有非空错误字段的行指示文件相应行中的问题。</p>
<p><strong>提示：要连接到特定数据库，用户不仅必须通过 --bsql_hba_conf_csv 检查，而且必须具有该数据库的 CONNECT 权限。 要限制哪些用户可以连接到哪些数据库，授予或撤销 CONNECT 权限通常比将规则放在 --bsql_hba_conf_csv 条目中更容易。 请参阅 GRANT 和 REVOKE BSQL 语句。</strong></p>
<h5 id="bsql_hbaconf"><strong>bsql_hba.conf 文件</strong></h5>
<p>BMDB bsql_hba.conf 文件中的记录是根据 --bsql_hba_conf_csv 标志中包含的值自动生成的。 例如，使用以下 --bsql_hba_conf_csv 标志启动 DBServer 将为除 bigmath 之外的所有用户启用 MD5 授权，bigmath 在从本地主机连接时可以使用信任：</p>
<div class="highlight"><pre><span></span><code>--bsql_hba_conf_csv=&quot;host all bigmath 127.0.0.1/0 trust, host all all 0.0.0.0/0 md5, host all bigmath ::1/128 trust, host all all ::0/0 md5&quot;
</code></pre></div>
<p>要显示 bsql_hba.conf 文件中的值，请运行以下 SHOW 语句来获取文件位置：</p>
<div class="highlight"><pre><span></span><code>bigmath=# SHOW hba_file;
</code></pre></div>
<div class="highlight"><pre><span></span><code>                             hba_file
-------------------------------------------------------------------
 /Users/bigmath/bigmath-data/node-1/disk-1/pg_data/bsql_hba.conf
(1 row)
</code></pre></div>
<p>然后查看文件。 由于该文件是自动生成的，因此编辑内容将被自动生成的内容覆盖。 这是一个示例。</p>
<div class="highlight"><pre><span></span><code># This is an autogenerated file, do not edit manually!
host all bigmath 127.0.0.1/0 trust
host all bigmath ::1/128 trust
/Users/bigmath/bigmath-data/node-1/disk-1/pg_data/bsql_hba.conf (END)
</code></pre></div>
<p>由于每次连接尝试都会按顺序检查 bsql_hba.conf 记录，因此记录的顺序很重要。 通常，较早的记录具有严格的连接匹配参数和较弱的身份验证方法，而较晚的记录具有较宽松的匹配参数和较强的身份验证方法。 例如，您可能希望对本地 TCP/IP 连接使用信任身份验证，但需要远程 TCP/IP 连接的密码。 在这种情况下，为来自 127.0.0.1 的连接指定信任身份验证的记录将出现在为更广泛的允许客户端 IP 地址指定密码身份验证的记录之前。</p>
<h5 id="_56"><strong>记录字段</strong></h5>
<p>--bsql_hba_conf_csv 标志中指定的每条记录必须与本地、CIDR 地址或 IP 地址可用的以下记录格式之一匹配：</p>
<div class="highlight"><pre><span></span><code>local       database  user  auth-method   [auth-options]
host        database  user  address      auth-method  [auth-options]
hostssl      database  user  address      auth-method  [auth-options]
hostnossl    database  user  address      auth-method  [auth-options]
host        database  user  IP-address    netmask     auth-method  [auth-options]
hostssl      database  user  IP-address    netmask     auth-method  [auth-options]
hostnossl    database  user  IP-address    netmask     auth-method  [auth-options]
</code></pre></div>
<p><strong>1.连接</strong>
（1）local
在BMDB中，与PostgreSQL类似，当使用本地认证方法（如"peer"或"trust"）时，可以通过UNIX套接字打开连接。然而，与PostgreSQL不同的是，当使用以下认证方法时，BMDB要求在使用sqlsh、psql和其他工具时提供套接字位置的完整路径：</p>
<ul>
<li>使用"peer"进行本地认证</li>
<li>使用"trust"进行本地认证</li>
</ul>
<p>获取套接字位置的一种方法是从DBServer日志中查找，类似于以下内容：</p>
<div class="highlight"><pre><span></span><code>2023-09-05 13:56:20.154 UTC [1261] LOG: listening on Unix socket &quot;/tmp/.bm.127.0.0.1:2521/.s.PGSQL.2521&quot;
</code></pre></div>
<p>使用sqlsh时，您可以使用"-h"标志，并按以下方式传递路径的第一部分（例如，/tmp/.bm.127.0.0.1:2521/）：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -h /tmp/.bm.127.0.0.1:2521
</code></pre></div>
<p>对于psql，您还需要指定端口号，如下所示：</p>
<div class="highlight"><pre><span></span><code>psql -h /tmp/.bm.127.0.0.1:2521/ -p 2521
</code></pre></div>
<p>（3）host
此记录匹配使用TCP/IP进行的连接尝试，包括本地主机。host记录可以匹配使用SSL或非SSL的连接尝试。</p>
<p>（4）hostssl
此记录指定可以使用SSL连接到BMDB集群的本地或远程主机。</p>
<p>（5）hostnossl
此记录仅匹配不使用SSL的TCP/IP连接尝试。</p>
<p><strong>2.数据库</strong>
指定该记录匹配哪些数据库名称。 有效值包括：</p>
<ul>
<li>all：匹配所有数据库。</li>
<li>SameUser：如果请求的数据库与请求的用户同名，则记录匹配。</li>
<li>samerole：请求的用户必须是与请求的数据库同名的角色的成员。 出于相同角色的目的，超级用户不被视为角色的成员，除非他们直接或间接地明确成为角色的成员，而不仅仅是因为是超级用户。</li>
<li>replication：如果请求物理复制连接，则记录匹配（请注意，复制连接不指定任何特定数据库）。 否则，这是特定 PostgreSQL 数据库的名称。</li>
</ul>
<p>可以通过用逗号分隔来提供多个数据库名称。 可以通过在文件名前添加 @ 来指定包含数据库名称的单独文件。</p>
<p>@ 构造包含的文件被读取为名称列表，可以用空格或逗号分隔。 注释由 # 引入，就像在 --bsql_hba_conf_csv 标志中一样，并且允许嵌套 @ 结构。 除非@后面的文件名是绝对路径，否则它被视为相对于包含引用文件的目录。</p>
<p><strong>3.用户</strong>
指定该记录匹配哪些数据库用户名。 有效值包括：</p>
<ul>
<li>all 匹配所有用户。 否则，它是特定数据库用户的名称，或者是前面带有 + 的组名称。 （回想一下，BMDB 中的用户和组之间没有真正的区别；+ 实际上意味着“匹配直接或间接属于该角色的任何角色”，而没有 + 的名称仅匹配该特定角色。） 为此，只有当超级用户直接或间接地明确是某个角色的成员，而不仅仅是因为是超级用户时，才被视为该角色的成员。</li>
</ul>
<p>可以通过用逗号分隔来提供多个用户名。</p>
<p>可以通过在文件名前添加 @ 来指定包含用户名的单独文件。</p>
<p><strong>4.Address</strong>
指定该记录匹配的客户端计算机地址。 该字段可以包含主机名、IP 地址范围或下面提到的特殊关键字之一。</p>
<p>（1）IP地址
IP 地址范围是使用范围起始地址的标准数字表示法指定的，然后是斜杠 (/) 和 CIDR 掩码长度。 掩码长度表示必须匹配的客户端 IP 地址的高位位数。 在给定的 IP 地址中，其右侧的位应为零。 IP 地址、/ 和 CIDR 掩码长度之间不能有任何空格。</p>
<p>以这种方式指定的 IPv4 地址范围的示例为：对于单个主机为 172.20.143.89/32，对于小型网络为 172.20.143.0/24，或者对于较大网络为 10.6.0.0/16。 0.0.0.0/0 代表所有 IPv4 地址。</p>
<p>IPv6 地址范围对于单个主机（在本例中为 IPv6 环回地址）可能类似于 ::1/128，对于小型网络可能类似于 fe80::7a31:c1ff:0000:0000/96。 ::0/0 代表所有 IPv6 地址。</p>
<p>要指定单个主机，请对 IPv4 使用掩码长度 32，对 IPv6 使用掩码长度 128。 在网络地址中，请勿省略尾随零。</p>
<p>以 IPv4 格式给出的条目将仅匹配 IPv4 连接，以 IPv6 格式给出的条目将仅匹配 IPv6 连接，即使表示的地址位于 IPv4-in-IPv6 范围内。 如果系统的 C 库不支持 IPv6 地址，则 IPv6 格式的条目将被拒绝。</p>
<p>（2）Key words 
您还可以使用以下关键词：</p>
<ul>
<li>all 匹配任何 IP 地址。</li>
<li>SameHost 匹配任何服务器自己的 IP 地址。</li>
<li>Samenet 匹配服务器直接连接到的任何子网中的任何地址。</li>
</ul>
<p>（3）Host names 
如果指定了主机名（任何不是 IP 地址范围或特殊关键字的内容都被视为主机名），则将该名称与客户端 IP 地址的反向名称解析结果进行比较（例如，反向 DNS 查找（如果使用 DNS）。 主机名比较不区分大小写。 如果存在匹配，则对主机名执行正向名称解析（例如，正向 DNS 查找），以检查其解析到的任何地址是否等于客户端的 IP 地址。 如果两个方向都匹配，则认为该条目匹配。 （--bsql_hba_conf_csv 标志中指定的主机名应该是客户端 IP 地址的地址到名称解析返回的主机名，否则该行将不会匹配。某些主机名数据库允许将一个 IP 地址与多个主机关联 名，但操作系统在要求解析 IP 地址时只会返回一个主机名。）</p>
<p>以点 (.) 开头的主机名规范与实际主机名的后缀匹配。 因此 .example.com 将匹配 foo.example.com （但不仅仅是 example.com）。</p>
<p>当使用 --bsql_hba_conf_csv 标志指定主机名时，您希望名称解析相当快。 设置本地名称解析缓存（例如 nscd）可能会很有利。</p>
<p><strong>5.IP 地址 | 网络掩码</strong>
这两个字段可以用作 IP 地址/掩码长度表示法的替代。 实际掩码不是指定掩码长度，而是在单独的列中指定。 例如，255.0.0.0 表示 IPv4 CIDR 掩码长度为 8，255.255.255.255 表示 CIDR 掩码长度为 32。</p>
<p>适用于 host、hostssl 和 hostnossl 记录。</p>
<p>当只有一台主机时，网络掩码为 255.255.255.255，代表单个 IP 地址。 有关详细信息，请参阅网络掩码快速参考。</p>
<p><strong>6.auth-method</strong> 
指定当连接与此记录匹配时要使用的身份验证方法。</p>
<p>（1）trust
指定来自已定义主机的任何用户都可以连接到 BMDB 数据库，而无需密码。 如果指定的主机不安全或向未知用户提供访问权限，则存在安全风险。 即使对于本地连接，也应该使用对等连接。</p>
<p>（2）reject
指定应拒绝主机或用户。 无条件拒绝连接。 使用它可以从组中过滤掉某些主机。 例如，拒绝行可能会阻止特定主机连接，而后面的行则允许特定网络中的其余主机进行连接。</p>
<p>（3）MD5
使用md5密码加密。 详细信息请参见密码认证。</p>
<p>（4）scram-sha256
使用 scram-sha256 密码加密。 详细信息请参见密码认证。</p>
<p>（5）password
指定对于连接用户，提供的密码必须与全局 bm_show 系统表中用户名的密码匹配。 密码必须以明文形式发送。</p>
<p>（6）ident
通过联系客户端上的ident服务器获取客户端的操作系统用户名，并检查是否与请求的数据库用户名匹配。 身份验证只能在 TCP/IP 连接上使用。 当为本地连接指定时，将使用对等身份验证。</p>
<p>（7）peer 
从操作系统获取客户端的操作系统用户名，并检查是否与请求的数据库用户名匹配。 这仅适用于本地连接。</p>
<p>（8）LDAP
使用 LDAP 进行密码验证。 有关更多信息，请参阅LDAP 身份验证。</p>
<p>（9）cert
指定任何用户都需要 TLS 证书才能连接。 有关更多信息，请参阅传输中加密。</p>
<p>（10）gss
指定任何用户都需要 GSSAPI 身份验证才能连接。</p>
<p><strong>7.授权选项</strong>
在 auth-method 字段之后，您可以以 name=value 的形式添加字段，指定特定于身份验证方法的选项。</p>
<p>除了特定于方法的选项之外，还有一个与方法无关的身份验证选项 clientcert，可以在任何 Hostssl 记录中指定。 当设置为 1 时，除了身份验证方法的其他要求之外，此选项还要求客户端提供有效（受信任）的 SSL 证书。</p>
<h5 id="_57"><strong>示例</strong></h5>
<p>1.Single host entry
以下记录允许 IP 地址为 192.168.1.10 的单个主机以任何用户（全部）身份连接到任何数据库（全部），而无需密码（信任）。</p>
<div class="highlight"><pre><span></span><code>host all 192.168.1.10 255.255.255.255 trust
</code></pre></div>
<p>2.local entry
以下记录允许以用户 bigmath 的身份本地连接到任何数据库，无需密码（信任）。</p>
<div class="highlight"><pre><span></span><code>local all bigmath trust
</code></pre></div>
<p>3.hostssl entry 
以下记录允许任何用户从任何地址使用 md5 密码身份验证到任何数据库的 SSL 连接。</p>
<div class="highlight"><pre><span></span><code>hostssl all all all md5
</code></pre></div>
<h4 id="_58"><strong>信任认证</strong></h4>
<p>当指定信任身份验证时，BMDB 假定任何尝试连接 DBServer 的用户都可以使用他们指定的数据库用户名访问数据库。 这种方式对于本地连接BMDB集群来说比较合适，也非常方便。</p>
<p>默认情况下，BMDB 集群使用信任身份验证。 可以通过设置以下 --bsql_hba_conf_csv 标志来显式指定信任身份验证：</p>
<div class="highlight"><pre><span></span><code>--bsql_hba_conf_csv=&#39;host all all 0.0.0.0/0 trust, host all all ::0/0 trust&#39;
</code></pre></div>
<h3 id="_59"><strong>基于角色的访问控制</strong></h3>
<h4 id="_60"><strong>概述</strong></h4>
<p>BSQL 中基于角色的访问控制 (RBAC) 模型是授予角色的资源权限的集合。 因此，整个 RBAC 模型是围绕角色、资源和权限构建的。 为了理解 RBAC 模型，必须理解这些概念。</p>
<h5 id="_61"><strong>角色</strong></h5>
<p>BSQL 中的角色可以代表单个用户或一组用户。 它们封装了一组可以分配给其他角色（或用户）的权限。 角色对于在 BMDB 集群上实施和管理访问控制至关重要。 以下是有关角色的一些要点：</p>
<ul>
<li>具有 LOGIN 权限的角色是用户。 因此，所有用户都是角色，但并非所有角色都是用户。</li>
<li>角色可以被授予其他角色，从而可以将角色组织成层次结构。</li>
<li>角色继承授予它们的所有其他角色的特权。</li>
</ul>
<p>BMDB 继承了 PostgreSQL 的许多角色，包括 postgres 用户，并添加了几个新角色。 使用以下命令查看集群的 BMDB 特定角色（或使用 \duS 显示所有角色）：</p>
<div class="highlight"><pre><span></span><code>bigmath=&gt; \du
</code></pre></div>
<div class="highlight"><pre><span></span><code>                                     List of roles
  Role name   |                         Attributes                         | Member of
--------------------+--------------------------------------------------------------------------------------+-----------
 postgres     | Superuser, Create role, Create DB, Replication, Bypass RLS       | {}
 bm_extension  | Cannot login                                               | {}
 bm_fdw       | Cannot login                                               | {}
 bigmath     | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
</code></pre></div>
<p>下面描述了 BMDB 集群中默认的 BSQL 角色和用户。
Postgres：在数据库创建期间创建的超级用户角色。
bm_extension：允许非超级用户创建 PostgreSQL 扩展的角色。
bm_fdw：允许非超级用户创建、更改和删除外部数据包装器的角色。
bigmath：在数据库创建期间使用的超级用户角色，由 bigmath 支持执行维护操作以及备份（使用 bm-dump）。</p>
<p><strong>bm_extension</strong>
bm_extension 角色允许非超级用户角色创建扩展。 授予此角色的用户可以创建 BMDB 中捆绑的所有扩展。</p>
<p>创建角色 test 并将 bm_extension 授予该角色。</p>
<div class="highlight"><pre><span></span><code>bigmath=# create role test;
bigmath=# grant bm_extension to test;
bigmath=# set role test;
bigmath=&gt; select * from current_user;
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_user
--------------
 test
(1 row)
</code></pre></div>
<p>以测试用户身份创建一个扩展并检查它是否已创建。</p>
<div class="highlight"><pre><span></span><code>bigmath=&gt; create extension pgcrypto;
bigmath=&gt; select * from pg_extension where extname=&#39;pgcrypto&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> extname  | extowner | extnamespace | extrelocatable | extversion | extconfig | extcondition
--------------+------------+-----------------+----------------+--------------+--------------+--------------
 pgcrypto |    16386 |         2200 | t         | 1.3       |          |
</code></pre></div>
<h5 id="_62"><strong>资源</strong></h5>
<p>BSQL 定义了许多代表底层数据库对象的特定资源。 资源可以代表一个对象或对象的集合。 BSQL 资源是分层的，如下所述：</p>
<ul>
<li>数据库和表遵循层次结构：所有数据库 &gt; 数据库 &gt; 表</li>
<li>角色是分层的（它们可以分配给其他角色）。 它们遵循层次结构：所有角色 &gt; 角色 #1 &gt; 角色 #2 ...</li>
</ul>
<p>下面列出了各种资源。
DATABASE：表示一个数据库。 通常包括该数据库中定义的所有表和索引。
TABLE：表示一张表。 包括该表上定义的所有索引。
ROLE：表示一个角色。
ALL DATABASES：数据库中所有数据库的集合。
ALL ROLES：数据库中所有角色的集合。</p>
<h5 id="_63"><strong>权限</strong></h5>
<p>对数据库对象执行操作需要权限。 权限可以在数据库层次结构的任何级别授予，并向下继承。 该组权限包括：</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>对象</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>变更</td>
<td>Database,table,role</td>
<td>alter</td>
</tr>
<tr>
<td>授权</td>
<td>Database,table,role</td>
<td>GRANT privilege, REVOKE privilege</td>
</tr>
<tr>
<td>创建</td>
<td>database, table, role, index</td>
<td>create</td>
</tr>
<tr>
<td>删除</td>
<td>database, table, role, index</td>
<td>drop</td>
</tr>
<tr>
<td>修改</td>
<td>database, table</td>
<td>Insert,update,delete,truncate</td>
</tr>
<tr>
<td>查询</td>
<td>database, table</td>
<td>select</td>
</tr>
</tbody>
</table>
<h4 id="_64"><strong>管理用户和角色</strong></h4>
<p>BSQL 中的角色可以代表单个用户或一组用户。 用户是具有登录权限的角色。</p>
<p>您可以使用 CREATE ROLE、GRANT、REVOKE 和 DROP ROLE 语句来管理角色和用户。</p>
<h5 id="_65"><strong>创建角色</strong></h5>
<p>您可以使用 CREATE ROLE 语句创建角色。</p>
<p>例如，要为组织中的工程团队创建角色工程，请执行以下操作：</p>
<div class="highlight"><pre><span></span><code>bigmath=# CREATE ROLE engineering;
</code></pre></div>
<p>具有 LOGIN 权限的角色是用户。 例如，创建用户john如下：</p>
<div class="highlight"><pre><span></span><code>bigmath=# CREATE ROLE john LOGIN PASSWORD &#39;PasswdForJohn&#39;;
</code></pre></div>
<h5 id="_66"><strong>授予角色</strong></h5>
<p>您可以将一个角色授予另一个角色（可以是用户），或撤销已授予的角色。 执行 GRANT 和 REVOKE 操作需要对被授予或撤销的角色具有 AUTHORIZE 权限。</p>
<p>例如，您可以将上面创建的工程角色授予用户 john，如下所示：</p>
<div class="highlight"><pre><span></span><code>bigmath=# GRANT engineering TO john;
</code></pre></div>
<h5 id="_67"><strong>创建角色层次结构</strong></h5>
<p>在 BSQL 中，您可以创建角色层次结构。 层次结构中任何角色的权限都是向下流动的。</p>
<p>例如，您可以创建一个开发人员角色，该角色继承工程角色的所有权限。</p>
<p>首先，创建开发人员角色。</p>
<div class="highlight"><pre><span></span><code>bigmath=# CREATE ROLE developer;
</code></pre></div>
<p>接下来，将工程角色授予开发人员角色。</p>
<div class="highlight"><pre><span></span><code>bigmath=# GRANT engineering TO developer;
</code></pre></div>
<h5 id="_68"><strong>列出角色</strong></h5>
<p>您可以通过运行以下语句列出所有角色：</p>
<div class="highlight"><pre><span></span><code>bigmath=# SELECT rolname, rolcanlogin, rolsuper, memberof FROM pg_roles;
</code></pre></div>
<p>输出如下：</p>
<div class="highlight"><pre><span></span><code> rolname     | rolcanlogin | rolsuper | memberof
-------------+-------------+----------+-----------------
 john        | t           | f        | {engineering}
 developer   | f           | f        | {engineering}
 engineering | f           | f        | {}
 bigmath    | t           | t        | {}

(4 rows)
</code></pre></div>
<p>在表中，请注意以下事项：</p>
<ul>
<li>bigmath 角色是内置超级用户。</li>
<li>角色 john 可以登录，因此是一个用户。 请注意，john 不是超级用户。</li>
<li>工程师和开发人员角色无法登录。</li>
<li>john 和developer 都继承了工程角色。</li>
</ul>
<h5 id="_69"><strong>撤销角色</strong></h5>
<p>使用 REVOKE 语句撤销角色。</p>
<p>例如，您可以撤销用户 john 的工程角色，如下所示：</p>
<div class="highlight"><pre><span></span><code>bigmath=# REVOKE engineering FROM john;
</code></pre></div>
<p>现在列出所有角色表明 john 不再继承工程角色：</p>
<div class="highlight"><pre><span></span><code>bigmath=# SELECT rolname, rolcanlogin, rolsuperuser, memberof FROM pg_roles;
</code></pre></div>
<div class="highlight"><pre><span></span><code> rolname     | rolcanlogin | rolsuper | memberof
-------------+-------------+----------+-----------------
john         | t           | f        | {}
developer    | f           | f        | {engineering}
engineering  | f           | f        | {}
bigmath     | t           | t        | {}

(4 rows)
</code></pre></div>
<h5 id="_70"><strong>删除角色</strong></h5>
<p>使用 DROP ROLE 语句删除角色。</p>
<p>例如，您可以使用以下语句删除开发人员角色：</p>
<div class="highlight"><pre><span></span><code>bigmath=# DROP ROLE developer;
</code></pre></div>
<p>列出所有角色时，开发人员角色不再存在：</p>
<div class="highlight"><pre><span></span><code>bigmath=# SELECT rolname, rolcanlogin, rolsuper, memberof FROM pg_roles;
</code></pre></div>
<div class="highlight"><pre><span></span><code> rolname     | rolcanlogin | rolsuper | memberof
-------------+-------------+----------+-----------
 john        | t           | f        | {}
 engineering | f           | f        | {}
 bigmath    | t           | t        | {}

(3 rows)
</code></pre></div>
<h4 id="_71"><strong>授权</strong></h4>
<p>本教程演示如何使用一家公司的场景在 BSQL 中授予权限，该公司的工程组织包含三个子团队：开发人员、QA 和数据库管理员。</p>
<p>以下是您希望从基于角色的访问控制 (RBAC) 角度实现的目标：</p>
<p>所有工程成员都应该能够从任何数据库和表中读取数据。
开发人员和 QA 都应该能够修改数据库 dev_database 中现有表中的数据。
QA 应该能够更改数据库 dev_database 中的integration_tests 表。
数据库管理员应该能够对任何数据库执行所有操作。
本练习假设您已启用 BSQL 身份验证。</p>
<ol>
<li>创建角色层次结构
   使用超级用户角色连接到集群。 对于本教程，使用默认的 bigmath 用户并使用 sqlsh 连接到集群，如下所示：</li>
</ol>
<div class="highlight"><pre><span></span><code>$ ./bin/sqlsh
</code></pre></div>
<p>创建数据库dev_database。</p>
<div class="highlight"><pre><span></span><code>bigmath=# CREATE database dev_database;
</code></pre></div>
<p>切换到 dev_database。</p>
<div class="highlight"><pre><span></span><code>bigmath=# \c dev_database
</code></pre></div>
<p>创建integration_tests表：</p>
<div class="highlight"><pre><span></span><code>dev_database=# CREATE TABLE integration_tests (
                 id UUID PRIMARY KEY,
                 time TIMESTAMP,
                 result BOOLEAN,
                 details JSONB
                 );
</code></pre></div>
<p>接下来，创建角色 Engineering、Developer、qa 和 db_admin。</p>
<div class="highlight"><pre><span></span><code>dev_database=# CREATE ROLE engineering;
                 CREATE ROLE developer;
                 CREATE ROLE qa;
                 CREATE ROLE db_admin;
</code></pre></div>
<p>将工程角色授予开发人员、qa 和 db_admin 角色，因为它们都是工程组织的一部分。</p>
<div class="highlight"><pre><span></span><code>dev_database=# GRANT engineering TO developer;
                 GRANT engineering TO qa;
                 GRANT engineering TO db_admin;
</code></pre></div>
<ol>
<li>列出角色的权限
   您可以使用 \du 元命令列出授予各种角色的所有权限：</li>
</ol>
<div class="highlight"><pre><span></span><code>dev_database=# \du
</code></pre></div>
<p>输出如下：</p>
<div class="highlight"><pre><span></span><code>     List of roles
  Role name   |                         Attributes                         |   Member of
--------------+------------------------------------------------------------+---------------
 db_admin     | Cannot login                                               | {engineering}
 developer    | Cannot login                                               | {engineering}
 engineering  | Cannot login                                               | {}
 postgres     | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
 qa           | Cannot login                                               | {engineering}
 bm_extension | Cannot login                                               | {}
 bm_fdw       | Cannot login                                               | {}
 bigmath     | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
</code></pre></div>
<p>这展示了bigmath角色的各种角色属性。 因为bigmath是超级用户，所以它拥有所有数据库的所有权限。</p>
<ol>
<li>为角色授予权限
   在本部分中，您将向每个角色授予权限。</li>
</ol>
<p>（1）授予读取权限
所有工程成员都应该能够从任何数据库和表中读取数据。 使用 GRANT 语句将现有表 (integration_tests) 的 SELECT（或读取）访问权限授予工程角色。 这可以按如下方式完成：</p>
<div class="highlight"><pre><span></span><code>dev_database=# GRANT SELECT ON integration_tests to engineering;
dev_database=# GRANT USAGE ON SCHEMA public TO engineering;
</code></pre></div>
<p>使用 \z 元命令验证工程角色是否对表具有 SELECT 权限，该命令列出了表及其关联的访问权限：</p>
<div class="highlight"><pre><span></span><code>dev_database=# \z
</code></pre></div>
<p>输出如下：</p>
<div class="highlight"><pre><span></span><code> Schema |       Name        | Type  |     Access privileges     | Column privileges | Policies
--------+-------------------+-------+---------------------------+-------------------+----------
 public | integration_tests | table | bigmath=arwdDxt/bigmath+|                   |
        |                   |       | engineering=r/bigmath   +|                   |
</code></pre></div>
<p>访问权限“arwdDxt”包括用户bigmath（超级用户）的所有权限，而角色工程仅具有“r”（读取）权限。 有关 GRANT 语句和访问权限的详细信息，请参阅 GRANT。</p>
<p>将角色工程授予任何其他角色会导致所有这些角色继承指定的权限。 因此，developer、qa 和 db_admin 都继承了 SELECT 和 USAGE 权限，赋予他们读取访问权限。</p>
<p>（2）授予数据修改权限
开发人员和质量保证人员都应该能够修改数据库 dev_database 中现有表的数据。 他们应该能够执行 INSERT、UPDATE、DELETE 或 TRUNCATE 等语句来修改现有表上的数据。</p>
<div class="highlight"><pre><span></span><code>dev_database=# GRANT INSERT, UPDATE, DELETE, TRUNCATE ON table integration_tests TO developer;
dev_database=# GRANT INSERT, UPDATE, DELETE, TRUNCATE ON table integration_tests TO qa;
</code></pre></div>
<p>验证开发人员和质量保证角色是否具有适当的权限。</p>
<div class="highlight"><pre><span></span><code>dev_database=# \z
</code></pre></div>
<div class="highlight"><pre><span></span><code> Access privileges
 Schema |       Name        | Type  |     Access privileges     | Column privileges | Policies
--------+-------------------+-------+---------------------------+-------------------+----------
 public | integration_tests | table | bigmath=arwdDxt/bigmath+|                   |
        |                   |       | engineering=r/bigmath   +|                   |
        |                   |       | developer=awdD/bigmath  +|                   |
        |                   |       | qa=awdD/bigmath          |                   |
</code></pre></div>
<p>现在，开发人员和质量保证角色拥有表integration_tests 的访问权限awdD（追加/插入、写入/更新、删除和截断）。</p>
<p>（3）授予更改表访问权限
QA (qa) 应该能够更改数据库 dev_database 中的表integration_tests。 这可以按如下方式完成。</p>
<div class="highlight"><pre><span></span><code>dev_database=# ALTER TABLE integration_tests OWNER TO qa;
</code></pre></div>
<p>运行以下命令来验证权限。</p>
<div class="highlight"><pre><span></span><code>dev_database=# \z
</code></pre></div>
<p>所有者已从 bigmath 更改为 qa，并且 qa 拥有表integration_tests 的所有访问权限 (arwdDxt)</p>
<div class="highlight"><pre><span></span><code>Access privileges
 Schema |       Name        | Type  | Access privileges | Column privileges | Policies
--------+-------------------+-------+-------------------+-------------------+----------
 public | integration_tests | table | qa=arwdDxt/qa    +|                   |
        |                   |       | engineering=r/qa +|                   |
        |                   |       | developer=awdD/qa |                   |
</code></pre></div>
<p>（4）授予所有权限
数据库管理员应该能够对数据库执行所有操作。 您可以通过授予数据库管理员超级用户权限来做到这一点。 这样做也为数据库管理员提供了所有角色的所有权限。 只有超级用户才能授予超级用户权限。</p>
<p>要授予超级用户，请执行以下操作：</p>
<div class="highlight"><pre><span></span><code>dev_database=# ALTER USER db_admin WITH SUPERUSER;
</code></pre></div>
<p>运行以下命令来验证权限：</p>
<div class="highlight"><pre><span></span><code>dev_database=# \du
</code></pre></div>
<div class="highlight"><pre><span></span><code>                                       List of roles
  Role name   |                         Attributes                         |   Member of
--------------+------------------------------------------------------------+---------------
 db_admin     | Superuser, Cannot login                                    | {engineering}
 developer    | Cannot login                                               | {engineering}
 engineering  | Cannot login                                               | {}
 postgres     | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
 qa           | Cannot login                                               | {engineering}
 bm_extension | Cannot login                                               | {}
 bm_fdw       | Cannot login                                               | {}
 bigmath     | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
</code></pre></div>
<ol>
<li>撤销角色的权限
   要撤销数据库管理员的超级用户，以便他们无法再更改其他角色的权限，请执行以下操作：</li>
</ol>
<div class="highlight"><pre><span></span><code>dev_database=# ALTER USER db_admin WITH NOSUPERUSER;
</code></pre></div>
<p>运行以下命令来验证权限：</p>
<div class="highlight"><pre><span></span><code>dev_database=# \du
</code></pre></div>
<p>List of roles</p>
<div class="highlight"><pre><span></span><code>  Role name   |                         Attributes                         |   Member of
--------------+------------------------------------------------------------+---------------
 db_admin     | Cannot login                                               | {engineering}
 developer    | Cannot login                                               | {engineering}
 engineering  | Cannot login                                               | {}
 postgres     | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
 qa           | Cannot login                                               | {engineering}
 bm_extension | Cannot login                                               | {}
 bm_fdw       | Cannot login                                               | {}
 bigmath     | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
</code></pre></div>
<h4 id="_72"><strong>行级安全机制</strong></h4>
<p>除了通过角色和授权权限系统提供的数据库访问权限外，BMDB还提供了更细粒度的安全性，即表可以具有限制用户访问的行安全策略。</p>
<p>行级安全（RLS）限制了正常查询返回的行，以及可以通过DML命令进行插入、更新或删除的行。RLS策略可以针对特定的DML命令或使用ALL命令创建。它们还可以用于为特定角色或多个角色创建策略。</p>
<p>默认情况下，表不具有定义任何行级策略；如果用户对表具有访问权限，则可以查询和更新表中的所有行。</p>
<p>此示例使用行级安全策略来限制员工只能查看具有其各自姓名的行。</p>
<p>1.创建示例表
打开 BSQL shell (sqlsh)，指定 bigmath 用户并提示输入密码。</p>
<div class="highlight"><pre><span></span><code>$ ./sqlsh -U bigmath -W
</code></pre></div>
<p>当提示输入密码时，输入 bigmath 密码。 您应该能够登录并看到类似于以下内容的响应：</p>
<div class="highlight"><pre><span></span><code>sqlsh (11.2-BM-2.5.0.0-b0)
Type &quot;help&quot; for help.

bigmath=#
</code></pre></div>
<p>创建一个员工表并插入一些示例行：</p>
<div class="highlight"><pre><span></span><code>create table employees ( empno int, ename text, address text, salary int,
                         account_number text );
</code></pre></div>
<div class="highlight"><pre><span></span><code>insert into employees values (1, &#39;joe&#39;, &#39;56 grove st&#39;,  20000, &#39;AC-22001&#39; );
insert into employees values (2, &#39;mike&#39;, &#39;129 81 st&#39;,  80000, &#39;AC-48901&#39; );
insert into employees values (3, &#39;julia&#39;, &#39;1 finite loop&#39;,  40000, &#39;AC-77051&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> empno | ename |    address    | salary | account_number
-------+-------+---------------+--------+----------------
     1 | Joe   | 56 grove st   |  20000 | AC-22001
     2 | Mike  | 129 81 st     |  80000 | AC-48901
     3 | Julia | 1 finite loop |  40000 | AC-77051
(3 rows)
</code></pre></div>
<p>2.授予用户访问权限
通过根据行中的条目创建用户来设置数据库，并为他们提供表访问权限。</p>
<div class="highlight"><pre><span></span><code>create user joe;
grant select on employees to joe;
</code></pre></div>
<div class="highlight"><pre><span></span><code>create user mike;
grant select on employees to mike;
</code></pre></div>
<div class="highlight"><pre><span></span><code>create user julia;
grant select on employees to julia;
</code></pre></div>
<p>此时，用户可以看到所有的数据。</p>
<div class="highlight"><pre><span></span><code>\c bigmath joe;
select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> empno | ename |    address    | salary | account_number
-------+-------+---------------+--------+----------------
     1 | Joe   | 56 grove st   |  20000 | AC-22001
     3 | Julia | 1 finite loop |  40000 | AC-77051
     2 | Mike  | 129 81 st     |  80000 | AC-48901
(3 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>\c bigmath mike;
select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> empno | ename |    address    | salary | account_number
-------+-------+---------------+--------+----------------
     1 | Joe   | 56 grove st   |  20000 | AC-22001
     3 | Julia | 1 finite loop |  40000 | AC-77051
     2 | Mike  | 129 81 st     |  80000 | AC-48901
(3 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>\c bigmath julia;
select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> empno | ename |    address    | salary | account_number
-------+-------+---------------+--------+----------------
     1 | Joe   | 56 grove st   |  20000 | AC-22001
     3 | Julia | 1 finite loop |  40000 | AC-77051
     2 | Mike  | 129 81 st     |  80000 | AC-48901
(3 rows)
</code></pre></div>
<p>3.为用户设置 RLS
现在为用户 joe 创建行级安全策略：</p>
<div class="highlight"><pre><span></span><code>\c bigmath bigmath;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE POLICY emp_rls_policy ON employees FOR ALL TO PUBLIC USING (
           ename=current_user);
</code></pre></div>
<p>CREATE POLICY 命令的语法如下：</p>
<ul>
<li>CREATE POLICY用于创建策略。</li>
<li>emp_rls_policy是策略的用户定义名称。</li>
<li>employees是策略适用的表名。</li>
<li>ALL表示所有DDL命令。或者，您可以指定SELECT、INSERT、UPDATE、DELETE或其他需要限制的操作。</li>
<li>PUBLIC表示所有角色。或者，您可以提供策略适用的特定角色名称。</li>
<li>USING (ename = current_user)被称为表达式。它是一个返回布尔值的过滤条件。该表达式将employees表的ename列与当前登录用户进行比较，如果匹配，则该用户可以访问该行进行DDL操作。</li>
</ul>
<p>4.在表上启用 RLS
在表上启用行级安全性：</p>
<div class="highlight"><pre><span></span><code>\c bigmath bigmath;
</code></pre></div>
<div class="highlight"><pre><span></span><code>ALTER TABLE employees ENABLE ROW LEVEL SECURITY;
</code></pre></div>
<p>5.验证行级安全性
验证每个用户可以从员工表中查看哪些内容。</p>
<div class="highlight"><pre><span></span><code>\c bigmath bigmath;
select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> empno | ename |    address    | salary | account_number
-------+-------+---------------+--------+----------------
     2 | mike  | 129 81 st     |  80000 | AC-48901
     1 | joe   | 56 grove st   |  20000 | AC-22001
     3 | julia | 1 finite loop |  40000 | AC-77051
(3 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>\c bigmath joe;
</code></pre></div>
<div class="highlight"><pre><span></span><code>select current_user;
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_user
--------------
 joe
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> empno | ename |   address   | salary | account_number
-------+-------+-------------+--------+----------------
     1 | joe   | 56 grove st |  20000 | AC-22001
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>\c bigmath mike;
</code></pre></div>
<div class="highlight"><pre><span></span><code>select current_user;
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_user
--------------
 mike
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> empno | ename |  address  | salary | account_number
-------+-------+-----------+--------+----------------
     2 | mike  | 129 81 st |  80000 | AC-48901
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>\c bigmath julia
</code></pre></div>
<div class="highlight"><pre><span></span><code>select current_user;
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_user
--------------
 julia
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> empno | ename |    address    | salary | account_number
-------+-------+---------------+--------+----------------
     3 | julia | 1 finite loop |  40000 | AC-77051
(1 row)
</code></pre></div>
<p>根据策略中的定义，current_user 只能访问自己的行。</p>
<p>6.绕过行级安全性
BMDB具有BYPASSRLS和NOBYPASSRLS权限，可以分配给角色。 默认情况下，表所有者和超级用户分配有 BYPASSRLS 权限，因此这些用户可以跳过行级安全性。 默认情况下，数据库中的其他角色将分配有 NOBYPASSRLS。</p>
<p>将 BYPASSRLS 分配给用户 joe，以便他们可以看到员工表中的所有行。</p>
<div class="highlight"><pre><span></span><code>\c bigmath bigmath;
</code></pre></div>
<div class="highlight"><pre><span></span><code>ALTER USER joe BYPASSRLS;
</code></pre></div>
<div class="highlight"><pre><span></span><code>\c bigmath joe;
</code></pre></div>
<div class="highlight"><pre><span></span><code>select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> empno | ename |    address    | salary | account_number
-------+-------+---------------+--------+----------------
     2 | mike  | 129 81 st     |  80000 | AC-48901
     1 | joe   | 56 grove st   |  20000 | AC-22001
     3 | julia | 1 finite loop |  40000 | AC-77051
(3 rows)
</code></pre></div>
<p>7.删除行级策略
DROP POLICY 命令用于删除策略。</p>
<div class="highlight"><pre><span></span><code>\c bigmath bigmath;
</code></pre></div>
<div class="highlight"><pre><span></span><code>DROP POLICY emp_rls_policy ON employees;
</code></pre></div>
<p>以用户 mike 或 julia 身份登录不会返回任何数据，因为 RLS 策略已被删除并且表上的行级安全性仍然启用。</p>
<div class="highlight"><pre><span></span><code>\c bigmath mike;
</code></pre></div>
<div class="highlight"><pre><span></span><code>select current_user;
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_user
--------------
 mike
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> empno | ename | address | salary | account_number
-------+-------+---------+--------+----------------
(0 rows)
</code></pre></div>
<p>要完全禁用表的行级安全性，请使用 ALTER TABLE 删除行级安全性。</p>
<div class="highlight"><pre><span></span><code>\c bigmath bigmath;
</code></pre></div>
<div class="highlight"><pre><span></span><code>ALTER TABLE employees DISABLE ROW LEVEL SECURITY;
</code></pre></div>
<div class="highlight"><pre><span></span><code>\c bigmath mike;
</code></pre></div>
<div class="highlight"><pre><span></span><code>select current_user;
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_user
--------------
 mike
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> empno | ename |    address    | salary | account_number
-------+-------+---------------+--------+----------------
     2 | mike  | 129 81 st     |  80000 | AC-48901
     1 | joe   | 56 grove st   |  20000 | AC-22001
     3 | julia | 1 finite loop |  40000 | AC-77051
(3 rows)
</code></pre></div>
<h4 id="_73"><strong>列级安全机制</strong></h4>
<p>BMDB 中的列级安全性用于限制用户查看表中的特定列或列集。 在 BMDB 中实现列级安全性的最简单方法是创建一个仅包含用户需要访问的列的视图。</p>
<p>以下步骤显示如何使用 CREATE VIEW 命令启用列级安全性。</p>
<p>1.创建示例表
打开 BSQL shell (sqlsh)，指定 bigmath 用户并提示输入密码。</p>
<div class="highlight"><pre><span></span><code>./sqlsh -U bigmath -W
</code></pre></div>
<p>当提示输入密码时，输入 bigmath 密码。 您应该能够登录并看到类似于以下内容的响应：</p>
<div class="highlight"><pre><span></span><code>sqlsh (11.2-BM-2.5.0.0-b0)
Type &quot;help&quot; for help.
bigmath=#
</code></pre></div>
<p>创建一个员工表并插入一些示例行。</p>
<div class="highlight"><pre><span></span><code>create table employees ( empno int, ename text,
                         address text, salary int, account_number text );
</code></pre></div>
<div class="highlight"><pre><span></span><code>insert into employees values (1, &#39;joe&#39;, &#39;56 grove st&#39;,  20000, &#39;AC-22001&#39; );
insert into employees values (2, &#39;mike&#39;, &#39;129 81 st&#39;,  80000, &#39;AC-48901&#39; );
insert into employees values (3, &#39;julia&#39;, &#39;1 finite loop&#39;,  40000, &#39;AC-77051&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> empno | ename |    address    | salary | account_number
-------+-------+---------------+--------+----------------
     1 | Joe   | 56 grove st   |  20000 | AC-22001
     2 | Mike  | 129 81 st     |  80000 | AC-48901
     3 | Julia | 1 finite loop |  40000 | AC-77051
(3 rows)
</code></pre></div>
<p>2.创建bmadmin用户
创建用户 bmadmin 并为 bmadmin 用户提供表上的所有权限。</p>
<div class="highlight"><pre><span></span><code>\c bigmath bigmath;
</code></pre></div>
<div class="highlight"><pre><span></span><code>create user bmadmin;
</code></pre></div>
<div class="highlight"><pre><span></span><code>GRANT ALL PRIVILEGES ON employees TO bmadmin;
</code></pre></div>
<p>使用 bmadmin 用户连接到数据库。</p>
<div class="highlight"><pre><span></span><code>\c bigmath bmadmin;
</code></pre></div>
<p>3.验证权限
用户 bmadmin 有权查看表的所有内容。</p>
<div class="highlight"><pre><span></span><code>select current_user;
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_user
--------------
 bmadmin
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> empno | ename |    address    | salary | account_number
-------+-------+---------------+--------+----------------
     1 | joe   | 56 grove st   |  20000 | AC-22001
     3 | julia | 1 finite loop |  40000 | AC-77051
     2 | mike  | 129 81 st     |  80000 | AC-48901
(3 rows)
</code></pre></div>
<p>4a.使用 CREATE VIEW 限制列访问
管理员用户 bmadmin 有权查看员工表上的所有内容。 为了防止管理员用户查看工资和 account_number 等敏感信息，可以使用 CREATE VIEW 语句来保护这些列。</p>
<div class="highlight"><pre><span></span><code>\c bigmath bigmath;
</code></pre></div>
<div class="highlight"><pre><span></span><code>REVOKE SELECT ON employees FROM bmadmin;
CREATE VIEW emp_info as select empno, ename, address from employees;
GRANT SELECT on emp_info TO bmadmin;
</code></pre></div>
<p>验证访问权限
验证 bmadmin 用户对员工表的权限。</p>
<div class="highlight"><pre><span></span><code>\c bigmath bmadmin;
</code></pre></div>
<div class="highlight"><pre><span></span><code>select current_user;
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_user
--------------
 bmadmin
(1 row)
</code></pre></div>
<p>由于bmadmin的权限被撤销，该用户将无法查询employees表。</p>
<div class="highlight"><pre><span></span><code>select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code>ERROR:  permission denied for table employees
</code></pre></div>
<p>由于 bmadmin 被授予对 emp_info 表的 select 权限，因此 bmadmin 用户将能够查询 emp_info 表。</p>
<div class="highlight"><pre><span></span><code>select * from emp_info;
</code></pre></div>
<div class="highlight"><pre><span></span><code> empno | ename |    address
-------+-------+---------------
     1 | joe   | 56 grove st
     3 | julia | 1 finite loop
     2 | mike  | 129 81 st
(3 rows)
</code></pre></div>
<p>4b.使用 GRANT 限制列访问
BMDB 支持列级权限，而不是创建视图，可以使用 GRANT 命令为用户提供对表中选择列的访问权限。</p>
<p>考虑前面的示例，可以为 bmadmin 用户提供查看除工资和 account_number 之外的所有列的权限，而不是创建新视图，如下所示：</p>
<div class="highlight"><pre><span></span><code>\c bigmath bigmath;
</code></pre></div>
<div class="highlight"><pre><span></span><code>grant select (empno, ename, address) on employees to bmadmin;
</code></pre></div>
<p>验证访问权限
用户 bmadmin 现在将能够访问已授予权限的列。</p>
<div class="highlight"><pre><span></span><code>\c bigmath bmadmin;
</code></pre></div>
<div class="highlight"><pre><span></span><code>select empno, ename, address from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> empno | ename |    address
-------+-------+---------------
     1 | joe   | 56 grove st
     3 | julia | 1 finite loop
     2 | mike  | 129 81 st
(3 rows)
</code></pre></div>
<p>如果用户尝试访问其他列，bmadmin 仍将被拒绝。</p>
<div class="highlight"><pre><span></span><code>select empno, ename, address, salary from employees;

ERROR:  permission denied for table employees
</code></pre></div>
<h3 id="_74"><strong>传输加密</strong></h3>
<p>启用传输加密（使用 TLS）以保护网络通信。
BMDB 可以配置为使用以下内容保护传输中的数据：</p>
<p>用于 MServer 和 DBServer 节点之间的节点内通信的服务器-服务器加密。
使用 BSQL 和 BCQL 的 CLI、工具和 API 时，客户端-服务器用于客户端和节点之间的通信。
BMDB 支持基于 OpenSSL（v. 1.0.2u 或更高版本）的传输层安全 (TLS) 加密，OpenSSL 是一个开源加密工具包，提供传输层安全 (TLS) 和安全套接字层 (SSL) 协议的实现。</p>
<p>注意：YEDIS 不支持客户端-服务器 TLS 加密。</p>
<p>按照本节中的步骤了解如何使用 TLS 为三节点 BMDB 集群启用加密。</p>
<h4 id="_75"><strong>创建服务器证书</strong></h4>
<p>生成服务器证书并准备 BMDB 节点以进行服务器到服务器加密。
在使用传输安全层 (TLS) 启用服务器到服务器和客户端到服务器加密之前，您需要准备 BMDB 集群中的每个节点。</p>
<h5 id="_76"><strong>创建服务器证书</strong></h5>
<p>创建服务器证书涉及多个步骤。</p>
<p>1.创建安全数据目录
要生成并存储安全信息（例如根证书），请通过运行以下命令在根目录中创建一个目录 secure-data：</p>
<div class="highlight"><pre><span></span><code>mkdir secure-data
</code></pre></div>
<p>完成准备工作后，您将此数据复制到安全位置，然后删除此目录。</p>
<p>2.创建临时节点目录
为每个节点创建一个目录，将所有需要的数据放在该目录中，如下：</p>
<div class="highlight"><pre><span></span><code>mkdir 127.0.0.1/ 127.0.0.2/ 127.0.0.3/
</code></pre></div>
<p>添加到每个目录的文件将被复制到每个节点上的 tls-cert 目录中。</p>
<p>您现在应该有三个目录，分别名为 127.0.0.1、127.0.0.2 和 127.0.0.3，代表 BMDB 集群的三个节点。</p>
<p>3.创建根配置文件
使用 OpenSSL CA 配置在 secure-data 目录中创建文件 ca.conf，如下所示：</p>
<div class="highlight"><pre><span></span><code>cat &gt; secure-data/ca.conf
</code></pre></div>
<p>将以下示例根配置粘贴到文件中：</p>
<div class="highlight"><pre><span></span><code>####################################
# Example CA root configuration file
####################################

[ ca ]
default_ca = my_ca

[ my_ca ]
# Validity of the signed certificate in days
default_days = 3650

# Text file with next hex serial number to use
serial = secure-data/serial.txt

# Text database file to use, initially empty
database = secure-data/index.txt

# Message digest algorithm. Do not use MD5
default_md = sha256

# Section with a set of variables corresponding to DN fields
policy = my_policy

[ my_policy ]

# Policy for nodes and users. If the value is &quot;match&quot;, then
# field value must match the same field in the CA certificate.
# If the value is &quot;supplied&quot;, then it must be present. Optional
# means it may be present
organizationName = supplied
commonName = supplied

[req]
prompt=no
distinguished_name = my_distinguished_name
x509_extensions = my_extensions

[ my_distinguished_name ]
organizationName = bigmath
commonName = CA for BMDB

[ my_extensions ]
keyUsage = critical,digitalSignature,nonRepudiation,keyEncipherment,keyCertSign
basicConstraints = critical,CA:true,pathlen:1
</code></pre></div>
<p>要保存并关闭文件，请输入 Ctl+D。</p>
<p>4.添加所需文件
运行以下命令创建索引文件index.txt和数据库文件serial.txt：</p>
<div class="highlight"><pre><span></span><code>touch index.txt
echo &#39;01&#39; &gt; serial.txt
</code></pre></div>
<p>5.生成根密钥
要在 secure-data 目录中生成根私钥文件 ca.key，请运行以下 openssl genrsa 命令：</p>
<div class="highlight"><pre><span></span><code>openssl genrsa -out secure-data/ca.key
</code></pre></div>
<p>您应该看到类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>Generating RSA private key, 2048 bit long modulus (2 primes)
......................+++++
.................+++++
e is 65537 (0x010001)
</code></pre></div>
<p>通过运行chmod命令将生成的私钥的访问权限更改为只读权限，如下：</p>
<div class="highlight"><pre><span></span><code>chmod 400 secure-data/ca.key
</code></pre></div>
<h5 id="_77"><strong>生成根证书文件</strong></h5>
<p>通过运行以下 openssl req 命令生成根证书文件 ca.crt：</p>
<div class="highlight"><pre><span></span><code>openssl req -new \
            -x509 \
            -days 3650 \
            -config secure-data/ca.conf \
            -key secure-data/ca.key \
            -out secure-data/ca.crt
</code></pre></div>
<p>在 secure-data 目录中，您现在应该具有以下三个文件：</p>
<ul>
<li>ca.conf - 根配置文件</li>
<li>ca.key - 根密钥文件</li>
<li>ca.crt - 根证书文件
  您可以通过运行以下 openssl x509 命令来验证根证书：</li>
</ul>
<div class="highlight"><pre><span></span><code>openssl x509 -in secure-data/ca.crt -text -noout
</code></pre></div>
<p>您应该看到类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            61:ca:24:00:c8:40:f3:4d:66:59:80:35:86:ca:b9:6f:98:b1:1c:5e
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: O = bigmath, CN = CA for BMDB
        Validity
            Not Before: Feb 14 04:40:56 2020 GMT
            Not After : Mar 15 04:40:56 2020 GMT
        Subject: O = bigmath, CN = CA for BMDB
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (2048 bit)
                Modulus:
                    00:c9:8c:20:7d:63:ed:8d:9f:2d:f2:2e:90:34:2c:
                    79:0b:0b:77:2f:4c:88:78:63:28:db:91:6d:c4:21:
                    bd:e2:dd:14:a3:ba:e5:db:4d:b9:34:e8:74:7b:1f:
                    ff:70:a2:8c:0c:f5:df:d4:11:ae:5c:4c:1a:22:94:
                    98:4e:a7:63:ee:44:5b:c6:b7:f0:34:ef:4e:57:1a:
                    30:99:ee:f7:c9:d9:df:e9:af:ab:df:08:e3:69:d9:
                    d4:5d:8e:0c:50:7a:bf:be:7f:f0:7f:e3:20:13:d8:
                    c9:44:21:1f:05:6b:52:d3:77:b8:75:8e:78:c6:60:
                    3c:7e:9a:8a:77:b2:65:da:6c:25:7a:4a:ee:eb:4a:
                    a8:6b:43:79:ea:15:96:8b:3d:03:50:08:a4:2d:76:
                    2f:09:e3:eb:b3:f6:77:17:2a:3e:dc:9b:f8:60:cf:
                    93:f3:84:6a:19:b0:64:4a:0f:47:51:c9:47:0f:20:
                    5d:cd:af:1e:5d:65:36:0f:b0:44:c3:eb:9a:63:44:
                    dd:ac:25:f8:f4:60:6c:9b:72:46:6d:18:c3:94:7d:
                    b5:d9:89:79:e1:39:dd:4f:01:26:b2:da:c1:ac:af:
                    85:d9:cc:a7:02:65:2a:d6:06:47:cc:11:72:cc:d6:
                    92:45:c0:64:43:4c:13:07:d1:6f:38:8e:fe:db:1e:
                    5e:e5
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Key Usage: critical
                Digital Signature, Non Repudiation, Key Encipherment, Certificate Sign
            X509v3 Basic Constraints: critical
                CA:TRUE, pathlen:1
    Signature Algorithm: sha256WithRSAEncryption
         9e:d1:41:36:63:78:4b:e4:57:f2:bd:23:c4:4b:e1:64:e8:c0:
         e3:e1:30:c5:2b:dd:b0:c2:99:ca:86:cb:85:70:6f:29:4c:b0:
         3e:ba:76:af:87:22:a3:64:1f:3e:4f:69:74:8b:a3:b3:e0:71:
         12:aa:0b:28:85:0a:45:40:7b:a5:d1:42:cd:51:bc:85:6a:53:
         16:69:89:78:85:bd:46:9d:1a:ca:19:14:de:72:e4:5c:91:51:
         58:99:b5:83:97:a5:63:dc:b9:7a:05:1e:a9:a7:5f:42:e1:12:
         4e:2b:e1:98:e5:31:14:b5:64:5f:66:bc:13:b8:19:ca:9c:ad:
         12:44:f8:21:3b:ef:0d:ca:9b:c4:04:d6:d7:93:d2:83:87:79:
         2a:2d:dc:de:4c:ad:30:cf:10:de:05:24:52:91:31:fd:cc:d6:
         cb:3b:ba:73:8f:ae:0d:97:f0:e4:aa:ca:76:c0:15:3c:80:7d:
         3a:d8:28:3c:91:bc:19:c8:5c:cd:94:49:31:23:ae:08:e5:9a:
         ce:62:6a:53:08:38:6d:0f:b4:fd:e9:66:8c:fb:cd:be:a0:01:
         b4:9d:39:57:58:6c:b3:8e:25:e3:86:24:13:59:d6:a0:d2:f0:
         15:1e:8c:24:44:5b:3a:db:1c:ef:60:70:24:58:df:56:99:aa:
         22:78:12:d6
</code></pre></div>
<h5 id="_78"><strong>将根证书复制到各个节点目录</strong></h5>
<p>将生成的根证书文件ca.crt复制到所有三个节点目录下，如下：</p>
<div class="highlight"><pre><span></span><code>cp secure-data/ca.crt 127.0.0.1
cp secure-data/ca.crt 127.0.0.2
cp secure-data/ca.crt 127.0.0.3
</code></pre></div>
<h5 id="_79"><strong>为每个节点生成密钥和证书文件</strong></h5>
<p>现在您可以为每个节点生成节点密钥node.key和节点证书node.crt。</p>
<p>1.为每个节点生成配置
对每个节点重复以下步骤，将 <node-ip-address> 替换为主题节点的 IP 地址：
（1）为节点生成配置文件node.conf，使用节点的IP地址<node-ip-address>作为目录名，如下：</p>
<div class="highlight"><pre><span></span><code>cat &gt; &lt;node-ip-address&gt;/node.conf
</code></pre></div>
<p>（2）添加以下示例配置内容（按原样使用，或根据需要自定义）：</p>
<div class="highlight"><pre><span></span><code>#################################
# Example node configuration file
#################################

[ req ]
prompt=no
distinguished_name = my_distinguished_name

[ my_distinguished_name ]
organizationName = bigmath
# Required value for commonName, do not change
commonName = &lt;node-ip-address&gt;

# Multiple subject alternative names (SANs) such as IP Address,
# DNS Name, Email, URI, and so on, can be specified under this section
[ req_ext]
SubjectAltName = @alt_names
[alt_names]
IP.1 = &lt;IP Address&gt;
IP.2 = &lt;IP Address&gt;
DNS.1 = &lt;DNS Name&gt;
DNS.2 = &lt;DNS Name&gt;
</code></pre></div>
<p>（3）粘贴步骤 2 中的内容并将 <node-ip-address> 替换为节点 IP 地址后，通过输入 Ctl+D 保存并关闭文件。</p>
<p>您应该在 127.0.0.1、127.0.0.2 和 127.0.0.3 目录中拥有 node.conf 的副本。</p>
<p>2.为每个节点生成私钥文件
对于三个节点中的每一个，通过运行以下命令生成节点私钥，并将 <node-ip-address> 替换为节点 IP 地址：</p>
<div class="highlight"><pre><span></span><code>openssl genrsa -out &lt;node-ip-address&gt;/node.&lt;node-ip-address&gt;.key
chmod 400 &lt;node-ip-address&gt;/node.&lt;node-ip-address&gt;.key
</code></pre></div>
<p>为了使 BMDB 能够识别该文件，该文件的格式必须为 node.<commonName>.key。 在前面的示例中，您已使用 <node-ip-address> 作为 <commonName>，因此文件名应为 node.127.0.0.1.key、node.127.0.0.2.key 和 node.127.0.0.3.key。</p>
<p>3.生成节点证书
您需要通过为每个节点创建证书签名请求（CSR）来生成节点证书，如下所示：</p>
<div class="highlight"><pre><span></span><code>openssl req -new \
            -config &lt;node-ip-address&gt;/node.conf \
            -key &lt;node-ip-address&gt;/node.&lt;node-ip-address&gt;.key \
            -out &lt;node-ip-address&gt;/node.csr
</code></pre></div>
<p>使用根密钥 ca.key 和根证书 ca.crt 签署每个节点 CSR。 运行以下 openssl ca 命令：</p>
<div class="highlight"><pre><span></span><code>openssl ca -config secure-data/ca.conf \
           -keyfile secure-data/ca.key \
           -cert secure-data/ca.crt \
           -policy my_policy \
           -out &lt;node-ip-address&gt;/node.&lt;node-ip-address&gt;.crt \
           -outdir &lt;node-ip-address&gt;/ \
           -in &lt;node-ip-address&gt;/node.csr \
           -days 3650 \
           -batch
</code></pre></div>
<p>对于 127.0.0.1 节点，您应该看到类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>Using configuration from secure-data/ca.conf
Check that the request matches the signature
Signature ok
The Subject&#39;s Distinguished Name is as follows
organizationName      :ASN.1 12:&#39;bigmath&#39;
commonName            :ASN.1 12:&#39;127.0.0.1&#39;
Certificate is to be certified until Feb 11 04:53:11 2030 GMT (3650 days)

Write out database with 1 new entries
Data Base Updated
</code></pre></div>
<p>每个节点密钥和证书应使用node.<commonName>.[crt | key]命名格式。</p>
<p>您可以通过运行以下 openssl verify 命令来验证每个节点的签名证书：</p>
<div class="highlight"><pre><span></span><code>openssl verify -CAfile secure-data/ca.crt &lt;node-ip-address&gt;/node.&lt;node-ip-address&gt;.crt
</code></pre></div>
<p>您应该看到以下输出，显示节点 IP 地址：</p>
<div class="highlight"><pre><span></span><code>X.X.X.X/node.X.X.X.X.crt: OK
</code></pre></div>
<h5 id="_80"><strong>将配置文件复制到节点</strong></h5>
<p>每个节点需要的文件有：
ca.crt
node.<commonName>.crt（例如，node.127.0.0.1.crt）
node.<commonName>.key（例如，node.127.0.0.1.key）</p>
<p>您可以删除节点目录中的所有其他文件，因为它们是不必要的。</p>
<p>将必要的信息上传到每个目标节点。</p>
<p>创建将包含配置文件的目录，如下所示：</p>
<div class="highlight"><pre><span></span><code>ssh &lt;username&gt;@&lt;node-ip-address&gt; mkdir ~/certs
</code></pre></div>
<p>运行以下命令将所有配置文件复制到上述目录中：</p>
<div class="highlight"><pre><span></span><code>scp &lt;node-ip-address&gt;/ca.crt &lt;user&gt;@&lt;node-ip-address&gt;:~/certs/&lt;node-ip-address&gt;
</code></pre></div>
<div class="highlight"><pre><span></span><code>scp &lt;node-ip-address&gt;/node.&lt;node-ip-address&gt;.crt &lt;user&gt;@&lt;node-ip-address&gt;:~/certs/&lt;node-ip-address&gt;
</code></pre></div>
<div class="highlight"><pre><span></span><code>scp &lt;node-ip-address&gt;/node.&lt;node-ip-address&gt;.key &lt;user&gt;@&lt;node-ip-address&gt;:~/certs/&lt;node-ip-address&gt;
</code></pre></div>
<p>您现在可以删除或适当保护为本地计算机上的节点创建的目录。</p>
<h4 id="_81"><strong>启用服务器之间的加密</strong></h4>
<p>为节点内通信启用服务器到服务器加密（使用 TLS）。</p>
<h5 id="_82"><strong>先决条件</strong></h5>
<p>在启用和使用服务器到服务器加密之前，您需要为 BMDB 集群的每个节点创建并配置服务器证书。 有关信息，请参阅创建服务器证书。</p>
<h5 id="mserverdbserver"><strong>配置MServer和DBServer节点</strong></h5>
<p>要使用 TLS 启用服务器到服务器加密，请使用以下标志启动 MServer 和 DBServer 节点。</p>
<table>
<thead>
<tr>
<th>FLAG</th>
<th>节点</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>use_node_to_node_encryption</td>
<td>MServer, DBServer</td>
<td>设置为 true 以启用 BMDB 节点之间的加密。 默认值为 false。</td>
</tr>
<tr>
<td>allow_insecure_connections</td>
<td>MServer, DBServer</td>
<td>设置为 false 以禁止任何具有未加密通信的服务加入此集群。 默认值为 true。 请注意，此标志需要启用 --use_node_to_node_encryption。</td>
</tr>
<tr>
<td>certs_dir</td>
<td>MServer, DBServer</td>
<td>可选项。 包含为此节点创建的证书的目录，用于与其他节点执行加密通信。 请参阅创建服务器证书。 MServer 的默认值为 &lt;数据驱动器&gt;/bm-data/mserver/data/certs，DBServer 的默认值为 &lt;数据驱动器&gt;/bm-data/dbserver/data/certs</td>
</tr>
</tbody>
</table>
<h5 id="mservers"><strong>启动 MServers</strong></h5>
<p>您可以通过使用 --use_node_to_node_encryption=true 标志启动 mserver 服务来启用访问控制，如上所述。 您的命令应类似于以下内容：</p>
<div class="highlight"><pre><span></span><code>bin/mserver                               \
    --fs_data_dirs=&lt;data directories&gt;       \
    --mserver_addresses=&lt;mserver addresses&gt;   \
    --certs_dir=/home/centos/tls/$NODE_IP   \
    --allow_insecure_connections=false      \
    --use_node_to_node_encryption=true
</code></pre></div>
<p>有关启动 MServer 节点进行部署的信息，请参阅启动 MServer。</p>
<h5 id="dbserver_1"><strong>启动 DBServer</strong></h5>
<p>您可以通过使用上述 --use_node_to_node_encryption=true 标志启动 dbserver 服务来启用访问控制。 您的命令应类似于以下内容：</p>
<div class="highlight"><pre><span></span><code>bin/dbserver                                  \
    --fs_data_dirs=&lt;data directories&gt;           \
    --dbserver_mserver_addrs=&lt;mserver addresses&gt;   \
    --certs_dir /home/centos/tls/$NODE_IP       \
    --use_node_to_node_encryption=true &amp;
</code></pre></div>
<h5 id="_83"><strong>连接到集群</strong></h5>
<p>由于您仅启用了服务器到服务器加密，而没有启用客户端到服务器加密，因此您现在可以使用 BSQL shell (sqlsh) 或 BCQL shell (cqlsh) 连接到此集群，而无需启用加密，如下所示。
BSQL </p>
<div class="highlight"><pre><span></span><code>$ ./bin/sqlsh
</code></pre></div>
<div class="highlight"><pre><span></span><code>sqlsh (11.2-BM-2.0.11.0-b0)
Type &quot;help&quot; for help

bigmath=#
</code></pre></div>
<p>BCQL</p>
<div class="highlight"><pre><span></span><code>$ ./bin/cqlsh
</code></pre></div>
<div class="highlight"><pre><span></span><code>Connected to local cluster at 127.0.0.1:9542.
[cqlsh 5.0.1 | Cassandra 3.9-SNAPSHOT | CQL spec 3.4.2 | Native protocol v4]
Use HELP for help.

cqlsh&gt;
</code></pre></div>
<h4 id="_84"><strong>启用客户端到服务端的加密</strong></h4>
<p>为 BSQL 和 BCQL 启用客户端到服务器加密（使用 TLS）。
BMDB 集群可以配置为使用客户端到服务器加密来保护 BMDB 服务器与客户端、工具和 API 之间传输的数据。 启用后，传输层安全性 (TLS)（已弃用的安全套接字层 (SSL) 的后继者）用于确保仅 BSQL 和 BCQL 的数据保护。 请注意，没有计划支持 YEDIS。</p>
<h5 id="_85"><strong>先决条件</strong></h5>
<p>在启用客户端到服务器加密之前，您首先必须启用服务器到服务器加密。</p>
<h5 id="dbserver_2"><strong>配置DBServer节点</strong></h5>
<p>要为 BSQL 和 BCQL 启用客户端到服务器加密，请使用下述所需标志启动 DBServer 服务。 您的 MServer 服务不需要额外的配置。</p>
<table>
<thead>
<tr>
<th>FLAG</th>
<th>节点</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>use_client_to_server_encryption</td>
<td>DBServer</td>
<td>设置为 true 以启用各种 BMDB 客户端和数据库集群之间的加密。 默认值为 false。</td>
</tr>
<tr>
<td>allow_insecure_connections</td>
<td>DBServer</td>
<td>设置为 false 以禁止任何具有未加密通信的客户端加入此集群。 默认值为 true。 请注意，此标志需要启用 --use_client_to_server_encryption 。</td>
</tr>
<tr>
<td>certs_for_client_dir</td>
<td>DBServer</td>
<td>可选项。默认为与服务器到服务器加密相同的目录。 此目录应包含客户端与集群执行 TLS 通信的配置。 DBServer 的默认值为 &lt;数据驱动器&gt;/bm-data/dbserver/data/certs</td>
</tr>
</tbody>
</table>
<p>要启用访问控制，请按照以下步骤操作，使用以下标志启动 dbserver 服务（如上所述）：</p>
<div class="highlight"><pre><span></span><code>--use_client_to_server_encryption=true
</code></pre></div>
<p>此标志允许加密和未加密的客户端连接到集群。</p>
<p>为了防止没有适当加密的客户端连接，您必须添加以下标志：</p>
<div class="highlight"><pre><span></span><code>--allow_insecure_connections=false
</code></pre></div>
<p>您的命令应类似于以下内容：</p>
<div class="highlight"><pre><span></span><code>bin/dbserver                                       \
    --fs_data_dirs=&lt;data directories&gt;                \
    --dbserver_mserver_addrs=&lt;mserver addresses&gt;        \
    --certs_for_client_dir /home/centos/tls/$NODE_IP \
    --allow_insecure_connections=false               \
    --use_client_to_server_encryption=true &amp;
</code></pre></div>
<p>手动部署中启动DBServer节点的详细信息，请参见启动DBServer。</p>
<h4 id="_86"><strong>连接到集群</strong></h4>
<p>启用客户端到服务器加密后，您可以将 CLI、工具和 API 连接到远程 BMDB 集群。</p>
<h5 id="_87"><strong>先决条件</strong></h5>
<p>为了使用传输中加密连接到 BMDB 集群，您必须启用客户端到服务器加密，并且可能需要启用服务器到服务器加密（请参阅连接到 BMDB 集群）。</p>
<p>连接到 BMDB 集群的每个客户端都需要在客户端计算机上访问以下文件：</p>
<ul>
<li>ca.crt — 根证书文件（适用于 BSQL 和 BCQL）。 有关如何生成此文件的说明，请参阅生成根证书文件。</li>
</ul>
<p>该文件应位于 ~/.brightdb 中，这是本地运行 BSQL shell (sqlsh) 时 TLS 证书的默认位置。</p>
<h5 id="bmdb_1"><strong>连接到BMDB集群</strong></h5>
<p>对于每个客户端，这些步骤假设您已执行以下操作：</p>
<ul>
<li>在 BMDB 集群的 DBServer 节点上启用客户端到服务器加密。</li>
<li>在 BMDB 集群上启用服务器到服务器加密。</li>
</ul>
<p>1.sqlsh
sqlsh CLI 位于 BMDB 主目录的 bin 目录中。</p>
<p>要连接到远程 BMDB 集群，您需要有可用的 sqlsh 本地副本。 您可以使用本地安装的 BMDB 上提供的 sqlsh CLI。</p>
<p>要打开本地 sqlsh CLI 并访问 BMDB 集群，请运行 sqlsh 并定义以下标志：</p>
<ul>
<li>host: -h <node-ip-address> (required for remote node; default is 127.0.0.1)</li>
<li>port: -p <port> (optional; default is 2521)</li>
<li>user: -U <username> (optional; default is bigmath)</li>
<li>TLS/SSL: "sslmode=require" (required)</li>
</ul>
<div class="highlight"><pre><span></span><code>$ ./bin/sqlsh -h 127.0.0.1 -p 2521 -U bigmath &quot;sslmode=require&quot;
</code></pre></div>
<div class="highlight"><pre><span></span><code>sqlsh (11.2-BM-2.0.11.0-b0)
SSL connection (protocol: TLSv1.2, cipher: ECDHE-RSA-AES256-GCM-SHA384, bits: 256, compression: off)
Type &quot;help&quot; for help.

bigmath=#
</code></pre></div>
<p>2.bm-admin
要使 bm-admin 能够与启用了 TLS 的集群连接，请传入 certs_dir_name 的额外参数以及根证书所在的目录位置。 bm-admin 工具位于集群节点的 ~/mserver/bin/ 目录中。 集群节点上的 ~/bigmath-tls-config 目录包含所有证书。</p>
<p>例如，以下命令列出启用 TLS 的集群的主节点信息：</p>
<div class="highlight"><pre><span></span><code>export mserverS=node1:11000,node2:11000,node3:11000
./bin/bm-admin --mserver_addresses $mserverS -certs_dir_name ~/bigmath-tls-config list_all_mservers
</code></pre></div>
<p>输出如下：</p>
<div class="highlight"><pre><span></span><code>mserver UUID RPC Host/Port State Role
UUID_1   node1:11000   ALIVE  FOLLOWER
UUID_2  node2:11000      ALIVE  LEADER
UUID_3   node3:11000      ALIVE  FOLLOWER
</code></pre></div>
<p>3.cqlsh 
要使 cqlsh 连接到启用加密的 BMDB 集群，您需要设置以下环境变量：</p>
<div class="highlight"><pre><span></span><code>SSL_CERTFILE ：The root certificate file (ca.crt).
</code></pre></div>
<p>要设置环境变量，请使用以下export命令：</p>
<div class="highlight"><pre><span></span><code>$ export SSL_CERTFILE=&lt;path to file&gt;/ca.crt
</code></pre></div>
<p>下一步是使用 --ssl 标志进行连接。
（1）Local Cluster </p>
<div class="highlight"><pre><span></span><code>$ ./bin/cqlsh --ssl
</code></pre></div>
<p>输出如下：</p>
<div class="highlight"><pre><span></span><code>Connected to local cluster at X.X.X.X:9542.
[cqlsh 5.0.1 | Cassandra 3.9-SNAPSHOT | CQL spec 3.4.2 | Native protocol v4]
Use HELP for help.
cqlsh&gt; DESCRIBE KEYSPACES;

system_schema  system_auth  system
</code></pre></div>
<p>（2）Remote Cluster 
要连接到远程 BMDB 集群，您需要有可用的 cqlsh 本地副本。 您可以使用本地安装的 BMDB 上提供的 cqlsh CLI。</p>
<p>要打开本地 cqlsh CLI 并访问远程集群，请运行 cqlsh，并为远程集群的主机和端口设置标志。 您还必须添加 --ssl 标志以启用使用 TLS（SSL 的后继者）的客户端到服务器加密，如下所示：</p>
<div class="highlight"><pre><span></span><code>$ ./bin/cqlsh &lt;node-ip-address&gt; &lt;port&gt; --ssl
</code></pre></div>
<p>node-ip-address：远程节点的IP地址。
port：远程节点的端口。
例如，主机为127.0.0.2，端口为9542，用户为bigmath，则执行以下命令进行连接：</p>
<div class="highlight"><pre><span></span><code>$ ./bin/cqlsh 127.0.0.2 9542 --ssl
</code></pre></div>
<p>输出如下：</p>
<div class="highlight"><pre><span></span><code>Connected to local cluster at X.X.X.X:9542.
[cqlsh 5.0.1 | Cassandra 3.9-SNAPSHOT | CQL spec 3.4.2 | Native protocol v4]
Use HELP for help.
cqlsh&gt; DESCRIBE KEYSPACES;

system_schema  system_auth  system
</code></pre></div>
<h4 id="tls"><strong>TLS和认证</strong></h4>
<p>将身份验证与 TLS 加密结合使用
可以使用以下与 TLS 和身份验证相关的配置标志将 TLS 与身份验证结合起来进行配置：</p>
<ul>
<li>bsql_enable_auth 启用密码（md5）身份验证</li>
<li>use_client_to_server_encryption 启用客户端-服务器 TLS 加密</li>
<li>bsql_hba_conf_csv 手动设置基于主机的身份验证 (HBA) 配置</li>
</ul>
<p>bsql_hba.conf 文件中的默认（自动生成）配置取决于是否启用 auth (bsql_enable_auth) 和/或 TLS (use_client_to_server_encryption)。</p>
<p>四种默认情况如下表所示。</p>
<table>
<thead>
<tr>
<th></th>
<th>AUTH DISABLED</th>
<th>AUTH ENABLED</th>
</tr>
</thead>
<tbody>
<tr>
<td>TLS disabled</td>
<td>host all all all trust(no ssl, no password)</td>
<td>host all all all md5(no ssl, password required)</td>
</tr>
<tr>
<td>TLS enabled</td>
<td>hostssl all all all trust(require ssl, no password)</td>
<td>hostssl all all all md5(require ssl and password)</td>
</tr>
</tbody>
</table>
<p>此外，bsql_hba_conf_csv 可用于手动配置自定义 HBA 配置。</p>
<p>例如，要将 TLS 与 md5 和 cert 身份验证结合使用，您可以设置 bsql_hba_conf_csv 标志，如下所示：</p>
<div class="highlight"><pre><span></span><code>hostssl all all all md5 clientcert=1
</code></pre></div>
<p>bsql_hba_conf_csv 规则添加在 bsql_hba.conf 文件中自动生成的规则上方，因此，如果它们与连接类型、数据库、用户或主机不匹配，则自动生成的规则（即来自上表的规则） 仍可使用。</p>
<p>如果自定义用户定义的规则仅适用于某些连接类型（例如，host 与hostssl）、数据库、用户或主机，则自动生成的规则将应用于不匹配的主机、用户或数据库。 要完全禁用自动生成的规则，请使用拒绝身份验证选项。</p>
<p>例如，要通过证书身份验证启用 TLS，但仅针对某些特定数据库、用户和主机，请使用以下 bsql_hba_conf_csv 设置：</p>
<div class="highlight"><pre><span></span><code>hostssl mydb myuser myhost cert,hostssl all all all reject
</code></pre></div>
<h5 id="_88"><strong>示例</strong></h5>
<p>首先，下载并配置示例证书：</p>
<div class="highlight"><pre><span></span><code>$ wget https://gitlab.bigmath.com/bigmath/bigmath-db/mserver/test_certs/ca.crt
$ wget -O node.127.0.0.1.key https://gitlab.bigmath.com/bigmath/bigmath-db/mserver/test_certs/bsql.key
$ wget -O node.127.0.0.1.crt https://gitlab.bigmath.com/bigmath/bigmath-db/mserver/test_certs/bsql.crt
$ chmod 600 ca.crt node.127.0.0.1.key node.127.0.0.1.crt
$ CERTS=`pwd`
$ ENABLE_TLS=&quot;use_client_to_server_encryption=true,certs_for_client_dir=$CERTS&quot;
</code></pre></div>
<p>node.127.0.0.1.crt 和 node.127.0.0.1.key 是 BSQL 节点的 ssl_cert_file 和 ssl_key_file 服务器端配置的默认值。 如果您的本地 IP 不是 127.0.0.1，则使用适当的本地 IP 来命名这两个文件。 或者使用 bsql_pg_conf_csv 将 ssl_cert_file 和 ssl_key_file 设置为适当的值。</p>
<p>1.无需身份验证的 TLS
此配置要求客户端使用客户端到服务器加密进行连接。</p>
<p>创建数据库：</p>
<div class="highlight"><pre><span></span><code>$ ./bin/bm-dev-ctl destroy &amp;&amp; ./bin/bm-dev-ctl create --dbserver_flags=&quot;$ENABLE_TLS&quot;
</code></pre></div>
<p>如果客户端未启用 SSL，连接将失败。</p>
<div class="highlight"><pre><span></span><code>$ ./bin/sqlsh &quot;sslmode=disable&quot;
</code></pre></div>
<div class="highlight"><pre><span></span><code>sqlsh: FATAL:  no pg_hba.conf entry for host &quot;127.0.0.1&quot;, user &quot;bigmath&quot;, database &quot;bigmath&quot;, SSL off
</code></pre></div>
<p>要进行连接，必须在客户端中启用 SSL。</p>
<div class="highlight"><pre><span></span><code>$ ./bin/sqlsh &quot;sslmode=require&quot;
</code></pre></div>
<div class="highlight"><pre><span></span><code>sqlsh (11.2-BM-2.7.0.0-b0)
SSL connection (protocol: TLSv1.2, cipher: ECDHE-RSA-AES256-GCM-SHA384, bits: 256, compression: off)
Type &quot;help&quot; for help.
</code></pre></div>
<p>默认的 sqlsh SSL 模式是首选（请参阅 PostgreSQL 文档中的 SSL 支持），它首先尝试 SSL，但如果服务器不支持，则回退到禁用。</p>
<p>在这种情况下，不带任何选项的普通 sqlsh 将起作用并使用加密：</p>
<div class="highlight"><pre><span></span><code>$ ./bin/sqlsh
</code></pre></div>
<div class="highlight"><pre><span></span><code>sqlsh (11.2-BM-2.7.0.0-b0)
SSL connection (protocol: TLSv1.2, cipher: ECDHE-RSA-AES256-GCM-SHA384, bits: 256, compression: off)
Type &quot;help&quot; for help.
</code></pre></div>
<p>为了简洁起见，以下示例省略了 sslmode 设置。</p>
<p>2.带身份验证的 TLS
此配置要求客户端使用客户端到服务器加密并使用密码进行身份验证才能连接。</p>
<p>要创建数据库，请执行以下命令：</p>
<div class="highlight"><pre><span></span><code>$ ./bin/bm-dev-ctl destroy &amp;&amp; ./bin/bm-dev-ctl create --dbserver_flags=&quot;$ENABLE_TLS,bsql_enable_auth=true&quot;
</code></pre></div>
<p>要连接到数据库，需要密码（请参见下面的第二行）：</p>
<div class="highlight"><pre><span></span><code>$ ./bin/sqlsh
</code></pre></div>
<div class="highlight"><pre><span></span><code>Password for user bigmath:
sqlsh (11.2-BM-2.7.0.0-b0)
SSL connection (protocol: TLSv1.2, cipher: ECDHE-RSA-AES256-GCM-SHA384, bits: 256, compression: off)
Type &quot;help&quot; for help.
</code></pre></div>
<p>其他模式（即 sslmode=require 或disable）的行为类似。</p>
<p>3.通过证书进行身份验证的 TLS
此配置要求客户端使用客户端到服务器加密并使用适当的证书进行身份验证以进行连接。</p>
<p>注：在版本 2.5.2 之前，这是无需身份验证的 TLS 的默认设置。 此示例显示用于复制先前行为的 bsql_hba_conf_csv 配置。</p>
<p>要创建数据库，请执行以下命令：</p>
<div class="highlight"><pre><span></span><code>$ ./bin/bm-dev-ctl destroy &amp;&amp; ./bin/bm-dev-ctl create \
    --dbserver_flags=&quot;$ENABLE_TLS&quot; \
    --bsql_hba_conf_csv=&quot;hostssl all all all cert&quot;
</code></pre></div>
<p>如果没有证书，连接将失败。</p>
<div class="highlight"><pre><span></span><code>$ ./bin/sqlsh
</code></pre></div>
<div class="highlight"><pre><span></span><code>sqlsh: FATAL:  connection requires a valid client certificate
FATAL:  no pg_hba.conf entry for host &quot;127.0.0.1&quot;, user &quot;bigmath&quot;, database &quot;bigmath&quot;, SSL off
</code></pre></div>
<p>使用以下带证书参数的命令连接：</p>
<div class="highlight"><pre><span></span><code>$ ./bin/sqlsh &quot;sslcert=$CERTS/node.127.0.0.1.crt sslkey=$CERTS/node.127.0.0.1.key sslrootcert=$CERTS/ca.crt&quot;
</code></pre></div>
<div class="highlight"><pre><span></span><code>sqlsh (11.2-BM-2.7.0.0-b0)
SSL connection (protocol: TLSv1.2, cipher: ECDHE-RSA-AES256-GCM-SHA384, bits: 256, compression: off)
Type &quot;help&quot; for help.
</code></pre></div>
<p>4.具有密码和证书身份验证的 TLS
此配置要求客户端使用客户端到服务器加密并使用适当的证书和密码进行身份验证以进行连接。</p>
<p>注：在版本 2.5.2 之前，这是带有身份验证的 TLS 的默认设置。 此示例显示用于复制先前行为的 bsql_hba_conf_csv 配置。</p>
<p>要创建数据库，请执行以下命令：</p>
<div class="highlight"><pre><span></span><code>$ ./bin/bm-dev-ctl destroy &amp;&amp; ./bin/bm-dev-ctl create \
    --dbserver_flags=&quot;$ENABLE_TLS,bsql_enable_auth=true&quot; \
    --bsql_hba_conf_csv=&quot;hostssl all all all md5 clientcert=1&quot;
</code></pre></div>
<p>在这种情况下，bsql_enable_auth=true 标志是多余的，但包含它是为了演示使用 bsql_hba_conf_csv 覆盖自动生成的配置的能力。</p>
<p>如果没有证书和密码，连接将失败。</p>
<div class="highlight"><pre><span></span><code>$ ./bin/sqlsh
</code></pre></div>
<div class="highlight"><pre><span></span><code>sqlsh: FATAL:  connection requires a valid client certificate
FATAL:  no pg_hba.conf entry for host &quot;127.0.0.1&quot;, user &quot;bigmath&quot;, database &quot;bigmath&quot;, SSL off
</code></pre></div>
<p>使用以下命令通过证书和密码进行连接：</p>
<div class="highlight"><pre><span></span><code>$ ./bin/sqlsh &quot;sslcert=$CERTS/node.127.0.0.1.crt sslkey=$CERTS/node.127.0.0.1.key sslrootcert=$CERTS/ca.crt&quot;
</code></pre></div>
<div class="highlight"><pre><span></span><code>Password for user bigmath:
sqlsh (11.2-BM-2.7.0.0-b0)
SSL connection (protocol: TLSv1.2, cipher: ECDHE-RSA-AES256-GCM-SHA384, bits: 256, compression: off)
Type &quot;help&quot; for help.
</code></pre></div>
<h3 id="_89"><strong>静态加密</strong></h3>
<p>可以使用自行生成的密钥在BMDB集群中启用和禁用静态加密。
请注意，加密可以应用于以下级别：
1）在数据库层，在这种情况下，加密过程及其相关功能（如密钥轮换）是集群范围的。
2）在文件系统级别，在这种情况下，操作团队有责任在每个节点上手动管理流程。需要注意的是，文件系统或外部加密机制支持在线操作的程度可能会有所不同（例如，当数据库进程仍在运行时）。</p>
<h4 id="_90"><strong>启用加密</strong></h4>
<p>可以按如下步骤启用加密：</p>
<p>1.生成密钥：
通过在本地文件系统上执行以下命令，生成长度为32、40或48的密钥数据：</p>
<div class="highlight"><pre><span></span><code>openssl rand -out /path/to/universe_key [ 32 | 40 | 48 ]
</code></pre></div>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>openssl rand -out /c_key/cluster_key 32
</code></pre></div>
<p>请注意，较大的密钥更安全，但是性能稍差。</p>
<p>2.复制密钥
将密钥复制到主节点。 在以下示例中，假设 3 节点 RF=3 集群的 MSERVER_ADDRESSES=ip1:11000,ip2:11000,ip3:11000。 为此密钥选择任何字符串 <key_id> 并使用 bm-admin 将密钥复制到每个主服务器：</p>
<div class="highlight"><pre><span></span><code>bm-admin -mserver_addresses $MSERVER_ADDRESSES add_universe_key_to_all_mservers &lt;key_id&gt; /&lt;path_to_universe_key&gt;
</code></pre></div>
<p>注意：密钥只存在于内存中，而明文密钥永远不会持久存在于磁盘中。</p>
<p>3.启用密钥
启用集群范围的加密。 在轮换密钥之前，请确保mservers知道 <key_id>：</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>bm-admin -mserver_addresses $MSERVER_ADDRESSES all_mservers_have_universe_key_in_memory &lt;key_id&gt;
</code></pre></div>
<p>如果前面的命令失败，请重新运行步骤2。一旦成功，将指示集群开始使用新的密钥，如下所示：</p>
<div class="highlight"><pre><span></span><code>bm-admin -mserver_addresses $MSERVER_ADDRESSES rotate_universe_key_in_memory &lt;key_id&gt;
</code></pre></div>
<p>注意：由于数据是在后台作为磁盘刷新和压缩的一部分进行加密的，因此只有新数据才会被加密。</p>
<p>4.验证加密是否已启用
验证加密是否已启用。要执行下面操作，请通过执行以下bm-admin命令检查集群的加密状态：</p>
<div class="highlight"><pre><span></span><code>bm-admin -mserver_addresses $MSERVER_ADDRESSES is_encryption_enabled
</code></pre></div>
<p>预期输出如下：</p>
<div class="highlight"><pre><span></span><code>Encryption status: ENABLED with key id &lt;key_id&gt;
</code></pre></div>
<h4 id="_91"><strong>轮换新钥匙</strong></h4>
<p>您可以按如下方式轮换新密钥：</p>
<p>1.通过执行以下命令创建要轮换的密钥：</p>
<div class="highlight"><pre><span></span><code>openssl rand -out /path_to_universe_key_2 [ 32 | 40 | 48 ]
</code></pre></div>
<p>确保使用不同的密钥路径以避免覆盖以前的密钥文件。</p>
<p>2.将新密钥复制到主节点，通知主节点新密钥，如下：</p>
<div class="highlight"><pre><span></span><code>bm-admin -mserver_addresses $MSERVER_ADDRESSES add_universe_key_to_all_mservers
&lt;key_id_2&gt; /path_to_universe_key_2
</code></pre></div>
<p><key_id> 必须与之前的任何密钥不同。</p>
<p>3.确保mservers知道密钥，然后执行轮换，如下：</p>
<div class="highlight"><pre><span></span><code>bm-admin -mserver_addresses $MSERVER_ADDRESSES rotate_universe_key_in_memory &lt;key_id_2&gt;
</code></pre></div>
<p>由于该密钥仅用于新数据，并且最终只能通过压缩来加密旧数据，因此最好确保旧密钥保持安全。</p>
<p>4.验证新密钥。 为此，请检查新密钥是否正在加密集群，如下所示：</p>
<div class="highlight"><pre><span></span><code>bm-admin -mserver_addresses $MSERVER_ADDRESSES is_encryption_enabled
</code></pre></div>
<p>预期输出如下：</p>
<div class="highlight"><pre><span></span><code>Encryption status: ENABLED with key id &lt;key_id_2&gt;
</code></pre></div>
<p><key_id_2> 必须与之前的 <key_id> 不同。</p>
<h4 id="_92"><strong>禁用加密</strong></h4>
<p>您可以按如下方式禁用集群范围的加密：</p>
<p>1.通过执行以下 bm-admin 命令禁用加密：</p>
<div class="highlight"><pre><span></span><code>bm-admin -mserver_addresses $MSERVER_ADDRESSES disable_encryption
</code></pre></div>
<p>2.通过执行以下命令验证加密是否已禁用：</p>
<div class="highlight"><pre><span></span><code>bm-admin -mserver_addresses $MSERVER_ADDRESSES is_encryption_enabled
</code></pre></div>
<p>输出如下：</p>
<div class="highlight"><pre><span></span><code>Encryption status: DISABLED
</code></pre></div>
<h3 id="_93"><strong>列级加密</strong></h3>
<p>使用用户生成的密钥启用静态加密</p>
<p>BMDB 提供列级加密来限制对地址和信用卡详细信息等敏感数据的访问。 BMDB使用PostgreSQL pgcrypto扩展来启用列级加密，pgcrypto扩展的PGP_SYM_ENCRYPT和PGP_SYM_DECRYPT函数用于加密和解密列数据。</p>
<h4 id="_94"><strong>对称加密</strong></h4>
<p>在 BMDB 中启用对称列加密的步骤。</p>
<p>1.启用 pgcrypto 扩展
打开 BSQL shell (sqlsh)，指定 bigmath 用户并提示输入密码。</p>
<div class="highlight"><pre><span></span><code>$ ./sqlsh -U bigmath -W
</code></pre></div>
<p>当提示输入密码时，输入 bigmath 用户密码。 您应该能够登录并看到类似于以下内容的响应：</p>
<div class="highlight"><pre><span></span><code>sqlsh (11.2-BM-2.5.0.0-b0)
Type &quot;help&quot; for help.

bigmath=#
\c bigmath bigmath;

You are now connected to database &quot;bigmath&quot; as user &quot;bigmath&quot;.
</code></pre></div>
<p>在 BMDB 集群上启用 pgcrypto 扩展：</p>
<div class="highlight"><pre><span></span><code>create extension if not exists pgcrypto;
</code></pre></div>
<p>2.使用 PGP_SYM_ENCRYPT 插入数据
创建employees表，并使用PGP_SYM_ENCRYPT函数将数据插入表中需要加密的列。</p>
<p>首先，创建表：</p>
<div class="highlight"><pre><span></span><code>create table employees ( empno int, ename text, address text, salary int, account_number text );
</code></pre></div>
<p>接下来，使用 PGP_SYM_ENCRYPT 函数加密员工表中的帐号：</p>
<div class="highlight"><pre><span></span><code>insert into employees values (1, &#39;joe&#39;, &#39;56 grove st&#39;,  20000, PGP_SYM_ENCRYPT(&#39;AC-22001&#39;, &#39;AES_KEY&#39;));

insert into employees values (2, &#39;mike&#39;, &#39;129 81 st&#39;,  80000, PGP_SYM_ENCRYPT(&#39;AC-48901&#39;, &#39;AES_KEY&#39;));

insert into employees values (3, &#39;julia&#39;, &#39;1 finite loop&#39;,  40000, PGP_SYM_ENCRYPT(&#39;AC-77051&#39;, &#39;AES_KEY&#39;));
</code></pre></div>
<p>3.验证列加密
查看加密后的account_number数据，如下：</p>
<div class="highlight"><pre><span></span><code>select ename, account_number from employees limit 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code> ename |               account_number
-------+-------------------------------------------------
 joe   | \xc30d04070302ee4c6d5f6656ace96ed23901f56c717d4e
 162b6639429f516b5103acebc4bc91ec15df06c30e29e6841f4a5386
 e7698bfebb49a8660f9ae4b3f34fede3f28c9c7bb245bd
(1 rows)
</code></pre></div>
<p>4.使用 PGP_SYM_DECRYPT 查询
使用 PGP_SYM_DECRYPT 函数解密帐号，如下所示。 为了检索加密的列数据，请使用 PGP_SYM_DECRYPT 函数解密数据。 根据查询，解密函数需要在 SELECT 和 WHERE 子句中使用。</p>
<p>为了允许解密，字段名称也被转换为二进制数据类型，语法为：account_number::bytea。</p>
<div class="highlight"><pre><span></span><code>select PGP_SYM_DECRYPT(account_number::bytea, &#39;AES_KEY&#39;) as AccountNumber
       from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> accountnumber
---------------
 AC-22001
 AC-48901
 AC-77051
(3 rows)
</code></pre></div>
<h4 id="_95"><strong>非对称加密</strong></h4>
<p>非对称加密（也称为公钥加密）可与 BMDB 一起使用以启用列级加密。 BMDB 可以配置生成的公钥/私钥或公司 GPG 密钥来加密列数据。</p>
<p>下面的示例演示了使用一组新密钥（公钥和私钥）配置 BMDB 集群。</p>
<p>1.生成RSA密钥对
（1）首先使用 gpg 密钥生成器生成新的公共和私有 RSA 密钥对：</p>
<div class="highlight"><pre><span></span><code>$ gpg --gen-key
</code></pre></div>
<p>（2）经过配置提示后，会生成 RSA 密钥：</p>
<div class="highlight"><pre><span></span><code>public and secret key created and signed.

pub   rsa2048 2020-11-09 [SC] [expires: 2022-11-09]
      043E14210E7628F93383D78EA2969FF91871CE06
uid   bmadmin &lt;bmadmin@bigmath.com&gt;
sub   rsa2048 2020-11-09 [E] [expires: 2022-11-09]
</code></pre></div>
<p>（3）接下来，导出新生成的 RSA 密钥的公钥和私钥：
私钥：</p>
<div class="highlight"><pre><span></span><code>$ gpg --export-secret-keys \
      --armor 043E14210E7628F93383D78EA2969FF91871CE06 &gt; ./private_key.txt
</code></pre></div>
<p>公钥：</p>
<div class="highlight"><pre><span></span><code>$ gpg --export --armor 043E14210E7628F93383D78EA2969FF91871CE06 &gt; ./public_key.txt
</code></pre></div>
<p>2.启用 pgcrypto 扩展
（1）打开 BSQL shell (sqlsh)，指定 bigmath 用户并提示输入密码。</p>
<div class="highlight"><pre><span></span><code>$ ./sqlsh -U bigmath -W
</code></pre></div>
<p>当提示输入密码时，输入 bigmath 用户密码。</p>
<p>（2）在 BMDB 集群上启用 pgcrypto 扩展：</p>
<div class="highlight"><pre><span></span><code>create extension if not exists pgcrypto;
</code></pre></div>
<p>3.使用 pgp_pub_encrypt 插入数据
创建employees表并使用生成的公钥将数据插入表中以加密列数据</p>
<div class="highlight"><pre><span></span><code>create table employees ( empno int, ename text, address text, salary int, account_number text );
</code></pre></div>
<p>在此示例中，使用 pgp_pub_encrypt 函数和生成的公钥对员工表的帐号进行加密。</p>
<div class="highlight"><pre><span></span><code>insert into employees values (1, &#39;joe&#39;, &#39;56 grove st&#39;,  20000, PGP_PUB_ENCRYPT(&#39;AC-22001&#39;, dearmor(&#39;-----BEGIN PGP PUBLIC KEY BLOCK----- XXXX  -----END PGP PUBLIC KEY BLOCK-----&#39;)));

insert into employees values (2, &#39;mike&#39;, &#39;129 81 st&#39;,  80000, PGP_PUB_ENCRYPT(&#39;AC-48901&#39;, dearmor(&#39;-----BEGIN PGP PUBLIC KEY BLOCK----- XXXX  -----END PGP PUBLIC KEY BLOCK-----&#39;)));

insert into employees values (3, &#39;julia&#39;, &#39;1 finite loop&#39;,  40000, PGP_PUB_ENCRYPT(&#39;AC-77051&#39;, dearmor(&#39;-----BEGIN PGP PUBLIC KEY BLOCK----- XXXX  -----END PGP PUBLIC KEY BLOCK-----&#39;)));
</code></pre></div>
<p>4.验证列加密
验证 account_number 列的数据是否已加密，如下所示。</p>
<div class="highlight"><pre><span></span><code>select ename, account_number from employees limit 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code> ename |                   account_number
-------+------------------------------------------------------------
 julia | \xc1c04c039bd2f02876cc14ae0107ff44e68e5a4bb35784b426f4aeb46
 70976127d64e731cf8f70343b100ea0ed60b3de191fa19e245c4ce9b0289e44b53b
 7d3c42b8187487b3b0bb8ebed518a248ca3c1d663174d1c9d6769f7840ddbd8508d
 d4b91dcf77183779ff15b003431a7d05a1aef4b09313b602bcc2491cc2e417d5c39
 269230e032252547ce1fd51f27be0cc43c5fd75f35b21e0a72e8e
(1 row)
</code></pre></div>
<p>5.使用 pgp_pub_decrypt 进行查询
使用 pgp_pub_decrypt 和私钥来解密列数据。 要检索加密的列数据，请使用 pgp_pub_decrypt 函数解密数据，并使用 Dearmor 函数包装 PGP 私钥，将私钥转换为 PGP ASCII-armor 格式。 根据查询的不同，解密函数需要在 SELECT 和 WHERE 子句中使用。</p>
<p>为了允许解密，字段名称也被转换为二进制数据类型，语法为：account_number::bytea。</p>
<div class="highlight"><pre><span></span><code>select PGP_PUB_DECRYPT(account_number::bytea,dearmor(&#39;-----BEGIN PGP PRIVATE KEY BLOCK----- XXXX  -----END PGP PRIVATE KEY BLOCK-----&#39;),&#39;PRIVATE-KEY-PASSWORD&#39;) as AccountNumber from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> accountnumber
---------------
 AC-22001
 AC-48901
 AC-77051
(3 rows)
</code></pre></div>
<h3 id="_96"><strong>审计</strong></h3>
<p>使用审核日志记录来生成遵守政府、财务或 ISO 认证所需的审核日志。</p>
<h4 id="_97"><strong>跟踪语句</strong></h4>
<p>要跟踪会话中执行的语句，您可以使用会话标识符。 会话标识符可用于过滤 PostgreSQL 日志文件以查找在特定会话中执行的语句，并且在 DBServer 节点中是唯一的。 会话标识符是进程启动时间和 PostgreSQL 进程 ID (PID) 的组合，并以十六进制格式输出到日志。</p>
<p>请注意，在具有多个节点的 BMDB 集群中，不保证会话标识符是唯一的； 不同节点上的进程启动时间和 PostgreSQL PID 可以相同。 确保连接到执行语句的节点。</p>
<h5 id="_98"><strong>设置日志记录选项</strong></h5>
<p>要记录适当的会话信息，您需要为 DBServer 设置以下配置标志：</p>
<ul>
<li>将 bsql_log_statement DBServer 配置标志设置为 all 以打开 PostgreSQL 日志中的语句日志记录。</li>
<li>设置 log_line_prefix PostgreSQL 服务器选项以记录时间戳、PostgreSQL PID 和会话标识符。</li>
</ul>
<p>BMDB 包含额外的日志记录选项，以便您可以记录分布式位置信息。 例如：</p>
<div class="highlight"><pre><span></span><code>--bsql_pg_conf_csv=&quot;log_line_prefix=&#39;%m [%p %l %c] %q[%C %R %Z %H] [%r%a %u %d] &#39;&quot;
</code></pre></div>
<p>参数与PostgreSQL类似，增加了H、C、R、Z来添加分布式系统相关的主机、云、区域、可用区信息。 您还可以添加 %U 和 %N 来分别添加集群 UUID、节点和集群名称。</p>
<p>有关在 BMDB 中设置服务器选项的信息，请参阅 PostgreSQL 服务器选项。</p>
<h5 id="_99"><strong>查看日志</strong></h5>
<p>会话信息写入 PostgreSQL 日志，位于 bm-data/dbserver/logs 目录中的 BMDB 基本文件夹中。 有关检查日志的信息，请参阅检查 BMDB 日志。</p>
<h5 id="_100"><strong>会话示例</strong></h5>
<p>创建本地集群并配置 bsql_log_statement 来记录所有语句，并配置 log_line_prefix 来记录时间戳、PostgreSQL PID 和会话标识符，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl start --dbserver_flags=&quot;bsql_log_statement=all,bsql_pg_conf_csv=\&quot;log_line_prefix=&#39;timestamp: %m, pid: %p session: %c &#39;\&quot;&quot;
</code></pre></div>
<p>对于使用 bm-ctl 创建的本地集群，postgresql 日志位于 ~/var/data/bm-data/dbserver/logs 中。</p>
<p>使用 sqlsh 连接到集群，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh
</code></pre></div>
<div class="highlight"><pre><span></span><code>sqlsh (11.2-BM-2.15.2.1-b0)
Type &quot;help&quot; for help.

bigmath=# 
</code></pre></div>
<p><strong>1.跟踪语句执行</strong>
执行以下命令：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE my_table ( h int, r int, v int, primary key(h,r));

CREATE TABLE
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO my_table VALUES (1, 1, 1);

INSERT 0 1
</code></pre></div>
<p>您的 PostgreSQL 日志应包含类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>timestamp: 2022-10-24 16:49:42.825 UTC --pid: 1930 session: 6356c208.78a LOG:  statement: CREATE TABLE my_table ( h int, r int, v int, primary key(h,r));
timestamp: 2022-10-24 16:51:01.258 UTC --pid: 1930 session: 6356c208.78a LOG:  statement: INSERT INTO my_table VALUES (1, 1, 1);
</code></pre></div>
<p><strong>2.追踪显式事务</strong>
按如下方式启动显式事务：</p>
<div class="highlight"><pre><span></span><code>BEGIN;

BEGIN

INSERT INTO my_table VALUES (2,2,2);

INSERT 0 1

DELETE FROM my_table WHERE h = 1;

DELETE 1

COMMIT;

COMMIT
</code></pre></div>
<p>您的 PostgreSQL 日志应包含类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>timestamp: 2022-10-24 16:56:56.269 UTC --pid: 1930 session: 6356c208.78a LOG:  statement: BEGIN;
timestamp: 2022-10-24 16:57:05.410 UTC --pid: 1930 session: 6356c208.78a LOG:  statement: INSERT INTO my_table VALUES (2,2,2);
timestamp: 2022-10-24 16:57:25.015 UTC --pid: 1930 session: 6356c208.78a LOG:  statement: DELETE FROM my_table WHERE h = 1;
timestamp: 2022-10-24 16:57:27.595 UTC --pid: 1930 session: 6356c208.78a LOG:  statement: COMMIT;
</code></pre></div>
<p><strong>3.跟踪并发事务</strong>
启动两个会话并同时执行事务，如下所示：</p>
<table>
    <thead>
        <tr>
            <th>会话1</th>
            <th>会话2</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>BEGIN;
                <br>INSERT INTO my_table VALUES (5,2,2);
            </td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td>BEGIN;
                <br>INSERT INTO my_table VALUES (6,2,2);
                <br>COMMIT;
            </td>
        </tr>
        <tr>
            <td>COMMIT;</td>
            <td></td>
        </tr>
    </tbody>
</table>

<p>您的 PostgreSQL 日志应包含类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>timestamp: 2022-10-24 17:04:09.007 UTC --pid: 1930 session: 6356c208.78a LOG:  statement: BEGIN;
timestamp: 2022-10-24 17:05:10.647 UTC --pid: 1930 session: 6356c208.78a LOG:  statement: INSERT INTO my_table VALUES (5,2,2);
timestamp: 2022-10-24 17:05:15.042 UTC --pid: 2343 session: 6356c4a4.927 LOG:  statement: BEGIN;
timestamp: 2022-10-24 17:05:19.227 UTC --pid: 2343 session: 6356c4a4.927 LOG:  statement: INSERT INTO my_table VALUES (6,2,2);
timestamp: 2022-10-24 17:05:22.288 UTC --pid: 2343 session: 6356c4a4.927 LOG:  statement: COMMIT;
timestamp: 2022-10-24 17:05:25.404 UTC --pid: 1930 session: 6356c208.78a LOG:  statement: COMMIT;
</code></pre></div>
<h5 id="_101"><strong>下一步</strong></h5>
<p>使用 pgaudit 为特定数据库、表或特定操作集启用日志记录。 请参阅在 BSQL 中配置审核日志记录。</p>
<h4 id="_102"><strong>配置审计日志</strong></h4>
<p>BMDB BSQL 使用 PostgreSQL 审计扩展 (pgaudit) 通过 BMDB DBServer 日志记录提供详细的会话和/或对象审计日志记录。</p>
<p>BSQL 审计日志记录的目标是为您提供生成审计日志的能力，这些日志通常需要遵守政府、财务或 ISO 认证。 审计是对个人或组织账户的正式检查，通常由独立机构进行。</p>
<h5 id="_103"><strong>启用审核日志记录</strong></h5>
<p>要启用审核日志记录，请首先为集群配置审核日志记录。 这是通过以下方式之一完成的：</p>
<ul>
<li>在数据库启动时。
  使用 --bsql_pg_conf_csv DBServer 标志。
  数据库管理员可以使用 bsql_pg_conf_csv 使用 pgaudit 标志配置审核日志记录。
  以逗号分隔值的形式提供选项。 例如：
  bsql_pg_conf_csv="pgaudit.log='DDL',pgaudit.log_client=on,pgaudit.log_level=notice"</li>
<li>每个会话。
  在正在运行的会话中使用 SET 命令。
  SET 命令实质上更改了运行时配置参数。
  例如，SET pgaudit.log='DDL'
  SET 只影响当前会话使用的值。 有关更多信息，请参阅 PostgreSQL 文档。</li>
</ul>
<p><strong>创建扩展</strong>
配置DBServer并启动集群后，在sqlsh中执行以下语句创建pgaudit扩展：</p>
<div class="highlight"><pre><span></span><code>CREATE EXTENSION IF NOT EXISTS pgaudit;
</code></pre></div>
<p>您只需在单个节点上运行此语句，它将应用于整个集群。</p>
<h5 id="_104"><strong>自定义审核日志记录</strong></h5>
<p>默认情况下，审核日志记录包括您使用 pgaudit.log 标志指定的语句类中的所有语句的语句文本。 您可以使用 pgaudit 标志自定义 BSQL 审核日志记录，如下表所示。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>pgaudit.log</td>
<td>指定会话审计日志记录哪些类的语句，如下所示：READ：SELECT and COPY WRITE: INSERT, UPDATE, DELETE, TRUNCATE, and COPY FUNCTION: Function calls and DO blocks.ROLE: Statements related to roles and privileges: GRANT, REVOKE, CREATE/ALTER/DROP ROLE.DDL: All DDL that is not included in the ROLE class.MISC: Miscellaneous commands, such as DISCARD, FETCH, CHECKPOINT, VACUUM, SET.ALL: Include all of the preceding options.您可以使用逗号分隔的列表指定多个类。 通过在类前面添加减号 (-) 来减去类。</td>
<td>none</td>
</tr>
<tr>
<td>Pgaudit.log_catalog</td>
<td>pg_catalog 中 PostgreSQL 系统目录关系的日志语句。 这些系统目录表记录系统（而不是用户）活动，例如元数据查找和执行查找的第三方工具。典型的审核不需要这些语句，您可以禁用此选项以减少日志中的噪音。</td>
<td>ON</td>
</tr>
<tr>
<td>pgaudit.log_client</td>
<td>启用此选项可将日志消息直接回显到客户端，例如 sqlsh 和 psql。 日志消息直接打印到 shell，这有助于调试。启用后，您可以使用 pgaudit.log_level 设置输出的日志级别。</td>
<td>OFF</td>
</tr>
<tr>
<td>pgaudit.log_level</td>
<td>设置当 pgaudit.log_client 打开时写入客户端的日志的严重性级别。 使用此设置进行调试和测试。值：DEBUG1 .. DEBUG5, INFO, NOTICE, WARNING, LOG。不允许出现 ERROR、FATAL 和 PANIC。pgaudit.log_level 仅在 pgaudit.log_client 打开时适用； 否则使用默认的 LOG 级别。</td>
<td>LOG</td>
</tr>
<tr>
<td>pgaudit.log_parameter</td>
<td>包括随日志中的语句传递的参数。 当存在参数时，它们会以 CSV 格式包含在语句文本之后。</td>
<td>OFF</td>
</tr>
<tr>
<td>pgaudit.log_relation</td>
<td>为 SELECT 或 DML 语句中引用的每个关系（TABLE、VIEW 等）创建单独的日志条目。 这是在不使用对象审核日志记录的情况下进行详尽日志记录的快捷方式。</td>
<td>OFF</td>
</tr>
<tr>
<td>pgaudit.log_statement_once</td>
<td>通常，语句文本（以及参数（如果启用））包含在每个日志条目中。 启用此设置以仅包含语句或子语句组合的第一个条目的语句文本和参数。 这可以减少详细的日志记录，但可能会更难以确定生成日志条目的语句。</td>
<td>OFF</td>
</tr>
<tr>
<td>pgaudit.role</td>
<td>指定用于对象审核日志记录的主角色。 如需定义多个审计角色，请将角色授予mserver角色； 这允许多个小组负责审计日志记录的不同方面。</td>
<td>None</td>
</tr>
</tbody>
</table>
<h5 id="_105"><strong>示例</strong></h5>
<p>使用 sqlsh 连接到数据库并在 BMDB 集群上启用 pgaudit 扩展，如下所示：</p>
<div class="highlight"><pre><span></span><code>\c bigmath bigmath;
CREATE EXTENSION IF NOT EXISTS pgaudit;
</code></pre></div>
<p><strong>1.基本审计日志记录</strong>
在sqlsh中，执行以下命令：</p>
<div class="highlight"><pre><span></span><code>SET pgaudit.log=&#39;DDL&#39;;
SET pgaudit.log_client=ON;
SET pgaudit.log_level=notice;
</code></pre></div>
<p><strong>创建表并验证日志</strong>
配置 pgaudit.log='DDL' 后，会记录 CREATE TABLE BSQL 语句，并在 sqlsh 中显示相应的日志：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE employees (empno int, ename text, address text,
  salary int, account_number text);

NOTICE:  AUDIT: SESSION,2,1,DDL,CREATE TABLE,TABLE,public.employees,
&quot;create table employees ( empno int, ename text, address text, salary int,
account_number text );&quot;,&lt;not logged&gt;
CREATE TABLE
</code></pre></div>
<p>请注意，审核日志是为 DDL 语句生成的。</p>
<p><strong>2.高级审核日志记录</strong>
对于本示例，使用以下审核日志记录配置启动一个新集群：</p>
<div class="highlight"><pre><span></span><code>--bsql_pg_conf_csv=&quot;log_line_prefix=&#39;%m [%p %l %c] %q[%C %R %Z %H] [%r %a %u %d] &#39;,pgaudit.log=&#39;all&#39;,pgaudit.log_parameter=on,pgaudit.log_relation=on,pgaudit.log_catalog=off,suppress_nonpg_logs=on&quot;
</code></pre></div>
<p>在任意节点上启用 pgaudit 扩展，如下所示：</p>
<div class="highlight"><pre><span></span><code>CREATE EXTENSION IF NOT EXISTS pgaudit;
CREATE TABLE IF NOT EXISTS my_table ( h int, r int, v int, primary key(h,r));
</code></pre></div>
<p>启动两个会话并同时执行事务，如下所示：</p>
<table>
    <thead>
        <tr>
            <th>会话1</th>
            <th>会话2</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>BEGIN;
                <br>INSERT INTO my_table VALUES (5,2,2);
            </td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td>BEGIN;
                <br>INSERT INTO my_table VALUES (6,2,2);
                <br>COMMIT;
            </td>
        </tr>
        <tr>
            <td>INSERT INTO my_table VALUES (7,2,2);
                <br>COMMIT;
            </td>
            <td></td>
        </tr>
    </tbody>
</table>

<p>您的 PostgreSQL 日志应包含类似于以下内容的交错输出：</p>
<div class="highlight"><pre><span></span><code>2022-12-08 14:11:24.190 EST [93243 15 639235e1.16c3b] [cloud1 datacenter1 rack1 node1] [127.0.0.1(49823) sqlsh bigmath bigmath] LOG:  AUDIT: SESSION,6,1,MISC,BEGIN,,,begin;,&lt;none&gt;
2022-12-08 14:11:34.309 EST [93243 16 639235e1.16c3b] [cloud1 datacenter1 rack1 node1] [127.0.0.1(49823) sqlsh bigmath bigmath] LOG:  AUDIT: SESSION,7,1,WRITE,INSERT,TABLE,public.my_table,&quot;INSERT INTO my_table VALUES (5,2,2);&quot;,&lt;none&gt;
2022-12-08 14:11:38.294 EST [92937 8 639233f7.16b09] [cloud1 datacenter1 rack1 node1] [127.0.0.1(49633) sqlsh bigmath bigmath] LOG:  AUDIT: SESSION,6,1,MISC,BEGIN,,,begin;,&lt;none&gt;
2022-12-08 14:11:42.976 EST [92937 9 639233f7.16b09] [cloud1 datacenter1 rack1 node1] [127.0.0.1(49633) sqlsh bigmath bigmath] LOG:  AUDIT: SESSION,7,1,WRITE,INSERT,TABLE,public.my_table,&quot;INSERT INTO my_table VALUES (6,2,2);&quot;,&lt;none&gt;
2022-12-08 14:11:46.596 EST [92937 10 639233f7.16b09] [cloud1 datacenter1 rack1 node1] [127.0.0.1(49633) sqlsh bigmath bigmath] LOG:  AUDIT: SESSION,8,1,MISC,COMMIT,,,COMMIT;,&lt;none&gt;
2022-12-08 14:11:52.317 EST [93243 17 639235e1.16c3b] [cloud1 datacenter1 rack1 node1] [127.0.0.1(49823) sqlsh bigmath bigmath] LOG:  AUDIT: SESSION,8,1,WRITE,INSERT,TABLE,public.my_table,&quot;INSERT INTO my_table VALUES (7,2,2);&quot;,&lt;none&gt;
2022-12-08 14:11:54.374 EST [93243 18 639235e1.16c3b] [cloud1 datacenter1 rack1 node1] [127.0.0.1(49823) sqlsh bigmath bigmath] LOG:  AUDIT: SESSION,9,1,MISC,COMMIT,,,commit;,&lt;none&gt;
</code></pre></div>
<p>按会话标识符和时间戳排序，并包括集群中唯一性的节点信息，您可以对事务进行分组：</p>
<div class="highlight"><pre><span></span><code>cloud1 datacenter1 rack1 node1 639233f7.16b09 2022-12-08 14:11:38.294 SESSION,6,1,MISC,BEGIN,,,begin;,&lt;none&gt;
cloud1 datacenter1 rack1 node1 639233f7.16b09 2022-12-08 14:11:42.976 SESSION,7,1,WRITE,INSERT,TABLE,public.my_table,&quot;INSERT INTO my_table VALUES (6,2,2);&quot;,&lt;none&gt;
cloud1 datacenter1 rack1 node1 639233f7.16b09 2022-12-08 14:11:46.596 SESSION,8,1,MISC,COMMIT,,,COMMIT;,&lt;none&gt;

cloud1 datacenter1 rack1 node1 639235e1.16c3b 2022-12-08 14:11:24.190 SESSION,6,1,MISC,BEGIN,,,begin;,&lt;none&gt;
cloud1 datacenter1 rack1 node1 639235e1.16c3b 2022-12-08 14:11:34.309 SESSION,7,1,WRITE,INSERT,TABLE,public.my_table,&quot;INSERT INTO my_table VALUES (5,2,2);&quot;,&lt;none&gt;
cloud1 datacenter1 rack1 node1 639235e1.16c3b 2022-12-08 14:11:52.317 SESSION,8,1,WRITE,INSERT,TABLE,public.my_table,&quot;INSERT INTO my_table VALUES (7,2,2);&quot;,&lt;none&gt;
cloud1 datacenter1 rack1 node1 639235e1.16c3b 2022-12-08 14:11:54.374 SESSION,9,1,MISC,COMMIT,,,commit;,&lt;none&gt;
</code></pre></div>
<h4 id="_106"><strong>会话级审计日志</strong></h4>
<p>会话日志记录是在每个用户会话的基础上启用的。</p>
<p>要为所有 DML 和 DDL 语句启用会话日志记录并记录 DML 语句中的所有关系，您需要输入以下命令：</p>
<div class="highlight"><pre><span></span><code>set pgaudit.log = &#39;write, ddl&#39;;
set pgaudit.log_relation = on;
</code></pre></div>
<p>为除 MISC 之外的所有命令启用会话日志记录，并将审核日志消息作为“通知”发出。</p>
<h5 id="_107"><strong>会话级示例</strong></h5>
<p>在此示例中，会话审核日志记录用于记录 DDL 和 SELECT 语句。 请注意，由于未启用 WRITE 类，因此不会记录插入语句。</p>
<p>SQL语句如下所示。</p>
<p><strong>1.设置</strong>
使用 sqlsh 连接到数据库并在 BMDB 集群上启用 pgaudit 扩展，如下所示：</p>
<div class="highlight"><pre><span></span><code>\c bigmath bigmath;
CREATE EXTENSION IF NOT EXISTS pgaudit;
</code></pre></div>
<p><strong>2.启用会话审核日志记录</strong>
在 BMDB 集群中启用会话审核日志记录，如下所示：</p>
<div class="highlight"><pre><span></span><code>SET pgaudit.log = &#39;read, ddl&#39;;
</code></pre></div>
<p><strong>3.执行语句</strong>
运行一些语句如下：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE account
(
    id int,
    name text,
    password text,
    description text
);

INSERT INTO account (id, name, password, description)
             VALUES (1, &#39;user1&#39;, &#39;HASH1&#39;, &#39;blah, blah&#39;);

SELECT * FROM account;
</code></pre></div>
<p><strong>4.验证输出</strong>
您应该在日志中看到类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>2020-11-09 19:19:09.262 UTC [3710] LOG:  AUDIT: SESSION,1,1,DDL,CREATE
TABLE,TABLE,public.account,&quot;create table account
        (
            id int,
            name text,
            password text,
            description text
        );&quot;,&lt;not logged&gt;
2020-11-09 19:19:19.619 UTC [3710] LOG:  AUDIT: SESSION,2,1,READ,SELECT,,,&quot;select *
            from account;&quot;,&lt;not logged&gt;
</code></pre></div>
<h4 id="_108"><strong>对象级审计日志</strong></h4>
<p>对象审计日志记录影响特定关系的语句。 仅支持 SELECT、INSERT、UPDATE 和 DELETE 命令。 TRUNCATE 不包含在对象审核日志记录中。</p>
<p>对象审计日志记录旨在成为 pgaudit.log = 'read, write' 的更细粒度的替代。 因此，结合使用它们可能没有意义，但一种可能的情况是使用会话日志记录来捕获每个语句，然后用对象日志记录对其进行补充，以获得有关特定关系的更多详细信息。</p>
<p>在BMDB中，对象级审计日志记录是通过重用PG角色系统来实现的。 pgaudit.role 设置定义将用于审核日志记录的角色。 当审核角色具有执行命令的权限或从另一个角色继承权限时，关系（TABLE、VIEW 等）将被审核记录。 这使您可以有效地拥有多个审计角色，即使在任何上下文中只有一个主角色。</p>
<h5 id="_109"><strong>对象级示例</strong></h5>
<p>在此示例中，对象审核日志记录用于说明如何采用精细方法来记录 SELECT 和 DML 语句。</p>
<p><strong>1.设置</strong>
使用 sqlsh 连接到数据库并在 BMDB 集群上启用 pgaudit 扩展，如下所示：</p>
<div class="highlight"><pre><span></span><code>\c bigmath bigmath;
CREATE EXTENSION IF NOT EXISTS pgaudit;
</code></pre></div>
<p><strong>2.启用对象审计</strong>
将 pgaudit.role 设置为审计员并授予对帐户表的 SELECT 和 UPDATE 权限。 现在将记录帐户表上的任何 SELECT 或 UPDATE 语句。 请注意，account 表的日志记录是由列级权限控制的，而account_role_map 表的日志记录是表级的。</p>
<div class="highlight"><pre><span></span><code>CREATE ROLE auditor;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET pgaudit.role = &#39;auditor&#39;;
</code></pre></div>
<p><strong>3.创建表</strong></p>
<div class="highlight"><pre><span></span><code>CREATE TABLE account
(
    id int,
    name text,
    password text,
    description text
);

GRANT SELECT (password)
   ON public.account
   TO auditor;

SELECT id, name FROM account;

SELECT password FROM account;

GRANT UPDATE (name, password)
   ON public.account
   TO auditor;

UPDATE account
   SET description = &#39;yada, yada&#39;;

UPDATE account
   SET password = &#39;HASH2&#39;;

CREATE TABLE account_role_map
(
    account_id int,
    role_id int
);

GRANT SELECT
   ON public.account_role_map
   TO auditor;

SELECT account.password,
       account_role_map.role_id
  FROM account
       INNER JOIN account_role_map
            ON account.id = account_role_map.account_id;
</code></pre></div>
<p><strong>4.验证输出</strong>
您应该在日志中看到以下输出：</p>
<div class="highlight"><pre><span></span><code>2020-11-09 19:46:42.633 UTC [3944] LOG:  AUDIT: OBJECT,1,1,READ,SELECT,TABLE,public.account,&quot;select password
          from account;&quot;,&lt;not logged&gt;
2020-11-09 19:47:02.531 UTC [3944] LOG:  AUDIT: OBJECT,2,1,WRITE,UPDATE,TABLE,public.account,&quot;update account
           set password = &#39;HASH2&#39;;&quot;,&lt;not logged&gt;
I1109 19:47:09.418772  3944 bmccmds.c:453] Creating Table bigmath.public.account_role_map
I1109 19:47:09.418812  3944 pg_ddl.cc:310] PgCreateTable: creating a transactional table: bigmath.account_role_map
I1109 19:47:09.538868  3944 table_creator.cc:307] Created table bigmath.account_role_map of type PGSQL_TABLE_TYPE
2020-11-09 19:47:22.752 UTC [3944] LOG:  AUDIT: OBJECT,3,1,READ,SELECT,TABLE,public.account,&quot;select account.password,
               account_role_map.role_id
          from account
               inner join account_role_map
                    on account.id = account_role_map.account_id;&quot;,&lt;not logged&gt;
2020-11-09 19:47:22.752 UTC [3944] LOG:  AUDIT: OBJECT,3,1,READ,SELECT,TABLE,public.account_role_map,&quot;select account.password,
               account_role_map.role_id
          from account
               inner join account_role_map
                    on account.id = account_role_map.account_id;&quot;,&lt;not logged&gt;
</code></pre></div>
<h2 id="_110"><strong>备份恢复</strong></h2>
<h3 id="_111"><strong>备份和还原</strong></h3>
<p>备份和恢复是创建和存储数据副本以防止数据丢失的过程。 通过正确的备份策略，您始终可以将数据恢复到最新的已知工作状态，并最大限度地减少应用程序停机时间。 这反过来又保证了业务和应用程序的连续性。</p>
<p>与传统的单实例数据库不同，BMDB 专为容错而设计。 通过跨多个数据区域或多个云维护至少三个数据副本，可以确保在单个节点或单个数据区域不可用时不会发生任何损失。 因此，使用 BMDB，您主要使用备份来：</p>
<ul>
<li>从用户或软件错误中恢复，例如意外删除表。</li>
<li>从灾难场景中恢复，例如整个集群故障或多个数据区域同时中断。 尽管这种情况极不可能发生，但保持一种从中恢复的方法仍然是最佳实践。</li>
<li>根据数据保护法规的要求，维护数据的远程副本。</li>
</ul>
<h4 id="_112"><strong>导出和导入</strong></h4>
<p>BMDB 包括 bm-dump 和 bm-dumpall 实用程序，允许您将数据导出到 SQL 脚本中。 这些实用程序源自 PostgreSQL pg_dump 和 pg_dumpall。</p>
<p>一般来说，建议使用其他方式进行备份，例如分布式备份和恢复。 但是，如果您打算恢复 BMDB 以外的数据库上的数据，或者出于其他原因（例如法规）需要 SQL 格式的数据，则可以使用 bm-dump 和 bm-dumpall。</p>
<p>这两个实用程序都是线程安全的，并且始终生成一致版本的数据库，即使与读取和更新数据的其他应用程序同时运行也是如此。</p>
<p>有关更多详细信息和所有可用选项的列表，请参阅以下内容：</p>
<ul>
<li>bm-dump 参考</li>
<li>bm-dumpall 参考</li>
</ul>
<h5 id="_113"><strong>导出单个数据库</strong></h5>
<p>要导出单个数据库及其所有表、索引和其他本地工件，请通过执行以下命令来使用 bm-dump 实用程序：</p>
<div class="highlight"><pre><span></span><code>./postgres/bin/bm-dump -d &lt;db-name&gt; &gt; &lt;file&gt;
</code></pre></div>
<p>db-name 是要导出的数据库的名称。
file 是生成的 SQL 脚本文件的路径。
例如，要将 mydb 数据库导出到backup文件夹中名为 mydb-dump.sql 的文件中，命令如下：</p>
<div class="highlight"><pre><span></span><code>./postgres/bin/bm-dump -d mydb &gt; backup/mydb-dump.sql
</code></pre></div>
<h5 id="_114"><strong>导出单个表</strong></h5>
<p>要导出单个数据库表，请通过执行以下命令来使用 bm-dump 实用程序：</p>
<div class="highlight"><pre><span></span><code>./postgres/bin/bm-dump -t &lt;table-name&gt; &lt;db-name&gt; -f &lt;file&gt;
</code></pre></div>
<p>table-name 是要导出的表的名称。
db-name 是要导出的数据库的名称。
file 是生成的 SQL 脚本文件的路径。
例如，要将 mydb 数据库的 mytable 表导出到backup文件夹中名为 mytable-mydb-dump.sql 的文件中，命令如下：</p>
<div class="highlight"><pre><span></span><code>./postgres/bin/bm-dump -t mytable mydb -f backup/mytable-mydb-dump.sql
</code></pre></div>
<h5 id="_115"><strong>导出所有数据库</strong></h5>
<p>要导出所有数据库以及全局工件（例如用户、角色、权限等），请通过执行以下命令来使用 bm-dumpall 实用程序：</p>
<div class="highlight"><pre><span></span><code>./postgres/bin/bm-dumpall &gt; &lt;file&gt;
</code></pre></div>
<p>file 是生成的 SQL 脚本文件的路径。</p>
<p>以下是该脚本的两个常见命令行选项：
--roles-only 仅导出角色。
--schema-only 导出所有不带数据的数据库对象。</p>
<h5 id="_116"><strong>导入</strong></h5>
<p>您可以从 SQL 脚本将架构和对象导入 BMDB。 要创建此脚本，请按照导出单个数据库或导出所有数据库中提供的说明进行操作。 或者，您可以从支持 PostgreSQL 语法的外部数据库获取脚本。</p>
<p>要导入脚本，请使用 sqlsh 命令行工具，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -f &lt;sql_script&gt;
</code></pre></div>
<p>sql_script 是要导入的 SQL 脚本的路径。</p>
<p>您还可以在 sqlsh shell 中使用 \i 元命令导入 SQL 脚本，如下所示：</p>
<div class="highlight"><pre><span></span><code>bigmath=# \i &lt;sql_script&gt;
</code></pre></div>
<h4 id="_117"><strong>分布式快照</strong></h4>
<p>备份 BMDB 中存储的数据的最有效方法是创建分布式快照。 快照是在集群中所有节点上获取的一致数据。 对于 BSQL，快照是在每个数据库级别创建的。 目前不支持备份单个表。</p>
<p>BMDB创建快照时，并不物理复制数据； 相反，它会创建指向所有相关文件的硬链接。 这些链接驻留在存储数据本身的同一存储卷上，这使得备份和恢复操作几乎是即时的。</p>
<p>请注意，即使可以创建的快照数量没有技术限制，但增加存储的快照数量也会增加数据库所需的空间量。 实际开销取决于工作负载，但您可以通过基于应用程序运行测试来估计它。</p>
<h5 id="_118"><strong>创建快照</strong></h5>
<p>使用分布式快照，您可以备份数据库，然后在出现软件或操作错误时恢复数据库，同时将恢复时间目标 (RTO) 和开销降至最低。</p>
<p>要备份数据库，请使用 create_database_snapshot 命令创建快照，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin -mserver_addresses &lt;ip1:11000,ip2:11000,ip3:11000&gt; create_database_snapshot bsql.&lt;database_name&gt;
</code></pre></div>
<p>返回快照的唯一 ID，如以下示例输出所示：</p>
<div class="highlight"><pre><span></span><code>Started snapshot creation: 0d4b4935-2c95-4523-95ab-9ead1e95e794
</code></pre></div>
<p>然后，您可以使用此 ID 检查快照的状态、删除快照或使用它来恢复数据库。</p>
<p>create_database_snapshot 命令会立即退出，但快照可能需要一些时间才能完成。 在使用快照之前，请通过执行list_snapshots命令验证其状态，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin -mserver_addresses &lt;ip1:11000,ip2:11000,ip3:11000&gt; list_snapshots
</code></pre></div>
<p>列出集群中的所有快照及其状态。 您可以找到新快照的 ID 并确保它已完成，如以下示例输出所示：</p>
<div class="highlight"><pre><span></span><code>Snapshot UUID                           State       Creation Time
0d4b4935-2c95-4523-95ab-9ead1e95e794    COMPLETE    2023-04-20 00:20:38.214201
</code></pre></div>
<h5 id="_119"><strong>删除快照</strong></h5>
<p>快照永远不会过期，并且只要集群存在就会保留。 如果不再需要快照，可以通过执行delete_snapshot命令将其删除，如下：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin -mserver_addresses &lt;ip1:11000,ip2:11000,ip3:11000&gt; delete_snapshot 0d4b4935-2c95-4523-95ab-9ead1e95e794
</code></pre></div>
<h5 id="_120"><strong>恢复快照</strong></h5>
<p>要恢复之前创建的快照之一中备份的数据，请运行restore_snapshot 命令，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin -mserver_addresses &lt;ip1:11000,ip2:11000,ip3:11000&gt; restore_snapshot 0d4b4935-2c95-4523-95ab-9ead1e95e794
</code></pre></div>
<p>此命令将数据库回滚到创建快照时的状态。 恢复就地进行：它更改同一集群中现有数据库的状态。</p>
<p>请注意，所描述的集群内工作流程仅恢复数据更改，而不恢复架构更改。 例如，如果您创建快照、删除表，然后恢复快照，则不会恢复该表。 作为解决方法，您可以将快照存储在集群外部或使用时间点恢复。 此限制将在即将发布的版本中删除。 有关更多信息，请参阅跟踪问题 12977。</p>
<h5 id="_121"><strong>将快照移至外部存储</strong></h5>
<p>尽管在集群中存储快照非常高效，但它会增加存储卷上的空间消耗，从而增加集群的成本。 此外，集群内快照不提供针对文件系统损坏或硬件故障的保护。</p>
<p>为了缓解这些问题，请考虑将备份存储在集群外部、在地理上与集群分开的更便宜的存储中。 这种方法不仅可以降低成本，还可以将数据库恢复到不同的集群（可能位于不同的位置）。</p>
<p>要将快照移动到外部存储，请从所有节点收集所有相关文件，并将它们与在不同集群上恢复所需的附加元数据一起复制，如下所示：</p>
<p>1.通过在 sqlsh 中运行以下查询来获取当前的 BSQL 架构目录版本：</p>
<div class="highlight"><pre><span></span><code>SELECT bm_catalog_version();
</code></pre></div>
<p>输出如下：</p>
<div class="highlight"><pre><span></span><code> bm_catalog_version 
--------------------
                13
</code></pre></div>
<p>2.创建集群内快照。</p>
<p>3.使用bm-dump命令备份BSQL元数据，如下：</p>
<div class="highlight"><pre><span></span><code>./postgres/bin/bm-dump -h &lt;ip&gt; --include-bm-metadata --serializable-deferrable --create --schema-only --dbname &lt;database_name&gt; --file &lt;database_name&gt;_schema.sql
</code></pre></div>
<p>4.使用 sqlsh，验证目录版本是否与创建快照之前的版本相同，如下所示：</p>
<div class="highlight"><pre><span></span><code>SELECT bm_catalog_version();
</code></pre></div>
<p>如果目录版本不相同，则不能保证您获得一致的可恢复快照，您应该重新启动该过程。</p>
<p>5.通过执行export_snapshot命令并提供快照的ID来创建快照元数据文件，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin -mserver_addresses &lt;ip1:11000,ip2:11000,ip3:11000&gt; export_snapshot 0d4b4935-2c95-4523-95ab-9ead1e95e794 &lt;database_name&gt;.snapshot
</code></pre></div>
<p>6.将新创建的BSQL元数据文件（<database_name>_schema.sql）和快照元数据文件（<database_name>.snapshot）复制到外部存储。</p>
<p>7.将Tile快照数据复制到外部存储目录中。 对数据库中所有表的所有Tile执行此操作，如下所示：</p>
<div class="highlight"><pre><span></span><code>cp -r ~/bigmath-data/node-1/disk-1/bm-data/dbserver/data/rocksdb/table-00004000000030008000000000004003/tile-b0de9bc6a4cb46d4aaacf4a03bcaf6be.snapshots/snapshot_id/
</code></pre></div>
<p>以下是文件路径结构：</p>
<div class="highlight"><pre><span></span><code>&lt;bm_data_dir&gt;/node-&lt;node_number&gt;/disk-&lt;disk_number&gt;/bm-data/dbserver/data/rocksdb/table-&lt;table_id&gt;/[tile-&lt;tile_id&gt;.snapshots]/&lt;snapshot_id&gt;
</code></pre></div>
<ul>
<li><bm_data_dir> - 存储 BMDB 数据的目录。 默认值为~/bigmath-data。</li>
<li><node_number> - 当多个节点在同一服务器上运行时使用（用于测试、QA 和开发）。 默认值为 1。</li>
<li><disk_number> - 当使用 --fs_data_dirs 标志在多个磁盘上运行 BMDB 时使用。 默认值为 1。</li>
<li><table_id> - 表的 UUID。 您可以从管理 UI 中的 http://<mserver-ip>:10000/tables URL 获取它。</li>
<li><tile_id> - 每个表包含一个Tile列表。 每个Tile都有一个需要复制的 <tile_id>.snapshots 目录。</li>
<li><snapshot_id> - 每个快照都有一个目录，因为每个服务器上可以有多个已完成的快照。</li>
</ul>
<p>实际上，对于每个服务器，您将使用 --fs_data_dirs 标志，它是一个以逗号分隔的数据路径列表。 建议在不同的磁盘上有不同的路径。</p>
<p>要获取多节点集群的快照，您需要访问每个节点并仅复制该节点上的领导者Tile的文件夹。 由于每个 Tile 副本都有相同数据的副本，因此无需为每个副本保留副本。</p>
<p>如果您不想保留集群内快照，可以安全地将其删除。</p>
<h5 id="_122"><strong>从外部存储恢复快照</strong></h5>
<p>您可以恢复已移至外部存储的快照，如下所示：</p>
<p>1.确保要恢复的数据库不存在，如果存在则删除它：</p>
<div class="highlight"><pre><span></span><code>DROP DATABASE IF EXISTS &lt;database_name&gt;;
</code></pre></div>
<p>2.通过执行以下命令，从外部存储检索 BSQL 元数据文件并使用 sqlsh 工具应用它：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -h 127.0.0.1 --echo-all --file=&lt;database_name&gt;_schema.sql
</code></pre></div>
<p>3.从外部存储获取快照元数据文件并通过运行 import_snapshot 命令应用它，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin -mserver_addresses &lt;ip1:11000,ip2:11000,ip3:11000&gt; import_snapshot &lt;database_name&gt;.snapshot &lt;database_name&gt;
</code></pre></div>
<p>请注意，以下输出包含旧Tile ID 和新Tile ID 之间的映射：</p>
<div class="highlight"><pre><span></span><code>Read snapshot meta file my_database.snapshot
Importing snapshot 0d4b4935-2c95-4523-95ab-9ead1e95e794 (COMPLETE)
Table type: table
Target imported table name: test.t1
Table being imported: test.t1
Table type: table
Target imported table name: test.t2
Table being imported: test.t2
Successfully applied snapshot.
Object           Old ID                                 New ID
Keyspace         00004000000030008000000000000000       00004000000030008000000000000000
Table            00004000000030008000000000004003       00004000000030008000000000004001
Tile 0         b0de9bc6a4cb46d4aaacf4a03bcaf6be       50046f422aa6450ca82538e919581048
Tile 1         27ce76cade8e4894a4f7ffa154b33c3b       111ab9d046d449d995ee9759bf32e028
Snapshot         0d4b4935-2c95-4523-95ab-9ead1e95e794   6beb9c0e-52ea-4f61-89bd-c160ec02c729
</code></pre></div>
<p>4.复制Tile快照。 使用tile映射将tile快照文件从外部存储复制到适当的位置，例如bm-data/dbserver/data/rocksdb/table-<tableid>/tile-<tileid>.snapshots。</p>
<p>根据前面的示例，您将执行以下命令：</p>
<div class="highlight"><pre><span></span><code>scp -r /mnt/d0/bm-data/dbserver/data/rocksdb/table-00004000000030008000000000004003/ \
    tile-b0de9bc6a4cb46d4aaacf4a03bcaf6be.snapshots/0d4b4935-2c95-4523-95ab-9ead1e95e794/* \
    &lt;target_node_ip&gt;:/mnt/d0/bm-data/dbserver/data/rocksdb/table-00004000000030008000000000004001/ \
    tile-50046f422aa6450ca82538e919581048.snapshots/6beb9c0e-52ea-4f61-89bd-c160ec02c729/
</code></pre></div>
<div class="highlight"><pre><span></span><code>scp -r /mnt/d0/bm-data/dbserver/data/rocksdb/table-00004000000030008000000000004003/ \
    tile-27ce76cade8e4894a4f7ffa154b33c3b.snapshots/0d4b4935-2c95-4523-95ab-9ead1e95e794/* \
    &lt;target_node_ip&gt;:/mnt/d0/bm-data/dbserver/data/rocksdb/table-00004000000030008000000000004001/ \
    tile-111ab9d046d449d995ee9759bf32e028.snapshots/6beb9c0e-52ea-4f61-89bd-c160ec02c729/
</code></pre></div>
<p>对于每个Tile，您只需复制所有Tile对等方以及任何已配置的只读副本集群中快照文件夹的内容（而不是整个文件夹）。</p>
<p>5.恢复快照。</p>
<h4 id="point-in-time-recovery"><strong>Point-in-time recovery</strong></h4>
<p>BMDB 中的时间点恢复 (PITR) 可以从用户或软件错误中恢复，同时最大限度地减少恢复点目标 (RPO)、恢复时间目标 (RTO) 以及对集群的总体影响。</p>
<p>PITR 特别适用于以下情况：</p>
<ul>
<li>DDL 错误，例如意外删除表。</li>
<li>DML 错误，例如对其中一个表执行了不正确的更新语句。</li>
</ul>
<p>通常，您知道数据何时损坏并希望恢复到最接近的未损坏状态。 使用 PITR，您可以通过提供要恢复的时间戳来实现这一点。 您可以以高达 1 微秒的精度指定时间，这比通常每小时或每天拍摄的常规快照的精度要高得多。</p>
<h5 id="_123"><strong>怎么运行的</strong></h5>
<p>BMDB 中的 PITR 基于以下各项的组合：</p>
<p>1.闪回
闪回提供了一种在较短的历史保留期内将数据库回退到任何微秒的方法。 出于性能目的，闪回由 BMDB 自动进行内部管理。 历史记录保留期默认为 24 小时，可以缩短以提高数据库性能。</p>
<p>2.定期分布式快照
分布式快照捕获指定保留期内数据库数据文件的轻量级零成本副本，包括所有详细的数据更改。 通过定期创建和保存快照，您可以有效地创建总 PITR 历史记录，它是所有单独快照的组合。</p>
<p>例如，如果 PITR 的总体保留目标是三天，您可以指定以下配置：</p>
<ul>
<li>每天拍摄快照。</li>
<li>将每个快照保留三天。</li>
</ul>
<p>此配置可确保在任何时候都保留最近三天的连续更改历史记录。 当您触发时间点恢复时，BMDB 会选择与您提供的时间戳最接近的快照，然后在该快照中使用闪回。</p>
<p>例如，假设每天晚上 11:00 拍摄快照，当前时间为 4 月 14 日下午 5:00，您希望恢复到 4 月 12 日下午 3:00。 BMDB 执行以下操作：</p>
<ul>
<li>找到 4 月 12 日拍摄的快照（这是恢复时间之后拍摄的最近的快照），并恢复该快照。</li>
<li>
<p>闪回 8 小时以恢复到下午 3:00 时的状态（而不是拍摄快照时的晚上 11:00）。
<img alt="" src="./media/chapter6/44.png" />
<strong>操作注意事项</strong>
启用 PITR 会影响磁盘消耗和性能。 请记住以下几点：</p>
</li>
<li>
<p>保留更多快照或保留更长的时间会增加存储消耗，但不会影响数据库性能。 实际的存储消耗开销取决于工作负载，因此建议通过基于您的应用程序运行测试来估计它。</p>
</li>
<li>指定较低的快照间隔（特别是低于 24 小时）可以允许数据库缩短其内部历史记录保留期。 这可以通过允许更频繁的压缩发生来提高数据库性能，从而减少检索给定记录的 CoreDB 扫描时间。</li>
</ul>
<p><strong>配置详情</strong>
默认情况下，历史保留周期由历史保留间隔标志控制。 这是一个集群范围的全局标志，在启用 PITR 时会影响每个 BSQL 数据库和 BCQL 键空间。</p>
<p>当为特定数据库或键空间启用 PITR 时，每个数据库的保留期是全局历史记录保留期和为数据库或键空间配置 PITR 时指定的快照间隔的最大值。</p>
<p>例如，如果全局历史记录保留期为 8 小时，但 PITR 配置为特定数据库每 4 小时拍摄一次快照，则在时间 t0 拍摄的快照将包含从（时间 t0 - 8h 到时间 t0）的所有数据， 即使这意味着 2 个快照具有相同详细变更数据的重叠和重复副本。</p>
<h5 id="pitr"><strong>启用和禁用 PITR</strong></h5>
<p>BMDB 通过一组快照计划命令公开 PITR 功能。 计划是自动管理 BSQL 数据库或 BCQL 键空间的定期快照的实体，并为同一数据库或键空间启用 PITR。</p>
<p>为数据库或键空间创建快照计划可以有效地为该数据库或键空间启用 PITR。 除非创建计划，否则无法恢复到时间点。</p>
<p><strong>1.创建计划</strong>
要创建计划并启用 PITR，请使用带有以下参数的 create_snapshot_schedule 命令：</p>
<ul>
<li>快照之间的间隔（以分钟为单位）。</li>
<li>总保留时间（以分钟为单位）。</li>
<li>数据库或键空间的名称。</li>
</ul>
<p>假设保留目标是三天，您可以执行以下命令来创建一个计划，每天（每 1,440 分钟）生成一次快照并保留三天（4,320 分钟）：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin -mserver_addresses &lt;ip1:11000,ip2:11000,ip3:11000&gt; create_snapshot_schedule 1440 4320 &lt;database_name&gt;
</code></pre></div>
<p>以下输出是新创建的快照计划的唯一 ID：</p>
<div class="highlight"><pre><span></span><code>{
  &quot;schedule_id&quot;: &quot;6eaaa4fb-397f-41e2-a8fe-a93e0c9f5256&quot;
}
</code></pre></div>
<p>您可以使用此 ID 删除计划或恢复到某个时间点。</p>
<p><strong>2.删除计划</strong>
要删除计划并禁用 PITR，请使用以下 delete_snapshot_schedule 命令，该命令将要删除的计划的 ID 作为参数：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin -mserver_addresses &lt;ip1:11000,ip2:11000,ip3:11000&gt; delete_snapshot_schedule 6eaaa4fb-397f-41e2-a8fe-a93e0c9f5256
</code></pre></div>
<p><strong>3.列出计划</strong>
要查看集群中当前存在的计划列表，请使用以下 list_snapshot_schedules 命令：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin -mserver_addresses &lt;ip1:11000,ip2:11000,ip3:11000&gt; list_snapshot_schedules
</code></pre></div>
<div class="highlight"><pre><span></span><code>{
  &quot;schedules&quot;: [
    {
      &quot;id&quot;: &quot;6eaaa4fb-397f-41e2-a8fe-a93e0c9f5256&quot;,
      &quot;options&quot;: {
        &quot;interval&quot;: &quot;60.000s&quot;,
        &quot;retention&quot;: &quot;600.000s&quot;
      },
      &quot;snapshots&quot;: [
        {
          &quot;id&quot;: &quot;386740da-dc17-4e4a-9a2b-976968b1deb5&quot;,
          &quot;snapshot_time_utc&quot;: &quot;2021-04-28T13:35:32.499002+0000&quot;
        },
        {
          &quot;id&quot;: &quot;aaf562ca-036f-4f96-b193-f0baead372e5&quot;,
          &quot;snapshot_time_utc&quot;: &quot;2021-04-28T13:36:37.501633+0000&quot;,
          &quot;previous_snapshot_time_utc&quot;: &quot;2021-04-28T13:35:32.499002+0000&quot;
        }
      ]
    }
  ]
}
</code></pre></div>
<p>您还可以使用相同的命令通过提供其 ID 作为参数来查看有关特定计划的信息，如下所示：
./bin/bm-admin -mserver_addresses <ip1:11000,ip2:11000,ip3:11000> list_snapshot_schedules 6eaaa4fb-397f-41e2-a8fe-a93e0c9f5256</p>
<h5 id="_124"><strong>恢复到某个时间点</strong></h5>
<p>恢复前停止工作负载
在恢复到某个时间点之前停止所有应用程序工作负载。 与恢复操作同时运行的事务可能会导致数据不一致。
此要求将在即将发布的版本中删除，并在问题 12853 中进行跟踪。</p>
<p>如果数据库或键空间有关联的快照计划，您可以通过使用带有以下参数的restore_snapshot_schedule 命令，使用该计划将数据库或键空间恢复到特定时间点：
1.计划的 ID。
2.目标恢复时间，有以下两个选项：
（1）恢复到绝对时间，提供以下格式之一的特定时间戳：
①以秒、毫秒或微秒为单位的 Unix 时间戳。
②BSQL 时间戳。
③BCQL 时间戳。</p>
<p>例如，以下命令使用 Unix 时间戳恢复到 2022 年 5 月 1 日太平洋夏令时下午 1:00：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -mserver_addresses &lt;ip1:11000,ip2:11000,ip3:11000&gt; \
    restore_snapshot_schedule 6eaaa4fb-397f-41e2-a8fe-a93e0c9f5256 1651435200
</code></pre></div>
<p>以下是使用 BCQL 时间戳的等效命令：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -mserver_addresses &lt;ip1:11000,ip2:11000,ip3:11000&gt; \
    restore_snapshot_schedule 6eaaa4fb-397f-41e2-a8fe-a93e0c9f5256 &quot;2022-05-01 13:00-0700&quot;
</code></pre></div>
<p>（2）通过指定您希望将数据库或键空间回滚多少时间，恢复到相对于当前时间的时间（例如，从现在起恢复到 10 分钟前）。</p>
<p>例如，要恢复到5分钟前，请运行以下命令：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -mserver_addresses &lt;ip1:11000,ip2:11000,ip3:11000&gt; \
    restore_snapshot_schedule 6eaaa4fb-397f-41e2-a8fe-a93e0c9f5256 minus 5m
</code></pre></div>
<p>或者，要恢复到 1 小时前，请使用以下命令：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -mserver_addresses &lt;ip1:11000,ip2:11000,ip3:11000&gt; \
    restore_snapshot_schedule 6eaaa4fb-397f-41e2-a8fe-a93e0c9f5256 minus 1h
</code></pre></div>
<p>有关相对时间格式的详细信息，请参阅restore_snapshot_schedule 参考。</p>
<p>BSQL索引回填
BMDB 支持索引回填，即异步填充新索引。 该过程在后台运行，可能需要大量时间，具体取决于数据的大小。 如果您在创建索引后不久恢复到某个时间点，则可能会遇到索引处于回填过程中间的状态。</p>
<p>BMDB 在读取操作期间忽略这些部分回填的索引。 为了确保正确使用索引，您需要删除并再次创建它们以重新启动回填过程。 运行以下查询以获取需要重新创建的索引列表：</p>
<div class="highlight"><pre><span></span><code>SELECT pg_class.relname
    FROM pg_index
    JOIN pg_class
    ON pg_index.indexrelid = pg_class.oid
    WHERE NOT indisvalid;
</code></pre></div>
<p>这仅影响 BSQL 数据库。 对于BCQL，BMDB在恢复后自动重新启动索引回填。</p>
<p>此限制将在即将发布的版本中删除，并在问题 12672 中进行跟踪。</p>
<h5 id="_125"><strong>局限性</strong></h5>
<p>PITR 功能有一些限制，主要与与其他 BMDB 功能的交互有关。 大多数限制将在即将发布的版本中得到解决； 有关详细信息，请参阅每个限制的相应跟踪问题。</p>
<p><strong>1.CDC</strong>
目前不支持同时使用 PITR 和 CDC。</p>
<p>追踪问题：12773</p>
<p><strong>2.xDCR复制</strong>
xDCR 不会复制任何与 PITR 相关的命令。 如果您有两个集群之间存在复制，请在两端独立启用 PITR。 您可以使用以下推荐过程执行恢复：
（1）停止应用程序工作负载并确保没有活动事务。
（2）等待复制完成。
（3）从两个集群中删除 xDCR 复制。
（4）将两个集群恢复到完全相同的时间。
（5）重新建立 xDCR 复制。
（6）恢复应用程序工作负载。</p>
<p><strong>3.全局对象</strong>
PITR 不支持全局对象，例如表空间、角色和权限，因为它们当前未由分布式快照备份。 如果您更改或删除全局对象，然后尝试恢复到更改之前的时间点，则该对象将无法恢复。
BSQL 表空间的跟踪问题：10257
BSQL 角色和权限的跟踪问题：10349
BCQL 的跟踪问题：8453</p>
<p>表空间的特殊情况
表空间对于地理分区部署至关重要。 尝试恢复依赖于已删除表空间的数据库将导致意外行为，因此如果集群中的任何数据库上存在计划，则当前不允许使用 DROP TABLESPACE 命令。</p>
<p><strong>4.BSQL系统目录升级</strong>
您无法使用 PITR 恢复到最近一次 BSQL 系统目录升级之前的状态。 尝试这样做会产生错误。 在这种情况下，您仍然可以使用分布式快照进行恢复。
追踪问题：13158
此限制仅适用于 BSQL 数据库。 BCQL 不受影响。</p>
<p><strong>5.其他限制</strong>
对于具有快照计划的数据库，不允许使用 TRUNCATE 命令。 跟踪问题：7129。
PITR 仅适用于集群内分布式快照。 未来正在考虑对集群外备份的 PITR 支持。 跟踪问题：8847。
快照计划一旦创建就无法修改。 如果需要更改间隔或保留期，请删除快照并使用新参数重新创建它。 跟踪问题：8417。</p>
<h3 id="_126">时间点回复</h3>
<h4 id="bsql_1"><strong>BSQL</strong></h4>
<p>时间点恢复 (PITR) 允许您从特定时间点恢复集群数据和某些类型元数据的状态。 这可以是相对的，例如“三小时前”，也可以是绝对时间戳。</p>
<p>有关更多信息，请参阅时间点恢复。 有关 bm-admin 命令的详细信息，请参阅 bm-admin 文档的备份和快照命令部分。</p>
<p>以下示例展示了如何通过创建数据库并填充数据库、创建快照计划以及从计划上的快照进行恢复来使用 PITR 功能。</p>
<p>请注意，这些示例是故意简化的。 在许多情况下，您可以删除索引或表来恢复。 将这些示例视为撤消较大架构更改（例如已执行多个操作的数据库迁移）的一部分。</p>
<h5 id="universe"><strong>设置universe</strong></h5>
<p>这些示例在本地多节点 BMDB Universe 上运行。 要创建 Universe，请参阅设置 BMDB Universe</p>
<h5 id="_127"><strong>撤消数据更改</strong></h5>
<p>撤消数据更改的过程涉及创建表并拍摄快照，然后从绝对时间或相对时间执行恢复。</p>
<p>在尝试恢复之前，您需要确认主题键空间或表没有正在进行的恢复； 如果发出多个恢复命令，数据可能会进入不一致状态。 详细信息请参见恢复到某个时间点。</p>
<p>1.创建表
（1）启动 BSQL shell 并连接到本地实例：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -h 127.0.0.1
</code></pre></div>
<p>（2）创建一个表并填充一些示例数据：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE employees (
  employee_no integer PRIMARY KEY,
  name text,
  department text,
  salary integer
);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees (employee_no, name, department, salary)
  VALUES
  (1221, &#39;John Smith&#39;, &#39;Marketing&#39;, 50000),
  (1222, &#39;Bette Davis&#39;, &#39;Sales&#39;, 55000),
  (1223, &#39;Lucille Ball&#39;, &#39;Operations&#39;, 70000),
  (1224, &#39;John Zimmerman&#39;, &#39;Sales&#39;, 60000);
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> employee_no |      name      | department | salary
-------------+----------------+------------+--------
        1223 | Lucille Ball   | Operations |  70000
        1224 | John Zimmerman | Sales      |  60000
        1221 | John Smith     | Marketing  |  50000
        1222 | Bette Davis    | Sales      |  55000
(4 rows)
</code></pre></div>
<p><strong>2.创建快照</strong>
创建快照如下：
（1）在终端提示符处，通过 shell 提示符为数据库创建快照计划。 在以下示例中，计划为每分钟一个快照，每个快照保留十分钟：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    create_snapshot_schedule 1 10 bsql.bigmath
</code></pre></div>
<div class="highlight"><pre><span></span><code>{
    &quot;schedule_id&quot;: &quot;0e4ceb83-fe3d-43da-83c3-013a8ef592ca&quot;
}
</code></pre></div>
<p>（2）验证快照是否已发生：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    list_snapshot_schedules
</code></pre></div>
<div class="highlight"><pre><span></span><code>{
    &quot;schedules&quot;: [
        {
            &quot;id&quot;: &quot;0e4ceb83-fe3d-43da-83c3-013a8ef592ca&quot;,
            &quot;options&quot;: {
                &quot;interval&quot;: &quot;60.000s&quot;,
                &quot;retention&quot;: &quot;600.000s&quot;
            },
            &quot;snapshots&quot;: [
                {
                    &quot;id&quot;: &quot;8d588cb7-13f2-4bda-b584-e9be47a144c5&quot;,
                    &quot;snapshot_time_utc&quot;: &quot;2021-05-07T20:16:08.492330+0000&quot;
                }
            ]
        }
    ]
}
</code></pre></div>
<p><strong>3.从绝对时间恢复</strong>
（1）从命令提示符处获取时间戳：</p>
<div class="highlight"><pre><span></span><code>python -c &#39;import datetime; print(datetime.datetime.now().strftime(&quot;%s%f&quot;))&#39;
</code></pre></div>
<div class="highlight"><pre><span></span><code>1620418817729963
</code></pre></div>
<p>（2）将员工 9999 的行添加到表中：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO employees (employee_no, name, department, salary)
  VALUES
  (9999, &#39;Wrong Name&#39;, &#39;Marketing&#39;, 10000);
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> employee_no |      name      | department | salary
-------------+----------------+------------+--------
        1223 | Lucille Ball   | Operations |  70000
        9999 | Wrong Name     | Marketing  |  10000
        1224 | John Zimmerman | Sales      |  60000
        1221 | John Smith     | Marketing  |  50000
        1222 | Bette Davis    | Sales      |  55000
(5 rows)
</code></pre></div>
<p>（3）在终端提示符下，将快照计划恢复到添加数据之前获取的时间戳：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    restore_snapshot_schedule 0e4ceb83-fe3d-43da-83c3-013a8ef592ca 1620418817729963
</code></pre></div>
<div class="highlight"><pre><span></span><code>{
    &quot;snapshot_id&quot;: &quot;2287921b-1cf9-4bbc-ad38-e309f86f72e9&quot;,
    &quot;restoration_id&quot;: &quot;1c5ef7c3-a33a-46b5-a64e-3fa0c72709eb&quot;
}
</code></pre></div>
<p>（4）接下来，验证恢复是否处于 RESTORED 状态（您还将在列表中看到更多快照）：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    list_snapshots
</code></pre></div>
<div class="highlight"><pre><span></span><code>Snapshot UUID                           State       Creation Time
8d588cb7-13f2-4bda-b584-e9be47a144c5    COMPLETE    2023-04-20 00:24:58.246932
1f4db0e2-0706-45db-b157-e577702a648a    COMPLETE    2023-04-20 00:26:03.257519
b91c734b-5c57-4276-851e-f982bee73322    COMPLETE    2023-04-20 00:27:08.272905
04fc6f05-8775-4b43-afbd-7a11266da110    COMPLETE    2023-04-20 00:28:13.287202
e7bc7b48-351b-4713-b46b-dd3c9c028a79    COMPLETE    2023-04-20 00:29:18.294031
2287921b-1cf9-4bbc-ad38-e309f86f72e9    COMPLETE    2023-04-20 00:30:23.306355
97aa2968-6b56-40ce-b2c5-87d2e54e9786    COMPLETE    2023-04-20 00:31:28.319685
Restoration UUID                        State
1c5ef7c3-a33a-46b5-a64e-3fa0c72709eb    RESTORED
</code></pre></div>
<p>（5）在 BSQL shell 中，验证数据是否已恢复，没有员工 9999 的行：</p>
<div class="highlight"><pre><span></span><code>bigmath=# select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> employee_no |      name      | department | salary
-------------+----------------+------------+--------
        1223 | Lucille Ball   | Operations |  70000
        1224 | John Zimmerman | Sales      |  60000
        1221 | John Smith     | Marketing  |  50000
        1222 | Bette Davis    | Sales      |  55000
(4 rows)
</code></pre></div>
<p><strong>4.从相对时间恢复</strong>
除了恢复到特定时间戳之外，您还可以从相对时间恢复，例如“十分钟前”。</p>
<p>指定相对时间时，可以指定天、小时、分钟和秒中的任意一个或全部。 例如：</p>
<ul>
<li>“5m”恢复为五分钟前</li>
<li>“1h”恢复一小时前</li>
<li>“3d”恢复三天前</li>
<li>“1h 5m”恢复一小时五分钟前</li>
</ul>
<p>相对时间可以采用以下任何格式（再次注意，您可以指定任何或所有天、小时、分钟和秒）：</p>
<ul>
<li>ISO 8601：3d 4h 5m 6s</li>
<li>缩写 PostgreSQL：3 d 4 hrs 5 mins 6 secs</li>
<li>传统 PostgreSQL：3 days 4 hours 5 minutes 6 seconds</li>
<li>SQL 标准：D H:M:S</li>
</ul>
<p>有关更多详细信息，请参阅 bm-admin Restore-snapshot-schedule 命令。</p>
<h5 id="_128"><strong>撤消元数据更改</strong></h5>
<p>除了数据更改之外，您还可以使用 PITR 从元数据更改中恢复，例如创建、更改和删除表和索引。</p>
<p>在开始之前，如果本地 Universe 当前正在运行，请首先销毁它，然后创建本地多节点 BMDB Universe，如设置 BMDB Universe 中所述。</p>
<p><strong>1.撤消表创建</strong>
（1）在终端提示符处，为数据库创建快照计划。 在本例中，计划是在默认的 bigmath 数据库上，每分钟一个快照，每个快照保留十分钟：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    create_snapshot_schedule 1 10 bsql.bigmath
</code></pre></div>
<div class="highlight"><pre><span></span><code>{
  &quot;schedule_id&quot;: &quot;1fb2d85a-3608-4cb1-af63-3e4062300dc1&quot;
}
</code></pre></div>
<p>（2）验证快照是否已发生：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    list_snapshot_schedules
</code></pre></div>
<div class="highlight"><pre><span></span><code>{
    &quot;schedules&quot;: [
        {
            &quot;id&quot;: &quot;1fb2d85a-3608-4cb1-af63-3e4062300dc1&quot;,
            &quot;options&quot;: {
                &quot;filter&quot;: &quot;bsql.bigmath&quot;,
                &quot;interval&quot;: &quot;1 min&quot;,
                &quot;retention&quot;: &quot;10 min&quot;
            },
            &quot;snapshots&quot;: [
                {
                    &quot;id&quot;: &quot;34b44c96-c340-4648-a764-7965fdcbd9f1&quot;,
                    &quot;snapshot_time&quot;: &quot;2023-04-20 00:20:38.214201&quot;
                }
            ]
        }
    ]
}
</code></pre></div>
<p>（3）要从绝对时间恢复，请从命令提示符获取时间戳。 您将创建一个表，然后恢复到此时以撤消表创建：</p>
<div class="highlight"><pre><span></span><code>python -c &#39;import datetime; print(datetime.datetime.now().strftime(&quot;%s%f&quot;))&#39;
</code></pre></div>
<div class="highlight"><pre><span></span><code>1681964544554620
</code></pre></div>
<p>（4）启动 BSQL shell 并创建表，如创建表中所述。
（5）在终端提示符下，将快照计划恢复到创建表之前获得的时间戳：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    restore_snapshot_schedule 1fb2d85a-3608-4cb1-af63-3e4062300dc1 1681964544554620
</code></pre></div>
<div class="highlight"><pre><span></span><code>{
    &quot;snapshot_id&quot;: &quot;0f1582ea-c10d-4ad9-9cbf-e2313156002c&quot;,
    &quot;restoration_id&quot;: &quot;a61046a2-8b77-4d6e-87e1-1dc44b5ebc69&quot;
}
</code></pre></div>
<p>（6）验证恢复是否处于 RESTORED 状态（您还将在列表中看到更多快照）：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    list_snapshots
</code></pre></div>
<div class="highlight"><pre><span></span><code>Snapshot UUID                           State       Creation Time
34b44c96-c340-4648-a764-7965fdcbd9f1    COMPLETE    2023-04-20 00:20:38.214201
bacd0b53-6a51-4628-b898-e35116860735    COMPLETE    2023-04-20 00:21:43.221612
0f1582ea-c10d-4ad9-9cbf-e2313156002c    COMPLETE    2023-04-20 00:22:48.231456
617f9df8-3087-4b04-9187-399b52e738ee    COMPLETE    2023-04-20 00:23:53.239147
489e6903-2848-478b-30000-577084e49adf    COMPLETE    2023-04-20 00:24:58.246932
Restoration UUID                        State
a61046a2-8b77-4d6e-87e1-1dc44b5ebc69    RESTORED
</code></pre></div>
<p>（7）验证该表不再存在：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -d bigmath;
</code></pre></div>
<div class="highlight"><pre><span></span><code>\d employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code>Did not find any relation named &quot;employees&quot;.
</code></pre></div>
<p><strong>2.撤消表删除</strong>
（1）启动 BSQL shell 并创建表，如创建表中所述。</p>
<p>（2）验证自表创建以来是否已发生快照：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    list_snapshot_schedules
</code></pre></div>
<div class="highlight"><pre><span></span><code>{
    &quot;schedules&quot;: [
        {
            &quot;id&quot;: &quot;1fb2d85a-3608-4cb1-af63-3e4062300dc1&quot;,
            &quot;options&quot;: {
                &quot;filter&quot;: &quot;bsql.bigmath&quot;,
                &quot;interval&quot;: &quot;1 min&quot;,
                &quot;retention&quot;: &quot;10 min&quot;
            },
            &quot;snapshots&quot;: [
                {
                    &quot;id&quot;: &quot;34b44c96-c340-4648-a764-7965fdcbd9f1&quot;,
                    &quot;snapshot_time&quot;: &quot;2023-04-20 00:20:38.214201&quot;
                },
                {
                    &quot;id&quot;: &quot;bacd0b53-6a51-4628-b898-e35116860735&quot;,
                    &quot;snapshot_time&quot;: &quot;2023-04-20 00:21:43.221612&quot;,
                    &quot;previous_snapshot_time&quot;: &quot;2023-04-20 00:20:38.214201&quot;
                },
                [...]
                {
                    &quot;id&quot;: &quot;c98c890a-97ae-49f0-9c73-8d27c430874f&quot;,
                    &quot;snapshot_time&quot;: &quot;2023-04-20 00:28:13.287202&quot;,
                    &quot;previous_snapshot_time&quot;: &quot;2023-04-20 00:27:08.272905&quot;
                }
            ]
        }
    ]
}
</code></pre></div>
<p>（3）要从绝对时间恢复，请从命令提示符获取时间戳。 您将删除该表，然后恢复到此时以撤消删除：</p>
<div class="highlight"><pre><span></span><code>python -c &#39;import datetime; print(datetime.datetime.now().strftime(&quot;%s%f&quot;))&#39;
</code></pre></div>
<div class="highlight"><pre><span></span><code>1681965106732671
</code></pre></div>
<p>（4）在 sqlsh 中，删除此表：</p>
<div class="highlight"><pre><span></span><code>drop table employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code>DROP TABLE
</code></pre></div>
<p>（5）在终端提示符下，将快照计划恢复到删除表之前获得的时间戳：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    restore_snapshot_schedule 1fb2d85a-3608-4cb1-af63-3e4062300dc1 1681965106732671
</code></pre></div>
<div class="highlight"><pre><span></span><code>{
    &quot;snapshot_id&quot;: &quot;fc95304a-b713-4468-a128-d5155c85333a&quot;,
    &quot;restoration_id&quot;: &quot;2bc005ca-c842-4c7c-9cc7-34e1f75ca467&quot;
}
</code></pre></div>
<p>（6）验证恢复是否处于 RESTORED 状态（您还将在列表中看到更多快照）：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    list_snapshots
</code></pre></div>
<div class="highlight"><pre><span></span><code>Snapshot UUID                           State       Creation Time
489e6903-2848-478b-30000-577084e49adf    COMPLETE    2023-04-20 00:24:58.246932
e4c12e39-6b15-49f2-97d1-86f777650d6b    COMPLETE    2023-04-20 00:26:03.257519
3d1176d0-f56d-44f3-bb29-2fcb9b08186b    COMPLETE    2023-04-20 00:27:08.272905
c98c890a-97ae-49f0-9c73-8d27c430874f    COMPLETE    2023-04-20 00:28:13.287202
17e9c8f7-2965-48d0-8459-c9dc90b8ed93    COMPLETE    2023-04-20 00:29:18.294031
e1900004-9a89-4c3a-b60b-4b570058c4da    COMPLETE    2023-04-20 00:30:23.306355
15ac0ae6-8ac2-4248-af69-756bb0abf534    COMPLETE    2023-04-20 00:31:28.319685
fc95304a-b713-4468-a128-d5155c85333a    COMPLETE    2023-04-20 00:32:33.332482
4a42a175-8065-4def-969a-b33ddc1bbdba    COMPLETE    2023-04-20 00:33:38.345533
Restoration UUID                        State
a61046a2-8b77-4d6e-87e1-1dc44b5ebc69    RESTORED
2bc005ca-c842-4c7c-9cc7-34e1f75ca467    RESTORED
</code></pre></div>
<p>（7）验证表中的数据是否存在：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -d bigmath;
</code></pre></div>
<div class="highlight"><pre><span></span><code>select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> employee_no |      name      | department | salary
-------------+----------------+------------+--------
        1223 | Lucille Ball   | Operations |  70000
        1224 | John Zimmerman | Sales      |  60000
        1221 | John Smith     | Marketing  |  50000
        1222 | Bette Davis    | Sales      |  55000
(4 rows)
</code></pre></div>
<p><strong>3.撤消表更改</strong>
<strong>撤消列添加</strong>
（1）验证自表恢复以来是否已发生快照：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    list_snapshot_schedules
</code></pre></div>
<div class="highlight"><pre><span></span><code>{
    &quot;schedules&quot;: [
        {
            &quot;id&quot;: &quot;1fb2d85a-3608-4cb1-af63-3e4062300dc1&quot;,
            &quot;options&quot;: {
                &quot;filter&quot;: &quot;bsql.bigmath&quot;,
                &quot;interval&quot;: &quot;1 min&quot;,
                &quot;retention&quot;: &quot;10 min&quot;
            },
            &quot;snapshots&quot;: [
                {
                    &quot;id&quot;: &quot;e4c12e39-6b15-49f2-97d1-86f777650d6b&quot;,
                    &quot;snapshot_time&quot;: &quot;2023-04-20 00:26:03.257519&quot;,
                    &quot;previous_snapshot_time&quot;: &quot;2023-04-20 00:24:58.246932&quot;
                },
                {
                    &quot;id&quot;: &quot;3d1176d0-f56d-44f3-bb29-2fcb9b08186b&quot;,
                    &quot;snapshot_time&quot;: &quot;2023-04-20 00:27:08.272905&quot;,
                    &quot;previous_snapshot_time&quot;: &quot;2023-04-20 00:26:03.257519&quot;
                },
                [...]
                {
                    &quot;id&quot;: &quot;d30fb638-6315-466a-a080-a6050e0dbb04&quot;,
                    &quot;snapshot_time&quot;: &quot;2023-04-20 00:34:43.358691&quot;,
                    &quot;previous_snapshot_time&quot;: &quot;2023-04-20 00:33:38.345533&quot;
                }
            ]
        }
    ]
}
</code></pre></div>
<p>（2）要从绝对时间恢复，请从命令提示符获取时间戳。 您将向表中添加一列，然后恢复到此时以撤消列添加：</p>
<div class="highlight"><pre><span></span><code>python -c &#39;import datetime; print(datetime.datetime.now().strftime(&quot;%s%f&quot;))&#39;
</code></pre></div>
<div class="highlight"><pre><span></span><code>1681965472490517
</code></pre></div>
<p>（3）使用相同的数据库，通过添加列来更改表：</p>
<div class="highlight"><pre><span></span><code>alter table employees add column v2 int;
select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> employee_no |      name      | department | salary | v2
-------------+----------------+------------+--------+----
        1223 | Lucille Ball   | Operations |  70000 |
        1224 | John Zimmerman | Sales      |  60000 |
        1221 | John Smith     | Marketing  |  50000 |
        1222 | Bette Davis    | Sales      |  55000 |
(4 rows)
</code></pre></div>
<p>（4）在终端提示符下，将快照计划恢复到添加列之前获得的时间戳：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    restore_snapshot_schedule 1fb2d85a-3608-4cb1-af63-3e4062300dc1 1681965472490517
</code></pre></div>
<div class="highlight"><pre><span></span><code>{
    &quot;snapshot_id&quot;: &quot;b3c12c51-e7a3-41a5-bf0d-77cde8520527&quot;,
    &quot;restoration_id&quot;: &quot;470a8e0b-9fe4-418f-a13a-773bdedca013&quot;
}
</code></pre></div>
<p>（5）验证恢复是否处于 RESTORED 状态（您还将在列表中看到更多快照）：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    list_snapshots
</code></pre></div>
<div class="highlight"><pre><span></span><code>Snapshot UUID                           State       Creation Time
e1900004-9a89-4c3a-b60b-4b570058c4da    COMPLETE    2023-04-20 00:30:23.306355
15ac0ae6-8ac2-4248-af69-756bb0abf534    COMPLETE    2023-04-20 00:31:28.319685
fc95304a-b713-4468-a128-d5155c85333a    COMPLETE    2023-04-20 00:32:33.332482
4a42a175-8065-4def-969a-b33ddc1bbdba    COMPLETE    2023-04-20 00:33:38.345533
d30fb638-6315-466a-a080-a6050e0dbb04    COMPLETE    2023-04-20 00:34:43.358691
d228210b-cd87-4a74-bff6-42108f73456f    COMPLETE    2023-04-20 00:35:48.372783
390e4fec-8aa6-466d-827d-6bee435af5aa    COMPLETE    2023-04-20 00:36:53.394833
b3c12c51-e7a3-41a5-bf0d-77cde8520527    COMPLETE    2023-04-20 00:37:58.408458
d99317fe-6d20-4c7f-b469-ffb16409fbcf    COMPLETE    2023-04-20 00:39:03.419109
Restoration UUID                        State
a61046a2-8b77-4d6e-87e1-1dc44b5ebc69    RESTORED
2bc005ca-c842-4c7c-9cc7-34e1f75ca467    RESTORED
470a8e0b-9fe4-418f-a13a-773bdedca013    RESTORED
</code></pre></div>
<p>（6）检查 v2 列已经消失：</p>
<div class="highlight"><pre><span></span><code>select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> employee_no | name           | department | salary
-------------+----------------+------------+--------
        1223 |   Lucille Ball | Operations |  70000
        1224 | John Zimmerman |      Sales |  60000
        1221 |     John Smith |  Marketing |  50000
        1222 |    Bette Davis |      Sales |  55000

(4 rows)
</code></pre></div>
<p><strong>撤消列删除</strong>
（1）要从绝对时间恢复，请从命令提示符获取时间戳。 您将从表中删除一列，然后恢复到此时以恢复该列：</p>
<div class="highlight"><pre><span></span><code>python -c &#39;import datetime; print(datetime.datetime.now().strftime(&quot;%s%f&quot;))&#39;
</code></pre></div>
<div class="highlight"><pre><span></span><code>1681965684502460
</code></pre></div>
<p>（2）使用相同的数据库，通过删除列来更改表：</p>
<div class="highlight"><pre><span></span><code>alter table employees drop salary;
select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> employee_no | name           | department
-------------+----------------+-----------
        1223 |   Lucille Ball | Operations
        1224 | John Zimmerman |      Sales
        1221 |     John Smith |  Marketing
        1222 |    Bette Davis |      Sales

(4 rows)
</code></pre></div>
<p>（3）在终端提示符下，将快照计划恢复到删除列之前获得的时间戳。</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    restore_snapshot_schedule 1fb2d85a-3608-4cb1-af63-3e4062300dc1 1681965684502460
</code></pre></div>
<div class="highlight"><pre><span></span><code>{
    &quot;snapshot_id&quot;: &quot;49311e65-cc5b-4d41-9f87-e84d630016a9&quot;,
    &quot;restoration_id&quot;: &quot;fe08826b-9b1d-4621-99ca-505d1d58e184&quot;
}
</code></pre></div>
<p>（4）验证恢复是否处于 RESTORED 状态（您还将在列表中看到更多快照）：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    list_snapshots
</code></pre></div>
<div class="highlight"><pre><span></span><code>Snapshot UUID                           State       Creation Time
4a42a175-8065-4def-969a-b33ddc1bbdba    COMPLETE    2023-04-20 00:33:38.345533
d30fb638-6315-466a-a080-a6050e0dbb04    COMPLETE    2023-04-20 00:34:43.358691
d228210b-cd87-4a74-bff6-42108f73456f    COMPLETE    2023-04-20 00:35:48.372783
390e4fec-8aa6-466d-827d-6bee435af5aa    COMPLETE    2023-04-20 00:36:53.394833
b3c12c51-e7a3-41a5-bf0d-77cde8520527    COMPLETE    2023-04-20 00:37:58.408458
d99317fe-6d20-4c7f-b469-ffb16409fbcf    COMPLETE    2023-04-20 00:39:03.419109
3f6651a5-00b2-4a9d-99e2-63b8b8e75ccf    COMPLETE    2023-04-20 00:40:08.432723
7aa1054a-1c96-4d33-bd37-02cdefaa5cad    COMPLETE    2023-04-20 00:41:13.445282
49311e65-cc5b-4d41-9f87-e84d630016a9    COMPLETE    2023-04-20 00:42:18.454674
Restoration UUID                        State
a61046a2-8b77-4d6e-87e1-1dc44b5ebc69    RESTORED
2bc005ca-c842-4c7c-9cc7-34e1f75ca467    RESTORED
470a8e0b-9fe4-418f-a13a-773bdedca013    RESTORED
fe08826b-9b1d-4621-99ca-505d1d58e184    RESTORED
</code></pre></div>
<p>（5）验证工资列是否已返回：</p>
<div class="highlight"><pre><span></span><code>select * from employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> employee_no | name           | department | salary
-------------+----------------+------------+--------
        1223 |   Lucille Ball | Operations |  70000
        1224 | John Zimmerman |      Sales |  60000
        1221 |     John Smith |  Marketing |  50000
        1222 |    Bette Davis |      Sales |  55000

(4 rows)
</code></pre></div>
<p><strong>撤消索引创建</strong>
（1）要从绝对时间恢复，请从命令提示符获取时间戳。 您将在表上创建索引，然后恢复到此时以撤消索引创建：</p>
<div class="highlight"><pre><span></span><code>python -c &#39;import datetime; print(datetime.datetime.now().strftime(&quot;%s%f&quot;))&#39;
</code></pre></div>
<div class="highlight"><pre><span></span><code>1681965868912921
</code></pre></div>
<p>（2）在表上创建索引：</p>
<div class="highlight"><pre><span></span><code>create index t1_index on employees (employee_no);
\d employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code>              Table &quot;public.employees&quot;
   Column    |  Type   | Collation | Nullable | Default
-------------+---------+-----------+----------+---------
 employee_no | integer |           | not null |
 name        | text    |           |          |
 department  | text    |           |          |
 salary      | integer |           |          |
 Indexes:
     &quot;employees_pkey&quot; PRIMARY KEY, lsm (employee_no HASH)
     &quot;t1_index&quot; lsm (employee_no HASH)
</code></pre></div>
<p>（3）在终端提示符下，将快照计划恢复到创建索引之前获得的时间戳：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    restore_snapshot_schedule 1fb2d85a-3608-4cb1-af63-3e4062300dc1 1681965868912921
</code></pre></div>
<div class="highlight"><pre><span></span><code>{
    &quot;snapshot_id&quot;: &quot;6a014fd7-5aad-4da0-883b-0c59a9261ed6&quot;,
    &quot;restoration_id&quot;: &quot;6698a1c4-58f4-48cb-8ec7-fa7b31ecca72&quot;
}
</code></pre></div>
<p>（4）验证恢复是否处于 RESTORED 状态（您还将在列表中看到更多快照）：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    list_snapshots
</code></pre></div>
<div class="highlight"><pre><span></span><code>Snapshot UUID                           State       Creation Time
390e4fec-8aa6-466d-827d-6bee435af5aa    COMPLETE    2023-04-20 00:36:53.394833
b3c12c51-e7a3-41a5-bf0d-77cde8520527    COMPLETE    2023-04-20 00:37:58.408458
d99317fe-6d20-4c7f-b469-ffb16409fbcf    COMPLETE    2023-04-20 00:39:03.419109
3f6651a5-00b2-4a9d-99e2-63b8b8e75ccf    COMPLETE    2023-04-20 00:40:08.432723
7aa1054a-1c96-4d33-bd37-02cdefaa5cad    COMPLETE    2023-04-20 00:41:13.445282
49311e65-cc5b-4d41-9f87-e84d630016a9    COMPLETE    2023-04-20 00:42:18.454674
c6d37ea5-002e-4dff-b691-94d458f4b1f9    COMPLETE    2023-04-20 00:43:23.469233
98879e83-d507-496c-aa69-368fc2de8cf8    COMPLETE    2023-04-20 00:44:28.476244
6a014fd7-5aad-4da0-883b-0c59a9261ed6    COMPLETE    2023-04-20 00:45:33.467234
Restoration UUID                        State
a61046a2-8b77-4d6e-87e1-1dc44b5ebc69    RESTORED
2bc005ca-c842-4c7c-9cc7-34e1f75ca467    RESTORED
470a8e0b-9fe4-418f-a13a-773bdedca013    RESTORED
fe08826b-9b1d-4621-99ca-505d1d58e184    RESTORED
6698a1c4-58f4-48cb-8ec7-fa7b31ecca72    RESTORED
</code></pre></div>
<p>（5）验证索引已消失：</p>
<div class="highlight"><pre><span></span><code>\d employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code>            Table &quot;public.employees&quot;
   Column    |  Type   | Collation | Nullable | Default
-------------+---------+-----------+----------+---------
 employee_no | integer |           | not null |
 name        | text    |           |          |
 department  | text    |           |          |
 salary      | integer |           |          |
 Indexes:
     &quot;employees_pkey&quot; PRIMARY KEY, lsm (employee_no HASH)
</code></pre></div>
<p>类似地，您可以撤消索引删除并更改表重命名列。</p>
<h2 id="_129"><strong>监控指标</strong></h2>
<h3 id="_130"><strong>指标</strong></h3>
<p>使用关键指标监控集群
BMDB 提供了近两千个指标，用于监控、性能调整以及系统、表和Tile问题的故障排除。 使用指标来监控和管理集群、解决性能问题并识别瓶颈。</p>
<p>BMDB 通过各种端点以 JSON、HTML 和 Prometheus 格式导出指标。 有关更多信息，请参阅指标端点。</p>
<p>本节介绍最常用的指标以及如何使用它们。</p>
<p>有关查询调优的信息，请参阅查询调优。</p>
<p><strong>1.常用指标</strong>
要了解某些指标类别以及如何将它们用于您的用例，请参阅以下内容。 请注意，这些部分仅涵盖最常用的指标，并不是 BMDB 导出的所有指标的详尽列表。</p>
<table>
<thead>
<tr>
<th>主题</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>吞吐量和延迟</td>
<td>BSQL 查询处理和数据库 IOPS。</td>
</tr>
<tr>
<td>连接</td>
<td>每个节点到 BSQL 后端的累计连接数</td>
</tr>
<tr>
<td>缓存和存储子系统</td>
<td>存储层 IOPS、块缓存、布隆过滤器、SST 文件、压缩、memtable 和预写日志记录指标。</td>
</tr>
<tr>
<td>Raft 和分布式系统</td>
<td>Raft 操作、吞吐量和延迟、时钟偏差和远程引导。</td>
</tr>
<tr>
<td>MServer</td>
<td>表和Tile管理。</td>
</tr>
<tr>
<td>复制</td>
<td>Replication lag</td>
</tr>
</tbody>
</table>
<p><strong>2.指标命名约定</strong>
指标使用以下命名约定：</p>
<div class="highlight"><pre><span></span><code>&lt;metric_category&gt;_&lt;server_type&gt;_&lt;service_type&gt;_&lt;service_method&gt;
</code></pre></div>
<p>请注意，虽然通常采用这种命名约定，但 BMDB 会导出不符合语法的其他服务器指标。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>metric_category</td>
<td>可选项。 可以是以下之一：handler_latency：逻辑架构块看到的延迟。rpcs_in_queue：服务队列中的 RPC 数量。service_request_bytes：服务在请求中发送到其他服务的字节数。 在非常有限的情况下是有益的service_response_bytes ：服务在请求中从其他服务接收的字节数。在非常有限的情况下是有益的proxy_request_bytes：代理在向服务发出的请求中发送的请求字节数。客户端需要本地 Tile 服务器无法提供的任何内容都将代理到正确的服务，该服务可以是主服务器（通过主领导者）或另一个 Tile 服务器，对追随者进行更改，并等待达成多数别名共识。 在非常有限的情况下是有益的。proxy_response_bytes：代理从服务接收的响应字节数。客户端需要本地 Tile 服务器无法提供的任何内容都将代理到正确的服务，该服务可以是主服务器（通过主领导者）或另一个 Tile 服务器，对追随者进行更改，并等待达成多数别名共识。 在非常有限的情况下是有益的。</td>
</tr>
<tr>
<td>server_type</td>
<td>描述发起指标的服务器类型，可以是以下之一：bm_dbserverbm_mserverbm_bcqlserver：BCQLbm_bsqlserver：BSQLbm_consensus：RAFT 共识bm_cdc：更改数据捕获</td>
</tr>
<tr>
<td>service_type</td>
<td>给定服务器类型的逻辑服务名称。</td>
</tr>
<tr>
<td>service_method</td>
<td>可选项。 标识服务方法，这是服务执行的特定功能</td>
</tr>
</tbody>
</table>
<p><strong>3.指标端点</strong>
BMDB 集群包含多个节点和服务，每个节点和服务都会发出指标。 指标可以针对整个集群，也可以针对特定节点、表或Tile，并且它们可以聚合到集群、节点、数据库和表视图中。 BMDB 每个节点有四种主要类型的指标：服务器、表、Tile和集群。 指标通过各种端点以 JSON、HTML 和 Prometheus 格式导出，如下图所示。
<img alt="" src="./media/chapter6/45.png" />
下表描述了每个端点公开的指标类型以及可以从中导出其指标的 URL。</p>
<table>
<thead>
<tr>
<th>服务</th>
<th>描述</th>
<th>JSON</th>
<th>PROMETHEUS</th>
</tr>
</thead>
<tbody>
<tr>
<td>MServer</td>
<td>与系统目录、集群范围的元数据（例如tile和表的数量）以及集群范围的操作（表创建/删除等）相关的指标。</td>
<td><node-ip>:10000/metrics</td>
<td><node-ip>:10000/prometheus-metrics</td>
</tr>
<tr>
<td>DBServer</td>
<td>与最终用户DML请求相关的指标（例如表插入），其中包括表、Tile和存储级别指标（例如 Write-Ahead-Logging 等）</td>
<td><node-ip>:20000/metrics</td>
<td><node-ip>:20000/prometheus-metrics</td>
</tr>
<tr>
<td>BSQL</td>
<td>BSQL 查询处理和连接指标，例如各种操作的吞吐量和延迟。</td>
<td><node-ip>:8100/metrics</td>
<td><node-ip>:8100/prometheus-metrics</td>
</tr>
<tr>
<td>BCQL</td>
<td>BCQL 查询处理和连接指标，例如各种操作的吞吐量和延迟。</td>
<td><node-ip>:8200/metrics</td>
<td><node-ip>:8200/prometheus-metrics</td>
</tr>
</tbody>
</table>
<p>BMDB 不会公开系统级指标，如果使用 Prometheus，则通常使用外部工具（例如 node_exporter）收集系统级指标。</p>
<h4 id="_131"><strong>吞吐量和时延</strong></h4>
<p>监控查询处理和数据库 IOPS
BMDB 支持延迟指标的附加属性，使您能够计算吞吐量。</p>
<p>这些属性包括以下内容：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>total_count</td>
<td>衡量指标值的次数。</td>
</tr>
<tr>
<td>min</td>
<td>所有测量中指标的最小值。</td>
</tr>
<tr>
<td>mean</td>
<td>所有测量的指标平均值。</td>
</tr>
<tr>
<td>Percentile_75</td>
<td>所有测量中指标的第 75 个百分位值。</td>
</tr>
<tr>
<td>Percentile_95</td>
<td>所有测量中指标的第 95 个百分位值。</td>
</tr>
<tr>
<td>Percentile_99</td>
<td>所有指标测量中指标的第 99 个百分位。</td>
</tr>
<tr>
<td>Percentile_99_9</td>
<td>所有指标测量中指标的第 99.9 个百分位。</td>
</tr>
<tr>
<td>Percentile_99_99</td>
<td>所有指标测量中指标的第 99.99 个百分位。</td>
</tr>
<tr>
<td>max</td>
<td>所有测量中指标的最大值。</td>
</tr>
<tr>
<td>total_sum</td>
<td>Total_count/count 中反映的测量中所有指标值的聚合。</td>
</tr>
</tbody>
</table>
<p>例如，如果 SELECT * FROM table 执行一次并在 10 微秒内返回 8 行，则 handler_latency_bm_bsqlserver_SQLProcessor_SelectStmt 指标将具有以下属性值：total_count=1、total_sum=10、min=10、max=10 和mean=10。 如果再次运行相同的查询并在 6 微秒内返回，则属性将如下：total_count=2、total_sum=16、min=6、max=10 和mean=8。</p>
<p>尽管这些属性存在于所有 handler_latency 指标中，但可能不会针对所有指标计算它们。</p>
<h5 id="bsql_2"><strong>BSQL查询处理</strong></h5>
<p>BSQL 查询处理指标表示查询处理层开始执行后 BMDB 处理 BSQL 语句所花费的总包含时间。 这些指标包括解析和执行SQL语句、通过网络复制所花费的时间、在存储层花费的时间等等。 前面的指标不捕获反序列化网络字节和解析查询的时间。</p>
<p>以下是评估 BSQL 查询处理的关键指标。 所有指标都是计数器，单位是微秒。
| 指标（数量|微妙）                                      | 描述                                                         |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| handler_latency_bm_bsqlserver_SQLProcessor_InsertStmt   | 解析和执行 INSERT 语句所花费的时间                           |
| handler_latency_bm_bsqlserver_SQLProcessor_SelectStmt   | 解析和执行 Select 语句所花费的时间                           |
| handler_latency_bm_bsqlserver_SQLProcessor_UpdateStmt   | 解析和执行 Update 语句所花费的时间                           |
| handler_latency_bm_bsqlserver_SQLProcessor_BeginStmt    | 解析和执行 Begin 语句所花费的时间                            |
| handler_latency_bm_bsqlserver_SQLProcessor_CommitStmt   | 解析和执行 Commit 语句所花费的时间                           |
| handler_latency_bm_bsqlserver_SQLProcessor_RollbackStmt | 解析和执行 Rollback 语句所花费的时间                         |
| handler_latency_bm_bsqlserver_SQLProcessor_OtherStmts   | 解析和执行除此表中列出的前面的语句之外的所有其他语句所花费的时间。 包括 PREPARE、RELEASE SAVEPOINT 等语句。 |
| handler_latency_bm_bsqlserver_SQLProcessor_Transactions | 执行该表中的任何语句所花费的时间                             |</p>
<p>通过应用适当的聚合，BSQL 吞吐量可以被视为整个集群、每个表和每个节点的聚合。</p>
<h5 id="iops"><strong>数据库 IOPS（读取和写入）</strong></h5>
<p>DBServer 负责 BMDB 集群中客户端请求的实际 I/O。 集群中的每个节点都有一个 DBServer，每个节点都托管一个或多个Tile对等点。</p>
<p>以下是评估数据库 IOPS 的关键指标。 所有指标都是计数器，单位是微秒。
| 指标（数量|微妙）                                  | 描述                                  |
| --------------------------------------------------- | ------------------------------------- |
| handler_latency_bm_dbserver_TileServerService_Read  | 在Tile级别执行 READ 操作所花费的时间  |
| handler_latency_bm_dbserver_TileServerService_Write | 在Tile级别执行 WRITE 操作所花费的时间 |</p>
<p>通过应用适当的聚合，可以将这些指标视为整个集群、每个表和每个节点的聚合。</p>
<h4 id="_132"><strong>连接数</strong></h4>
<p>监控BSQL连接.</p>
<p>连接指标表示每个节点到 BSQL 后端的累积连接数。 这包括各种后台连接，例如检查点、客户端后端连接的活动连接数、新建立的连接以及超过最大连接限制而被拒绝的连接。</p>
<p>连接指标仅以 Prometheus 格式提供。</p>
<p>下表描述了关键连接指标。 所有单位均以连接数计。</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>bm_bsqlserver_active_connection_total</td>
<td>gauge</td>
<td>与 BSQL 服务器的活动客户端后端连接的数量。 如果客户端连接正在执行语句，则它被视为活动连接。 任何不执行语句的客户端连接都被视为空闲连接。</td>
</tr>
<tr>
<td>bm_bsqlserver_connection_total</td>
<td>gauge</td>
<td>BSQL的所有连接总数，包括活跃连接、空闲连接和后台连接。</td>
</tr>
<tr>
<td>bm_bsqlserver_max_connection_total</td>
<td>gauge</td>
<td>BSQL 服务器在任何给定时间可以支持的最大并发连接数。 可以使用 --bsql_max_connections DBServer 标志更改该值。</td>
</tr>
<tr>
<td>bm_bsqlserver_connection_over_limit_total</td>
<td>counter</td>
<td>BSQL 服务器拒绝超过最大连接限制的连接请求数，基于 bm_bsqlserver_max_connection_total。</td>
</tr>
<tr>
<td>bm_bsqlserver_new_connection_total</td>
<td>counter</td>
<td>自进程启动以来与 BSQL 服务器建立的连接总数。</td>
</tr>
</tbody>
</table>
<p>可以使用适当的聚合在整个集群中聚合这些指标。</p>
<h4 id="_133"><strong>缓存和存储</strong></h4>
<p>监控 CoreDB 存储子系统指标。</p>
<h5 id="iops_1"><strong>存储层IOPS</strong></h5>
<p>CoreDB使用RocksDB（一种基于LSM的键值存储，由多个逻辑级别组成，每个级别中的数据按键排序）的修改版本作为存储层。 该存储层执行查找、next和prev操作。</p>
<p>下表描述了存储 (RocksDB) 层的关键吞吐量和延迟指标。</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>单位</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rocksdb_number_db_next</td>
<td>keys</td>
<td>数量</td>
<td>每当从数据库读取/更新元组时，都会向 RocksDB key 发出请求。 每个数据库操作都会向 RocksDB 发出多个请求。 当数据库读取/更新元组时，RocksDB 为查找键而执行的 NEXT 操作的数量。</td>
</tr>
<tr>
<td>rocksdb_number_db_prev</td>
<td>keys</td>
<td>数量</td>
<td>当从数据库读取/更新元组时，RocksDB 为查找键而执行的 PREV 操作的数量。</td>
</tr>
<tr>
<td>rocksdb_number_db_seek</td>
<td>keys</td>
<td>数量</td>
<td>从数据库读取/更新元组时，RocksDB 为查找键而执行的 SEEK 操作的数量。</td>
</tr>
<tr>
<td>rocksdb_db_write_micros</td>
<td>微秒</td>
<td>数量</td>
<td>RocksDB 写入数据所花费的时间（以微秒为单位）</td>
</tr>
<tr>
<td>rocksdb_db_get_micros</td>
<td>微秒</td>
<td>数量</td>
<td>RocksDB 检索与某个值匹配的数据所花费的时间（以微秒为单位）</td>
</tr>
<tr>
<td>rocksdb_db_seek_micros</td>
<td>微秒</td>
<td>数量</td>
<td>RocksDB 在范围查询中检索数据所花费的时间（以微秒为单位）</td>
</tr>
</tbody>
</table>
<p>可以使用适当的聚合在整个集群中聚合这些指标。</p>
<h5 id="_134"><strong>块缓存</strong></h5>
<p>当从BSQL层请求的数据位于SST文件中时，它将被缓存在RocksDb块缓存中。 这是位于 RocksDB 而不是 BSQL 层的基本缓存。 块在添加到缓存的multi-touch (hot)部分之前需要多次访问。</p>
<p>下表描述了存储（RocksDB）层的关键缓存指标。</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>单位</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rocksdb_block_cache_hit</td>
<td>块</td>
<td>数量</td>
<td>块缓存命中总数（缓存索引+缓存过滤器+缓存数据）</td>
</tr>
<tr>
<td>rocksdb_block_cache_miss</td>
<td>块</td>
<td>数量</td>
<td>块缓存未命中总数（缓存索引+缓存过滤器+缓存数据）</td>
</tr>
<tr>
<td>block_cache_single_touch_usage</td>
<td>块</td>
<td>数量</td>
<td>由 BSQL 层缓存和读取一次的数据块被分类在缓存的单点访问部分中。 具有单次访问的块的缓存使用量的大小（以字节为单位）</td>
</tr>
<tr>
<td>block_cache_multi_touch_usage</td>
<td>块</td>
<td>数量</td>
<td>由 BSQL 层缓存和多次读取的数据块被分类在缓存的多点访问部分中。 具有多次访问的块使用的缓存大小（以字节为单位）</td>
</tr>
</tbody>
</table>
<p>可以使用适当的聚合在整个集群中聚合这些指标。</p>
<h5 id="_135"><strong>布隆过滤器</strong></h5>
<p>布隆过滤器是哈希表，用于确定给定的 SSTable 是否具有用于查找特定值的查询的数据。</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>单位</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rocksdb_bloom_filter_checked</td>
<td>块</td>
<td>数量</td>
<td>布隆过滤器被检查的次数</td>
</tr>
<tr>
<td>rocksdb_bloom_filter_useful</td>
<td>块</td>
<td>数量</td>
<td>布隆过滤器避免文件读取（避免 IOPS）的次数。</td>
</tr>
</tbody>
</table>
<p>可以使用适当的聚合在整个集群中聚合这些指标。</p>
<h5 id="sst"><strong>SST 文件</strong></h5>
<p>RocksDB LSM 树将传入数据缓冲在内存缓冲区中，当内存缓冲区满时，将进行排序，并以排序运行的形式刷新到磁盘。 当排序的运行刷新到磁盘时，它可以迭代地与相同大小的现有运行合并。 总的来说，由于这种迭代合并，磁盘上的排序运行（也称为排序字符串表或 SST 文件）形成大小呈指数级增长的级别集合，并且各个级别之间的键范围可能重叠。</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>单位</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rocksdb_current_version_sst_files_size</td>
<td>字节</td>
<td>数量</td>
<td>所有 SST 文件的总大小</td>
</tr>
<tr>
<td>rocksdb_current_version_num_sst_files</td>
<td>文件</td>
<td>数量</td>
<td>SST 文件的数量</td>
</tr>
</tbody>
</table>
<p>可以使用适当的聚合在整个集群中聚合这些指标。</p>
<h5 id="_136"><strong>压实</strong></h5>
<p>为了随着时间的推移提高读取性能，RocksDB 通过在后台对 SST 文件运行压缩（排序合并）来定期减少逻辑级别的数量，其中部分或多个逻辑级别合并为一个。 换句话说，RocksDB 使用压缩来平衡写入、空间和读取放大。</p>
<p>下表列出了该类别中关键指标的描述：</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>单位</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rocksdb_compact_read_bytes</td>
<td>字节</td>
<td>数量</td>
<td>为进行压缩而读取的字节数</td>
</tr>
<tr>
<td>rocksdb_compact_write_bytes</td>
<td>字节</td>
<td>数量</td>
<td>为进行压缩而写入的字节数</td>
</tr>
<tr>
<td>rocksdb_compaction_times_micros</td>
<td>微秒</td>
<td>数量</td>
<td>压缩过程完成的时间</td>
</tr>
<tr>
<td>rocksdb_numfiles_in_singlecompaction</td>
<td>文件</td>
<td>数量</td>
<td>任何一次压缩中的文件数量</td>
</tr>
</tbody>
</table>
<h5 id="memtable"><strong>Memtable</strong></h5>
<p>Memtable 是第一级数据存储，当您开始插入时，数据将被存储在其中。 它提供有关阅读文档的统计信息，这些统计信息本质上是表中的列。 如果Memtable已满，现有Memtable将变为不可变并作为 SST 文件存储在磁盘上。</p>
<p>Memtable 有读取文档的统计信息，本质上就是表中的列。</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>单位</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rocksdb_memtable_compaction_micros</td>
<td>微秒</td>
<td>数量</td>
<td>压缩一组 SST 文件的总时间</td>
</tr>
<tr>
<td>rocksdb_memtable_hit</td>
<td>keys</td>
<td>数量</td>
<td>内存表命中数</td>
</tr>
<tr>
<td>rocksdb_memtable_miss</td>
<td>keys</td>
<td>数量</td>
<td>内存表未命中数</td>
</tr>
</tbody>
</table>
<p>这些指标可用于每个Tile，并且可以使用适当的聚合在整个集群中进行聚合。</p>
<h5 id="wal"><strong>预写日志记录 (WAL)</strong></h5>
<p>预写日志（或 WAL）用于将更新写入并保存到每个Tile上的磁盘。 下表描述了观察 WAL 组件性能的指标</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>单位</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>log_sync_latency</td>
<td>微秒</td>
<td>数量</td>
<td>将 WAL 条目刷新（fsync）到磁盘所花费的时间</td>
</tr>
<tr>
<td>log_append_latency</td>
<td>微秒</td>
<td>数量</td>
<td>将一批日志附加到 WAL 所花费的时间</td>
</tr>
<tr>
<td>log_group_commit_latency</td>
<td>微秒</td>
<td>数量</td>
<td>Group commit日志所花费的时间</td>
</tr>
<tr>
<td>log_bytes_logged</td>
<td>字节</td>
<td>数量</td>
<td>Tile启动后写入 WAL 的字节数</td>
</tr>
<tr>
<td>log_reader_bytes_read</td>
<td>字节</td>
<td>数量</td>
<td>Tile 启动后从 WAL 读取的字节数</td>
</tr>
</tbody>
</table>
<p>这些指标可用于每个Tile，并且可以使用适当的聚合在整个集群中进行聚合。</p>
<h4 id="raft"><strong>Raft</strong></h4>
<p>监控 raft 和分布式系统指标。</p>
<h5 id="raft_1"><strong>Raft 操作、吞吐量和延迟</strong></h5>
<p>BMDB 实现了 RAFT 共识协议，并进行了少量修改。 副本实现了一种名为 UpdateConsensus 的 RPC 方法，该方法允许Tile领导者将一批日志条目复制到追随者。 副本还实现了一个名为 RequestConsensusVote 的 RPC 方法，候选人调用该方法来收集选票。 ChangeConfig RPC 方法指示在共识组中添加或删除节点的次数。 当 BMDB 需要移动数据时，通常会增加更改配置。 这可能是由于计划的服务器添加或停用或服务器崩溃循环而发生的。 请求共识的数量较高表明许多副本正在寻找新的选举，因为它们尚未收到领导者的心跳。 这可能是由于 CPU 高或网络分区情况造成的。</p>
<p>所有处理程序延迟指标都包含附加属性。 请参阅吞吐量和延迟。</p>
<p>以下是监控 RAFT 处理的关键指标。 所有指标都是以微秒为单位的计数器。
| 指标（数量|微妙）                                           | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| handler_latency_bm_consensus_ConsensusService_UpdateConsensus | 将一批日志条目从领导者复制到跟随者所花费的时间。 包括被调用的 RPC 方法的总数 |
| handler_latency_bm_consensus_ConsensusService_RequestConsensusVotes | 候选人收集选票的时间。 包括被调用的 RPC 方法的总数           |
| handler_latency_bm_consensus_ConsensusService_ChangeConfig   | 候选人在 Raft 组中添加或删除对等点的时间。 包括正在调用的 RPC 方法的总数 |</p>
<p>可以使用适当的聚合来计算和聚合整个集群中的节点的吞吐量（Ops/Sec）。</p>
<h5 id="_137"><strong>时钟偏差</strong></h5>
<p>时钟偏差是性能和数据一致性的重要指标。 如果 BMDB 使用的混合逻辑时钟 (HLC) 处于故障状态或者您的虚拟机是否已暂停或迁移，它会发出信号。 如果偏差超过500毫秒，可能会影响BMDB的一致性保证。 如果查询响应中出现无法解释的、看似随机的延迟，并且时钟偏差指标出现峰值，则可能表明虚拟机已迁移到另一台计算机，或者虚拟机管理程序已超额负荷。</p>
<p>时钟偏差是以微秒为单位的计量单位。</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>hybrid_clock_skew</td>
<td>时钟漂移和偏移的时间</td>
</tr>
</tbody>
</table>
<h5 id="_138"><strong>远程引导</strong></h5>
<p>当 Raft 对等点发生故障时，BMDB 会执行自动远程引导，从剩余的对等点创建新的对等点。 添加或停用节点时计划的用户活动也可能导致引导。</p>
<p>远程引导程序是一个以微秒为单位的计数器。</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>handler_latency_bm_consensus_ConsensusService_StartRemoteBootstrap</td>
<td>远程引导一个新的 Raft 对等点所花费的时间。 包括远程引导连接的总数。</td>
</tr>
</tbody>
</table>
<p>可以使用适当的聚合来聚合整个集群中的节点的该指标。</p>
<h4 id="mserver_2"><strong>MServer</strong></h4>
<p>监控表和Tile的操作。</p>
<p>MServer 托管系统元数据，记录系统中的表及其Tile的位置、用户、角色、权限等。 MServer 还负责协调后台操作，例如架构更改、处理集群中节点的添加和删除、永久故障时自动重新复制数据等。</p>
<p>所有处理程序延迟指标都包含附加属性。 请参阅吞吐量和延迟。</p>
<p>以下是评估 MServer 性能的关键指标。 所有指标都是计数数量，单位是微秒。
| 指标（数量|微妙）                                        | 描述                                                         |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| handler_latency_bm_mserver_mserverClient_GetTileLocations | 从主服务器获取副本所花费的时间。 该指标包括从主服务器获取副本位置的次数。 |
| handler_latency_bm_dbserver_TileServerService_Read        | 读取 PostgreSQL 系统表（在 DDL 期间）所花费的时间。 该指标包括读取次数。 |
| handler_latency_bm_dbserver_TileServerService_Write       | 写入 PostgreSQL 系统表（在 DDL 期间）所花费的时间。 该指标包括写入次数。 |
| handler_latency_bm_mserver_mserverDdl_CreateTable         | 创建表的时间（DDL 期间）。 该指标包括创建表操作的计数。      |
| handler_latency_bm_mserver_mserverDdl_DeleteTable         | 删除表所花费的时间（在 DDL 期间）。 该指标包括删除表操作的计数 |</p>
<p>可以使用适当的聚合来聚合整个集群中的节点的这些指标。</p>
<h4 id="_139"><strong>复制</strong></h4>
<p>监控 xDCR 复制。</p>
<p>xDCR
BMDB 允许您在独立的 BMDB 集群之间异步复制数据。</p>
<p>复制滞后指标在tile级别计算为源tile服务器上的混合逻辑时钟 (HLC) 时间与从源提取的最新记录的混合时钟时间戳之间的差异。</p>
<p>下表描述了关键复制指标。 所有指标都是计数数量，单位是微秒。
| 指标（数量|微妙）                     | 描述                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| async_replication_committed_lag_micros | 目标集群上的复制延迟时间。该指标仅在源集群上可用。           |
| time_since_last_getchanges             | 从源集群收到目标集群的复制请求以来所用的时间（以微秒为单位）。 该指标仅在源集群上可用。 |
| consumer_safe_time_lag                 | 物理时间和安全时间之间经过的时间（以微秒为单位）。 安全时间是指数据已复制到消费者集群上的所有Tile上的时间。 该指标仅在目标集群上可用。 |
| consumer_safe_time_skew                | 消费者集群上第一个和最后一个 Tile 副本之间的复制所用的时间（以微秒为单位）。 该指标仅在目标集群上可用。 |</p>
<h2 id="_140"><strong>问题排查</strong></h2>
<p>通常，故障排除涉及许多相当一致的步骤，无论特定情况如何。 这些步骤包括以下内容：</p>
<p>1.验证 BMDB 是否正在运行：您需要确保当前节点上正在运行预期的 BMDB 进程。 至少，DBServer 进程必须正在运行才能通过客户端或应用程序连接到节点。
此外，根据设置，您可能期望 MServer 进程在此节点上运行。
有关详细信息，请参阅检查进程。</p>
<p>2.检查集群级别的问题及其解决方案。</p>
<p>3.检查日志：您应该检查 BMDB 日志以获取有关您的问题的更多详细信息。 有关详细信息，请参阅检查日志。</p>
<p>4.浏览知识库文章：您可以在 bigmath 支持页面上找到其他故障排除资源和信息。</p>
<h3 id="_141"><strong>集群级别故障排除</strong></h3>
<p>典型 BMDB 集群问题的诊断和解决方案。</p>
<h4 id="bcql-api"><strong>BCQL API 连接问题</strong></h4>
<p>要解决 BCQL API 连接问题，您应该执行多项检查。</p>
<p><strong>1.BMDB进程是否正在运行？</strong>
您应该确保预期的 BMDB 进程位于当前节点上。 至少，DBServer 进程需要运行才能使用 BCQL 客户端或应用程序连接到该节点。</p>
<p>此外，根据设置，您可能期望 MServer 进程也在此节点上运行。</p>
<p>有关详细说明，请参阅检查 BMDB 服务器。</p>
<p><strong>2.与 Cassandra 兼容的 BCQL API 是否正在运行？</strong>
如果 DBServer 进程正在运行，请执行以下命令来验证 BCQL API 是否已启用并侦听 BCQL 端口（默认 9542）：</p>
<div class="highlight"><pre><span></span><code>lsof -i :9542
</code></pre></div>
<div class="highlight"><pre><span></span><code>COMMAND  PID   USER   FD   TYPE  DEVICE     SIZE/OFF  NODE  NAME
bm-tserve     9268  bigmath 109u   IPv4   331456       0t0       TCP    *:9542 (LISTEN)
</code></pre></div>
<p>您可能需要先安装 lsof。</p>
<p>使用 bm-ctl 运行本地集群时，您应该看到具有不同 IP 地址的所有节点，如下例所示：</p>
<div class="highlight"><pre><span></span><code>lsof -i :9542
</code></pre></div>
<div class="highlight"><pre><span></span><code>COMMAND  PID   USER   FD   TYPE     DEVICE SIZE/OFF NODE NAME
bm-tserve     81590  centos  131u  IPv4      0xdeadbeef      0t0  TCP localhost:9542 (LISTEN)
bm-tserve     81593  centos  131u  IPv4      0xdeadbeef      0t0  TCP 127.0.0.2:9542 (LISTEN)
bm-tserve     81596  centos  131u  IPv4      0xdeadbeef      0t0  TCP 127.0.0.3:9542 (LISTEN)
</code></pre></div>
<p>如果另一个进程正在使用此端口，您可能需要停止该进程并重新启动 DBServer 进程。 否则，如果没有进程正在侦听但 DBServer 正在运行，请检查传递给 DBServer 进程的 --cql_proxy_bind_address 标志的值。</p>
<p><strong>3.cqlsh可以本地连接吗？</strong>
在运行 BMDB 的计算机上，使用 cqlsh 连接到本地 BMDB 实例，如下所示：</p>
<div class="highlight"><pre><span></span><code>cqlsh &lt;bm-local-address&gt;
</code></pre></div>
<p>根据您的配置，您可能需要安装 cqlsh； 否则，它可以在 BMDB bin 目录中找到。</p>
<p>在上述命令中，<bm-local-address> 是 BMDB BCQL 服务器正在侦听的地址（例如，由 lsof 返回）。 例如，它映射到本文档中提供的示例中的 localhost（或者，对于 bm-ctl 情况，另外映射到 127.0.0.2 和 127.0.0.3）。</p>
<p>如果 cqlsh 可以连接，则问题可能是网络问题，原始客户端无法访问 BMDB 运行的节点。</p>
<h4 id="yedis-api"><strong>YEDIS API连接问题</strong></h4>
<p>要解决 YEDIS API 连接问题，您应该执行多项检查。</p>
<p><strong>1.BMDB进程是否正在运行？</strong>
您应该确保预期的 BMDB 进程位于当前节点上。 至少，DBServer 进程需要运行才能通过 Redis 客户端或应用程序连接到该节点。</p>
<p>此外，根据设置，您可能期望MServer也在此节点上运行。</p>
<p>有关详细说明，请参阅检查进程。</p>
<p><strong>2.兼容Redis的YEDIS API是否正在运行？</strong>
如果DBServer进程正在运行，请执行以下命令来验证YEDIS API是否已启用并侦听Redis端口（默认6879）：</p>
<div class="highlight"><pre><span></span><code>lsof -i :6879
</code></pre></div>
<div class="highlight"><pre><span></span><code>COMMAND PID   USER   FD   TYPE     DEVICE SIZE/OFF NODE NAME
dbserver    81590  centos   92u  IPv4 0xdeadbeef      0t0  TCP localhost:6879 (LISTEN)
</code></pre></div>
<p>您可能需要先安装 lsof。</p>
<p>使用 bm-ctl 运行本地集群时，您应该看到具有不同 IP 地址的所有节点，如下例所示：</p>
<div class="highlight"><pre><span></span><code>lsof -i :6879
</code></pre></div>
<div class="highlight"><pre><span></span><code>COMMAND PID   USER   FD   TYPE     DEVICE SIZE/OFF NODE NAME
dbserver    81590 centos   92u  IPv4 0xdeadbeef      0t0  TCP localhost:6879 (LISTEN)
dbserver    81593 centos   92u  IPv4 0xdeadbeef      0t0  TCP 127.0.0.2:6879 (LISTEN)
dbserver    81596 centos   92u  IPv4 0xdeadbeef      0t0  TCP 127.0.0.3:6879 (LISTEN)
</code></pre></div>
<p>如果另一个进程正在使用此端口，您可能需要停止该进程并重新启动 DBServer 进程。 否则，如果没有进程正在侦听但 DBServer 正在运行，请检查传递给 DBServer 进程的 --cql_proxy_bind_address 标志的值。</p>
<p><strong>3.redis-cli可以本地连接吗？</strong>
使用redis-cli连接本地节点，如下：</p>
<div class="highlight"><pre><span></span><code>./redis-cli -h &lt;bm-local-address&gt;
</code></pre></div>
<p>根据您的配置，您可能需要安装 redis-cli。 更多信息请参见初始化YEDIS API并连接redis-cli。</p>
<p>在上述命令中，<bm-local-address> 是 YEDIS 服务正在监听的地址（例如 lsof 返回的地址）。</p>
<p>如果 redis-cli 可以连接，则问题可能是网络问题，原始客户端无法访问运行 BMDB 的此节点。</p>
<p>否则，您可能需要使用 bm-admin 工具来运行以下命令：</p>
<div class="highlight"><pre><span></span><code>.bin/bm-admin --mserver_addresses &lt;mserver-ip-addresses&gt; setup_redis_table
</code></pre></div>
<h4 id="dbservermserver"><strong>恢复失败的DBServer和MServer</strong></h4>
<p>当 DBServer 进程、MServer 进程或节点发生故障时，集群可能正在运行。</p>
<p>以下示例步骤演示了如果您有复制因子 (RF)=3 的 N 节点设置，如何恢复进程。</p>
<p><strong>1.监控进程</strong>
建议设置 cron 或 systemd 以确保 DBServer 和 MServer 进程在未运行时重新启动。</p>
<p>这可以处理暂时性故障，例如由于意外行为导致的节点重新启动或进程崩溃。</p>
<p>如果您正在使用 systemd 并且想要查找要重新启动的服务的名称，请使用以下命令：</p>
<div class="highlight"><pre><span></span><code>sudo systemctl list-units --type=service | grep bm
</code></pre></div>
<p>您应该看到类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>bm-controller.service                       loaded active running bigmath Controller
mserver.service                           loaded active running bigmath mserver service
dbserver.service                          loaded active running bigmath dbserver service
</code></pre></div>
<p><strong>2.节点故障</strong>
通常，如果一个节点发生故障，系统会自动恢复并继续与其余 N-1 个节点一起运行。 如果故障节点没有足够快地恢复，且 N-1 &gt;= 3，则复制不足的tiles将自动重新复制，以在剩余 N-1 节点上返回到 RF=3。</p>
<p>如果某个节点在 DBServer 上遇到永久性故障，则应在新节点上启动另一个 DBServer 进程。 该节点将加入集群，负载均衡器将自动考虑新的 DBServer 并开始重新平衡tiles。</p>
<p><strong>3.mserver故障</strong>
如果需要启动新的MServer来替换发生故障的MServer，则需要更新mserver仲裁。 假设原来的MServers是n1，n2，n3。 并且n3需要更换为新的MServer n4。 然后需要使用bm-admin子命令change_mserver_config，如下：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin -mserver_addresses n1:11000,n2:11000 change_mserver_config REMOVE_SERVER n3 11000
./bin/bm-admin -mserver_addresses n1:11000,n2:11000 change_mserver_config ADD_SERVER n4 11000
</code></pre></div>
<p>DBServer 的内存状态会在 ADD_SERVER 步骤之后自动了解新的mserver，并且不需要重新启动。</p>
<p>您应该更新所有 DBServer 进程的配置文件，该文件指定mserver地址以反映 n1、n2、n4 的新仲裁。</p>
<p>这是为了处理 dbserver 在将来某个时刻重新启动的情况。</p>
<p><strong>4.计划的集群变更</strong>
您可以选择执行计划的集群更改，例如将整个集群移动到一组全新的节点（例如，从类型 A 的计算机移动到类型 B）。 有关如何执行此操作的说明，请参阅更改集群配置。</p>
<h4 id="dbserver_3"><strong>更换出现故障的 DBServer</strong></h4>
<p>您可以替换 BMDB 集群中出现故障的 DBServer，如下所示：
1.安装并启动一个新的 DBServer，确保它与您要替换的服务器位于同一置放群组中。 有关详细说明，请参阅启动 DBServers。</p>
<p>2.使用以下命令将出现故障的 DBServer 列入黑名单：</p>
<div class="highlight"><pre><span></span><code>〜/ mserver / bin / bm-admin -mserver_addresses $ MSERVERS change_blacklist ADD $ OLD_IP：21000
</code></pre></div>
<p>有关详细信息，请参阅 bm-admin 参考页面中的change_blacklist。</p>
<p>3.等待数据从发生故障的 DBServer 中排出，然后将数据加载到新 DBServer 中。 您可以通过运行以下命令来检查重新平衡是否完成：</p>
<div class="highlight"><pre><span></span><code>〜/ mserver / bin / bm-admin -mserver_addresses $ MSERVERS get_load_move_completion
</code></pre></div>
<p>仅当来自故障 DBServer 的数据有可存储的地方时，加载和重新平衡才会完成。 您需要首先启动新的 DBServer，或者确保剩余的 DBServer 有足够的容量并且位于正确的放置区域。</p>
<p>有关使用此命令的详细信息，请参阅 get_load_move_completion。</p>
<p>4.当数据移动完成 (100%) 时，通过停止 dbserver 进程或终止 VM 来终止发生故障的 DBServer。 然后等待DBServer被MServer领导者标记为DEAD。 MServer领导者在一分钟没有响应后将服务器标记为DEAD（基于dbserver_unresponsive_timeout_ms，默认为60000）。</p>
<p>要验证发生故障的 DBServer 是否已死亡，请打开 Web 浏览器 $MSERVER_LEADER_IP:10000/tile-servers 并检查输出。</p>
<p>5.由于替换的DBServer正在运行并正在加载数据，因此将发生故障的DBServer的地址从黑名单中删除，如下所示：</p>
<div class="highlight"><pre><span></span><code>~/mserver/bin/bm-admin -mserver_addresses $MSERVERS change_blacklist REMOVE $OLD_IP:21000
</code></pre></div>
<h4 id="mserver_3"><strong>更换发生故障的 MServer</strong></h4>
<p>您可以替换 BMDB 集群中出现故障的 MServer 服务器。</p>
<p>本文档中包含的示例使用以下场景：</p>
<ul>
<li>该集群包括三台 mserver 服务器：M1、M2、M3。</li>
<li>MServer服务器M1出现故障，需要更换。</li>
<li>新的 MServer 服务器 (M4) 将取代 M1。</li>
<li>默认主RPC端口是11000</li>
</ul>
<p>如果要更换的 MServer 已经失效（例如，VM 被终止），则需要先执行 REMOVE 步骤，然后执行 ADD 步骤。</p>
<p>1.通过将 --mserver_addresses 标志设置为空字符串 ("")，以备用模式启动替换 MServer 服务器，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bin/mserver --mserver_addresses=&quot;&quot; --fs_data_dirs=&lt;your_data_directories&gt; [any other flags you would typically pass to this mserver process]
</code></pre></div>
<p>当 --mserver_addresses 为“”时，此 MServer 服务器启动时不会加入任何现有的主仲裁。 该节点将在稍后的步骤中添加到主仲裁中。</p>
<p>2.通过运行 bm-admin change_mserver_config ADD_SERVER 命令将替换 MServer 服务器添加到现有集群中，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin -mserver_addresses M1:11000,M2:11000,M3:11000 change_mserver_config ADD_SERVER M4 11000
</code></pre></div>
<p>3.使用 bm-admin change_mserver_config REMOVE_SERVER 命令从集群中删除发生故障的 MServer 服务器，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bm-admin -mserver_addresses M1:11000,M2:11000,M3:11000,M4:11000 change_mserver_config REMOVE_SERVER M1 11000
</code></pre></div>
<p>确保指定所有 MServer 地址，包括 M4，以确保如果 M4 成为领导者，则 bm-admin 可以找到它。</p>
<p>4.通过检查您的主节点集现在是否为 M2、M3 和 M4 来验证集群，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bm-admin -mserver_addresses M2:11000,M3:11000,M4:11000 list_all_mservers
</code></pre></div>
<p>默认情况下，DBServer 只能识别在启动时使用的 --dbserver_mserver_addrs 标志中编码的 MServer 服务器。 如果这些 MServer 服务器中的任何一个仍然是活动仲裁的一部分，那么它们可以通过心跳传播新的主仲裁。 如果当前的 MServer 服务器都不存在于 DBServer 标志中，则 DBServer 无法加入集群。 因此，将每个 DBServer 上的 --dbserver_mserver_addrs 更新为新的主地址集 M2:11000、M3:11000、M4:11000 非常重要。</p>
<h4 id="_142"><strong>手动远程引导失败的对等点</strong></h4>
<p>当 Raft 对等点发生故障时，BMDB 会执行自动远程引导，从剩余的对等点创建新的对等点。</p>
<p>如果给定Tile的大多数 Raft 对等点失败，您需要手动执行远程引导程序。 可通过 mserver-ip:10000/tile-replication（bm-admin UI）获取平板电脑列表。</p>
<p>假设您有一个适用以下条件的集群：</p>
<ul>
<li>复制因子为3。</li>
<li>具有 UUID Tile1 的Tile。</li>
<li>三个Tile对等体，其中一个工作状态良好，称为 NODE_GOOD，两个损坏的对等体，称为 NODE_BAD1 和 NODE_BAD2。</li>
<li>一些与Tile相关的数据将从好对等点复制到每个坏对等点，直到大部分数据恢复为止。</li>
</ul>
<p>以下是要遵循的步骤：
1.如有必要，通过运行以下命令从损坏的对等点中删除Tile：</p>
<div class="highlight"><pre><span></span><code>dbserver-ctl --server_address=NODE_BAD1 delete_tile Tile1
dbserver-ctl --server_address=NODE_BAD2 delete_tile Tile1
</code></pre></div>
<ul>
<li>触发 TILE1 从 NODE_GOOD 到 NODE_BAD1 的远程引导。</li>
</ul>
<div class="highlight"><pre><span></span><code>dbserver-ctl --server_address=NODE_BAD1 remote_bootstrap NODE_GOOD TILE1
</code></pre></div>
<p>远程引导完成后，NODE_BAD2 应自动从仲裁中删除，并且 TILE1 已修复，因为它已获得大多数健康对等点。</p>
<p>如果您无法执行上述步骤，您可以执行以下操作来手动执行远程引导程序的等效操作：</p>
<ul>
<li>在 NODE_GOOD 上，为 TILE1 创建WALS (Raft data), RocksDB (regular) directories, intents (transactions data)和快照目录的存档。</li>
<li>将这些存档复制到 NODE_BAD1，在 TILE1 当前拥有 Raft 和 RocksDB 数据的同一驱动器上。</li>
<li>停止NODE_BAD1，因为下面的文件系统数据将会改变。</li>
<li>从 NODE_BAD1 中删除 TILE1 的旧 WALS、RocksDB、intents、快照数据。</li>
<li>将从 NODE_GOOD 复制的数据解压到 NODE_BAD1 上相应的（现在为空）目录中。</li>
<li>重新启动 NODE_BAD1，以便它可以使用此新数据引导 TILE1。</li>
<li>重新启动NODE_GOOD，以便它可以正确观察NODE_BAD1上更改的状态和数据。</li>
</ul>
<p>此时，NODE_BAD2 应自动从仲裁中删除，并且 TILE1 已修复，因为它已获得大多数健康对等点。</p>
<p>请注意，通常，当您尝试查找Tile数据时，您将在 --fs_data_dir 路径中使用 find 命令。</p>
<p>在以下示例中，假设设置为 /mnt/d0 并且您的Tile UUID 为 c08596d5820a4683a96893e092088c39：</p>
<div class="highlight"><pre><span></span><code>find /mnt/d0/ -name &#39;*c08596d5820a4683a96893e092088c39*&#39;
/mnt/d0/bm-data/dbserver/wals/table-2fa481734909462385e005ba23664537/tile-c08596d5820a4683a96893e092088c39
/mnt/d0/bm-data/dbserver/tile-meta/c08596d5820a4683a96893e092088c39
/mnt/d0/bm-data/dbserver/consensus-meta/c08596d5820a4683a96893e092088c39
/mnt/d0/bm-data/dbserver/data/rocksdb/table-2fa481734909462385e005ba23664537/tile-c08596d5820a4683a96893e092088c39
/mnt/d0/bm-data/dbserver/data/rocksdb/table-2fa481734909462385e005ba23664537/tile-c08596d5820a4683a96893e092088c39.intents
/mnt/d0/bm-data/dbserver/data/rocksdb/table-2fa481734909462385e005ba23664537/tile-c08596d5820a4683a96893e092088c39.snapshots
</code></pre></div>
<p>您可能感兴趣的数据如下：</p>
<ul>
<li>对于Raft WALS：</li>
</ul>
<div class="highlight"><pre><span></span><code>/mnt/d0/bm-data/dbserver/wals/table-2fa481734909462385e005ba23664537/tile-c08596d5820a4683a96893e092088c39
</code></pre></div>
<ul>
<li>对于 RocksDB regular database：</li>
</ul>
<div class="highlight"><pre><span></span><code>/mnt/d0/bm-data/dbserver/data/rocksdb/table-2fa481734909462385e005ba23664537/tile-c08596d5820a4683a96893e092088c39
</code></pre></div>
<ul>
<li>对于intents files：</li>
</ul>
<div class="highlight"><pre><span></span><code>/mnt/d0/bm-data/dbserver/data/rocksdb/table-2fa481734909462385e005ba23664537/tile-c08596d5820a4683a96893e092088c39.intents
</code></pre></div>
<ul>
<li>对于快照文件：</li>
</ul>
<div class="highlight"><pre><span></span><code>/mnt/d0/bm-data/dbserver/data/rocksdb/table-2fa481734909462385e005ba23664537/tile-c08596d5820a4683a96893e092088c39.snapshots
</code></pre></div>
<h4 id="dbserver_4"><strong>从崩溃循环中恢复 DBServer</strong></h4>
<p>当 DBServer 进程或节点发生故障时，BMDB 会针对大多数类型的Tile数据损坏或故障自动触发远程引导。 然而，在某些情况下，自动引导可能无法解决问题，从而导致崩溃循环。 当某个条件导致编码为崩溃的代码路径（例如，CHECK 或 FATAL）或崩溃原因未知（例如，导致 SIGSEGV 的代码错误）时，可能会发生这种情况。 在所有这些情况下，当进程重新启动时，根本原因可能会重复出现。</p>
<p>由于陷入崩溃循环的服务器通常无法保持足够长的时间来安全地对其发出运行时命令，因此需要管理员进行手动干预才能使 DBServer 恢复到健康状态。</p>
<p>为此，管理员需要找到所有有故障的Tile，在磁盘上查找其数据（可能分布在多个磁盘上，具体取决于您的 fs_data_dirs），然后将其删除。</p>
<p>以下是解决这种情况的步骤：
1.停止 DBServer 进程以防止在操作期间重新启动。
2.找到遇到这些问题的Tile。 您可以查阅日志来获取Tile的UUID。 在所描述的场景中，Tile的 UUID 为 FOO，--fs_data_dirs 标志为 /mnt/disk1。
3.找到并删除所有的tile文件，如下：</p>
<div class="highlight"><pre><span></span><code>find /mnt/disk1 -name &#39;*FOO*&#39; | xargs rm -rf
</code></pre></div>
<p>4.对 --fs_data_dirs 中的每个磁盘重复上述命令。
5.重新启动DBServer进程。</p>
<p>完成后，DBServer 应该能够启动、保持活动状态并重新加入集群，同时集中式负载均衡器重新复制或重新分发任何受影响的Tile的副本。</p>
<h4 id="_143"><strong>性能问题</strong></h4>
<p>您可以采取多种步骤来调查 BMDB 集群的性能并对其进行故障排除。</p>
<p><strong>1.BMDB集群上的文件</strong>
了解 BMDB 集群上文件的默认位置有助于解决集群性能问题。</p>
<p>请注意，以下位置是典型的集群安装目录。</p>
<p>（1）BMDB 软件和二进制文件
软件包的符号链接位于 /home/bigmath/{mserver|dbserver}。</p>
<p>请注意，MServer 和 DBServer 可能是不同版本的软件（例如，这可能是滚动软件升级的结果）。</p>
<p>例如，要了解 MServer 上的文件位置，请执行以下命令：</p>
<div class="highlight"><pre><span></span><code>ls -lrt /home/bigmath/mserver
</code></pre></div>
<p>预期输出类似于以下内容：</p>
<div class="highlight"><pre><span></span><code>total 4
lrwxrwxrwx. 1 bigmath bigmath   27 Jan 15 19:27 logs -&gt; /mnt/d0/bm-data/mserver/logs
lrwxrwxrwx. 1 bigmath bigmath   66 Jan 15 19:28 bin -&gt; /home/bigmath/bm-software/bigmath-2.5.1.0-b187-centos-x86_64/bin
lrwxrwxrwx. 1 bigmath bigmath   66 Jan 15 19:28 lib -&gt; /home/bigmath/bm-software/bigmath-2.5.1.0-b187-centos-x86_64/lib
lrwxrwxrwx. 1 bigmath bigmath   72 Jan 15 19:28 linuxbrew -&gt; /home/bigmath/bm-software/bigmath-2.5.1.0-b187-centos-x86_64/linuxbrew
lrwxrwxrwx. 1 bigmath bigmath   85 Jan 15 19:28 linuxbrew-xxxxxxxxxxxx -&gt; /home/bigmath/bm-software/bigmath-2.5.1.0-b187-centos-x86_64/linuxbrew-xxxxxxxxxxxx
lrwxrwxrwx. 1 bigmath bigmath   71 Jan 15 19:28 postgres -&gt; /home/bigmath/bm-software/bigmath-2.5.1.0-b187-centos-x86_64/postgres
lrwxrwxrwx. 1 bigmath bigmath   68 Jan 15 19:28 pylib -&gt; /home/bigmath/bm-software/bigmath-2.5.1.0-b187-centos-x86_64/pylib
lrwxrwxrwx. 1 bigmath bigmath   68 Jan 15 19:28 share -&gt; /home/bigmath/bm-software/bigmath-2.5.1.0-b187-centos-x86_64/share
lrwxrwxrwx. 1 bigmath bigmath   68 Jan 15 19:28 tools -&gt; /home/bigmath/bm-software/bigmath-2.5.1.0-b187-centos-x86_64/tools
lrwxrwxrwx. 1 bigmath bigmath   65 Jan 15 19:28 ui -&gt; /home/bigmath/bm-software/bigmath-2.5.1.0-b187-centos-x86_64/ui
lrwxrwxrwx. 1 bigmath bigmath   84 Jan 15 19:28 version_metadata.json -&gt; /home/bigmath/bm-software/bigmath-2.5.1.0-b187-centos-x86_64/version_metadata.json
lrwxrwxrwx. 1 bigmath bigmath   66 Jan 15 19:28 www -&gt; /home/bigmath/bm-software/bigmath-2.5.1.0-b187-centos-x86_64/www
-rw-rw-r--. 1 bigmath bigmath    0 Jan 15 19:29 mserver.out
-rw-rw-r--. 1 bigmath bigmath 2200 Jan 15 20:18 mserver.err
drwxr-xr-x. 2 bigmath bigmath   25 Jan 15 20:18 conf
</code></pre></div>
<p>（2）配置文件
MServer 和 DBServer 的配置文件位于 /home/bigmath/{mserver|dbserver}/conf/server.conf 中。</p>
<p>（3）事务日志
如果 BMDB 使用 --fs_data_dirs=/mnt/d0,/mnt/d1 运行，您可以在 /mnt/d*/bm-data/{mserver|dbserver}/wals 处找到事务日志（也称为预写日志 (WAL)）。</p>
<p>要打印 WAL 的内容，请使用 log-dump 实用程序，如下所示：</p>
<div class="highlight"><pre><span></span><code>./home/bigmath/dbserver/bin/log-dump /mnt/d0/bm-data/dbserver/wals/table-e85a116bc557403e82f57037e7b13879/tile-05bef5ed6fb74cabb420b648b6f850e3/

# use -print_entries=pb to print the entire contents of each record
</code></pre></div>
<p>（4）Tile的数据库文件
数据库（也称为 SSTable）文件位于 /mnt/d*/bm-data/{mserver|dbserver}/data。</p>
<p>您可以按如下方式打印 SSTable 文件的内容：</p>
<div class="highlight"><pre><span></span><code>./home/bigmath/dbserver/bin/ldb dump --compression_type=snappy --db=/mnt/d0/bm-data/dbserver/data/table-e85a116bc557403e82f57037e7b13879/tile-05bef5ed6fb74cabb420b648b6f850e3/
</code></pre></div>
<p>（5）调试日志
调试日志输出到/home/bigmath/{mserver|dbserver}/logs。</p>
<p>（6）标准输出和标准错误
MServer 和 DBServer 进程的 stderr 和 stdout 输出到 /home/bigmath/dbserver/dbserver.{err|out}。</p>
<p><strong>2.慢响应日志</strong>
缓慢的响应占用了配置的 RPC 超时时间的 75% 以上。 默认情况下，这些响应以以下格式记录在警告级别，并在各个阶段进行时间细分：</p>
<div class="highlight"><pre><span></span><code>W0325 06:47:13.032176 116514816 inbound_call.cc:204] Call bm.consensus.ConsensusService.UpdateConsensus from 127.0.0.1:61050 (request call id 22856) took 2644ms (client timeout 1000).
W0325 06:47:13.033341 116514816 inbound_call.cc:208] Trace:
0325 06:47:10.388015 (+     0us) service_pool.cc:109] Inserting onto call queue
0325 06:47:10.394859 (+  6844us) service_pool.cc:170] Handling call
0325 06:47:10.450697 (+ 55838us) raft_consensus.cc:1026] Updating replica for 0 ops
0325 06:47:13.032064 (+2581367us) raft_consensus.cc:1242] Filling consensus response to leader.
0325 06:47:13.032106 (+    42us) spinlock_profiling.cc:233] Waited 2.58 s on lock 0x108dc3d40. stack: 0000000103d63b0c 0000000103d639fc 00000001040ac908 0000000102f698ec 0000000102f698a4 0000000102f93039 0000000102f7e124 0000000102fdcf7b 0000000102fd90c9 00000001\
02504396 00000001032959f5 0000000103470473 0000000103473491 00000001034733ef 000000010347338b 000000010347314c
0325 06:47:13.032168 (+    62us) inbound_call.cc:125] Queueing success response
</code></pre></div>
<p><strong>3.dbserver-ctl</strong>
您可以通过使用 dbserver-ctl （指向 MServer ）运行各种与Tile相关的命令，如下所示：</p>
<div class="highlight"><pre><span></span><code>./dbserver-ctl list_tiles --server_address=localhost:20000
./dbserver-ctl dump_tile --server_address=localhost:20000 e1bc59288ee849ab850ae0a40bd88649
</code></pre></div>
<p><strong>4.bm-admin</strong>
您可以使用 bm-admin 运行各种命令。 您需要使用 -mserver_addresses 指定完整的 MServer 端口 {ip:ports} 集，如下所示：</p>
<div class="highlight"><pre><span></span><code># Get all tables
./bm-admin -mserver_addresses 127.0.0.1:10000,127.0.0.2:10000,127.0.0.3:10000 list_tables

# Get all tiles for a specific table
./bm-admin -mserver_addresses 127.0.0.1:10000,127.0.0.2:10000,127.0.0.3:10000 list_tiles bm_load_test

# List the tile servers for each tile
./bm-admin -mserver_addresses 127.0.0.1:10000,127.0.0.2:10000,127.0.0.3:10000 list_tile_servers $(./bm-admin -mserver_addresses 127.0.0.1:10000,127.0.0.2:10000,127.0.0.3:10000 list_tiles bm_load_test)

# List all tile servers
./bm-admin -mserver_addresses 127.0.0.1:10000,127.0.0.2:10000,127.0.0.3:10000 list_all_tile_servers

# List all mservers
./bm-admin -mserver_addresses 127.0.0.1:10000,127.0.0.2:10000,127.0.0.3:10000 list_all_mservers

# Output mserver state to console
./bm-admin -mserver_addresses 127.0.0.1:10000,127.0.0.2:10000,127.0.0.3:10000 dump_mservers_state
</code></pre></div>
<p><strong>5.实时指标</strong>
您可以通过以下端口查看特定节点（例如 127.0.0.1）上各个 BMDB 进程的指标：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>MSserver</td>
<td>127.0.0.1:10000</td>
</tr>
<tr>
<td>DBServer</td>
<td>127.0.0.1:20000</td>
</tr>
<tr>
<td>Yedis</td>
<td>127.0.0.1:8300</td>
</tr>
<tr>
<td>BCQL</td>
<td>127.0.0.1:8200</td>
</tr>
<tr>
<td>BSQL</td>
<td>127.0.0.1:8100</td>
</tr>
</tbody>
</table>
<p>对于每个进程，您可以看到以下类型的指标：</p>
<table>
<thead>
<tr>
<th>描述</th>
<th>端点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Per-Tile, JSON Metrics</td>
<td>/metrics</td>
</tr>
<tr>
<td>Per-Table, Prometheus Metrics</td>
<td>/prometheus-metrics</td>
</tr>
</tbody>
</table>
<p><strong>6.RPC 追踪</strong>
要启用跟踪，您可以设置enable_tracing标志，如下所示：</p>
<div class="highlight"><pre><span></span><code>./dbserver-ctl --server_address=localhost:21000 set_flag enable_tracing 1
</code></pre></div>
<p>要启用对所有 RPC（不仅仅是慢速 RPC）的跟踪（包括 enable_tracing 标志），您还可以设置 rpc_dump_all_traces gflag，如下所示：</p>
<div class="highlight"><pre><span></span><code>./dbserver-ctl --server_address=localhost:21000 set_flag rpc_dump_all_traces 1
</code></pre></div>
<p><strong>7.gflags 的动态设置</strong>
尽管不建议动态设置字符串 gflags，因为它不是线程安全的，但 dbserver-ctl 实用程序允许您这样做。</p>
<p>在尝试设置 gflags 之前，您需要使用其远程过程调用 (RPC) 端口（而不是 HTTP 端口）来识别服务器。</p>
<p>例如，您可以通过执行以下命令将详细日志记录级别增加到 2：</p>
<div class="highlight"><pre><span></span><code>./dbserver-ctl --server_address=localhost:21000 set_flag v 2
</code></pre></div>
<p><strong>8.原型文件内容</strong>
要转储包含proto的文件的内容（例如consensus-meta或tile-meta目录中的文件），请使用bm-pbc-dump实用程序，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bm-pbc-dump /mnt/d0/bm-data/dbserver/consensus-meta/dd57975ef2f2440497b5d96fc32146d3
./bm-pbc-dump /mnt/d0/bm-data/dbserver/tile-meta/bfb3f18736514eeb841b0307a066e66c
</code></pre></div>
<p>在 macOS 上，需要设置环境变量 DYLD_FALLBACK_LIBRARY_PATH 才能使 pbc-dump 工作。 要设置此变量，请将以下内容添加到 ~/.bash_profile：</p>
<div class="highlight"><pre><span></span><code>export DYLD_FALLBACK_LIBRARY_PATH=~/code/bigmath/build/latest/rocksdb-build
</code></pre></div>
<h3 id="_144"><strong>节点级别故障排除</strong></h3>
<p>诊断并解决单个 BMDB 节点上的问题。</p>
<h4 id="bmdb_2"><strong>检查</strong> <strong>BMDB服务器</strong></h4>
<p>要解决服务器问题，您应该执行多项检查。</p>
<p><strong>1.BMDB服务器是否正在运行？</strong>
要验证服务器是否正在运行，您需要连接到运行 BMDB 的本地节点。 在本地设置中，这将是您的本地计算机（或在本地计算机上运行的 Docker 实例）。 在多节点集群上，您可能需要 ssh 进入运行 BMDB 节点的计算机，如下所示：</p>
<div class="highlight"><pre><span></span><code>ps aux | grep dbserver
</code></pre></div>
<p>如果您期望此节点上有 MServer 服务器，请执行以下命令：</p>
<div class="highlight"><pre><span></span><code>$ ps aux | grep mserver
</code></pre></div>
<p>如果服务器未运行，您可以使用以下命令启动它们：</p>
<ul>
<li>bm-ctl。</li>
<li>使用手动部署时的 dbserver 和 mserver。</li>
</ul>
<p>如果服务器正在运行，但无法从您的客户端计算机访问它们，则可能表明存在网络问题。</p>
<p><strong>2.MServer 和 DBServer 端点是否可访问？</strong>
通常，端点定义如下：</p>
<table>
<thead>
<tr>
<th>描述</th>
<th>URL</th>
</tr>
</thead>
<tbody>
<tr>
<td>mserver Web Page</td>
<td><node-ip>:10000</td>
</tr>
<tr>
<td>dbserver Web Page</td>
<td><node-ip>:20000</td>
</tr>
<tr>
<td>Redis Metrics</td>
<td><node-ip>:8300/metrics</td>
</tr>
<tr>
<td>BCQL Metrics</td>
<td><node-ip>:8200/metrics</td>
</tr>
<tr>
<td>Redis Server</td>
<td><node-ip>:6879</td>
</tr>
<tr>
<td>BCQL Server</td>
<td><node-ip>:9542</td>
</tr>
</tbody>
</table>
<p>但是，在某些情况下，这些端点可能无法访问，具体取决于您的物理机或云提供商帐户上的配置。</p>
<p>（1）IP无法访问
私有 IP 与公共 IP：考虑设置 VPN 或使用节点的公共 IP（例如，从云提供商帐户上的计算机状态获取它）。</p>
<p>（2）端口关闭
云帐户配置：根据以下定义，为云提供商帐户上的 TCP 流量打开相关端口（例如安全组规则）。</p>
<p>防火墙已启用：如果您的主机启用了防火墙，请运行以下命令以使用防火墙例外打开端口。</p>
<div class="highlight"><pre><span></span><code>sudo firewall-cmd --zone=public --add-port=10000/tcp;
sudo firewall-cmd --zone=public --add-port=11000/tcp;
sudo firewall-cmd --zone=public --add-port=20000/tcp;
sudo firewall-cmd --zone=public --add-port=21000/tcp;
sudo firewall-cmd --zone=public --add-port=8300/tcp;
sudo firewall-cmd --zone=public --add-port=8200/tcp;
sudo firewall-cmd --zone=public --add-port=9300/tcp;
sudo firewall-cmd --zone=public --add-port=9542/tcp;
sudo firewall-cmd --zone=public --add-port=6879/tcp;
</code></pre></div>
<p>（3）端口已在使用中
macOS Monterey默认开启AirPlay接收，监听10000端口。这与BMDB冲突，导致bm-ctl启动失败，如下：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl start
</code></pre></div>
<div class="highlight"><pre><span></span><code>Starting bm-ctl...
/ Running system checks...Failed to bind to address:  0.0.0.0:10000
</code></pre></div>
<p>解决方法是禁用 AirPlay 接收，然后启动 BMDB，然后（可选）启用 AirPlay 接收。 或者，这是推荐的方法，您可以在启动集群时使用 --mserver_webserver_port 标志更改默认端口号，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl start --mserver_webserver_port=9999
</code></pre></div>
<h4 id="bmdb_3"><strong>检查</strong> <strong>BMDB日志</strong></h4>
<p>BMDB 具有广泛的错误处理机制，日志记录是其主要组件之一。</p>
<p><strong>1.BMDB基本文件夹</strong>
每个节点的日志都写入 BMDB bigmath-data 目录的子目录中，并且可能会根据您的部署而有所不同，如下所示：</p>
<ul>
<li>当您使用 bm-ctl 在单个主机（例如您的计算机）上创建本地 BMDB 集群时，每个节点的默认位置是 /bigmath-data/node-<node_nr>/。 对于 3 节点集群，bm-ctl 实用程序创建三个目录：node-1、node-2、node-3。</li>
<li>对于多主机的多节点集群部署，每个节点（主机）上 BMDB 磁盘的设置位置可能有所不同（例如，/home/centos/、/mnt/ 或其他目录）。</li>
<li>当用 --fs_data_dirs 标志设置多个目录时，日志将保存在列表中的第一个目录中。</li>
<li>使用 Docker 容器时，日志位于容器内的 /root/var/logs 中。</li>
<li>使用 bm-ctl 命令行界面创建本地 BMDB 集群时，默认日志位于 ~/var/logs 中。</li>
</ul>
<p>在本文档中，BMDB bigmath-data 目录由 <bigmath-data-directory> 表示。</p>
<p><strong>2.MServer 日志</strong>
MServer 服务管理系统元数据，例如命名空间（数据库或键空间）和表。 它还处理数据定义语言 (DDL) 语句，例如 CREATE TABLE、DROP TABLE、ALTER TABLE、KEYSPACE/TYPE。 此外，它还管理用户、权限并协调后台操作，例如负载平衡。 您可以按如下方式访问这些日志：</p>
<div class="highlight"><pre><span></span><code>cd &lt;bigmath-data-directory&gt;/disk1/bm-data/mserver/logs/
</code></pre></div>
<p>日志按错误严重性组织：FATAL、ERROR、WARNING、INFO。</p>
<p><strong>3.DBServer日志</strong>
DBServer 服务执行最终用户请求的实际输入输出。 它处理数据操作语言 (DML) 语句，例如 INSERT、UPDATE、DELETE 和 SELECT。 您可以按如下方式访问这些日志：</p>
<div class="highlight"><pre><span></span><code>cd &lt;bigmath-data-directory&gt;/disk1/bm-data/dbserver/logs/
</code></pre></div>
<p>日志按错误严重性组织：FATAL、ERROR、WARNING、INFO。</p>
<p><strong>4.日志管理</strong>
对于 MServer 和 DBServer，日志轮换大小由 --max_log_size 标志控制。 例如，将此标志设置为 256，将每个文件限制为 256 MB。 默认大小为 1.8 GB。</p>
<p>对于 BSQL，还有额外的 postgres*log 文件，它们具有基于每日和基于大小的日志轮换。 也就是说，每天或当日志大小达到 10 MB 时，都会创建一个新的日志文件。</p>
<p>有关可用配置标志的信息，请参阅 MServer 日志记录标志和 DBServer 日志记录标志。</p>
<p><strong>5.日志格式</strong>
MServer 和 DBServer 日志消息遵循以下模式：</p>
<div class="highlight"><pre><span></span><code>Lmmdd hh:mm:ss.uuuuuu threadid file:line] msg
</code></pre></div>
<p>字段如下：</p>
<ul>
<li>L：单个字符，代表日志级别（I 表示 INFO，W 表示 WARNING，E 表示 ERROR，F 表示 FATAL）。</li>
<li>mm：月份（以零填充；例如，五月是 05）。</li>
<li>dd：日（以零填充）。</li>
<li>hh:mm:ss.uuuuuu：以小时、分钟和秒小数形式表示的时间。</li>
<li>threadid：线程 ID。</li>
<li>file：文件名。</li>
<li>line：行号。</li>
<li>msg：记录的消息。</li>
</ul>
<h4 id="_145"><strong>检查系统统计数据</strong></h4>
<p>有一些系统统计信息可能有助于排除故障。</p>
<p><strong>1.主机资源使用情况</strong>
要检查Linux机器上的CPU、内存和磁盘使用情况，可以运行以下命令：</p>
<div class="highlight"><pre><span></span><code>sudo echo -n &quot;CPUs: &quot;;cat /proc/cpuinfo | grep processor | wc -l; echo -n &quot;Mem: &quot;;free -h | grep Mem | tr -s &quot; &quot; | cut -d&quot; &quot; -f 2; echo -n &quot;Disk: &quot;; df -h / | grep -v Filesystem;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CPUs: 72
Mem: 251G
Disk: /dev/sda2       160G   13G  148G   8% /
10.1.12.104
CPUs: 88
Mem: 251G
Disk: /dev/sda2       208G   22G  187G  11% /
10.1.12.105
CPUs: 88
Mem: 251G
Disk: /dev/sda2       208G  5.1G  203G   3% /
</code></pre></div>
<p>一般来说，top 或 iostat 等常用工具可能很有用。</p>
<p>2.Auditd
如果 top 报告auditd进程的CPU使用率很高，则它可能有审核BMDB经常使用的某些系统调用的规则，这可能会显着影响性能。 您可以尝试通过在每个 BMDB 节点上运行以下命令来暂时禁用审核：</p>
<div class="highlight"><pre><span></span><code>auditctl -e 0
</code></pre></div>
<p>然后您将检查这是否会提高性能。</p>
<p>要稍后重新启用审核，请运行以下命令：</p>
<div class="highlight"><pre><span></span><code>auditctl -e 1
</code></pre></div>
<p><strong>2.BMDB进程状态</strong>
BMDB 提供以下 Web 端点，其中聚合每个进程的当前状态。 这包括日志、标志以及内存、磁盘和网络使用指标。 此外，它还分别为 BCQL 和 Redis 请求提供专用指标端点：</p>
<table>
<thead>
<tr>
<th>描述</th>
<th>URL</th>
</tr>
</thead>
<tbody>
<tr>
<td>MServer Web Page</td>
<td><node-ip>:10000</td>
</tr>
<tr>
<td>DBServer Web Page</td>
<td><node-ip>:20000</td>
</tr>
<tr>
<td>Redis Metrics</td>
<td><node-ip>:8300/metrics</td>
</tr>
<tr>
<td>BCQL Metrics</td>
<td><node-ip>:8200/metrics</td>
</tr>
</tbody>
</table>
<p>当使用默认值在本地运行 bm-ctl 时，会创建三个本地 IP 地址：127.0.0.1、127.0.0.2 和 127.0.0.3，每个 BMDB 节点一个。</p>
<h4 id="_146"><strong>恢复故障磁盘</strong></h4>
<p>通过设置 --fs_data_dirs 标志，可以将 BMDB 配置为使用多个存储磁盘。 这引入了磁盘故障和恢复问题的可能性。</p>
<p><strong>1.集群复制恢复</strong>
DBServer服务自动检测磁盘故障并尝试将数据从故障磁盘传播到集群中的其他健康节点。 在复制因子 (RF) 为 3 的单可用区设置中：如果一开始有四个或更多节点，那么在一个节点发生故障后，至少会剩下三个节点。 在这种情况下，如果 DBServer 或磁盘宕机 10 分钟，则会自动启动重新复制。</p>
<p>在复制因子 (RF) 为 3 的多可用区设置中：BMDB 尝试为每个可用区保留一份数据副本。 在这种情况下，为了自动重新复制数据，一个可用区需要至少有两台 DBServer，以便在其中一台出现故障时，可以将其数据重新复制到另一台。 因此，这意味着至少有一个六节点集群。</p>
<p><strong>2.更换磁盘失败</strong>
要更换故障磁盘，请执行以下步骤：
（1）停止DBServer节点。
（2）更换发生故障的磁盘。
（3）重新启动 dbserver 服务。</p>
<p>重新启动时，DBServer 将看到新的空磁盘并开始从其他节点复制Tile。</p>
<h4 id="_147"><strong>磁盘已满问题</strong></h4>
<p><strong>崩溃循环时磁盘空间已满</strong>
在 DBServer 崩溃循环期间，磁盘可能会被填满，从而无法恢复。</p>
<p>在 DBServer 重新启动期间发生的Tile引导过程中，会分配一个新的 WAL 文件，而不管服务器先前的 WAL 文件中生成的日志量是多少。 如果DBServer有多个tile并进入崩溃循环，则每个tile都会在每个引导程序上创建新的WAL文件，从而填满磁盘。</p>
<p>从 v2.18.1 开始，您可以使用 --reuse_unished_segment_threshold_bytes 标志来防止崩溃循环中重复的 WAL 文件分配。</p>
<p>如果一个tile的最后一个WAL文件大小小于或等于这个阈值，引导进程将重用最后一个WAL文件而不是创建一个新的。 要设置该标志以便始终重用最后一个 WAL 文件，可以将该标志设置为当前最大 WAL 文件大小（64MB），如下所示：</p>
<div class="highlight"><pre><span></span><code>reuse_unclosed_segment_threshold_bytes=67108864
</code></pre></div>
<h4 id="_148"><strong>常见错误消息</strong></h4>
<p>所有 BMDB 组件都有许多常见的错误消息。</p>
<p><strong>1.跳过添加副本</strong>
当新节点加入集群或删除现有节点时，您可能会看到类似以下内容的错误消息：</p>
<div class="highlight"><pre><span></span><code>W1001 10:23:00.969424 22338 cluster_balance.cc:232] Skipping add replicas for 21d0a966e9c048978e35fad3cee31698:
Operation failed. Try again. Cannot add replicas. Currently have a total overreplication of 1, when max allowed is 1
</code></pre></div>
<p>此消息无害，可以忽略。 这意味着 MServer 负载均衡器在集群中远程引导的并发Tile的最大数量已达到其限制。 此限制在 mserver 配置中的 --load_balancer_max_concurrent_tile_remote_bootstraps 中配置。</p>
<p><strong>2.超出 SST 文件限制</strong>
当 SST 文件的数量超过其限制时，会发出以下错误：</p>
<div class="highlight"><pre><span></span><code>Service unavailable (bm/dbserver/tile_service.cc:257): SST files limit exceeded 58 against (24, 48), score: 0.35422774182913203: 3.854s (tile server delay 3.854s)
</code></pre></div>
<p>通常，客户端运行较高的 INSERT、UPDATE、DELETE 工作负载，并且压缩会落后。</p>
<p>要确定发生此错误的原因，您可以检查磁盘带宽、网络带宽以及服务器中是否有足够的 CPU 可用。</p>
<p>这些限制由以下 DBServer 配置标志控制：--sst_files_hard_limit=48 和 --sst_files_soft_limit=24。</p>
<p><strong>3.目录版本不匹配：处理此查询时发生 DDL</strong>
在BSQL层执行查询时，查询可能会失败，并出现以下错误：</p>
<div class="highlight"><pre><span></span><code>org.postgresql.util.PSQLException: ERROR: Catalog Version Mismatch: A DDL occurred while processing this query. Try Again
</code></pre></div>
<p>BSQL 中的 DML 查询可能会触及多个服务器，每个服务器都有一个 Catalog Version，用于跟踪 schema 更改。 当 DDL 语句在 DML 查询中间运行时，目录版本会发生更改，并且查询不匹配，导致查询失败。</p>
<p>在这些情况下，数据库会中止查询并返回 40001 PostgreSQL 错误代码。 可以从客户端安全地重试此代码的错误。</p>
<p><strong>4.快照太旧：运行 bm-dump 时</strong>
当运行需要很长时间才能完成的 bm-dump 命令时，您可能会遇到以下错误：</p>
<div class="highlight"><pre><span></span><code>Snapshot too old: Snapshot too old. Read point: { physical: 1628678717824559 }, earliest read time allowed: { physical: 16286796752110006 }, delta (usec): 957446447: kSnapshotTooOld
</code></pre></div>
<p>当命令需要很长时间才能处理时，可能已发生压缩并删除了开始转储的快照上的一些行。 对于大型备份，建议使用分布式快照，效率更高、速度更快。</p>
<p>如果确实需要使用 bm-dump，可以增加 DBServer 中的 --timestamp_history_retention_interval_sec gflag 并重试。</p>
<p><strong>5.启用传输加密后无法使用 bm-admin 执行操作</strong>
为 BMDB 集群配置传输中加密后，您在尝试使用 bm-admin 时可能会遇到以下错误：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin -mserver_addresses &lt;mserver-addresses&gt; list_all_mservers
</code></pre></div>
<div class="highlight"><pre><span></span><code>Unable to establish connection to leader mserver at [mserverIP1:11000,mserverIP2:11000,mserverIP3:11000].
Please verify the addresses.
Could not locate the leader mserver: GetLeadermserverRpc(addrs: [mserverIP1:11000, mserverIP2:11000, mserverIP3:11000], num_attempts: 338)
passed its deadline 79595.999s (passed: 60.038s): Network error (bm/util/net/socket.cc:535):
recvmsg got EOF from remote (system error 108)
Timed out (bm/rpc/rpc.cc:211):
Unable to establish connection to leader mserver at [mserverIP1:11000,mserverIP2:11000,mserverIP3:11000].
Please verify the addresses.
Could not locate the leader mserver: GetLeadermserverRpc(addrs: [mserverIP1:11000, mserverIP2:11000, mserverIP3:11000]
</code></pre></div>
<p>为了解决这种情况，您应该通过 bm-admin 命令上的 --certs_dir_name 传递证书目录的位置。</p>
<p><strong>6.sqlsh: FATAL: password authentication failed for user "bigmath" after fresh installation</strong> 
创建新集群后尝试使用 sqlsh CLI 连接到 BSQL 时，您可能会遇到以下错误：</p>
<div class="highlight"><pre><span></span><code>sqlsh: FATAL:  password authentication failed for user &quot;bigmath&quot;
</code></pre></div>
<p>默认情况下，PostgreSQL 监听端口 5432。为了避免冲突，BSQL 端口设置为 2521。但由于您可以在本地创建多个 PostgreSQL 集群，因此每个集群都会占用下一个可用端口，从 2521 开始，从而与 BSQL 端口冲突 。</p>
<p>如果您在创建 BMDB 集群之前创建了两个 PostgreSQL 集群，则 sqlsh shell 会尝试连接到在端口 2521 上运行的 PostgreSQL，但无法进行身份验证。 要进行验证，您可以运行以下命令来检查哪个进程正在侦听端口 2521：</p>
<div class="highlight"><pre><span></span><code>sudo lsof -i :2521
</code></pre></div>
<div class="highlight"><pre><span></span><code>COMMAND PID   USER   FD  TYPE   DEVICE SIZE/OFF NODE NAME
postgres     1263  postgres  7u  IPv4    35344      0t0  TCP localhost:postgresql (LISTEN)
</code></pre></div>
<p>您可以关闭该 PostgreSQL 集群或终止该进程，然后重新启动 BMDB。</p>
<p><strong>7.ServerError: Server Error. Unknown keyspace/cf pair (system.peers_v2)</strong> 
连接BCQL层时，可能会遇到类似如下的错误：</p>
<div class="highlight"><pre><span></span><code>ServerError: Server Error. Unknown keyspace/cf pair (system.peers_v2)
SELECT * FROM system.peers_v2;
^^^^^^
 (ql error -2)
</code></pre></div>
<p>最可能的原因是您没有使用 Cassandra 客户端驱动程序的 BMDB 分支之一。 BMDB 中不存在 system.peers_v2 表。 要解决此问题，您应该检查驱动程序页面以查找适合您的客户端语言的驱动程序。</p>
<h2 id="_149"><strong>性能调优</strong></h2>
<h3 id="_150"><strong>引言</strong></h3>
<p>BMDB集群由运行dbserver服务器进程的多个节点组成。由于BMDB数据库的分布式性质，调优需要记住的一点是，与大多数常见的只有本地机器影响数据库查询的数据库不同，数据是存储在集群的所有节点上的。本节介绍如何调整BMDB和及其一些可用的工具的介绍。</p>
<h4 id="_151"><strong>准备</strong></h4>
<p>在尝试优化单个语句之前，请确保BMDB集群以最佳方式运行：</p>
<ul>
<li>验证所有应该运行的节点是否确实在运行。</li>
<li>验证dbserver和mserver进程是否在节点上运行。</li>
</ul>
<p>要查看组成集群的节点和服务器，请使用bm-admin命令，查看mserver服务器和分片服务器信息。例如：
1）进入BMDB工作目录，此文中的工作目录均假设位于/home/bigmath/bmdb-0.1/bin，实际的工作目录，请以实际部署BMDB的工作目录为准：</p>
<div class="highlight"><pre><span></span><code>$ cd /home/bigmath/bmdb-0.1/bin/
</code></pre></div>
<p>2）执行如下命令，查看mserver服务器信息：</p>
<div class="highlight"><pre><span></span><code>./bm-admin -master_addresses 10.0.0.1:11000,10.0.0.2:11000,10.0.0.3:11000 list_all_masters
</code></pre></div>
<p>返回所有的mserver服务器信息，如下：</p>
<div class="highlight"><pre><span></span><code>Master UUID                     RPC Host/Port    State    Role          Broadcast Host/Port 
3d1ad31c7ccc499a93fede7f281fa677  10.0.0.1:11000     ALIVE   FOLLOWER        N/A                 
38381aa534ee4153a770fc0c5ddcd333  10.0.0.2:11000    ALIVE   LEADER           N/A                 
6eac0ec22d0b43768d40414975887a65  10.0.0.3:11000    ALIVE   FOLLOWER        N/A  
</code></pre></div>
<p>3）执行如下命令，查看dbserver服务器信息：</p>
<div class="highlight"><pre><span></span><code>./bm-admin -master_addresses 10.0.0.1:11000,10.0.0.2:11000,10.0.0.3:11000 list_all_tile_servers
</code></pre></div>
<p>返回所有的dbserver服务器信息，如下：</p>
<div class="highlight"><pre><span></span><code>Tile Server UUID                 RPC Host/Port    Heartbeat delay  Status   Reads/s  
9a86b61b1cb14d9087dc0c73a8bd3aa1  10.0.0.1:21000     0.66s           ALIVE    ...
0547c91c09ea43b19b274355591fb75f  10.0.0.2:21000      0.70s           ALIVE    ...
6e388d9feeb140d98fb5f425b8ef71e1   10.0.0.3:21000      0.58s           ALIVE    ...
</code></pre></div>
<p>接下来，确保有足够的磁盘空间，CPU、磁盘和网络等基本组件不会报告错误，操作系统也不会报告任何故障。 </p>
<p>在您知道整个集群正确运行之后，则可以转到语句调优。</p>
<h4 id="bsql_3"><strong>BSQL的调整</strong></h4>
<p>要研究一个运行速度明显较慢的特定查询，您首先需要确定查询运行在哪个节点上。要确定查询运行的节点，请登录到节点，并使用pg_stat_activity视图查看正在运行的查询。
注意：请记住，即使对于在一个节点上运行的单个查询，整个集群也可以显示活动，因为存储层是分布在所有节点上。</p>
<p>确定正确的节点后，BSQL提供了两个视图，可用于确定SQL语句及其性能特征：</p>
<p>1.pg_stat_activity：提供了当前活动的概述，包括SQL。除了查询文本之外，它不提供有关执行的SQL的信息；相反，它显示了PostgreSQL后端的当前状态。</p>
<p>2.pg_stat_statements：提供有关已执行SQL语句的历史信息。目前，没有记录 'block'/'blk' 信息（这是逻辑和物理I/O信息），因为没有使用PostgreSQL I/O代码路径。</p>
<p>用于性能调优的视图取决于性能问题，以及您是否可以现场目睹性能问题的发生，或者它是否是过去的性能问题。
请注意，由于数据的差异，相同的查询可能不会以相同的方式执行。</p>
<p>在识别出有问题的SQL语句后，下一步是使用EXPLAIN查看执行计划。执行计划是执行SQL语句中请求的工作的执行顺序和方法。此计划由数据库计划器生成。</p>
<p>BMDB使用PostgreSQL的基于成本的优化器，该优化器估计SQL语句的每个可能执行计划的成本。计划器根据从数据库表和支持的像二级辅助索引结构等导出的统计信息，来计算执行查询的最低成本的计划，假设这也是最快、最好的计划，最终执行此成本最低的执行计划。
注意：目前，BMDB不执行特定大小的成本计算，并假设每个计划都会生成1000行，这意味着成本为1000行。 </p>
<p>您可以在两种模式下使用EXPLAIN：
默认模式显示规划者创建的计划和预计的成本。
EXPLAIN ANALYZE模式执行查询，测量完成的时间和实际工作，并将这些统计信息作为“actual”而添加到执行计划中。
预测和实际的统计数据都有其用途。预测的统计数据是计划器使用的，假设统计数据没有改变，计划器将在下次运行查询时提出相同的执行计划，即使这在过去会导致性能问题。实际的统计数据显示了实际执行的工作量和内容，因此有利于了解执行计划的有效性。</p>
<h4 id="_152"><strong>性能调整工具</strong></h4>
<p>BMDB提供了许多工具，您可以使用这些工具来调整查询。</p>
<h5 id="_153"><strong>查找慢查询</strong></h5>
<p>使用pg_stat_statements扩展插件可以获取查询的统计信息。使用pg_stat_statements，您可以按userid、dbid、调用、行以及最小值、最大值、平均值、标准偏差和总时间来调查查询。
默认情况下会安装pg_stat_statements扩展模块，但在查询pg_stat_statements视图之前，必须为数据库启用该模块：</p>
<div class="highlight"><pre><span></span><code>CREATE EXTENSION if not exists pg_stat_statements;
</code></pre></div>
<p>要获得JSON格式的pg_stat_statements的输出，请通过浏览器访问https://＜dbserver ip＞：8100/statements，其中＜dbserver ip＞是集群中任意dbserver节点的ip地址：
例如：http://10.0.0.1:8100/statements</p>
<p>有关更多信息，请参阅使用pg_stat_statements获取查询统计信息。</p>
<h5 id="_154"><strong>查看实时查询</strong></h5>
<p>使用pg_stat_activity视图可以获取有关当前正在运行的任务的信息。使用pg_stat_activity，您可以识别非活动、活动和长时间活动会话，并获取进程信息和当前查询。
要获得JSON格式的pg_stat_activity的输出，请通过浏览器访问https://＜dbserver ip＞：8100/rpcz，其中＜dbserver ip＞是集群中任何dbserver节点的ip地址：
例如：http://10.0.0.1:8100/rpcz</p>
<p>有关更多信息，请参阅使用pg_stat_activity查看实时查询。 </p>
<h5 id="copy"><strong>查看COPY操作状态</strong></h5>
<p>使用pg_stat_progress_copy视图可以获取copy命令执行的状态信息。除了COPY状态外，pg_stat_progress_copy还提供处理的元组数量和其他附加信息，并在命令执行后保留COPY进度报告。</p>
<p>有关详细信息，请参阅使用pg_stat_progress_copy查看copy进度。</p>
<h5 id="explain"><strong>使用EXPLAIN查看计划</strong></h5>
<p>与PostgreSQL一样，BMDB提供EXPLAIN语句来显示BSQL为给定SQL语句生成的查询执行计划。使用EXPLAIN，您可以发现在查询计划中花费了大量的时间的查询的位置，并使用这些信息来决定提高查询性能的最佳方法。这可能包括添加索引，或更改索引排序顺序等策略。</p>
<p>有关更多信息，请参阅使用EXPLAIN分析查询。</p>
<h4 id="_155"><strong>高级工具</strong></h4>
<p>使用以下的工具，记录运行缓慢的查询，并使用提示优化查询。</p>
<h5 id="_156"><strong>记录慢查询</strong></h5>
<p>您可以设置--bsql_log_min_duration_statement标志来帮助跟踪慢速查询。配置后，BMDB会记录每个运行指定持续时间（以毫秒为单位），或更长时间的SQL语句。（将值设置为0，将打印所有语句。）
例如，在启动dbserver的时候，增加如下标志：</p>
<div class="highlight"><pre><span></span><code>./bm-dbserver --bsql_log_min_duration_statement 1000
</code></pre></div>
<p>样例日志输出类似如下：</p>
<div class="highlight"><pre><span></span><code>2023-10-13 10:13:49.701 EDT [73005] LOG:  duration: 34.378 ms  statement: SELECT c.oid,
        n.nspname,
        c.relname
    FROM pg_catalog.pg_class c
        LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
    WHERE c.relname OPERATOR(pg_catalog.~) &#39;^(products)$&#39;
        AND pg_catalog.pg_table_is_visible(c.oid)
    ORDER BY 2, 3;
</code></pre></div>
<p>结果会写入当前的postgres*日志文件。这些日志文件默认位于dbserver的 --fs_data_dirs标志指定的目录下的bm-data/dbserver/logs/下。</p>
<p>有关配置dbserver服务器的标志的更多信息，请参阅bm-dbserver 标志。</p>
<h5 id="_157"><strong>使用提示计划</strong></h5>
<p>BMDB使用PostgreSQL pg_hint_plan扩展来通过提示控制查询执行计划。
pg_hint_plan可以使用所谓的“hints”来影响查询计划器，“hints”使用特殊语法的C风格进行注释。 
注意：要有效地使用pg_hint_plan，您需要全面了解应用程序的部署方式。当数据库增长或部署发生变化时，还需要重新访问提示计划，以确保该计划不会限制性能，而不是优化性能。</p>
<p>有关更多信息，请参阅使用pg_hint_plan优化BSQL查询。</p>
<h3 id="_158"><strong>收集查询统计信息</strong></h3>
<p>数据库可能是资源密集型的，消耗大量内存CPU、IO和网络资源。优化SQL对于最大限度地减少资源利用率是非常有帮助的。pg_stat_statements模块可帮助您跟踪服务器执行的所有SQL语句的计划和执行统计信息，默认情况下是已经安装的。</p>
<p>下表中描述了pg_stat_statements视图的列：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>userid</td>
<td>oid</td>
<td>执行该语句的用户的 OID</td>
</tr>
<tr>
<td>dbid</td>
<td>oid</td>
<td>在其中执行该语句的数据库的 OID</td>
</tr>
<tr>
<td>queryid</td>
<td>bigint</td>
<td>内部哈希码，从语句的解析树计算得来</td>
</tr>
<tr>
<td>query</td>
<td>text</td>
<td>语句的文本形式</td>
</tr>
<tr>
<td>calls</td>
<td>bigint</td>
<td>被执行的次数</td>
</tr>
<tr>
<td>total_time</td>
<td>double precision</td>
<td>在该语句中花费的总时间，以毫秒计</td>
</tr>
<tr>
<td>min_time</td>
<td>double precision</td>
<td>在该语句中花费的最小时间，以毫秒计</td>
</tr>
<tr>
<td>max_time</td>
<td>double precision</td>
<td>在该语句中花费的最大时间，以毫秒计</td>
</tr>
<tr>
<td>mean_time</td>
<td>double precision</td>
<td>在该语句中花费的平均时间，以毫秒计</td>
</tr>
<tr>
<td>stddev_time</td>
<td>double precision</td>
<td>在该语句中花费时间的总体标准偏差，以毫秒计</td>
</tr>
<tr>
<td>rows</td>
<td>bigint</td>
<td>该语句检索或影响的行总数</td>
</tr>
<tr>
<td>shared_blks_hit</td>
<td>bigint</td>
<td>该语句造成的共享块缓冲命中总数</td>
</tr>
<tr>
<td>shared_blks_read</td>
<td>bigint</td>
<td>该语句读取的共享块的总数</td>
</tr>
<tr>
<td>shared_blks_dirtied</td>
<td>bigint</td>
<td>该语句弄脏的共享块的总数</td>
</tr>
<tr>
<td>shared_blks_written</td>
<td>bigint</td>
<td>该语句写入的共享块的总数</td>
</tr>
<tr>
<td>local_blks_hit</td>
<td>bigint</td>
<td>该语句造成的本地块缓冲命中总数</td>
</tr>
<tr>
<td>local_blks_read</td>
<td>bigint</td>
<td>该语句读取的本地块的总数</td>
</tr>
<tr>
<td>local_blks_dirtied</td>
<td>bigint</td>
<td>该语句弄脏的本地块的总数</td>
</tr>
<tr>
<td>local_blks_written</td>
<td>bigint</td>
<td>该语句写入的本地块的总数</td>
</tr>
<tr>
<td>temp_blks_read</td>
<td>bigint</td>
<td>该语句读取的临时块的总数</td>
</tr>
<tr>
<td>temp_blks_written</td>
<td>bigint</td>
<td>该语句写入的临时块的总数</td>
</tr>
<tr>
<td>blk_read_time</td>
<td>double precision</td>
<td><a href="#GUC-TRACK-IO-TIMING">该语句花在读取块上的总时间，以毫秒计（如果track_io_timing被启用，否则为零）</a></td>
</tr>
<tr>
<td>blk_write_time</td>
<td>double precision</td>
<td><a href="#GUC-TRACK-IO-TIMING">该语句花在写入块上的总时间，以毫秒计（如果track_io_timing被启用，否则为零）</a></td>
</tr>
<tr>
<td>bm_latency_histogram</td>
<td>jsonb</td>
<td>键值对列表，其中key是延迟范围，value是执行查询的次数</td>
</tr>
</tbody>
</table>
<h4 id="_159"><strong>配置参数</strong></h4>
<p>您可以在postgresql.conf中配置以下参数，此文件postgresql.conf默认位于dbserver的 --fs_data_dirs标志指定的目录下的pg_data/下： </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pg_stat_statements.max</td>
<td>integer</td>
<td>5000</td>
<td>是由该模块跟踪的语句的最大数目</td>
</tr>
<tr>
<td>pg_stat_statements.track</td>
<td>enum</td>
<td>top</td>
<td>控制哪些语句会被该模块计数。有效值为：top：可以跟踪顶层语句（那些直接由客户端发出的语句）all：可以跟踪顶层和嵌套的语句none：可以禁用语句统计信息收集</td>
</tr>
<tr>
<td>pg_stat_statements.track_utility</td>
<td>boolean</td>
<td>on</td>
<td>控制该模块是否会跟踪工具命令。</td>
</tr>
<tr>
<td>pg_stat_statements.save</td>
<td>boolean</td>
<td>on</td>
<td>指定是否在服务器关闭之后还保存语句统计信息。</td>
</tr>
</tbody>
</table>
<p>该模块要求与pg_stat_statements.max成比例的额外共享内存。注意只要该模块被载入就会消耗这么多的内存，即便pg_stat_statements.track被设置为none。</p>
<p>这些参数必须在postgresql.conf中设置。例如：</p>
<p># postgresql.conf</p>
<div class="highlight"><pre><span></span><code>pg_stat_statements.max = 10000
pg_stat_statements.track = all
pg_stat_statements.track_utility = off
pg_stat_statements.save = on
</code></pre></div>
<p>要跟踪IO运行时间，请打开postgresql.conf中的track_IO_timing参数： </p>
<div class="highlight"><pre><span></span><code>track_io_timing = on
</code></pre></div>
<p>track_activity_query_size参数设置报告SQL查询时要显示的字符数。如果您没有看到完整的较长查询，请增大此值。例如：</p>
<div class="highlight"><pre><span></span><code>track_activity_query_size = 2048 
</code></pre></div>
<p>默认情况下会创建extension。要手动添加或删除它，请使用以下语句：</p>
<div class="highlight"><pre><span></span><code>create extension pg_stat_statements;

drop extension pg_stat_statements;
</code></pre></div>
<h4 id="_160"><strong>示例</strong></h4>
<p>示例1,获取前10个I/O密集型查询 </p>
<div class="highlight"><pre><span></span><code>select userid ::regrole, dbid,query 
from pg_stat_statements 
order by (blk_read_time + blk_write_time)/ calls desc 
limit 10;
</code></pre></div>
<p>或者</p>
<div class="highlight"><pre><span></span><code>select userid ::regrole, dbid, query 
from pg_stat_statements 
order by (blk_read_time + blk_write_time) desc 
limit 10;
</code></pre></div>
<p>示例2 前10个耗时查询</p>
<div class="highlight"><pre><span></span><code>select userid::regrole, dbid, query
from pg_stat_statements
order by mean_time desc
limit 10;
</code></pre></div>
<p>或者</p>
<div class="highlight"><pre><span></span><code>select userid::regrole, dbid, query
from pg_stat_statements
order by total_time desc
limit 10;
</code></pre></div>
<p>示例3 获取前10个响应时间异常值</p>
<div class="highlight"><pre><span></span><code>select userid::regrole, dbid, query
from pg_stat_statements
order by stddev_time desc
limit 10;
</code></pre></div>
<p>示例4 按内存使用情况列出的前10个查询 </p>
<div class="highlight"><pre><span></span><code>select userid::regrole, dbid, query
from pg_stat_statements
order by (shared_blks_hit+shared_blks_dirtied) desc
limit 10;
</code></pre></div>
<p>示例5 获取前10个临时空间消耗的查询</p>
<div class="highlight"><pre><span></span><code>select userid::regrole, dbid, query
from pg_stat_statements
order by temp_blks_written desc
limit 10;
</code></pre></div>
<h4 id="_161"><strong>重置统计信息</strong></h4>
<p>pg_stat_statements_reset将丢弃pg_stat-statements迄今为止收集的所有统计信息。默认情况下，此函数只能由超级用户执行。 </p>
<div class="highlight"><pre><span></span><code>select pg_stat_statements_reset();
</code></pre></div>
<h3 id="_162"><strong>查看实时查询</strong></h3>
<p>BMDB支持PostgreSQL 的pg_stat_activity视图来分析实时查询。此视图返回有关活动的BMDB服务器进程、查询的分析和诊断信息。该视图为每个服务器进程返回一行，并显示与数据库连接的当前状态相关的信息。 
PostgreSQL的统计收集器是一个支持收集和报告服务器活动信息的子系统。 目前，这个收集器可以对表和索引的访问计数，计数可以按磁盘块和行来进行。它还跟踪每个表中的总行数、每个表的清理和分析动作的信息。它也统计调用用户定义函数的次数以及在每次调用中花费的总时间。
下表中描述了pg_stat_activity视图的列：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>datid</td>
<td>oid</td>
<td>这个后端连接到的数据库的OID</td>
</tr>
<tr>
<td>datname</td>
<td>name</td>
<td>这个后端连接到的数据库的名称</td>
</tr>
<tr>
<td>pid</td>
<td>integer</td>
<td>这个后端的进程 ID</td>
</tr>
<tr>
<td>usesysid</td>
<td>oid</td>
<td>登录到这个后端的用户的 OID</td>
</tr>
<tr>
<td>usename</td>
<td>name</td>
<td>登录到这个后端的用户的名称</td>
</tr>
<tr>
<td>application_name</td>
<td>text</td>
<td>连接到这个后端的应用的名称</td>
</tr>
<tr>
<td>client_addr</td>
<td>inet</td>
<td>连接到这个后端的客户端的 IP 地址。如果这个域为空，它表示客户端通过服务器机器上的一个 Unix 套接字连接或者这是一个内部进程（如自动清理）。</td>
</tr>
<tr>
<td>client_hostname</td>
<td>text</td>
<td><a href="#GUC-LOG-HOSTNAME">已连接的客户端的主机名，由client_addr的反向 DNS 查找报告。</a></td>
</tr>
<tr>
<td>client_port</td>
<td>integer</td>
<td>客户端用以和这个后端通信的 TCP 端口号，如果使用 Unix 套接字则为-1</td>
</tr>
<tr>
<td>backend_start</td>
<td>timestampz</td>
<td>这个进程被启动的时间。</td>
</tr>
<tr>
<td>xact_start</td>
<td>timestampz</td>
<td>这个进程的当前事务被启动的时间，如果没有活动事务则为空。如果当前查询是它的第一个事务，这一列等于query_start。</td>
</tr>
<tr>
<td>query_start</td>
<td>timestampz</td>
<td>当前活动查询被开始的时间，如果state不是active，这个域为上一个查询被开始的时间</td>
</tr>
<tr>
<td>state_change</td>
<td>timestampz</td>
<td>state上一次被改变的时间</td>
</tr>
<tr>
<td>wait_event_type</td>
<td>text</td>
<td>后端正在等待的事件类型，如果不存在则为 NULL。</td>
</tr>
<tr>
<td>wait_event</td>
<td>text</td>
<td><a href="#WAIT-EVENT-TABLE" title="表?28.4.?wait_event 描述">如果后端当前正在等待，则是等待事件的名称，否则为 NULL。</a></td>
</tr>
<tr>
<td>state</td>
<td>text</td>
<td>这个后端的当前总体状态。可能的值为：active，idle，idle in transaction，idle in transaction (aborted)，fastpath function call，disabled。</td>
</tr>
<tr>
<td>backend_xid</td>
<td>xid</td>
<td>这个后端的顶层事务标识符（如果存在）。</td>
</tr>
<tr>
<td>backend_xmin</td>
<td>xid</td>
<td>当前后端的xmin范围。</td>
</tr>
<tr>
<td>query</td>
<td>text</td>
<td><a href="#GUC-TRACK-ACTIVITY-QUERY-SIZE">这个后端最近查询的文本。如果state为active，这个域显示当前正在执行的查询。在所有其他状态下，它显示上一个被执行的查询。默认情况下，查询文本会被截断至1024个字符，这个值可以通过参数track_activity_query_size更改。</a></td>
</tr>
<tr>
<td>backend_type</td>
<td>text</td>
<td>当前后端的类型。可能的类型是autovacuum launcher，autovacuum worker，background worker，background writer，client backend，checkpointer，startup，walreceiver, walsender，和walwriter。</td>
</tr>
<tr>
<td>catalog_version</td>
<td>bigint</td>
<td>目录版本</td>
</tr>
</tbody>
</table>
<p>示例1：获取基本信息
以下查询返回有关活动BMDB进程的基本信息： </p>
<div class="highlight"><pre><span></span><code>SELECT datname, pid, application_name, state, query
FROM pg_stat_activity;
</code></pre></div>
<p>示例2：识别并终止一个开启的事务 
通常，您可能需要识别长时间运行的查询，因为这些查询可能指示更深层次的问题。pg_stat_activity视图可以帮助识别这些问题。在本例中，您创建一个打开的事务，识别它并终止它。
1.创建表，及其准备数据</p>
<div class="highlight"><pre><span></span><code>create table users(id int,name varchar(20),state char(2));
insert into users(id,name,state) values(212,&#39;Jacinthe Rowe&#39;,&#39;CO&#39;);
</code></pre></div>
<p>2.开启一个事务
使用以下查询可从t_users表中返回一行。 </p>
<div class="highlight"><pre><span></span><code>SELECT id, name, state
FROM users
WHERE id = 212;
</code></pre></div>
<p>返回：</p>
<div class="highlight"><pre><span></span><code> id  |     name      | state 
-------+--------------------------+-------
 212 | Jacinthe Rowe    | CO
</code></pre></div>
<p>使用事务更新state的值。查询故意缺少关闭事务的END；语句。</p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION;
    UPDATE users
        SET state = &#39;IA&#39;
     WHERE id = 212;
</code></pre></div>
<p>3.查找开启的事务
因为事务永远不会结束，所以它作为一个开启的进程浪费了资源。</p>
<p>4.通过打开另一个sqlsh会话，并使用pg_stat_activity查找有关此空闲事务的信息来检查事务的状态。</p>
<div class="highlight"><pre><span></span><code>SELECT datname, pid, application_name, state, query
FROM pg_stat_activity;
</code></pre></div>
<p>返回信息类似如下：</p>
<div class="highlight"><pre><span></span><code> datname |   pid   | application_name |        state   |       query              
------------+------------+---------------------+----------------------+------------------------------------------
test   | 1098588  | sqlsh         | idle in transaction | UPDATE users +
         |         |              |               |    SET state = &#39;IA&#39;  +
         |         |              |               | WHERE id = 212;
</code></pre></div>
<p>5.查找空闲事务的PID。在上一步的样本输出中，它是PID 1098588。 
6.终止事务。将＜pid＞替换为要终止的进程的pid。</p>
<div class="highlight"><pre><span></span><code>SELECT pg_terminate_backend(&lt;pid&gt;);
</code></pre></div>
<p>pg_terminate_backend函数在成功时返回t，在失败时返回f。在第二个终端中再次查询pg_stat_activity，验证空闲进程是否结束。</p>
<div class="highlight"><pre><span></span><code>SELECT datname, pid, application_name, state, query
FROM pg_stat_activity;
</code></pre></div>
<p>示例3：其他与时间相关的查询
您可以运行一些与时间相关的查询来帮助识别长时间运行的事务。当该节点上有很多打开的连接时，这些功能特别有用。 
1.获取按当前txn_duration排序的进程列表：</p>
<div class="highlight"><pre><span></span><code>SELECT datname, pid, application_name, state, query, now() - xact_start AS txn_duration
FROM pg_stat_activity
ORDER BY txn_duration desc;
</code></pre></div>
<p>2.获取耗时超过1分钟的进程列表： </p>
<div class="highlight"><pre><span></span><code>SELECT datname, pid, application_name, state, query, xact_start
FROM pg_stat_activity
WHERE now() - xact_start &gt; &#39;1 min&#39;;
</code></pre></div>
<h3 id="_163"><strong>查看已终止的查询</strong></h3>
<p>使用bm_terminated_queries视图可以查看终止的查询及其终止原因。
当查询由于意外原因退出时，将存储有关查询和负责后端的信息。您可以使用bm_terminated_queries视图来访问这些信息，该视图构建在bm_pg_stat_get_queriess函数的顶部。该视图使用以下条件返回查询：</p>
<ul>
<li>临时文件大小超过temp_file_limit。 </li>
<li>由SIGSEGV终止-查询因PostgreSQL进程崩溃而终止。</li>
<li>由SIGKILL终止-由于节点内存不足，查询被系统的内存不足杀手终止。
  此视图，可能默认情况下，并未创建。请自行执行如下脚本，进行此视图的创建：</li>
</ul>
<div class="highlight"><pre><span></span><code>CREATE view bm_terminated_queries AS
    SELECT
            D.datname AS databasename,
            S.backend_pid AS backend_pid,
            S.query_text AS query_text,
            S.termination_reason AS termination_reason,
            S.query_start AS query_start_time,
            S.query_end AS query_end_time
    FROM bm_pg_stat_get_queries(null) AS S
    LEFT JOIN pg_database AS D ON (S.db_oid = D.oid);
</code></pre></div>
<p>下表中描述了bm_terminated_queries视图的列：</p>
<table>
<thead>
<tr>
<th></th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>databasename</td>
<td>Name</td>
<td>查询终止时后端连接到的数据库的名称。</td>
</tr>
<tr>
<td>backend_pid</td>
<td>Integer</td>
<td>后端进程ID</td>
</tr>
<tr>
<td>query_text</td>
<td>Text</td>
<td>已执行的查询，最多256个字符。</td>
</tr>
<tr>
<td>termination_reason</td>
<td>Text</td>
<td>查询终止原因的解释。其中之一：被SIGKILL终止;被SIGSEGV终止;临时文件大小超过temp_file_limit (xxx kB)</td>
</tr>
<tr>
<td>query_start_time</td>
<td>Timestampz</td>
<td>查询开始的时间。</td>
</tr>
<tr>
<td>query_end_time</td>
<td>Timestampz</td>
<td>查询终止的时间。</td>
</tr>
</tbody>
</table>
<h4 id="_164"><strong>示例</strong></h4>
<p>示例1:PostgreSQL崩溃 
要模拟PostgreSQL进程中的崩溃，请向后端进程发送SIGSEGV信号。 
1.在sqlsh会话中，获取后端pid： </p>
<div class="highlight"><pre><span></span><code>SELECT pg_backend_pid();
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> pg_backend_pid 
-------------------------
        1101347
</code></pre></div>
<p>2.在同一会话中，启动一个长时间运行的查询，以便在查询运行时有时间发送信号： </p>
<div class="highlight"><pre><span></span><code>SELECT * FROM generate_series(1, 123456789);
</code></pre></div>
<p>3.在另一个会话中，将终止信号发送到后端进程 </p>
<div class="highlight"><pre><span></span><code>kill -SIGSEGV 1101347  # 前面步骤获取的后端进程id
</code></pre></div>
<p>4.验证该查询是否列为已终止的查询，如下所示：</p>
<div class="highlight"><pre><span></span><code>SELECT backend_pid, query_text, termination_reason FROM bm_terminated_queries;
</code></pre></div>
<div class="highlight"><pre><span></span><code> backend_pid |         query_text                           |  termination_reason
-----------------+------------------------------------------------------------------+--------------------
    1101347  | SELECT * FROM generate_series(1, 123456789); | Terminated by SIGSEGV
</code></pre></div>
<p>示例2:超过临时文件限制
1.要模拟查询终止，请将temp_file_limit设置为0KB： </p>
<div class="highlight"><pre><span></span><code>SET temp_file_limit TO 0;
</code></pre></div>
<p>2.现在，任何需要临时文件的查询都将导致错误。要确保失败，请运行一个生成数亿行的查询，如下所示：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM generate_series(1, 123456789);
</code></pre></div>
<p>3.要在bm_terminated_queries中查找查询，请输入以下命令： </p>
<div class="highlight"><pre><span></span><code>SELECT backend_pid, query_text, termination_reason FROM bm_terminated_queries;
</code></pre></div>
<div class="highlight"><pre><span></span><code>backend_pid |         query_text                         |  termination_reason
---------------+---------------------------------------------------------------+----------------------------
  1114562  | SELECT * FROM generate_series(1, 123456789);  | temporary file size exceeds temp_file_limit (0kB)
</code></pre></div>
<p>示例3:内存不足 
当系统的内存严重不足时，将强制杀死进程。要模拟此情况，请向后端进程发送一个KILL信号。</p>
<p>1.在sqlsh会话中，获取后端PID：</p>
<div class="highlight"><pre><span></span><code>SELECT pg_backend_pid();
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> pg_backend_pid 
--------------------------
        1116699
</code></pre></div>
<p>2.在同一会话中，启动一个长时间运行的查询，以便在查询运行时有时间发送信号： </p>
<div class="highlight"><pre><span></span><code>SELECT * FROM generate_series(1, 123456789);
</code></pre></div>
<p>3.在另一个会话中，向后端进程发送终止信号： </p>
<div class="highlight"><pre><span></span><code>kill -KILL 1116699   # 前面步骤获取的后端进程id
</code></pre></div>
<p>4.验证该查询是否列为已终止的查询，如下所示：</p>
<div class="highlight"><pre><span></span><code>SELECT backend_pid, query_text, termination_reason FROM bm_terminated_queries;
</code></pre></div>
<div class="highlight"><pre><span></span><code> backend_pid |         query_text                        |  termination_reason
-----------------+----------------------------------------------------------------+--------------------------------
    1116699 | SELECT * FROM generate_series(1, 123456789); | Terminated by SIGKILL
</code></pre></div>
<p>示例4:从另一个数据库返回查询</p>
<p>1.通过运行以下命令创建终止的查询：</p>
<div class="highlight"><pre><span></span><code>SET temp_file_limit TO 0;
SELECT &#39;db1&#39; FROM generate_series(1, 123456789);
</code></pre></div>
<p>2.创建第二个数据库并按如下方式连接到该数据库：</p>
<div class="highlight"><pre><span></span><code>CREATE DATABASE new_db;
\c new_db;
</code></pre></div>
<p>3.通过运行以下命令创建第二个终止的查询： </p>
<div class="highlight"><pre><span></span><code>SET temp_file_limit TO 0;
SELECT &#39;db2&#39; FROM generate_series(1, 123456789);
</code></pre></div>
<p>4.在不提供数据库名称的情况下查询bm_terminated_queries视图将返回两个查询： </p>
<div class="highlight"><pre><span></span><code>SELECT query_text FROM bm_terminated_queries;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>                    query_text
-----------------------------------------------------------------------
 SELECT &#39;db1&#39; FROM generate_series(1, 123456789);
 SELECT &#39;db2&#39; FROM generate_series(1, 123456789);
</code></pre></div>
<p>5.当您使用当前数据库的名称查询bm_terminated_queries时，您只能看到该数据库的条目。</p>
<p>使用数据库名称从bigmath数据库中获取终止的查询，如下所示： </p>
<div class="highlight"><pre><span></span><code>SELECT query_text FROM bm_terminated_queries WHERE databasename=&#39;bigmath&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> query_text
--------------------------------------------------------------------
 SELECT &#39;db1&#39; FROM generate_series(1, 123456789);
</code></pre></div>
<p>使用数据库名称从新的数据库中获取终止的查询，如下所示：</p>
<div class="highlight"><pre><span></span><code>SELECT query_text FROM bm_terminated_queries WHERE databasename=&#39;new_db&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> query_text
--------------------------------------------------------------------
 SELECT &#39;db2&#39; FROM generate_series(1, 123456789);
</code></pre></div>
<h4 id="_165"><strong>局限性</strong></h4>
<p>此视图存在如下的一定局限性：</p>
<ul>
<li>查询返回的基础数据每隔500毫秒刷新一次，因此，如果没有列出最近终止的查询，请再次尝试查询。</li>
<li>在开始覆盖第一个查询之前，后端最多可容纳1000个失败的查询。</li>
<li>如果stat收集器进程突然终止，则底层数据可能已损坏且无效。 </li>
</ul>
<h3 id="_166"><strong>查看复制状态</strong></h3>
<p>BMDB支持PostgreSQL 的pg_stat_progress_copy视图，报告copy命令执行的进度。无论何时运行COPY，pg_stat_progress_copy视图都会为当前运行COPY命令的每个客户端连接包含一行。</p>
<p>下表中描述了pg_stat_progress_copy视图的列：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pid</td>
<td>integer</td>
<td>后端的进程ID。</td>
</tr>
<tr>
<td>datid</td>
<td>oid</td>
<td>此后端连接到的数据库的对象ID。</td>
</tr>
<tr>
<td>datname</td>
<td>name</td>
<td>此后端连接到的数据库的名。</td>
</tr>
<tr>
<td>relid</td>
<td>oid</td>
<td>执行COPY命令的表的对象ID。如果从SELECT查询进行复制，则将其设置为0。</td>
</tr>
<tr>
<td>command</td>
<td>text</td>
<td>运行COPY FROM或COPY TO的命令。</td>
</tr>
<tr>
<td>type</td>
<td>text</td>
<td>读取或写入数据的I/O类型：FILE、PROGRAM、PIPE（用于COPY from STDIN和COPY to STDOUT）或CALLBACK（例如在逻辑复制中的初始表同步期间使用）。</td>
</tr>
<tr>
<td>bm_status</td>
<td>text</td>
<td>跟踪复制命令的状态。</td>
</tr>
<tr>
<td>bytes_processed</td>
<td>bigint</td>
<td>COPY命令已处理的字节数。</td>
</tr>
<tr>
<td>bytes_total</td>
<td>bigint</td>
<td>COPY FROM命令的源文件的大小（以字节为单位）。如果不可用，请设置为0。</td>
</tr>
<tr>
<td>tuples_processed</td>
<td>bigint</td>
<td>COPY命令已处理的元组数。</td>
</tr>
<tr>
<td>tuples_excluded</td>
<td>bigint</td>
<td>由于被COPY命令的WHERE子句排除而未处理的元组数。</td>
</tr>
</tbody>
</table>
<h4 id="bmdb_4"><strong>BMDB特定的更改</strong></h4>
<p>pg_stat_progress_copy视图包括以下BMDB特定的更改项：</p>
<h5 id="tuples_processed"><strong>tuples_processed定义</strong></h5>
<p>与PostgreSQL相比，BMDB中tuples_processed列的定义有所不同。 
在BMDB中，ROWS_PER_TRANSACTION选项被添加到COPY命令中，定义要使用的事务大小。例如，如果要复制的元组总数为5000，并且ROWS_PER_TRANSACTION设置为1000，则数据库创建5个事务，每个事务插入1000行。如果在执行过程中出现错误，则可以基于已完成的事务持久化一些元组。
因为每个COPY都被划分为多个事务，所以tuples_processed跟踪事务已经完成的行。
ROWS_PER_TRANSACTION：ROWS_PER_TRANSACTION选项定义了COPY命令要使用的事务大小，默认值：20000。
例如，如果要复制的元组总数为5000，并且ROWS_PER_TRANSACTION设置为1000，则数据库将创建5个事务，每个事务将插入1000行。如果在执行复制命令的过程中出现错误，则可以基于已完成的事务持久化一些元组。这意味着，如果在插入第3500行之后发生错误，那么前3000行将被保留在数据库中。</p>
<h5 id="bm_status"><strong>bm_status新列</strong></h5>
<p>在BMDB中，pg_stat_progress_copy视图包括bm_status列，用于指示copy命令的状态。
如果COPY命令因任何错误而终止，则可能会保留一些元组，如tuples_processed部分所述。在这种情况下，tuples_processed显示非零计数，bm_status显示COPY命令因错误而终止。这有助于发现复制是否已完成。这在PostgreSQL中是不必要的，因为副本是单个事务。
bm_status 有如下可能的值：</p>
<ul>
<li>IN PROGRESS – 表示COPY命令仍在运行。 </li>
<li>ERROR – COPY命令因错误而终止。 </li>
<li>SUCCESS – COPY命令已成功完成。 </li>
</ul>
<h5 id="copy_1"><strong>COPY 命令信息</strong></h5>
<p>pg_stat_progress_copy视图在copy 操作完成后保留copy 命令信息。
在PostgreSQL中，当COPY命令完成时，包含COPY命令详细信息的行将从视图中删除。在BMDB中，信息在copy 完成后保留在视图中。该信息仅保留用于该连接上最后执行的copy 命令。
这是BMDB所必需的，因为如果COPY命令由于错误而完成，那么您可能想知道有多少行被持久化到磁盘上。</p>
<h4 id="_167"><strong>示例</strong></h4>
<p>以下示例演示了copy操作的可能阶段（IN PROGRESS、ERROR、SUCCESS）。
先决条件
从BMDB安装目录运行以下脚本，将数据生成到文件test_data.csv中。 </p>
<div class="highlight"><pre><span></span><code>#!/bin/bash
rm -rf test_data.csv
for i in {1..100000}
do
   echo &quot;$i, $i, $i&quot; &gt;&gt; test_data.csv
done
</code></pre></div>
<p>从本地BMDB安装目录，连接到BSQL shell，并创建如下表：</p>
<div class="highlight"><pre><span></span><code>create table test_copy ( h1 int, r1 int, v1 int, primary key (h1, r1));
</code></pre></div>
<p>示例1：允许成功的copy命令
1.使用如下的copy命令来复制test_data.csv</p>
<div class="highlight"><pre><span></span><code>\copy test_copy from &#39;test_data.csv&#39;  (DELIMITER &#39;,&#39;);  
</code></pre></div>
<p>2.使用此视图确认bm_status</p>
<div class="highlight"><pre><span></span><code>select * from pg_stat_progress_copy ;
</code></pre></div>
<p>返回信息类似如下：</p>
<div class="highlight"><pre><span></span><code>pid   | datid | datname | relid |  command    | type | bm_status | bytes_processed | bytes_total | tuples_processed | tuples_excluded 
---------+-------+---------+-------+-------------------+------+-----------+---------------------+-------------+---------------------+-----------------
1253198 | 13291 | bigmath | 16780 | COPY FROM | PIPE | SUCCESS |     1966685 |        0 |         100000|         0
</code></pre></div>
<p>示例2：验证正在执行的COPY命令状态 </p>
<p>使用以下copy命令复制test_data.csv，并从另一个终端并行检查状态。 </p>
<div class="highlight"><pre><span></span><code>\copy test_copy from &#39;test_data.csv&#39;  (DELIMITER &#39;,&#39;);
</code></pre></div>
<p>select * from pg_stat_progress_copy ;
返回信息类似如下：
pid   | datid   | datname | relid |  command    | type |  bm_status     | bytes_processed | bytes_total | tuples_processed | tuples_excluded 
--------+----------+---------+-------+-----------+------+-------------+-----------------+--------------------+------------+---------------------+------------------
1253198 | 13291 | bigmath | 16780 | COPY FROM | PIPE | IN PROGRESS  |      366682 |       0 |           20000 |           0</p>
<p>示例3：验证中断的COPY操作
1.使用以下命令复制test_data.csv，然后使用Ctrl+C中断它： </p>
<div class="highlight"><pre><span></span><code>\copy test_copy from &#39;test_data.csv&#39;  (DELIMITER &#39;,&#39;);
</code></pre></div>
<p>报告错误信息如下：</p>
<div class="highlight"><pre><span></span><code>^CCancel request sent
ERROR:  canceling statement due to user request
CONTEXT:  COPY test_copy, line 93389: &quot;93389, 93389, 93389&quot;
</code></pre></div>
<p>2.使用此视图确认bm_status</p>
<div class="highlight"><pre><span></span><code>select * from pg_stat_progress_copy ;
</code></pre></div>
<p>返回信息类似如下：</p>
<p>pid    | datid  | datname | relid  |  command   | type | bm_status | bytes_processed | bytes_total | tuples_processed | tuples_excluded 
---------+--------+------------+-------+-------------------+------+-----------+---------------------+-------------+---------------------+-----------------
1253198 | 13291 | bigmath | 16780 | COPY FROM | PIPE | ERROR  |       766682 |        0 |          80000|          0</p>
<p>ROWS_PER_TRANSACTION的默认值是20K，并且中断发生在示例中的第93389行。结果，20K行的前4个事务被持久化，导致tuples_processed报告了80K行。下一个正在进行的事务被中断，因此剩余的6611行没有被持久化。 </p>
<h3 id="_168"><strong>查看索引创建状态</strong></h3>
<p>可以使用CREATE INDEX语句向现有的表增加新的索引。BMDB支持在线索引回填，默认是启用的。使用此功能，您可以在线在非空表上构建索引，而不会导致其它并发写入失败。BMDB还支持CREATE INDEX NONCONCURRENTLY语句来禁用在线索引回填。</p>
<p>BMDB支持PostgreSQL pg_stat_progress_create_index视图来报告create index命令执行的进度。针对当前正在运行CREATE INDEX命令的每个后端连接，该视图包含一行数据，并且该行在命令执行完成后被清除。</p>
<p>pg_stat_progress_create_index视图可以提供以下详细信息：</p>
<ul>
<li>索引回填期间处理的行数。</li>
<li>命令的当前阶段可能是初始化或回填的阶段。</li>
<li>索引进度报告，索引的所有不同配置，或者索引的生成，例如非并发索引生成、GIN索引、部分索引和包含索引。 </li>
</ul>
<p>下表中描述了pg_stat_progress_create_index视图的列：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pid</td>
<td>integer</td>
<td>运行CREATE INDEX的后端的进程ID</td>
</tr>
<tr>
<td>datid</td>
<td>OID</td>
<td>此后端连接到的数据库的对象ID。</td>
</tr>
<tr>
<td>datname</td>
<td>name</td>
<td>此后端连接到的数据库的名。</td>
</tr>
<tr>
<td>relid</td>
<td>OID</td>
<td>创建索引所依据的表的OID。</td>
</tr>
<tr>
<td>index_relid</td>
<td>OID</td>
<td>索引的OID</td>
</tr>
<tr>
<td>command</td>
<td>text</td>
<td>正在运行的命令：CREATE INDEX CONCURRENTLY或 CREATE INDEX NONCONCURRENTLY</td>
</tr>
<tr>
<td>phase</td>
<td>text</td>
<td>索引创建的当前处理阶段。可能的阶段是initializing或者 backfilling</td>
</tr>
<tr>
<td>tuples_total</td>
<td>bigint</td>
<td>已处理的索引表元组数。</td>
</tr>
<tr>
<td>tuples_done</td>
<td>bigint</td>
<td>元组总数的估计值（在索引表中）。此值是从pg_class.reltuples中检索的。</td>
</tr>
<tr>
<td>partitions_total</td>
<td>bigint</td>
<td>如果正在进行的CREATE INDEX是针对分区表的，则它指的是表中的分区总数。否则设置为0。</td>
</tr>
<tr>
<td>partitions_done</td>
<td>bigint</td>
<td>如果正在进行的CREATE INDEX是针对分区表的，那么它指的是已创建索引的分区数。否则设置为0。</td>
</tr>
</tbody>
</table>
<p>lockers_total、lockers_done、current_locker_pid、blocks_total和blocks_done等列不适用于BMDB，并且总是null值。</p>
<h4 id="bmdb_5"><strong>BMDB特定的更改</strong></h4>
<p>pg_stat_progress_create_index视图包括以下BMDB特定的更改项：</p>
<ul>
<li>
<p>在BMDB中，pg_stat_progress_create_index视图是本地视图；它只有本地BSQL客户端发出的CREATE INDEX命令的条目。</p>
</li>
<li>
<p>在PostgreSQL中，tuples_done和tuples_total指的是索引的元组。然而，在BMDB中，这些字段指的是索引表的元组。这种差异仅在部分指数中观察到，其中报告的进展小于实际进展。tuples_total是从pg_class.reltuples中检索到的估计值。</p>
</li>
<li>
<p>在BMDB中，针对临时索引，tuples_done和tuples_total不显示（设置为null）。</p>
</li>
</ul>
<h4 id="_169"><strong>示例</strong></h4>
<p>以下示例演示了使用pg_stat_progress_create_index视图进行CREATE INDEX操作的可能阶段（initializing, backfilling）。</p>
<p>1 从本地BMDB安装目录，连接到BSQL shell，并在现有表上创建索引，如下所示：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE customers(id int, customer_name text);
CREATE INDEX ON customers(customer_name);
</code></pre></div>
<p>2 在同一节点上的并行BSQL连接上，从视图中进行选择以查看命令的进度，如下所示： </p>
<div class="highlight"><pre><span></span><code>SELECT * FROM pg_stat_progress_create_index;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>pid   | datid  | datname| relid  | index_relid |       command             |    phase     | lockers_total | lockers_done | current_locker_pid | blocks_total | blocks_done | tuples_total | tuples_done | partitions_total | partitions_done
----------+--------+----------+-------+-------------+---------------------------+--------------+---------------+--------------+--------------------+--------------+-------------+--------------+-------------+------------------+-----------------
78841 | 13291  | bigmath| 16384 |       16390 | CREATE INDEX CONCURRENTLY | initializing |               |              |                    |              |             |       100000 |           0 |                0 |               0
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM pg_stat_progress_create_index;
</code></pre></div>
<div class="highlight"><pre><span></span><code>pid   | datid | datname  | relid | index_relid |          command          |    phase    | lockers_total | lockers_done | current_locker_pid | blocks_total | blocks_done | tuples_total | tuples_done | partitions_total | partitions_done
------+-------+----------+-------+-------------+---------------------------+-------------+---------------+--------------+--------------------+--------------+-------------+--------------+-------------+------------------+-----------------
77444 | 13291 | bigmath| 16404 |       16412 | CREATE INDEX CONCURRENTLY | backfilling |               |              |                    |              |             |       100000 |       49904 |                0 |               0
(1 row)
</code></pre></div>
<h3 id="_170"><strong>查询计划</strong></h3>
<p>本节介绍如何使用BSQL的EXPLAIN和EXPLAIN ANALYZE语句优化查询。</p>
<h4 id="explain_1"><strong>EXPLAIN语句</strong></h4>
<p>使用EXPLAIN语句，您可以获得由BSQL为给定SQL语句生成的查询执行计划。除了计划之外，EXPLAIN还返回以下信息:
1.启动成本，表示返回第一行之前的估计查询成本。
2.运行查询直至完成的总成本。
可以将EXPLAIN语句与SELECT、DELETE、INSERT、REPLACE和UPDATE语句结合使用。EXPLAIN语句的语法如下:</p>
<div class="highlight"><pre><span></span><code>EXPLAIN [ ( option [, ...] ) ] sql_statement;
</code></pre></div>
<p>下表中描述了选项（option）及其值。最重要的选项是ANALYZE。</p>
<table>
<thead>
<tr>
<th>选项（option）</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ANALYZE</td>
<td>boolean</td>
<td>通过执行sql_statement返回额外的运行时统计信息，例如在每个计划节点上花费的时间、处理的行数、查询执行期间的内存峰值使用情况等等(而不是像EXPLAIN不带ANALYZE那样只创建计划)。sql_statement的输出将被丢弃。输出包括查询执行过程中的峰值内存使用情况。为了在不影响数据的情况下对任何数据修改语句(如INSERT、UPDATE和DELETE)执行分析，必须在事务中使用以下语法包装EXPLAIN ANALYZE:BEGIN;EXPLAIN ANALYZE sql_statement;ROLLBACK;</td>
</tr>
<tr>
<td>VERBOSE</td>
<td>boolean</td>
<td>显示查询计划的详细信息。默认值为FALSE。</td>
</tr>
<tr>
<td>COSTS</td>
<td>boolean</td>
<td>提供每个计划节点的估计初始成本和总成本。此外，估计查询计划中的行数和每行的宽度。默认值为TRUE。</td>
</tr>
<tr>
<td>BUFFERS</td>
<td>boolean</td>
<td>提供有关查询中输入输出最密集部分的信息。默认值为FALSE。只有当ANALYZE设置为TRUE时，才能使用此选项。</td>
</tr>
<tr>
<td>TIMING</td>
<td>boolean</td>
<td>提供有关实际启动时间和输出的每个节点所花费的时间的信息。默认值为TRUE。只有当ANALYZE设置为TRUE时，才能使用此选项。</td>
</tr>
<tr>
<td>SUMMARY</td>
<td>boolean</td>
<td>提供附加信息，例如执行查询计划后的总时间。当ANALYZE设置为TRUE时，该选项的值为TRUE。</td>
</tr>
<tr>
<td>FORMAT</td>
<td>{ TEXT | XML | JSON | YAML }</td>
<td>允许您定义查询计划的输出格式，默认值为TEXT</td>
</tr>
</tbody>
</table>
<p><strong>示例</strong>
通常，首先在BrightDB中创建一个表，并向其中插入行。
要创建一个名为employees的表，执行以下命令:</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE employees(k1 int, k2 int, v1 int, v2 text, PRIMARY KEY (k1, k2));
</code></pre></div>
<p>要插入表行，执行以下命令:</p>
<div class="highlight"><pre><span></span><code>INSERT INTO employees (k1, k2, v1, v2)
VALUES (1, 2.0, 3, &#39;a&#39;), (2, 3.0, 4, &#39;b&#39;), (3, 4.0, 5, &#39;c&#39;);
</code></pre></div>
<p>检查基本选择查询的查询计划，执行如下命令:</p>
<div class="highlight"><pre><span></span><code>bigmath=# EXPLAIN SELECT * FROM employees WHERE k1 = 1;
</code></pre></div>
<p>以下输出显示查询执行成本估计值:</p>
<div class="highlight"><pre><span></span><code>    QUERY PLAN
------------------------------------------------------------------------------
 Index Scan using sample_pkey on sample  (cost=0.00..15.25 rows=100 width=44)
   Index Cond: (k1 = 1)
(2 rows)
</code></pre></div>
<p>如果需要查询需要过滤的复杂条件select的执行计划，执行如下命令:</p>
<div class="highlight"><pre><span></span><code>EXPLAIN SELECT * FROM employees
WHERE k1 = 2 and floor(k2 + 1.5) = v1;
</code></pre></div>
<p>下面的输出显示了基于过滤结果的成本估算:</p>
<div class="highlight"><pre><span></span><code>                                  QUERY PLAN
------------------------------------------------------------------------------
 Index Scan using sample_pkey on sample  (cost=0.00..17.75 rows=100 width=44)
   Index Cond: (k1 = 2)
   Filter: (floor(((k2)::numeric + 1.5)) = (v1)::numeric)
(3 rows)
</code></pre></div>
<p>通过启用ANALYZE选项并包装它以保持数据完整性，您可以触发查询执行，如下所示:</p>
<div class="highlight"><pre><span></span><code>BEGIN;
EXPLAIN ANALYZE SELECT * FROM employees
WHERE k1 = 2 and floor(k2 + 1.5) = v1;
ROLLBACK;
</code></pre></div>
<div class="highlight"><pre><span></span><code> QUERY PLAN
------------------------------------------------------------------------------------------------------------------------
 Index Scan using sample_pkey on sample  (cost=0.00..17.75 rows=100 width=44) (actual time=3.773..3.776 rows=1 loops=1)
   Index Cond: (k1 = 2)
   Filter: (floor(((k2)::numeric + 1.5)) = (v1)::numeric)
 Planning Time: 0.145 ms
 Execution Time: 4.840 ms
 Peak Memory Usage: 8 kB
(6 rows)
</code></pre></div>
<p>除了查询规划器的成本估算之外，EXPLAIN ANALYZE还显示语句执行期间产生的服务器输出，如下例所示:</p>
<div class="highlight"><pre><span></span><code>EXPLAIN ANALYZE SELECT * FROM employees a LEFT JOIN LATERAL
(SELECT * FROM employees b WHERE a = b) c ON TRUE;
</code></pre></div>
<div class="highlight"><pre><span></span><code>  QUERY PLAN
------------------------------------------------------------------------------------------------------------------------
 Merge Left Join  (cost=299.66..379.66 rows=5000 width=88) (actual time=2.382..2.389 rows=3 loops=1)
   Merge Cond: (a.* = b.*)
   -&gt;  Sort  (cost=149.83..152.33 rows=1000 width=112) (actual time=1.485..1.500 rows=3 loops=1)
         Sort Key: a.*
         Sort Method: quicksort  Memory: 25kB
         -&gt;  Seq Scan on employees a  (cost=0.00..100.00 rows=1000 width=112) (actual time=0.407..0.410 rows=3 loops=1)
   -&gt;  Sort  (cost=149.83..152.33 rows=1000 width=112) (actual time=0.657..0.658 rows=3 loops=1)
         Sort Key: b.*
         Sort Method: quicksort  Memory: 25kB
         -&gt;  Seq Scan on employees b  (cost=0.00..100.00 rows=1000 width=112) (actual time=0.278..0.280 rows=3 loops=1)
 Planning Time: 30.850 ms
 Execution Time: 3.943 ms
 Peak Memory Usage: 137 kB
(13 rows)
</code></pre></div>
<p>上一个示例的服务器输出包括每个节点执行的重新扫描(循环)次数、返回第一行之前经过的毫秒数、每个执行节点返回最后一个元组之前的总时间，以及每个执行节点返回的元组数量。
另一方面，EXPLAIN不提供这些附加信息，如下面的示例所示:</p>
<div class="highlight"><pre><span></span><code>bigmath=# EXPLAIN SELECT * FROM employees a LEFT JOIN LATERAL
(SELECT * FROM employees b WHERE a = b) c ON TRUE;
</code></pre></div>
<div class="highlight"><pre><span></span><code>                                  QUERY PLAN
------------------------------------------------------------------------------
 Merge Left Join  (cost=299.66..379.66 rows=5000 width=88)
   Merge Cond: (a.* = b.*)
   -&gt;  Sort  (cost=149.83..152.33 rows=1000 width=112)
         Sort Key: a.*
         -&gt;  Seq Scan on employees a  (cost=0.00..100.00 rows=1000 width=112)
   -&gt;  Sort  (cost=149.83..152.33 rows=1000 width=112)
         Sort Key: b.*
         -&gt;  Seq Scan on employees b  (cost=0.00..100.00 rows=1000 width=112)
(8 rows)
</code></pre></div>
<h4 id="_171"><strong>生产环境的例子</strong></h4>
<p>下面的示例来自一个真实场景，使用EXPLAIN语句查看查询计划，然后通过添加索引和调整表来优化这些查询。</p>
<h5 id="select-count"><strong>使用索引优化SELECT COUNT</strong></h5>
<p>下表代表了客户的数据。</p>
<div class="highlight"><pre><span></span><code>Table &quot;public.contacts&quot;
Column          | Type                           | Collation | Nullable | Default
------------------------+----------------------------------------------+------------+-----------+--------
id               | bigint                         |           | not null |
account_id        | integer                        |           |          |
email            | character varying                |           |          |
first_name        | character varying                |           |          |
last_name        | character varying                 |           |         |
address_line_1    | character varying                 |           |         |
address_line_2    | character varying                 |           |         |
address_city      | character varying                 |           |         |
address_state      | character varying                |           |         |
address_postal     | character varying                |           |         |
created_at        | timestamp(6) without time zone     |           | not null  |
updated_at        | timestamp(6) without time zone     |           | not null  |
is_over_charged   | boolean                         |           |         | false
is_paid           | boolean                         |           |         | false
data_source       | character varying                  |           |         |

Indexes:
    &quot;contacts_pkey&quot; PRIMARY KEY, lsm (id HASH)
</code></pre></div>
<p>运行以下带有EXPLAIN输出的查询将显示BSQL为给定SQL语句生成的查询执行计划。</p>
<div class="highlight"><pre><span></span><code>explain SELECT COUNT(*) FROM contacts WHERE contacts.account_id = 1234
    AND contacts.is_paid = TRUE
    AND contacts.is_over_charged = TRUE
    AND (updated_at &gt; &#39;2021-04-12 12:00:00 &#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>QUERY PLAN
----------------------------------------------
Aggregate (cost=107.50..107.51 rows=1 width=8)
    Seq Scan on contacts (cost=0.00..105.00 rows=1000 width=0)
        Filter: (is_paid AND is_over_charged AND (updated_at &gt; &#39;2021-04-12 12:00:00&#39;::timestamp without time zone) AND (account_id = 1234))
(3 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>explain SELECT COUNT(*) FROM contacts WHERE contacts.account_id = 5678
    AND contacts.is_paid_for = TRUE
    AND contacts.is_over_charged = TRUE
    AND (updated_at &gt; &#39;2021-04-12 12:00:00&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>QUERY PLAN
----------------------------------------------
Aggregate (cost=107.50..107.51 rows=1 width=8)
    Seq Scan on contacts (cost=0.00..105.00 rows=1000 width=0)
        Filter: (is_paid AND is_over_charged AND (updated_at &gt; &#39;2021-04-12 12:00:00&#39;::timestamp without time zone) AND (account_id = 5678))
(3 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>bigmath=# explain SELECT COUNT(*) FROM contacts WHERE contacts.account_id = 7890
    AND contacts.is_paid = FALSE
    AND (updated_at &gt; &#39;2021-04-12 12:00:00&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>QUERY PLAN
----------------------------------------------
Aggregate (cost=107.50..107.51 rows=1 width=8)
    Seq Scan on contacts (cost=0.00..105.00 rows=1000 width=0)
        Filter: ((NOT is_paid) AND (updated_at &gt; &#39;2021-04-12 12:00:00&#39;::timestamp without time zone) AND (account_id =1234))
(3 rows)
</code></pre></div>
<p>在每种情况下，查询都对表执行Seq扫描(顺序扫描)。该操作需要扫描整个表来检索所需的列。即使使用分区键进行查找，它仍然需要进行大量扫描。</p>
<p>在大多数情况下避免SELECT COUNT(*)查询，因为它们可能需要对表进行完整扫描才能获得结果。这可能会导致查询性能下降，在某些情况下还会导致查询根本不返回。</p>
<p>由于上面的大多数查询都使用account_id作为主要限定符，因此可以通过在该列上创建直接索引，然后使用INCLUDE特性覆盖索引中需要的其他列，从而避免顺序扫描。索引是一种强大的工具，可以加快具有较高延迟的查询。在创建索引时，要考虑列基数以及不同的索引类型。</p>
<p>按如下方法创建索引:</p>
<div class="highlight"><pre><span></span><code>create index contacts_account_id on contacts (account_id hash, updated_at desc) include (is_paid, is_over_charged);
</code></pre></div>
<p>有了索引后，查询现在执行索引而不是顺序扫描来获取数据，从而显著提高了性能。</p>
<div class="highlight"><pre><span></span><code>bigmath=# explain SELECT COUNT(*) FROM contacts WHERE contacts.account_id = 1234
    AND contacts.is_paid = TRUE
    AND contacts.is_over_charged = TRUE
    AND (updated_at &gt; &#39;2021-04-12 12:00:00&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>QUERY PLAN
------------------------------------------
Aggregate (cost=5.30..5.31 rows=1 width=8)
    Index Scan using contacts_account_id on contacts (cost=0.00..5.28 rows=10 width=0)
    Index Cond: (account_id = 1234)
        Filter: (is_paid AND is_over_charged AND (updated_at &gt; &#39;2021-04-12 12:00:00&#39;::timestamp without time zone))
(4 rows)

Time: 57.208 ms
Previous run time: 194 seconds
</code></pre></div>
<div class="highlight"><pre><span></span><code>bigmath=# explain SELECT COUNT(*) FROM contacts WHERE contacts.account_id = 5678
    AND contacts.is_paid = TRUE
    AND contacts.is_over_charged = TRUE
    AND (updated_at &gt; &#39;2021-04-12 12:00:00&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>QUERY PLAN
------------------------------------------
Aggregate (cost=5.30..5.31 rows=1 width=8)
    Index Scan using contacts_account_id on contacts (cost=0.00..5.28 rows=10 width=0)
    Index Cond: (account_id = 5678)
        Filter: (is_paid AND is_over_charged AND (updated_at &gt; &#39;2021-04-12 12:00:00&#39;::timestamp without time zone))
(4 rows)

Time: 11.923 ms
Previous run time 188 seconds
</code></pre></div>
<div class="highlight"><pre><span></span><code>bigmath=# explain SELECT COUNT(*) FROM contacts WHERE contacts.account_id = 7890
    AND contacts.is_paid = FALSE
    AND (updated_at &gt; &#39;2021-04-12 12:00:00&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>QUERY PLAN
------------------------------------------
Aggregate (cost=5.30..5.31 rows=1 width=8)
    Index Scan using contacts_account_id on contacts (cost=0.00..5.28 rows=10 width=0)
    Index Cond: (account_id = 8060)
        Filter: ((NOT is_paid) AND (updated_at &gt; &#39;2021-04-12 12:00:00&#39;::timestamp without time zone))
(4 rows)

Time: 46.658 ms
Previous run time: 147 seconds
</code></pre></div>
<h5 id="select"><strong>通过更改表排序优化SELECT</strong></h5>
<p>以下查询从已定义某些索引的帐户表中检索数据。</p>
<p>表定义：</p>
<div class="highlight"><pre><span></span><code>bigmath=# \d accounts
</code></pre></div>
<pre><code>                                Table "public.accounts"
</code></pre>
<div class="highlight"><pre><span></span><code>Column        | Type                        | Collation | Nullable | Default
--------------+-----------------------------+-----------+----------+--------
id            | bigint                      | For       | not null | nextval(&#39;accounts_id_seq&#39;::regclass)
company_name  | character varying(125)      |           | not null |
status        | character varying(25)       |           |          |
first_name    | character varying(55)       |           |          |
last_name     | character varying(55)       |           |          |
phone         | character varying(25)       |           |          |
created_at    | timestamp without time zone |           | not null |
updated_at    | timestamp without time zone |           | not null |
product_id    | integer                     |           |          |
business_type | character varying(55)       |           |          |
sales_rep     | character varying           |           |          |

Indexes:
    &quot;accounts_pkey&quot; PRIMARY KEY, lsm (id HASH)
    &quot;index_on_company_name&quot; lsm (company_name HASH)
</code></pre></div>
<p>EXPLAIN查询的输出如下所示：</p>
<div class="highlight"><pre><span></span><code>bigmath=# explain SELECT accounts.* FROM accounts
    ORDER BY accounts.id desc, accounts.id desc LIMIT 25 OFFSET 0;
</code></pre></div>
<div class="highlight"><pre><span></span><code>QUERY PLAN
----------------------------------------------
Limit (cost=128.22..128.28 rows=25 width=1642)
    Sort (cost=128.22..130.72 rows=1000 width=1642)
        Sort Key: id DESC
            Seq Scan on accounts (cost=0.00..100.00 rows=1000 width=1642)
</code></pre></div>
<p>在这种情况下，首先运行排序，这会给查询增加额外的时间，然后再运行表的顺序扫描，这也会降低性能。
为了优化这个查询，将表的主键排序调整为DESC而不是HASH。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE public.accounts ( id bigint NOT NULL, ... ,PRIMARY KEY(id desc);
</code></pre></div>
<p>现在，查询不再执行顺序扫描;相反，它使用索引扫描，将执行时间从430毫秒减少到3毫秒。</p>
<div class="highlight"><pre><span></span><code>bigmath=# explain SELECT accounts.* FROM accounts
    ORDER BY accounts.id desc, accounts.id desc LIMIT 25 OFFSET 0;
</code></pre></div>
<div class="highlight"><pre><span></span><code>QUERY PLAN
------------------------------------------
Limit (cost=0.00..2.85 rows=25 width=1642)
    Index Scan using accounts_pkey on accounts (cost=0.00..114.00 rows=1000 width=1642)

Time: 2.994 ms
Previous run time: 426.627 ms
</code></pre></div>
<h5 id="select_1"><strong>使用索引优化SELECT</strong></h5>
<p>以下示例中的查询运行顺序扫描，可以通过添加索引来修复。</p>
<div class="highlight"><pre><span></span><code>bigmath=# \d account_type
</code></pre></div>
<pre><code>                                Table "public.account_type"
</code></pre>
<div class="highlight"><pre><span></span><code>Column      | Type                           | Collation | Nullable | Default
------------+--------------------------------+-----------+----------+--------
id          | bigint                         |           | not null | nextval(&#39;account_domains_id_seq&#39;::regclass)
account_id  | integer                        |           | For      |
type        | character varying(55)          |           |          |
url         | character varying              |           |          |
is_valid    | boolean                        |           |          |
created_at  | timestamp(6) without time zone |           | not null |
updated_at  | timestamp(6) without time zone |           | not null |
verified_at | timestamp without time zone    |           |          |

Indexes:
    &quot;account_type_pkey&quot; PRIMARY KEY, lsm (id HASH)
</code></pre></div>
<div class="highlight"><pre><span></span><code>bigmath=# explain SELECT account_type.* FROM account_type
    WHERE account_type.account_id = 1234 ORDER BY account_type.url ASC;
</code></pre></div>
<div class="highlight"><pre><span></span><code>QUERY PLAN
----------------------------------------------
Sort (cost=152.33..154.83 rows=1000 width=237)
    Sort Key: url
        Seq Scan on account_type (cost=0.00..102.50 rows=1000 width=237)
            Filter: (account_id = 6873)
</code></pre></div>
<p>查询在account_type表上运行顺序扫描，因此在account_id上添加索引可以防止对表进行完整扫描，如下所示:</p>
<div class="highlight"><pre><span></span><code>create index account_id on account_type(account_id);
</code></pre></div>
<p>使用新索引，查询扫描索引而不是更大的主表，从而显著提高了性能。</p>
<div class="highlight"><pre><span></span><code>bigmath=# explain SELECT account_type.* FROM account_type
    WHERE account_type.account_id = 6873 ORDER BY account_type.url ASC;
</code></pre></div>
<div class="highlight"><pre><span></span><code>QUERY PLAN
----------------------------------------
Sort (cost=5.39..5.42 rows=10 width=237)
    Sort Key: url
        Index Scan using account_id on account_type (cost=0.00..5.22 rows=10 width=237)
            Index Cond: (account_id = 6873)

Time: 71.757 ms
Previous runtime: 460 ms
</code></pre></div>
<h3 id="bsql_4"><strong>优化BSQL查询</strong></h3>
<p>BrightDB利用PostgreSQL的pg_hint_plan扩展来控制查询执行计划。
BrightDB使用PostgreSQL的基于成本的优化器，该优化器估计SQL语句的每个可能执行计划的成本。执行成本最低的执行计划。计划者尽其所能选择最佳的执行计划，但并不完美。此外，BrightDB使用的规划器版本不是最优的。例如，基于成本的优化器很幼稚，它假设所有表的行数为1000。然而，行数在计算成本估算中起着至关重要的作用。为了克服这些限制，可以使用pg_hint_plan。
pg_hint_plan使得使用“hints”来调整执行计划成为可能，“hints”是以SQL注释形式来描述。</p>
<p>重新审视你的提示计划
要有效地使用pg_hint_plan，您需要彻底了解如何部署应用程序。当数据库增长或部署更改时，还需要重新访问提示计划，以确保该计划不会限制性能，而是优化性能。</p>
<h4 id="pg_hint_plan"><strong>配置pg_hint_plan</strong></h4>
<p>pg_hint_plan是预先配置的，默认是启用的。下面的BSQL配置参数控制pg_hint_plan:</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>pg_hint_plan.enable_hint</td>
<td>打开或关闭pg_hint_plan。</td>
<td>on</td>
</tr>
<tr>
<td>pg_hint_plan.debug_print</td>
<td>控制调试输出。有效值为off(无调试输出)、on、detailed和verbose。</td>
<td>off</td>
</tr>
<tr>
<td>pg_hint_plan.message_level</td>
<td>指定调试输出的最小消息级别。按照严重程度递减的顺序，这些级别是:error, warning, notice, info, log和debug。fatal和panic级别的消息总是包含在输出中。</td>
<td>info</td>
</tr>
</tbody>
</table>
<p><strong>开启pg_hint_plan</strong>
启用pg_hint_plan，命令如下:</p>
<div class="highlight"><pre><span></span><code>bigmath=# SET pg_hint_plan.enable_hint=ON;
</code></pre></div>
<p><strong>打开调试输出</strong>
要查看pg_hint_plan使用并转发给查询规划器的特定提示，请打开调试输出。这对于提示短语中出现语法错误或错误提示名称的情况很有帮助。要查看这些调试打印，运行以下命令:</p>
<div class="highlight"><pre><span></span><code>bigmath=# SET pg_hint_plan.debug_print TO on;
bigmath=# \set SHOW_CONTEXT always
bigmath=# SET client_min_messages TO log;
</code></pre></div>
<h4 id="_172"><strong>编写提示计划</strong></h4>
<p>pg_hint_plan解析SQL语句中出现的特殊形式的提示短语。这种特殊形式以字符序列/<em>+开始，以</em>/结束。提示短语由提示名称后跟用括号括起来并以空格分隔的提示参数组成。
在下面的示例中，选择HashJoin作为连接pg_bench_branches和pg_bench_accounts的连接方法，并使用SeqScan扫描表pgbench_accounts。</p>
<div class="highlight"><pre><span></span><code>bigmath=# /*+
bigmath*#    HashJoin(a b)
bigmath*#    SeqScan(a)
bigmath*#  */
bigmath-# EXPLAIN SELECT *
bigmath-#    FROM pgbench_branches b
bigmath-#    JOIN pgbench_accounts a ON b.bid = a.bid
bigmath-#   ORDER BY a.aid;
</code></pre></div>
<div class="highlight"><pre><span></span><code>                                    QUERY PLAN
---------------------------------------------------------------------------------------
 Sort  (cost=31465.84..31715.84 rows=100000 width=197)
   Sort Key: a.aid
   -&gt;  Hash Join  (cost=1.02..4016.02 rows=100000 width=197)
         Hash Cond: (a.bid = b.bid)
         -&gt;  Seq Scan on pgbench_accounts a  (cost=0.00..2640.00 rows=100000 width=97)
         -&gt;  Hash  (cost=1.01..1.01 rows=1 width=100)
               -&gt;  Seq Scan on pgbench_branches b  (cost=0.00..1.01 rows=1 width=100)
(7 rows)
</code></pre></div>
<h4 id="pg_hint_plan_1"><strong>使用pg_hint_plan</strong></h4>
<p>下面的表和索引定义在下面的例子中被用来说明pg_hint_plan的特性:</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE t1 (id int PRIMARY KEY, val int);
CREATE TABLE t2 (id int PRIMARY KEY, val int);
CREATE TABLE t3 (id int PRIMARY KEY, val int);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO t1 SELECT i, i % 100 FROM (SELECT generate_series(1, 10000) i) t;
INSERT INTO t2 SELECT i, i % 10 FROM (SELECT generate_series(1, 1000) i) t;
INSERT INTO t3 SELECT i, i FROM (SELECT generate_series(1, 100) i) t;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE INDEX t1_val ON t1 (val);
CREATE INDEX t2_val ON t2 (val);
CREATE INDEX t3_id1 ON t3 (id);
CREATE INDEX t3_id2 ON t3 (id);
CREATE INDEX t3_id3 ON t3 (id);
CREATE INDEX t3_val ON t3 (val);
</code></pre></div>
<p>表的模式如下:</p>
<div class="highlight"><pre><span></span><code> Table &quot;public.t1&quot;
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 id     | integer |           | not null |
 val    | integer |           |          |
Indexes:
    &quot;t1_pkey&quot; PRIMARY KEY, lsm (id HASH)
    &quot;t1_val&quot; lsm (val HASH)

                 Table &quot;public.t2&quot;
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 id     | integer |           | not null |
 val    | integer |           |          |
Indexes:
    &quot;t2_pkey&quot; PRIMARY KEY, lsm (id HASH)
    &quot;t2_val&quot; lsm (val HASH)

                 Table &quot;public.t3&quot;
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 id     | integer |           | not null |
 val    | integer |           |          |
Indexes:
    &quot;t3_pkey&quot; PRIMARY KEY, lsm (id HASH)
    &quot;t3_id1&quot; lsm (id HASH)
    &quot;t3_id2&quot; lsm (id HASH)
    &quot;t3_id3&quot; lsm (id HASH)
    &quot;t3_val&quot; lsm (val HASH)
</code></pre></div>
<p><strong>扫描方法hints</strong>
扫描方法hints与适当的提示短语一起指定时，对表强制执行扫描方法。应该通过别名指定所需的扫描方法和相应的目标表(如果有的话)。BrightDB支持以下扫描方法，使用来自pg_hint_plan的hints短语:</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SeqScan(table)</td>
<td>在表上启用SeqScan</td>
</tr>
<tr>
<td>NoSeqScan(table)</td>
<td>不要在表上启用SeqScan。</td>
</tr>
<tr>
<td>IndexScan(table)</td>
<td>在表上启用IndexScan</td>
</tr>
<tr>
<td>IndexScan(table idx)</td>
<td>在索引为idx的表上启用IndexScan</td>
</tr>
<tr>
<td>NoIndexScan(table)</td>
<td>不要在表上启用IndexScan。</td>
</tr>
<tr>
<td>IndexOnlyScan(table)</td>
<td>在表上启用IndexOnlyScan。</td>
</tr>
<tr>
<td>NoIndexOnlyScan(table)</td>
<td>不要在表上启用IndexOnlyScan。</td>
</tr>
<tr>
<td>IndexScanRegexp(table regex)</td>
<td>用regex定义的正则表达式的表启用索引表达式扫描</td>
</tr>
<tr>
<td>IndexOnlyScanRegexp(table regex)</td>
<td>不要在索引与正则表达式匹配的表上启用索引扫描</td>
</tr>
</tbody>
</table>
<p>在下面的例子中，提示/<em>+SeqScan(t2)</em>/允许使用SeqScan扫描表t2。</p>
<div class="highlight"><pre><span></span><code>/*+SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
</code></pre></div>
<div class="highlight"><pre><span></span><code>LOG:  pg_hint_plan:
used hint:
SeqScan(t2)
not used hint:
duplication hint:
error hint:

              QUERY PLAN
--------------------------------------
 Nested Loop
   -&gt;  Seq Scan on t2
   -&gt;  Index Scan using t1_pkey on t1
         Index Cond: (id = t2.id)
(4 rows)
</code></pre></div>
<p>在下面的例子中，由于提示/<em>+SeqScan(t1)IndexScan(t2)</em>/， t2使用IndexScan扫描，t1使用SeqScan扫描。</p>
<div class="highlight"><pre><span></span><code>/*+SeqScan(t1)IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
</code></pre></div>
<div class="highlight"><pre><span></span><code>LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:

              QUERY PLAN
--------------------------------------
 Nested Loop
   -&gt;  Seq Scan on t1
   -&gt;  Index Scan using t2_pkey on t2
         Index Cond: (id = t1.id)
(4 rows)
</code></pre></div>
<p>还可以使用hints短语指示查询规划器不要使用特定类型的扫描。如下例所示，提示/<em>+NoIndexScan(t1)</em>/限制了表t1上的IndexScan。</p>
<div class="highlight"><pre><span></span><code>/*+NoIndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
</code></pre></div>
<div class="highlight"><pre><span></span><code>LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
not used hint:
duplication hint:
error hint:

              QUERY PLAN
--------------------------------------
 Nested Loop
   -&gt;  Seq Scan on t1
   -&gt;  Index Scan using t2_pkey on t2
         Index Cond: (id = t1.id)
(4 rows)
</code></pre></div>
<p><strong>在hint短语中指定索引</strong>
单个表可以有多个索引。使用pg_hint_plan，您可以指定在对表执行扫描时要使用的确切索引。以表t3为例。它包含列id的多个索引(t3_pkey, t3_id1, t3_id2, t3_id3)。通过使用适当的hint短语执行SQL查询，您可以选择这些索引中的任何一个来运行扫描。
（1）不带hint短语的查询:</p>
<div class="highlight"><pre><span></span><code>EXPLAIN (COSTS false) SELECT * FROM t3 WHERE t3.id = 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>  QUERY PLAN
--------------------------------
 Index Scan using t3_pkey on t3
   Index Cond: (id = 1)
(2 rows)
</code></pre></div>
<p>（2）使用二级索引查询:</p>
<div class="highlight"><pre><span></span><code>/*+IndexScan(t3 t3_id2)*/
EXPLAIN (COSTS false) SELECT * FROM t3 WHERE t3.id = 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>LOG:  available indexes for IndexScan(t3): t3_id2
LOG:  pg_hint_plan:
used hint:
IndexScan(t3 t3_id2)
not used hint:
duplication hint:
error hint:

          QUERY PLAN
-------------------------------
 Index Scan using t3_id2 on t3
   Index Cond: (id = 1)
(2 rows)
</code></pre></div>
<p>（3）查询返回到SeqScan，因为没有索引可以使用:</p>
<div class="highlight"><pre><span></span><code>/*+IndexScan(t3 no_exist)*/
EXPLAIN (COSTS false) SELECT * FROM t3 WHERE t3.id = 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>LOG:  available indexes for IndexScan(t3):
LOG:  pg_hint_plan:
used hint:
IndexScan(t3 no_exist)
not used hint:
duplication hint:
error hint:

     QUERY PLAN
--------------------
 Seq Scan on t3
   Filter: (id = 1)
(2 rows)
</code></pre></div>
<p>（4）有选择性索引列表的查询:</p>
<div class="highlight"><pre><span></span><code>/*+IndexScan(t3 t3_id1 t3_id2)*/
EXPLAIN (COSTS false) SELECT * FROM t3 WHERE t3.id = 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>LOG:  available indexes for IndexScan(t3): t3_id2 t3_id1
LOG:  pg_hint_plan:
used hint:
IndexScan(t3 t3_id1 t3_id2)
not used hint:
duplication hint:
error hint:

          QUERY PLAN
-------------------------------
 Index Scan using t3_id2 on t3
   Index Cond: (id = 1)
(2 rows)
</code></pre></div>
<p>在前面的示例中，执行第一个查询时没有提示短语。因此，索引扫描使用主键索引t3_pkey。但是，第二个查询包含提示/<em>+IndexScan(t3 t3_id2)</em>/，因此它使用二级索引t3_id2执行索引扫描。当提供提示短语/<em>+IndexScan(t3 no_exist)</em>/时，计划器将恢复到SeqScan，因为没有索引可以使用。还可以在提示短语中提供索引的选择性列表，由查询规划器从中进行选择。</p>
<p><strong>连接方法的hints</strong>
连接方法hints强制SQL语句的连接方法。使用pg_hint_plan，您可以指定连接表的方法。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashJoin(t1 t2 t3 ...)</td>
<td>使用HashJoin连接t1、t2和t3。</td>
</tr>
<tr>
<td>NoHashJoin(t1 t2 t3 ...)</td>
<td>不要使用HashJoin连接t1、t2和t3</td>
</tr>
<tr>
<td>NestLoop(t1 t2 t3 ...)</td>
<td>使用NestLoop Join连接t1、t2和t3。</td>
</tr>
<tr>
<td>NoNestLoop(t1 t2 t3 ...)</td>
<td>不要使用NestLoop join连接t1、t2和t3。</td>
</tr>
<tr>
<td>BMDBBatchedNL(t1 t2)</td>
<td>使用BMDBBatchedNL Join连接t1和t2。</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code>/*+HashJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
</code></pre></div>
<div class="highlight"><pre><span></span><code>LOG:  pg_hint_plan:
used hint:
HashJoin(t1 t2)
not used hint:
duplication hint:
error hint:

          QUERY PLAN
------------------------------
 Hash Join
   Hash Cond: (t1.id = t2.id)
   -&gt;  Seq Scan on t1
   -&gt;  Hash
         -&gt;  Seq Scan on t2
(5 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>/*+NestLoop(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
</code></pre></div>
<div class="highlight"><pre><span></span><code>LOG:  pg_hint_plan:
used hint:
NestLoop(t1 t2)
not used hint:
duplication hint:
error hint:

              QUERY PLAN
--------------------------------------
 Nested Loop
   -&gt;  Seq Scan on t1
   -&gt;  Index Scan using t2_pkey on t2
         Index Cond: (id = t1.id)
(4 rows)
</code></pre></div>
<p>在本例中，第一个查询分别对表t1和t2使用HashJoin，而第二个查询对表t1和t2使用NestedLoop连接。所需的连接方法在它们各自的hints短语中指定。您可以使用多个hints短语来组合连接方法和扫描方法。</p>
<div class="highlight"><pre><span></span><code>/*+NestLoop(t2 t3 t1) SeqScan(t3) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3
WHERE t1.id = t2.id AND t1.id = t3.id;
</code></pre></div>
<div class="highlight"><pre><span></span><code>LOG:  pg_hint_plan:
used hint:
SeqScan(t2)
SeqScan(t3)
NestLoop(t1 t2 t3)
not used hint:
duplication hint:
error hint:

              QUERY PLAN
--------------------------------------
 Nested Loop
   -&gt;  Hash Join
         Hash Cond: (t2.id = t3.id)
         -&gt;  Seq Scan on t2
         -&gt;  Hash
               -&gt;  Seq Scan on t3
   -&gt;  Index Scan using t1_pkey on t1
         Index Cond: (id = t2.id)
(8 rows)
</code></pre></div>
<p>在上面的例子中，提示/<em>+NestLoop(t2 t3 t1) SeqScan(t3) SeqScan(t2)</em>/使能表t1、t2、t3上的NestLoop join。由于hints短语，它还在表t3和t4上启用了SeqScan。其余的扫描使用IndexScan执行。</p>
<p><strong>加入顺序hints</strong>
连接顺序hints按特定顺序执行连接，如hints短语的参数列表中枚举的那样。可以使用Leading hints以特定顺序强制连接。</p>
<div class="highlight"><pre><span></span><code>/*+Leading(t1 t2 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t1.id = t3.id;
</code></pre></div>
<div class="highlight"><pre><span></span><code>                 QUERY PLAN
--------------------------------------------
 Nested Loop
   -&gt;  Nested Loop
         -&gt;  Seq Scan on t1
         -&gt;  Index Scan using t2_pkey on t2
               Index Cond: (id = t1.id)
   -&gt;  Index Scan using t3_pkey on t3
         Index Cond: (id = t1.id)
(7 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>/*+Leading(t2 t3 t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t1.id = t3.id;
</code></pre></div>
<div class="highlight"><pre><span></span><code>                 QUERY PLAN
--------------------------------------------
 Nested Loop
   -&gt;  Nested Loop
         -&gt;  Seq Scan on t2
         -&gt;  Index Scan using t3_pkey on t3
               Index Cond: (id = t2.id)
   -&gt;  Index Scan using t1_pkey on t1
         Index Cond: (id = t2.id)
(7 rows)
</code></pre></div>
<p>第一个查询的连接顺序是/<em>+Leading(t1 t2 t3)</em>/，而第二个查询的连接顺序是/<em>+Leading(t2 t3 t1)</em>/。您可以看到，查询计划的执行顺序遵循hints短语的参数列表中指定的连接顺序。</p>
<p><strong>设置工作区内存大小</strong>
您可以利用PostgreSQL中的work_mem设置来提高对大量表行进行排序、连接或聚合的慢速查询的性能。有关其含义的详细描述，请参见调优PostgreSQL中的work_mem设置以加速慢速SQL查询。</p>
<p>下面的示例展示了如何启用work_mem作为提示计划的一部分。</p>
<div class="highlight"><pre><span></span><code>/*+Set(work_mem &quot;1MB&quot;)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
</code></pre></div>
<div class="highlight"><pre><span></span><code>LOG:  pg_hint_plan:
used hint:
Set(work_mem 1MB)
not used hint:
duplication hint:
error hint:

              QUERY PLAN
--------------------------------------
 Nested Loop
   -&gt;  Seq Scan on t1
   -&gt;  Index Scan using t2_pkey on t2
         Index Cond: (id = t1.id)
(4 rows)
</code></pre></div>
<p><strong>配置计划器方法</strong>
计划器方法配置参数提供了一种影响查询优化器选择的查询计划的粗略方法。如果优化器为特定查询选择的默认计划不是最优的，那么临时解决方案是使用这些配置参数之一来强制优化器选择不同的计划。BrightDB支持以下配置参数:enable_hashagg、enable_hashjoin、enable_indexscan、enable_indexonlyscan、enable_material、enable_nestloop、enable_partition_pruning、enable_partitionwise_join、enable_partitionwise_aggregate、enable_seqscan、enable_sort。
Pg_hint_plan通过在每个查询的注释中嵌入这些配置参数来利用计划器方法配置。考虑下面的例子:</p>
<div class="highlight"><pre><span></span><code>EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
</code></pre></div>
<div class="highlight"><pre><span></span><code> QUERY PLAN
--------------------------------------
 Nested Loop
   -&gt;  Seq Scan on t1
   -&gt;  Index Scan using t2_pkey on t2
         Index Cond: (id = t1.id)
(4 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>/*+Set(enable_indexscan off)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
</code></pre></div>
<div class="highlight"><pre><span></span><code>LOG:  pg_hint_plan:
used hint:
Set(enable_indexscan off)
not used hint:
duplication hint:
error hint:

          QUERY PLAN
------------------------------
 Hash Join
   Hash Cond: (t1.id = t2.id)
   -&gt;  Seq Scan on t1
   -&gt;  Hash
         -&gt;  Seq Scan on t2
(5 rows)
</code></pre></div>
<p>第一个查询使用表t2中的IndexScan。但是，当添加/<em>+Set(enable_indexscan off)</em>/时，第二个查询使用表t2中的SeqScan。您可以在SQL查询的hints短语中组合任何参数。</p>
<p>有关Planner Method Configuration的更详细说明和可用配置参数的完整列表，请参阅PostgreSQL文档中的Planner Method Configuration。</p>
<p><strong>使用hints表</strong>
在每个查询中嵌入hints短语可能会让人不知所措。为了提供帮助，pg_hint_plan可以使用一个名为hint_plan.hits的表，来提示存储常用的hints短语。使用hints表，您可以对类似类型的查询进行分组，并指示pg_hint_plan为所有此类查询启用相同的hints短语。</p>
<p>启用hints表的命令如下:</p>
<div class="highlight"><pre><span></span><code>/* Create the hint_plan.hints table */
CREATE EXTENSION pg_hint_plan;

/*
 * Tell pg_hint_plan to check the hint table for
 * hint phrases to be embedded along with the query.
 */
SET pg_hint_plan.enable_hint_table = on;
</code></pre></div>
<p>下面的示例详细说明了这一点。</p>
<div class="highlight"><pre><span></span><code>bigmath=# INSERT INTO hint_plan.hints
(norm_query_string,
 application_name,
 hints)
VALUES
(&#39;EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = ?;&#39;,
 &#39;&#39;,
 &#39;SeqScan(t1)&#39;);

INSERT 0 1

bigmath=# INSERT INTO hint_plan.hints
(norm_query_string,
 application_name,
 hints)
VALUES
(&#39;EXPLAIN (COSTS false) SELECT id FROM t1 WHERE t1.id = ?;&#39;,
 &#39;&#39;,
 &#39;IndexScan(t1)&#39;);

INSERT 0 1

bigmath=# select * from hint_plan.hints;
</code></pre></div>
<div class="highlight"><pre><span></span><code>-[ RECORD 1 ]-----+--------------------------------------------------------
id                | 1
norm_query_string | EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = ?;
application_name  |
hints             | SeqScan(t1)
-[ RECORD 2 ]-----+--------------------------------------------------------
id                | 2
norm_query_string | EXPLAIN (COSTS false) SELECT id FROM t1 WHERE t1.id = ?;
application_name  |
hints             | IndexScan(t1)
</code></pre></div>
<p>本例将查询插入到hint_plan中。提示表，位置参数的占位符分别使用问号(?)和所需的hints短语。在运行时，当执行这些查询时，pg_hint_plan会自动使用它们各自的hints短语执行这些查询。</p>
<h2 id="_173"><strong>高可用</strong></h2>
<p>BMDB 可以在发生计划内或计划外停机时持续处理请求，例如系统升级以及与节点、可用区或区域相关的停机。</p>
<p>BMDB 通过跨故障域复制数据来提供高可用性 (HA)。 如果故障域发生故障，则在当前领导者发生故障后几秒钟内，活动副本就准备好接管作为新的领导者并服务请求。</p>
<p>这反映在 BMDB Universe 的恢复点目标 (RPO) 和恢复时间目标 (RTO) 中：</p>
<p>BMDB 全域中Tile的 RPO 为 0，这意味着在故障转移到另一个故障域时不会丢失任何数据。
区域中断的 RTO 大约为 3 秒，这是完成故障转移并在剩余故障域中恢复运行的时间窗口。
<img alt="" src="./media/chapter6/46.png" />
BMDB 还通过跨故障域复制未提交的值（也称为临时记录）来提供事务 HA。</p>
<p>持续可用性的好处扩展到执行维护和数据库升级。 您可以通过执行滚动升级来维护和升级您的 Universe 到较新版本的 BMDB； 也就是说，停止每个节点，升级软件，然后重新启动节点，整个Universe 的停机时间为零。</p>
<h3 id="_174"><strong>节点、可用区和区域级故障容灾</strong></h3>
<p>在节点、专区和区域故障期间保持请求服务。</p>
<h3 id="_175"><strong>事务高可用</strong></h3>
<p>高可用性和容错事务。
事务和弹性都是 BMDB 的关键功能，并且它们旨在协同工作。 这意味着即使在某些失败情况下事务也可以取得进展。</p>
<p>以下示例演示了 BMDB 事务如何应对处理事务时可能发生的常见故障场景。 在示例中，您执行更新单行的客户端驱动事务，故障场景如下表所示。</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>事务执行语句之前的leader节点故障</td>
<td>语句即将被发送到的leader节点在执行语句之前发生故障。 BMDB 会自动处理这个问题。</td>
</tr>
<tr>
<td>事务执行语句后leader节点故障</td>
<td>已向其发送语句的leader节点在事务提交之前发生故障。 BMDB 会自动处理这个问题</td>
</tr>
<tr>
<td>客户端连接的节点发生故障</td>
<td>客户端连接的节点在语句之后但事务提交之前发生故障。 数据库返回一个标准错误，该错误在客户端中使用重试逻辑进行处理</td>
</tr>
</tbody>
</table>
<h4 id="_176"><strong>前置条件</strong></h4>
<p>1.按照设置说明启动三节点 Universe。 这将创建一个包含 3 个不同区域中的节点的集群，如下图所示：
<img alt="" src="./media/chapter6/47.png" />
3. 使用 sqlsh 连接到您的 Universe
4. 创建一个表空间以确保示例事务中键的leader位于节点192.168.50.109中，如下所示：</p>
<div class="highlight"><pre><span></span><code>create tablespace txndemo_tablespace
with (replica_placement=&#39;{&quot;num_replicas&quot;:3,&quot;placement_blocks&quot;:[
{&quot;cloud&quot;:&quot;qq&quot;,&quot;region&quot;:&quot;east&quot;,&quot;zone&quot;:&quot;east-1&quot;,&quot;min_num_replicas&quot;:1,&quot;leader_preference&quot;:1},
{&quot;cloud&quot;:&quot;qq&quot;,&quot;region&quot;:&quot;south&quot;,&quot;zone&quot;:&quot;south-2&quot;,&quot;min_num_replicas&quot;:1,&quot;leader_preference&quot;:2},
{&quot;cloud&quot;:&quot;qq&quot;,&quot;region&quot;:&quot;west&quot;,&quot;zone&quot;:&quot;west-3&quot;,&quot;min_num_replicas&quot;:1,&quot;leader_preference&quot;:3}
 ]}&#39;);
</code></pre></div>
<ol>
<li>使用以下命令在表空间中创建表：</li>
</ol>
<div class="highlight"><pre><span></span><code>CREATE TABLE txndemo (
    k int,
    v int,
    PRIMARY KEY(k)
) TABLESPACE txndemo_tablespace;
</code></pre></div>
<p>由于leader首选项已设置为 192.168.50.109，因此 txndemo 表的所有leader现在都位于 192.168.50.109。
<img alt="" src="./media/chapter6/48.png" />
5.使用以下命令插入示例数据：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO txndemo SELECT id,10 FROM generate_series(1,5) AS id;
</code></pre></div>
<p>导航到 http://192.168.50.109:10000/tile-servers 以列出服务器并查看数据所在位置。
<img alt="" src="./media/chapter6/49.png" />
所有leader (3/3) 都在节点192.168.50.109中，这是您在以下故障场景中停止的节点。
使用以下命令检查 k=1 处的行的值：</p>
<div class="highlight"><pre><span></span><code>SELECT * from txndemo where k=1;

  k | v
----+----
  1 | 10
(1 row)
</code></pre></div>
<p>k=1 的行的值为v=10。</p>
<h4 id="1"><strong>场景1：事务执行语句之前节点发生故障</strong></h4>
<p>在事务期间，当修改或获取行时，BMDB 会将相应的请求发送到包含正在修改或获取的行的节点。</p>
<p>在此示例中，您可以通过关闭节点 192.168.50.109 来了解当即将接收临时写入的节点失败时事务如何完成，因为该节点具有事务将要修改的行。</p>
<p>下图说明了当节点在接收写入之前发生故障时确保事务成功的高级步骤。
<img alt="" src="./media/chapter6/50.png" />
1.按如下方式连接到节点192.168.50.142：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -h 127.0.0.1
</code></pre></div>
<p>2.开始事务如下：</p>
<div class="highlight"><pre><span></span><code>BEGIN;

BEGIN
Time: 2.047 ms
</code></pre></div>
<p>事务已启动，但尚未修改任何行。 此时，还没有临时记录发送到节点192.168.50.109。</p>
<p>3.停止节点192.168.50.109，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl stop --base_dir=/tmp/bmd2
</code></pre></div>
<p>4.导航到 http://192.168.50.109:10000/tile-servers 以验证节点 2 是否已从Tile列表中消失。
<img alt="" src="./media/chapter6/51.png" />192.168.50.109已dead，并且已为192.168.50.109中的所有Tile选举了新的leader 192.168.50.142。</p>
<p>5.将第 k=1 行的值更新为 20 并提交事务，如下所示：</p>
<div class="highlight"><pre><span></span><code>UPDATE txndemo set v=20 where k=1;
COMMIT;

UPDATE 1
Time: 1728.246 ms (00:01.728)
COMMIT
Time: 2.964 ms
</code></pre></div>
<p>即使节点192.168.50.109在接收临时写入之前发生故障，事务也会成功，并且值更新为 20。事务会成功，因为节点 192.168.50.109 故障后很快会选举出新的leader（192.168.50.142）。</p>
<p>6.使用以下命令检查 k=1 处的行的值：</p>
<div class="highlight"><pre><span></span><code>SELECT * from txndemo where k=1;

  k | v
----+----
  1 | 20
(1 row)
</code></pre></div>
<p>k=1 的行的新值 v=20，确认事务完成。</p>
<p>7.使用以下命令重新启动节点 192.168.50.109：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl start --base_dir=/tmp/bmd2
</code></pre></div>
<h4 id="2"><strong>场景2：事务执行语句后节点发生故障</strong></h4>
<p>正如前面的示例中提到的，当在事务期间修改或获取行时，BMDB 会将适当的语句发送到包含正在修改或获取的行的节点。 在此示例中，您可以看到当刚刚收到临时写入的节点失败时事务如何完成。</p>
<p>下图说明了当节点在收到语句后发生故障时确保事务成功的高级步骤。</p>
<p><img alt="" src="./media/chapter6/52.png" />
1.如果尚未连接，请使用以下 sqlsh 命令连接到 192.168.50.142：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -h 127.0.0.1
</code></pre></div>
<p>2.使用以下命令启动事务以将行 k=1 的值更新为 30：</p>
<div class="highlight"><pre><span></span><code>BEGIN;

BEGIN
Time: 2.047 ms
UPDATE txndemo set v=30 where k=1;

UPDATE 1
Time: 51.513 ms
</code></pre></div>
<p>更新成功。 这意味着值 v=30 的更新行已发送到节点 192.168.50.109，但尚未提交。</p>
<p>3.停止节点 192.168.50.109，因为这是已接收修改行的节点。</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl stop --base_dir=/tmp/bmd2
</code></pre></div>
<p>4.导航到 http://192.168.50.109:10000/tile-servers 以验证节点 192.168.50.109 是否已从服务器列表中消失，并且已为 k=1 的行选举了新的leader。
<img alt="" src="./media/chapter6/53.png" />192.168.50.109已dead，并且已为192.168.50.109中的所有Tile选举了新的leader 192.168.50.142。</p>
<p>5.提交事务如下：</p>
<div class="highlight"><pre><span></span><code>COMMIT;

COMMIT
Time: 6.243 ms
</code></pre></div>
<p>即使192.168.50.109在收到临时写入后失败，并且行值更新为30，事务也会成功。这是因为临时写入已复制到跟随者Tile，并且当leader失败时，新当选的leader已经有了临时写入 ，这使得交易能够不间断地继续进行。</p>
<p>6.使用以下命令检查 k=1 处的行的值：</p>
<div class="highlight"><pre><span></span><code>SELECT * from txndemo where k=1;

  k | v
----+----
  1 | 30
(1 row)
</code></pre></div>
<p>k=1 的行的新值 v=30，确认事务完成。</p>
<p>7.使用以下命令重新启动节点 192.168.50.109：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl start --base_dir=/tmp/bmd2
</code></pre></div>
<h4 id="3"><strong>场景3：客户端连接的节点故障</strong></h4>
<p>客户端连接的节点充当事务的管理器。 事务管理器协调事务流并维护客户端和事务id（每个事务的唯一标识符）之间的相关性。 BMDB 本质上对节点故障具有弹性，如前面两个场景所示。</p>
<p>在此示例中，您可以看到当事务管理器失败时事务如何中止。 有关事务管理器角色的更多详细信息，请参阅事务 I/O。</p>
<p>下图说明了当客户端连接到的节点发生故障时导致事务中止的高级步骤。
<img alt="" src="./media/chapter6/54.png" /></p>
<p>对于这种情况，您可以连接到集群中的任何节点； 本例中选择了192.168.50.142。
1.连接到节点192.168.50.142</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -h 127.0.0.1
</code></pre></div>
<p>2.启动一个事务将第k=1行的值更新为40，如下：</p>
<div class="highlight"><pre><span></span><code>BEGIN;

BEGIN
Time: 2.047 ms
UPDATE txndemo set v=40 where k=1;

UPDATE 1
Time: 50.624 ms
</code></pre></div>
<p>3.停止节点 192.168.50.142（您已连接到的节点），如下所示：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl stop --base_dir=/tmp/bmd1
</code></pre></div>
<p>4.提交事务如下：</p>
<div class="highlight"><pre><span></span><code>COMMIT;
</code></pre></div>
<p>请注意，客户端会从服务器收到类似于以下内容的错误响应：</p>
<div class="highlight"><pre><span></span><code>FATAL:  57P01: terminating connection due to unexpected postmaster exit
server closed the connection unexpectedly
  This probably means the server terminated abnormally
  before or while processing the request.
The connection to the server was lost. Attempting reset: Failed.
Time: 2.499 ms
</code></pre></div>
<p>5.从 BMDB 主目录的另一个终端连接到不同的节点并检查值，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -h 127.0.0.2
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * from txndemo where k=1;

  k | v
----+----
  1 | 30
(1 row)
</code></pre></div>
<p>交易失败； 该行没有获得预期的值 40，并且仍然保留旧值 30。当事务管理器在提交发生之前失败时，事务就会丢失。 此时，应用程序有责任重新启动事务。</p>
<h2 id="_177"><strong>高扩展性</strong></h2>
<p>通过向集群添加节点来处理更大的工作负载。
在BMDB中，数据被分割（分片）为多个Tile，这些多个Tile被放置在各个节点上。 当添加更多节点时，一些Tile会自动重新平衡到新节点。 Tile可以根据需要动态分割以使用新添加的资源，这导致每个节点管理更少的Tile。 因此，整个集群可以并行处理更多事务和查询，从而提高处理更大工作负载的能力。</p>
<p>您可以添加更多节点来分发Tile，也可以增加节点的规格来有效、可靠地扩展您的universe，以处理以下任务：</p>
<ul>
<li>每秒高交易量</li>
<li>大量并发客户端连接</li>
<li>大型数据集</li>
<li>多个地区和大洲的数据</li>
</ul>
<p><strong>水平扩展</strong>（scale out）
水平扩展，也称为scale out，是向分布式数据库添加更多节点以处理增加的负载和数据的过程。 水平扩展是BMDB中最常见的扩展模型，具有多个优点，包括：</p>
<ul>
<li>提高性能 - 更多节点可以并行处理请求，从而减少响应时间。</li>
<li>成本效益 - 您可以使用商用硬件，通常比高端服务器便宜。</li>
<li>弹性扩展 - 您可以根据需要添加新节点以适应增长或临时横向扩展以处理特殊事件（例如黑色星期五购物或重大新闻爆发）的高流量。 事件发生后，您可以通过排出某些节点（或 Kubernetes Pod）中的所有数据并将它们从 Universe 中删除来减小集群的大小（缩减）。</li>
</ul>
<p><strong>垂直缩放（scale up）</strong>
垂直扩展涉及升级集群中每个节点的现有硬件或资源。 您无需添加更多机器，而是通过增加 CPU、内存、存储等来增强单台机器的功能。 垂直扩展通常受到单个服务器容量的限制，并且当您转向更强大的硬件时可能会变得昂贵。 尽管保留相同数量的节点可以简化操作，但最终硬件资源会达到极限，进一步扩展可能不可行。</p>
<p>在某些情况下，根据您的应用程序需求和预算限制，可以结合使用水平和垂直扩展来实现所需的性能和可扩展性目标。
<strong>水平缩放与垂直缩放</strong>
下表列出了 BMDB 集群水平和垂直扩展的优缺点。</p>
<table>
<thead>
<tr>
<th></th>
<th>水平扩展</th>
<th>垂直扩展</th>
</tr>
</thead>
<tbody>
<tr>
<td>节点数量</td>
<td>增加</td>
<td>保持不变</td>
</tr>
<tr>
<td>易操作性</td>
<td>添加新节点到集群</td>
<td>添加更强大的节点，耗尽旧节点，并将旧节点从集群中删除</td>
</tr>
<tr>
<td>容错能力</td>
<td>随着更多节点的添加而增加</td>
<td>保持不变</td>
</tr>
<tr>
<td>集群再平衡</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>未来扩展性</td>
<td>可以添加更多节点</td>
<td>仅限于当前可用的最强大的机器</td>
</tr>
<tr>
<td>增加成本</td>
<td>新机器的成本</td>
<td>新旧机器成本差异</td>
</tr>
<tr>
<td>磁盘</td>
<td>可以使用与其他节点相同的磁盘作为数据，并且连接将被分布式</td>
<td>除了 CPU 和内存之外，磁盘也应该升级以处理增加的工作负载</td>
</tr>
</tbody>
</table>
<p><strong>增强功能</strong>
CoreDB 是 BMDB 的底层分布式文档存储， 它经过彻底设计，可大规模提供高性能。 CoreDB 中内置了多项功能来增强性能，包括：</p>
<ul>
<li>Scan-resistant全局块缓存</li>
<li>Bloom/索引数据拆分</li>
<li>全局内存存储限制</li>
<li>单独的压缩队列以减少读放大</li>
<li>跨磁盘智能负载平衡</li>
</ul>
<h3 id="sharding-and-rebalancing"><strong>分片和再平衡（Sharding and Rebalancing）</strong></h3>
<p>跨节点无缝地将表拆分为Tile
水平扩展是 BMDB 的一流功能。 该数据库被设计为在添加节点时无缝水平扩展。 数据透明地移动到新节点，不会造成任何服务中断。</p>
<p>BMDB 将表数据存储在 Tile 中。 分片是将表数据分割并分布到Tile中的过程。 水平可扩展性需要透明的数据分片。</p>
<p>下面说明了分片的工作原理。</p>
<h4 id="_178"><strong>初始集群设置</strong></h4>
<p>假设您有一个复制因子 (RF) 为 3 的 3 节点集群，并且您将存储一个以整数作为主键的基本表。 数据存储在单个Tile中（例如 T1）。 该表从一个具有高可用性的 Tile 开始，其中包含一个 Tile 领导者（节点 2）和两个追随者（节点 1 和节点 3 上的副本）。
<img alt="" src="./media/chapter6/55.png" /></p>
<h4 id="_179"><strong>添加更多数据</strong></h4>
<p>当您向表中添加更多数据时，Tile T1 的领导者和追随者开始增长。
<img alt="" src="./media/chapter6/56.png" /></p>
<h4 id="tile"><strong>Tile分裂</strong></h4>
<p>一旦Tile达到阈值大小（在本例中假设为 4 行），Tile T1 将通过创建新Tile T2 分成两部分。 Tile的分裂几乎是瞬时的，并且对应用程序是透明的。 新创建的Tile将有领导者和追随者。
<img alt="" src="./media/chapter6/57.png" /></p>
<h4 id="_180"><strong>再平衡</strong></h4>
<p>在上图中，T1 和 T2 位于同一节点 (node-2)。 BMDB 意识到领导者不平衡，并自动将领导者分布在不同的节点上。 这可确保集群得到最佳使用。
<img alt="" src="./media/chapter6/58.png" />重新平衡也适用于追随者，而不仅仅是领导者。</p>
<h4 id="_181"><strong>完全横向扩展</strong></h4>
<p>随着更多数据添加到表中，Tile会进一步分裂并根据需要重新平衡。 添加更多数据后，您将得到类似于下图的分布：
<img alt="" src="./media/chapter6/59.png" /></p>
<h3 id="_182"><strong>节点扩容</strong></h3>
<p>通过添加新节点进行横向扩展，按需无缝扩展集群
在 BMDB 中，您可以通过添加新节点来按需水平扩展集群，而不会中断您的应用程序。</p>
<h4 id="_183"><strong>初始设置</strong></h4>
<p>假设您有一个包含 4 个Tile且复制因子 (RF) 为 3 的 3 节点集群。您注意到集群不平衡，一个节点获得更多流量，并决定向集群添加另一个节点。
<img alt="" src="./media/chapter6/60.png" /></p>
<h4 id="_184"><strong>复制</strong></h4>
<p>添加节点后，Tile将重新平衡。 该过程首先在新节点中为Tile添加一个额外的副本，然后新Tile从Tile领导者引导其数据。 在此过程中，吞吐量不会受到影响，因为数据引导是异步的。
<img alt="" src="./media/chapter6/61.png" /></p>
<h4 id="_185"><strong>更换领导者</strong></h4>
<p>新的副本完全引导后，会触发该Tile的领导者选举，并提示让新添加的节点中的副本成为领导者。 这次领导者切换非常快。
<img alt="" src="./media/chapter6/62.png" />现在节点4有了Tile leader，它就可以主动承担负载，从而减少其他节点的负载。</p>
<h4 id="_186"><strong>修复过度复制</strong></h4>
<p>添加新节点时，会创建 Tile T4 的新副本。 现在T4有4个副本，虽然集群是RF3。 通过删除其他副本之一可以修复这种过度复制。
<img alt="" src="./media/chapter6/63.png" /></p>
<h4 id="_187"><strong>重新平衡追随者</strong></h4>
<p>现在领导者已经转移到新节点并且过度复制已经得到解决，追随者也被重新均匀地分布在集群中。
<img alt="" src="./media/chapter6/64.png" /></p>
<h4 id="_188"><strong>完全横向扩展的集群</strong></h4>
<p>重新平衡完成后，您应该看到集群中领导者和追随者的合理分布，如下所示：
<img alt="" src="./media/chapter6/65.png" />集群现已完全横向扩展。</p>
<h4 id="_189"><strong>负载均衡</strong></h4>
<p>现在您已成功添加节点并扩展集群，应用程序可以连接到任何节点并发送查询。 但是您的应用程序如何知道新节点呢？ 为此，您可以在应用程序中使用 BMDB 智能驱动程序。 当新添加的节点处于活动状态时，智能驱动程序会自动将流量发送到它们。 尽管您可以使用外部负载平衡器，但智能驱动程序具有拓扑感知能力，并且会在需要时正确进行故障转移。
<img alt="" src="./media/chapter6/66.png" /></p>
<h3 id="scaling-reads"><strong>Scaling reads</strong></h3>
<p>通过添加更多节点来水平扩展读取。
随着更多节点添加到集群中，BMDB 中的读取呈线性扩展。</p>
<h4 id="_190"><strong>读取数据如何运作</strong></h4>
<p>当连接到节点的应用程序发送对键的读取请求时，例如 SELECT * FROM T WHERE K=5，BMDB 首先识别包含指定键 (K=5) 的行的 Tile Leader 的位置。 识别出数据块领导者的位置后，请求将在内部重定向到包含所请求key的数据块领导者的节点。 领导者掌握最新数据并立即响应。</p>
<p>基本 select 语句最多仅涉及 2 个节点。 这种重定向对于应用程序来说是完全透明的。
<img alt="" src="./media/chapter6/67.png" />
多个应用程序可以连接到任何节点，并且读取将被正确重定向。</p>
<h4 id="sysbench"><strong>Sysbench下的工作负载展示</strong></h4>
<p>下面显示了如何使用基本配置选项的 sysbench 工作负载在 BMDB 中水平扩展读取。 该集群由 m6i.4xlarge 实例组成，拥有 1024 个连接。 所有请求的延迟均小于 3 毫秒。
<img alt="" src="./media/chapter6/68.png" />您可以清楚地看到，随着节点数量的增加，读取数量呈线性缩放。</p>
<h3 id="scaling-writes"><strong>Scaling writes</strong></h3>
<p>当您添加更多节点时，在 BMDB 中写入能力会水平扩展。
随着更多节点添加到集群中，在 BMDB 中写入性能线性增长。</p>
<h4 id="_191"><strong>写作如何工作</strong></h4>
<p>当连接到节点的应用程序发送对键的写入请求时，例如 UPDATE T SET V=2 WHERE K=5，BMDB 首先识别包含指定键 (K=5) 的行的 Tile Leader 的位置。 识别出数据块领导者的位置后，请求将在内部重定向到包含所请求key的数据块领导者的节点。</p>
<p>领导者将写入复制给追随者，然后将写入确认返回应用程序。 复制到追随者会增加请求的额外延迟。</p>
<p>基本写入最多只涉及 2 个节点。
<img alt="" src="./media/chapter6/69.png" />
如果必须提取多行并且位于不同的Tile中，则从位于不同节点的各个Tile内部获取各个行。 这种重定向对于应用程序来说是完全透明的。 
<img alt="" src="./media/chapter6/70.png" /></p>
<h4 id="sysbench_1"><strong>Sysbench下的工作负载展示</strong></h4>
<p>下面显示了如何使用基本配置选项的 Sysbench 工作负载在 BMDB 中水平扩展写入。 该集群由 m6i.4xlarge 实例组成，拥有 1024 个连接。 所有请求的延迟均小于 10 毫秒。
<img alt="" src="./media/chapter6/71.png" />您可以清楚地看到，随着节点数量的增加，写入数量呈线性增长。</p>
<h3 id="scaling-transactions"><strong>Scaling transactions</strong></h3>
<p>横向扩展时的事务性能。
事务是一组预期以原子方式执行的 SQL 语句。 让事务正常工作涉及多个组件。</p>
<p>用最简单的解释来说，客户端连接的节点充当事务管理器。 节点获取必要的锁，与领导者对话以获取事务中涉及的key，将事务提交给领导者，最后复制到各自的追随者。
<img alt="" src="./media/chapter6/72.png" /></p>
<h4 id="oltp"><strong>OLTP 基准</strong></h4>
<p>事务处理系统基准（TPC-C）是衡量数据库事务处理能力的黄金标准。 它模拟批发零件供应商的订单输入。 它包括多种交易类型，其中包括：</p>
<ul>
<li>输入和交付订单</li>
<li>记录付款</li>
<li>检查订单状态</li>
<li>监控库存水平
  性能指标衡量每分钟可以处理的新订单数量，并以每分钟交易数 (TPM-C) 表示。 该基准旨在通过增加仓库数量来模拟业务扩张。</li>
</ul>
<h4 id="tpc-c"><strong>TPC-C 结果</strong></h4>
<p>下面显示了使用以下配置的 TPC-C 基准测试的结果：</p>
<ul>
<li>BMDB 版本 2.20.1</li>
<li>AWS，美国西部区域，c5d.9xlarge 实例</li>
<li>复制因子3</li>
</ul>
<p><strong>100K仓库</strong>
100K 基准测试在具有 59 个节点的 Universe 上运行。</p>
<table>
<thead>
<tr>
<th>效率</th>
<th>TPMC</th>
<th>平均新订单延迟(MS)</th>
<th>BSQL 操作数/秒</th>
<th>CPU使用率％</th>
</tr>
</thead>
<tbody>
<tr>
<td>99.83</td>
<td>1283804.18</td>
<td>51.86</td>
<td>348602.48</td>
<td>58.22</td>
</tr>
</tbody>
</table>
<p>BMDB 仅用 59 个节点，以 99.83% 的效率轻松处理 100K 仓库，每分钟处理 130 万个事务。</p>
<p><strong>150K仓库</strong>
100K 基准测试在扩展到 75 个节点的universe上运行。</p>
<table>
<thead>
<tr>
<th>效率</th>
<th>TPMC</th>
<th>平均新订单延迟(MS)</th>
<th>BSQL 操作数/秒</th>
<th>CPU使用率％</th>
</tr>
</thead>
<tbody>
<tr>
<td>99.3</td>
<td>1M</td>
<td>123.33</td>
<td>950K</td>
<td>80</td>
</tr>
</tbody>
</table>
<p>测试执行期间的延迟和IOPS如下图所示。
<img alt="" src="./media/chapter6/73.png" /></p>
<h3 id="large-datasets"><strong>Large datasets</strong></h3>
<p>横向扩展时运行大型数据集的性能
随着时间序列指标和 IoT 传感器事件等数据工作负载的不断增长，数据库需要处理大数据（大于 10 TB）。 从成本效益的角度来看，运行每个节点都存储 TB 级数据的高密度数据库集群非常有意义。 但是，启动新的数据节点以获得更多的每个节点存储会导致昂贵的计算资源的严重浪费。</p>
<p>BMDB 专为处理大数据而设计，并由激进的复制和存储架构提供支持。 与最终一致的 Cassandra 兼容数据库相比，在 BMDB 中引导新节点和删除现有节点更加简单且更具弹性。</p>
<p>以下场景展示了 BMDB 如何在四台通用机器上处理总计 18 TB 的数据.</p>
<h4 id="_192"><strong>配置和数据大小</strong></h4>
<p>集群节点数量：4
节点配置：c4.4xlarge (16-vcpus, 30 GB RAM, 1 x 6000 TB gp2 EBS SSD)
复制因子：3
KV记录数：200亿条
键 + 值大小：~300 字节
Key大小：50 字节
值大小：256 字节（故意选择不太可压缩）
逻辑数据集大小： 200 亿个keys * 300 字节 = 6000 GB
包含复制的原始数据：6000 GB * 3 = 18 TB
每个节点的数据：18TB / 4 = 4.5 TB</p>
<h4 id="_193"><strong>数据加载</strong></h4>
<p>使用 “Cassandra Key Value” 示例应用程序在大约 6 天内以稳定的速率加载数据。 下图显示了每个节点的 SSTable 大小在 6 天内稳定增长，超过该值后稳定在 4.5 TB。
<img alt="" src="./media/chapter6/74.png" />
下图显示了 MServer 管理 UI，其中包含Tile服务器、每个服务器上的Tile数量、Tile领导者数量以及磁盘上 SSTable 文件的大小 (4.5 TB)。
<img alt="" src="./media/chapter6/75.png" /></p>
<h4 id="read-heavy-workload"><strong>Read-heavy workload</strong></h4>
<p>在具有 32 个读取器和 2 个写入器的读取密集型工作负载中，BMDB 提供了 19K ops/s 的服务，延迟为 1.35 毫秒。
<img alt="" src="./media/chapter6/76.png" />请注意，这是一个随机读取工作负载，每个节点仅需要 30GB RAM 即可存储 4.5TB 数据。 因此，每次读取都将被迫转到磁盘，并且此工作负载受到 EBS 卷可以支持的 IO 的瓶颈。</p>
<p>正如预期的那样，CPU 不是此工作负载的瓶颈，CPU 使用率低于 7%</p>
<h4 id="write-heavy-workload"><strong>Write-heavy workload</strong></h4>
<p>在具有 2 个读取器和 64 个写入器的写入密集型工作负载上，BMDB 提供 25K 操作/秒服务，延迟为 4 毫秒。
<img alt="" src="./media/chapter6/77.png" />
对于写入密集型工作负载，由于使用通用 SSD (gp2) EBS 卷，因此存在更多变化。 这种可变性是由于需要执行定期压实而产生的。 请注意，对于 IoT 或类似 KairosDB 的工作负载等时间序列数据，BMDB 不需要执行激进的压缩，结果会更好。 但这个特定的实验正在运行任意 KV 工作负载，并且正如预期的那样对系统提出了更高的要求。</p>
<p>使用 2x3000GB EBS 卷可能是获得更高吞吐量的更好选择，而不是每个节点使用 1x6000GB EBS 卷。 当磁盘 R + W 吞吐量在压缩期间达到最大值（大约 150MB/秒）时，延迟也会增加一点。</p>
<p>为了在低端 gp2 SSD 基于卷的设置上为前台操作留出足够的空间，我们将压缩/刷新速率的默认配额设置从 100MB/秒减少到 30MB/秒。</p>
<p>在直接连接 NVMe SSD 的 i3* 实例类型（具有更高的磁盘 IOPS 和吞吐量）上，对于类似的工作负载，观察到的这种变化应该很小。</p>
<h3 id="scale-out-a-universe"><strong>Scale out a universe</strong></h3>
<p>BMDB 中的水平扩展和缩减</p>
<p>BMDB 可以在运行读写工作负载时无缝扩展。 您可以通过对复制因子为 3 的三节点 Universe 使用 BM 工作负载模拟器应用程序并在工作负载运行时添加一个节点来查看这一点。 使用内置指标，您可以通过验证读取和写入 IOPS 数量始终均匀分布在所有节点上来观察Universe如何扩展。</p>
<h2 id="_194"><strong>多区域部署</strong></h2>
<p>BMDB 支持一组丰富的多区域部署拓扑。 本节介绍其中一些部署。 主要部署包括：</p>
<ul>
<li>跨区域同步复制：默认</li>
<li>地理分区：根据策略将数据固定到不同的地理位置</li>
<li>xDCR：用于单向和双向异步复制</li>
<li>读副本：使用异步复制为不同区域提供读取服务</li>
</ul>
<p>下表总结了 BMDB 中的这些不同的多区域部署及其一些关键特征。</p>
<table>
<thead>
<tr>
<th></th>
<th>默认</th>
<th>地理分区</th>
<th>xDCR</th>
<th>读取副本</th>
</tr>
</thead>
<tbody>
<tr>
<td>复制方式</td>
<td>同步</td>
<td>同步</td>
<td>异步（单向/双向）</td>
<td>异步（单向）</td>
</tr>
<tr>
<td>数据驻留</td>
<td>所有数据跨区域复制</td>
<td>数据跨区域分区。分区在区域内复制。</td>
<td>所有数据都在区域内复制，配置每表跨区域复制。</td>
<td>所有数据都复制在主区域中。集群范围内的异步复制到只读副本</td>
</tr>
<tr>
<td>一致性</td>
<td>事务一致性</td>
<td>事务一致性</td>
<td>时间线一致性</td>
<td>时间线一致性</td>
</tr>
<tr>
<td>写延迟</td>
<td>高延迟</td>
<td>低延迟</td>
<td>低延迟</td>
<td>N/A</td>
</tr>
<tr>
<td>读延迟</td>
<td>高延迟</td>
<td>低延迟（当从附近的地理位置查询时）</td>
<td>低延迟</td>
<td>低延迟</td>
</tr>
<tr>
<td>Schema changes</td>
<td>透明管理</td>
<td>透明管理</td>
<td>手动操作</td>
<td>透明管理</td>
</tr>
<tr>
<td>RPO</td>
<td>无数据丢失</td>
<td>无数据丢失（可能部分不可用）</td>
<td>部分数据丢失</td>
<td>无数据丢失</td>
</tr>
</tbody>
</table>
<h3 id="3_1"><strong>3区域部署（节点之间数据同步复制）</strong></h3>
<p>为了在整个云区域发生故障时提供保护，您可以通过同步复制的多区域universe跨多个区域部署 BMDB。 在同步的多区域 Universe 中，跨三个区域至少复制三个节点，复制因子 (RF) 为 3。如果某个区域发生故障，Universe 会继续为来自其余区域的数据请求提供服务。 BMDB 自动执行到其他两个区域中的节点的故障转移，并且被故障转移的Tile均匀分布在其余两个区域中。</p>
<p>这种部署具有以下优点：</p>
<ul>
<li>弹性 - 将universe节点放在不同的区域可以提供更高程度的故障独立性。</li>
<li>一致性 - 所有写入都会同步复制。 事务是全球一致的。</li>
</ul>
<h3 id="_195"><strong>行级数据地理分布</strong></h3>
<p>将数据固定到区域以实现合规性并降低延迟</p>
<p>行级地理分区允许对用户表中的数据（每行级）固定到地理位置进行细粒度控制，从而允许在表行级管理数据驻留。 需要低延迟多区域部署、事务一致性语义和跨区域透明模式更改传播的用例将受益于此功能。</p>
<p>地理分区允许您将数据移至更靠近用户的位置：</p>
<ul>
<li>实现更低的延迟和更高的性能</li>
<li>满足数据驻留要求，以遵守 GDPR 等法规</li>
</ul>
<p>数据的地理分区可以对表数据在不同地理位置的放置进行细粒度的行级控制。 这是通过两个步骤完成的：</p>
<ul>
<li>将表划分为用户定义的表分区。</li>
<li>通过为每个分区配置元数据，将这些分区固定到所需的地理位置。</li>
</ul>
<p>要创建用户定义的表分区，请将表的一列指定为将用于对数据进行地理分区的分区列。 给定行的该列的值用于确定该行所属的表分区。</p>
<p><strong>第二步</strong>涉及使用表空间在各个地理位置创建分区。 请注意，每个分区中的数据可以配置为跨云提供商区域中的多个可用区（zone）、跨多个附近区域（region）或数据中心进行复制。</p>
<p>通过添加新的表分区并将其配置为将数据驻留在所需的地理位置，可以动态引入全新的地理分区。 通过删除必要的分区，可以有效地清除一个或多个现有地理位置中的数据。 传统 RDBMS 的用户会认为这种方案接近用户定义的基于列表的表分区，并且能够控制每个分区的地理位置。</p>
<p>在此部署中，用户可以低延迟地访问其数据，因为数据驻留在地理位置较近的服务器上，并且查询不需要访问遥远地理位置的数据。</p>
<p>本教程在下一节中描述的示例场景的上下文中解释了此功能。</p>
<p>示例场景
假设一家虚构的大型银行 Bigmath Bank 想要为许多国家的用户提供在线银行服务，处理他们的存款、取款和转账。</p>
<p>构建这样的服务需要以下属性：</p>
<ul>
<li>具有高可用性的事务语义：数据的一致性在银行应用程序中至关重要，因此数据库应该符合 ACID。 此外，用户希望服务始终可用，这使得高可用性和故障恢复能力成为关键要求。</li>
<li>高性能：在线交易需要低延迟处理，以确保良好的最终用户体验。 这要求特定用户的数据位于附近的地理区域。 将所有数据放在 RDBMS 中的单个位置意味着远离该位置的用户的请求将具有非常高的延迟，从而导致糟糕的用户体验。</li>
<li>合规性的数据驻留要求：许多国家/地区都有关于可以存储其居民个人数据的地理区域的规定，并且作为个人数据的银行交易必须遵守这些要求。 例如，GDPR 有一项数据驻留规定，实际上要求欧盟境内个人的个人数据存储在欧盟。 同样，印度储备银行（简称 RBI）发布了一项要求，强制要求所有银行、中介机构和其他第三方在印度存储与支付数据有关的所有信息 - 尽管在国际交易中， 交易国外部分的数据可以存储在国外位置。</li>
</ul>
<p>注：虽然此场景具有法规遵从性要求，即数据需要驻留在某些地理位置，但完全相同的技术也适用于将数据移近用户以实现低延迟和高性能的目标。 因此，上面列出了高性能作为要求。</p>
<p><strong>1.创建表空间</strong>
首先，为您希望将数据分区到的每个地理区域创建表空间：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLESPACE eu_central_1_tablespace WITH (
  replica_placement=&#39;{&quot;num_replicas&quot;: 3, &quot;placement_blocks&quot;:
  [{&quot;cloud&quot;:&quot;aws&quot;,&quot;region&quot;:&quot;eu-central-1&quot;,&quot;zone&quot;:&quot;eu-central-1a&quot;,&quot;min_num_replicas&quot;:1},
  {&quot;cloud&quot;:&quot;aws&quot;,&quot;region&quot;:&quot;eu-central-1&quot;,&quot;zone&quot;:&quot;eu-central-1b&quot;,&quot;min_num_replicas&quot;:1},
  {&quot;cloud&quot;:&quot;aws&quot;,&quot;region&quot;:&quot;eu-central-1&quot;,&quot;zone&quot;:&quot;eu-central-1c&quot;,&quot;min_num_replicas&quot;:1}]}&#39;
);

CREATE TABLESPACE us_west_2_tablespace WITH (
  replica_placement=&#39;{&quot;num_replicas&quot;: 3, &quot;placement_blocks&quot;:
  [{&quot;cloud&quot;:&quot;aws&quot;,&quot;region&quot;:&quot;us-west-2&quot;,&quot;zone&quot;:&quot;us-west-2a&quot;,&quot;min_num_replicas&quot;:1},
  {&quot;cloud&quot;:&quot;aws&quot;,&quot;region&quot;:&quot;us-west-2&quot;,&quot;zone&quot;:&quot;us-west-2b&quot;,&quot;min_num_replicas&quot;:1},
  {&quot;cloud&quot;:&quot;aws&quot;,&quot;region&quot;:&quot;us-west-2&quot;,&quot;zone&quot;:&quot;us-west-2c&quot;,&quot;min_num_replicas&quot;:1}]}&#39;
);

CREATE TABLESPACE ap_south_1_tablespace WITH (
  replica_placement=&#39;{&quot;num_replicas&quot;: 3, &quot;placement_blocks&quot;:
  [{&quot;cloud&quot;:&quot;aws&quot;,&quot;region&quot;:&quot;ap-south-1&quot;,&quot;zone&quot;:&quot;ap-south-1a&quot;,&quot;min_num_replicas&quot;:1},
  {&quot;cloud&quot;:&quot;aws&quot;,&quot;region&quot;:&quot;ap-south-1&quot;,&quot;zone&quot;:&quot;ap-south-1b&quot;,&quot;min_num_replicas&quot;:1},
  {&quot;cloud&quot;:&quot;aws&quot;,&quot;region&quot;:&quot;ap-south-1&quot;,&quot;zone&quot;:&quot;ap-south-1c&quot;,&quot;min_num_replicas&quot;:1}]}&#39;
);
</code></pre></div>
<p>要查看您的表空间，您可以输入以下命令：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM pg_tablespace;
</code></pre></div>
<p><strong>2.创建带分区的表</strong>
接下来，创建包含 geo_partition 列的父表，该列用于为要将数据分区到的每个地理区域创建基于列表的分区，如下图所示：
<img alt="" src="./media/chapter6/78.png" />
（1）创建父表</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE bank_transactions (
    user_id   INTEGER NOT NULL,
    account_id INTEGER NOT NULL,
    geo_partition VARCHAR,
    account_type VARCHAR NOT NULL,
    amount NUMERIC NOT NULL,
    txn_type VARCHAR NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
) PARTITION BY LIST (geo_partition);
</code></pre></div>
<p>注：您可以将 geo_partition 设置为 DEFAULT bm_server_region() 以基于区域进行分区。 这样，对本地分区表的插入不必指定 geo_partition 列值。</p>
<p>（2）接下来，在父表下为每个所需的地理位置创建一个分区，并将每个分区分配给适用的表空间。 在这里，您创建三个表分区：一个用于欧盟区域，称为bank_transactions_eu，另一个用于印度区域，称为bank_transactions_india，第三个分区用于美国区域，称为bank_transactions_us。 为每个分区创建任何所需的索引，确保将每个索引与分区表的表空间关联。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE bank_transactions_eu
    PARTITION OF bank_transactions
      (user_id, account_id, geo_partition, account_type,
      amount, txn_type, created_at,
      PRIMARY KEY (user_id HASH, account_id, geo_partition))
    FOR VALUES IN (&#39;EU&#39;) TABLESPACE eu_central_1_tablespace;

CREATE INDEX ON bank_transactions_eu(account_id) TABLESPACE eu_central_1_tablespace;

CREATE TABLE bank_transactions_india
    PARTITION OF bank_transactions
      (user_id, account_id, geo_partition, account_type,
      amount, txn_type, created_at,
      PRIMARY KEY (user_id HASH, account_id, geo_partition))
    FOR VALUES IN (&#39;India&#39;) TABLESPACE ap_south_1_tablespace;

CREATE INDEX ON bank_transactions_india(account_id) TABLESPACE ap_south_1_tablespace;

CREATE TABLE bank_transactions_us
    PARTITION OF bank_transactions
      (user_id, account_id, geo_partition, account_type,
      amount, txn_type, created_at,
      PRIMARY KEY (user_id HASH, account_id, geo_partition))
    FOR VALUES IN (&#39;US&#39;) TABLESPACE us_west_2_tablespace;

CREATE INDEX ON bank_transactions_us(account_id) TABLESPACE us_west_2_tablespace;
</code></pre></div>
<p>（3）使用 \d 元命令查看迄今为止创建的表和分区。</p>
<div class="highlight"><pre><span></span><code>bigmath=# \d
</code></pre></div>
<div class="highlight"><pre><span></span><code>                List of relations
 Schema |         Name          | Type |  Owner
-----------+-----------------------------------+-------+----------
 public  | bank_transactions         | table | bigmath
 public  | bank_transactions_eu      | table | bigmath
 public  | bank_transactions_india    | table | bigmath
 public  | bank_transactions_us      | table | bigmath
(4 rows)
</code></pre></div>
<p>现将数据整理如下：
<img alt="" src="./media/chapter6/79.png" />
区域-本地事务表
当您使用具有放置集的表空间创建表时，BMDB 会自动在表空间下创建一个事务表（如果尚不存在），其名称类似于 system.transactions_90141438-f42c-4a39-8a12-4072c1216d46。</p>
<p>3.固定特定于地理位置的用户分区
现在，设置应该能够根据 geo_partition 列中设置的值自动将行固定到适当的区域。 如下图所示：
<img alt="" src="./media/chapter6/80.png" />
您可以通过插入几行数据并验证它们是否写入正确的分区来测试此区域固定。</p>
<p>扩展输出显示
示例输出包括扩展的自动模式输出格式，以提高可读性。 您可以使用以下语句启用此模式：</p>
<div class="highlight"><pre><span></span><code>bigmath=# \x auto
</code></pre></div>
<div class="highlight"><pre><span></span><code>Expanded display is used automatically.
</code></pre></div>
<p>（1）在下面的表中插入一行，其中 geo_partition 列值设置为 EU。</p>
<div class="highlight"><pre><span></span><code>INSERT INTO bank_transactions
    VALUES (100, 10001, &#39;EU&#39;, &#39;checking&#39;, 120.50, &#39;debit&#39;);
</code></pre></div>
<p>（2）验证该行是否存在于bank_transactions 表中。</p>
<div class="highlight"><pre><span></span><code>bigmath=# select * from bank_transactions;

-[ RECORD 1 ]-+---------------------------
user_id       | 100
account_id    | 10001
geo_partition | EU
account_type  | checking
amount        | 120.5
txn_type      | debit
created_at    | 2020-11-07 21:28:11.056236
</code></pre></div>
<p>此外，该行必须仅存在于bank_transactions_eu分区中，可以通过直接针对该分区运行select语句来轻松验证这一点。 其他分区不应包含任何行。</p>
<div class="highlight"><pre><span></span><code>bigmath=# select * from bank_transactions_eu;
</code></pre></div>
<div class="highlight"><pre><span></span><code>-[ RECORD 1 ]-+---------------------------
user_id       | 100
account_id    | 10001
geo_partition | EU
account_type  | checking
amount        | 120.5
txn_type      | debit
created_at    | 2020-11-07 21:28:11.056236
</code></pre></div>
<div class="highlight"><pre><span></span><code>bigmath=# select count(*) from bank_transactions_india;
</code></pre></div>
<div class="highlight"><pre><span></span><code> count
-------
     0
</code></pre></div>
<div class="highlight"><pre><span></span><code>bigmath=# select count(*) from bank_transactions_us;
</code></pre></div>
<div class="highlight"><pre><span></span><code> count
-------
     0
</code></pre></div>
<p>将数据插入其他分区。</p>
<div class="highlight"><pre><span></span><code>INSERT INTO bank_transactions
    VALUES (200, 20001, &#39;India&#39;, &#39;savings&#39;, 1000, &#39;credit&#39;);
INSERT INTO bank_transactions
    VALUES (300, 30001, &#39;US&#39;, &#39;checking&#39;, 105.25, &#39;debit&#39;);
</code></pre></div>
<p>这些可以验证如下：</p>
<div class="highlight"><pre><span></span><code>bigmath=# select * from bank_transactions_india;
</code></pre></div>
<div class="highlight"><pre><span></span><code>-[ RECORD 1 ]-+---------------------------
user_id       | 200
account_id    | 20001
geo_partition | India
account_type  | savings
amount        | 1000
txn_type      | credit
created_at    | 2020-11-07 21:45:26.011636
</code></pre></div>
<div class="highlight"><pre><span></span><code>bigmath=# select * from bank_transactions_us;
</code></pre></div>
<div class="highlight"><pre><span></span><code>-[ RECORD 1 ]-+---------------------------
user_id       | 300
account_id    | 30001
geo_partition | US
account_type  | checking
amount        | 105.25
txn_type      | debit
created_at    | 2020-11-07 21:45:26.067444
</code></pre></div>
<p><strong>4.查询本地分区</strong>
可以通过在分区键上使用 WHERE 子句来完成对特定分区的查询。 例如，如果客户端位于美国，则可以通过运行以下查询来查询本地分区：</p>
<div class="highlight"><pre><span></span><code>bigmath=# select * from bank_transactions where geo_partition=&#39;US&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>-[ RECORD 1 ]-+---------------------------
user_id       | 300
account_id    | 30001
geo_partition | US
account_type  | checking
amount        | 105.25
txn_type      | debit
created_at    | 2020-11-07 21:45:26.067444
</code></pre></div>
<p>但是，如果需要查询本地分区而不指定分区列，可以使用函数 bm_is_local_table。 要使用 bm_is_local_table 实现与上面相同的查询，您可以执行以下操作：</p>
<div class="highlight"><pre><span></span><code>bigmath=# select * from bank_transactions where bm_is_local_table(tableoid);
</code></pre></div>
<div class="highlight"><pre><span></span><code>-[ RECORD 1 ]-+---------------------------
user_id       | 300
account_id    | 30001
geo_partition | US
account_type  | checking
amount        | 105.25
txn_type      | debit
created_at    | 2020-11-07 21:45:26.067444
</code></pre></div>
<p>5.跨地理位置旅行的用户
更有趣的是，用户 100 的第一笔银行交易是在欧盟地区进行的，他前往印度和美国，并进行了另外两笔银行交易。 这可以通过使用以下语句来模拟：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO bank_transactions
    VALUES (100, 10001, &#39;India&#39;, &#39;savings&#39;, 2000, &#39;credit&#39;);
INSERT INTO bank_transactions
    VALUES (100, 10001, &#39;US&#39;, &#39;checking&#39;, 105, &#39;debit&#39;);
</code></pre></div>
<p>现在，每笔银行交易都将被固定到适当的地理位置。 这可以如下验证。</p>
<div class="highlight"><pre><span></span><code>bigmath=# select * from bank_transactions_india where user_id=100;
</code></pre></div>
<div class="highlight"><pre><span></span><code>-[ RECORD 1 ]-+---------------------------
user_id       | 100
account_id    | 10001
geo_partition | India
account_type  | savings
amount        | 2000
txn_type      | credit
created_at    | 2020-11-07 21:56:26.760253
</code></pre></div>
<div class="highlight"><pre><span></span><code>bigmath=# select * from bank_transactions_us where user_id=100;
</code></pre></div>
<div class="highlight"><pre><span></span><code>-[ RECORD 1 ]-+---------------------------
user_id       | 100
account_id    | 10001
geo_partition | US
account_type  | checking
amount        | 105
txn_type      | debit
created_at    | 2020-11-07 21:56:26.794173
</code></pre></div>
<p>可以使用以下 SQL 语句检索用户进行的所有银行交易。</p>
<div class="highlight"><pre><span></span><code>bigmath=# select * from bank_transactions where user_id=100 order by created_at desc;
</code></pre></div>
<div class="highlight"><pre><span></span><code>-[ RECORD 1 ]-+---------------------------
user_id       | 100
account_id    | 10001
geo_partition | US
account_type  | checking
amount        | 105
txn_type      | debit
created_at    | 2020-11-07 21:56:26.794173
-[ RECORD 2 ]-+---------------------------
user_id       | 100
account_id    | 10001
geo_partition | India
account_type  | savings
amount        | 2000
txn_type      | credit
created_at    | 2020-11-07 21:56:26.760253
-[ RECORD 3 ]-+---------------------------
user_id       | 100
account_id    | 10001
geo_partition | EU
account_type  | checking
amount        | 120.5
txn_type      | debit
created_at    | 2020-11-07 21:28:11.056236
</code></pre></div>
<p><strong>6.添加新的地理位置</strong>
假设一段时间后，Bigmath Bank 在全球范围内获得了大量客户，并希望向也有数据居住法的巴西居民提供服务。 使用行级地理分区，您可以通过添加新分区并将其固定到 AWS 南美洲（圣保罗）区域 sa-east-1 来实现此目的。</p>
<p>首先，创建表空间：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLESPACE sa_east_1_tablespace WITH (
    replica_placement=&#39;{&quot;num_replicas&quot;: 3, &quot;placement_blocks&quot;:
      [{&quot;cloud&quot;:&quot;aws&quot;,&quot;region&quot;:&quot;sa-east-1&quot;,&quot;zone&quot;:&quot;sa-east-1a&quot;,&quot;min_num_replicas&quot;:1},
      {&quot;cloud&quot;:&quot;aws&quot;,&quot;region&quot;:&quot;sa-east-1&quot;,&quot;zone&quot;:&quot;sa-east-1b&quot;,&quot;min_num_replicas&quot;:1},
      {&quot;cloud&quot;:&quot;aws&quot;,&quot;region&quot;:&quot;sa-east-1&quot;,&quot;zone&quot;:&quot;sa-east-1c&quot;,&quot;min_num_replicas&quot;:1}]}&#39;
    );
</code></pre></div>
<p>然后，为巴西创建分区：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE bank_transactions_brazil
    PARTITION OF bank_transactions
      (user_id, account_id, geo_partition, account_type,
       amount, txn_type, created_at,
       PRIMARY KEY (user_id HASH, account_id, geo_partition))
    FOR VALUES IN (&#39;Brazil&#39;) TABLESPACE sa_east_1_tablespace;
</code></pre></div>
<p>至此，新区域已准备好存储巴西居民的银行交易。</p>
<div class="highlight"><pre><span></span><code>INSERT INTO bank_transactions
    VALUES (400, 40001, &#39;Brazil&#39;, &#39;savings&#39;, 1000, &#39;credit&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>select * from bank_transactions_brazil;
</code></pre></div>
<div class="highlight"><pre><span></span><code>-[ RECORD 1 ]-+-------------------------
user_id       | 400
account_id    | 40001
geo_partition | Brazil
account_type  | savings
amount        | 1000
txn_type      | credit
created_at    | 2020-11-07 22:09:04.8537
</code></pre></div>
<p><strong>7.区域中断期间的容错</strong>
到目前为止，您已经设置了 3 个数据副本的复制，这有助于容忍单个节点或区域的丢失。 但是，区域中断会导致不可用，因为所有节点都在一个区域内。 将每个副本放置在不同的区域有助于解决此问题。</p>
<p>重新创建之前的 us_west_2_表空间，并在 us-west2、us-west1 和 us-east1 中各放置一个副本。 然后使用leader_preference继续将所有领导者放置在us-west-2中，以便他们保持靠近客户端并提供最佳性能。 （您可以在领导者偏好中找到更多信息）</p>
<div class="highlight"><pre><span></span><code>CREATE TABLESPACE us_west_2_tablespace WITH (
  replica_placement=&#39;{&quot;num_replicas&quot;: 3, &quot;placement_blocks&quot;:
  [{&quot;cloud&quot;:&quot;aws&quot;,&quot;region&quot;:&quot;us-west-2&quot;,&quot;zone&quot;:&quot;us-west-2a&quot;,&quot;min_num_replicas&quot;:1,&quot;leader_preference&quot;:1},
  {&quot;cloud&quot;:&quot;aws&quot;,&quot;region&quot;:&quot;us-west-1&quot;,&quot;zone&quot;:&quot;us-west-1a&quot;,&quot;min_num_replicas&quot;:1,&quot;leader_preference&quot;:2},
  {&quot;cloud&quot;:&quot;aws&quot;,&quot;region&quot;:&quot;us-east-1&quot;,&quot;zone&quot;:&quot;us-east-1a&quot;,&quot;min_num_replicas&quot;:1}]}&#39;
);
</code></pre></div>
<h3 id="xdcr-2"><strong>xDCR (2个区域异步复制)</strong></h3>
<p>单向（主从）和双向（多主）复制
默认情况下，BMDB 提供跨地理分布式数据中心的同步复制和强一致性。 然而，许多用例不需要同步复制，也不需要证明与管理三个或更多数据中心相关的额外复杂性和运营成本是合理的。 跨集群 (xDCR) 部署提供跨两个数据中心或云区域的异步复制。</p>
<p>本练习使用两个本地 BMDB 集群模拟地理分布式双数据中心 (2DC) 部署，一个代表“Data Center - East”，另一个代表“Data Center - West”。</p>
<p>有关详细信息，请参阅以下内容：
xDCR复制架构
xDCR 复制命令
变更数据捕获 (CDC)</p>
<p><strong>1.创建两个数据中心</strong>
创建两个数据中心如下：
（1）通过从 BMDB 主目录运行以下命令来创建并启动模拟“Data Center - East”的本地集群：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl start \
                --advertise_address=127.0.0.1 \
                --base_dir=/tmp/bmd1
</code></pre></div>
<p>这将使用 IP 地址 127.0.0.1 启动单节点本地集群，并创建 /tmp/bmd1 作为基目录。</p>
<p>（2）如果您在 macOS 上运行并且尚未创建任何loopback地址，请按如下方式配置一个：</p>
<div class="highlight"><pre><span></span><code>sudo ifconfig lo0 alias 127.0.0.2
</code></pre></div>
<p>（3）通过运行以下命令创建并启动模拟“Data Center - West”的第二个本地集群：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl start \
                --advertise_address=127.0.0.2 \
                --base_dir=/tmp/bmd2
</code></pre></div>
<p>这将使用 IP 地址 127.0.0.2 启动单节点集群，并创建 /tmp/bmd2 作为基目录。</p>
<p><strong>2.创建表</strong>
在默认的 bigmath 数据库中，您可以在“Data Center - East”集群上创建表 users：
（1）通过指定主机IP地址127.0.0.1打开sqlsh，如下：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -h 127.0.0.1
</code></pre></div>
<p>（2）创建表users，如下：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE users (
    email varchar PRIMARY KEY,
    username varchar
    );
</code></pre></div>
<p>在第二个集群上创建一个相同的表：
（1）打开“Data Center - West”的sqlsh，指定主机IP地址127.0.0.2，如下：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -h 127.0.0.2
</code></pre></div>
<p>（2）创建表users，如下：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE users (
    email varchar PRIMARY KEY,
    username varchar
    );
</code></pre></div>
<p>集群上有两个相同的表允许您跨两个数据中心设置 xDCR 复制。</p>
<p><strong>3.配置单向复制</strong>
要将“Data Center - West”配置为“Data Center - East”集群中数据更改的目标，您需要使用 bm-admin 实用程序 setup_universe_replication 命令。 语法如下：</p>
<div class="highlight"><pre><span></span><code>bm-admin -master_addresses &lt;target-master-addresses&gt; \
    setup_universe_replication &lt;source-universe_uuid&gt; \
    &lt;source_master_addresses&gt; &lt;source-table-ids&gt;
</code></pre></div>
<ul>
<li>target-master-addresses：目标 MServer 服务器的逗号分隔列表。 对于此模拟，您有一台用于目标的 MServer 服务器，127.0.0.2:11000。</li>
<li>source-universe-uuid：源集群的唯一标识符。 在源MServer UI（http://127.0.0.1:10000）中查找UUID。</li>
<li>source-master-addresses：以逗号分隔的源 MServer 服务器列表。 对于此模拟，您有一台 MServer 服务器作为源，127.0.0.1:11000。</li>
<li>source-table-ids：以逗号分隔的表 UUID 列表。 对于此模拟，用户表； 在MServer UI（http://127.0.0.1:10000/tables）中查找UUID。</li>
</ul>
<p>根据从 MServer UI 获取的实际值，从 BMDB 主目录运行 bm-admin setup_universe_replication 命令，类似于以下示例中所示的命令：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin -master_addresses 127.0.0.2:11000 \
    setup_universe_replication 7acd6399-657d-42dc-a90a-646869898c2d \
    127.0.0.1:11000 000033e8000030008000000000004000
</code></pre></div>
<p>target-master-addresses: 127.0.0.2:11000
source-universe-uuid: 7acd6399-657d-42dc-a90a-646869898c2d
source-master-addresses: 127.0.0.1:11000
source-table-ids: 000033e8000030008000000000004000</p>
<p>您应该看到以下消息：</p>
<div class="highlight"><pre><span></span><code>Replication setup successfully
</code></pre></div>
<p><strong>4.验证单向复制</strong>
要检查复制，您可以将数据添加到一个集群上的用户表中，并查看数据出现在第二个集群上的用户表中。</p>
<p>（1）使用以下命令将数据添加到“Data Center - East”集群，确保您指向新的源主机：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -h 127.0.0.1
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO users(email, username) VALUES (&#39;hector@example.com&#39;, &#39;hector&#39;), (&#39;steve@example.com&#39;, &#39;steve&#39;);
</code></pre></div>
<p>（2）在目标“Data Center - West”集群上，执行以下命令，可以看到集群间数据已复制：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -h 127.0.0.2
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM users;
</code></pre></div>
<p>输出如下：</p>
<div class="highlight"><pre><span></span><code>        email         | username
---------------------+----------
  hector@example.com  | hector
  steve@example.com   | steve
(2 rows)
</code></pre></div>
<p><strong>5.配置双向复制</strong>
双向 xDCR 复制允许您将数据插入任一集群上的同一个表中，并将数据更改添加到另一个集群中。</p>
<p>要为同一表配置双向复制，请运行 bm-admin setup_universe_replication 命令以使“Data Center - East”集群成为“Data Center - West”集群的目标。 这次，目标是127.0.0.1:11000，源是127.0.0.2:11000。</p>
<p>在源 MServer UI (http://127.0.0.2:10000) 中查找源 UUID，在 http://127.0.0.2:10000/tables 中查找源表 UUID。</p>
<p>根据从 MServer UI 获取的实际值，运行 bm-admin setup_universe_replication 命令，类似于以下示例中所示的命令：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin -master_addresses 127.0.0.1:11000 \
    setup_universe_replication 0a315687-e9bd-430f-b6f4-ac831193a394 \
    127.0.0.2:11000 000030a9000030008000000000004000
</code></pre></div>
<ul>
<li>target-master-addresses: 127.0.0.1:11000</li>
<li>source-universe-uuid: 0a315687-e9bd-430f-b6f4-ac831193a394</li>
<li>source-master-addresses: 127.0.0.2:11000</li>
<li>source-table-ids: 000030a9000030008000000000004000</li>
</ul>
<p>您应该看到以下消息：</p>
<div class="highlight"><pre><span></span><code>Replication setup successfully
</code></pre></div>
<p><strong>6.验证双向复制</strong>
配置双向复制后，您可以将数据添加到“Data Center - West”集群上的用户表中，并看到数据出现在“Data Center - East”集群上的用户表中。</p>
<p>（1）使用以下命令将数据添加到“Data Center - West”集群，确保您指向新的源主机：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -h 127.0.0.2
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO users(email, username) VALUES (&#39;neha@example.com&#39;, &#39;neha&#39;), (&#39;mikhail@example.com&#39;, &#39;mikhail&#39;);
</code></pre></div>
<p>（2）在新的目标集群上，运行以下命令可以看到集群之间的数据已复制：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -h 127.0.0.1
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM users;
</code></pre></div>
<p>您应该看到以下输出：</p>
<div class="highlight"><pre><span></span><code>        email         | username
---------------------+----------
  hector@example.com  | hector
  steve@example.com   | steve
  neha@example.com    | neha
  mikhail@example.com | mikhail
(4 rows)
</code></pre></div>
<p><strong>7.添加表</strong>
您可以使用 bm-admin 命令 alter_universe_replication add_table 将更多表添加到现有复制：</p>
<div class="highlight"><pre><span></span><code>bm-admin -master_addresses &lt;target-master-addresses&gt; \
        alter_universe_replication &lt;source-universe_uuid&gt; \
        add_table &lt;source-table-ids&gt;
</code></pre></div>
<p>以下是一个示例命令：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin -master_addresses 127.0.0.2:11000 \
    alter_universe_replication 7acd6399-657d-42dc-a90a-646869898c2d \
    add_table 000030a9000030008000000000004000
</code></pre></div>
<p>有关详细信息，请参阅 alter_universe_replication。</p>
<h3 id="_196"><strong>读副本</strong></h3>
<p>将数据异步复制到一个或多个只读副本集群。</p>
<h4 id="bsql_5"><strong>BSQL</strong></h4>
<p>在其他区域运行的应用程序会因读取领导者的最新数据而产生跨区域延迟。 如果对于在其他区域中运行的应用程序来说，读取的一点陈旧性是可以接受的，那么只读副本就是要采用的模式。</p>
<p>只读副本集群是连接到主集群的一组从属节点。 这些纯粹是观察者节点，这意味着它们不参与 Raft 共识和选举。 因此，只读副本可以具有与主集群不同的复制因子 (RF)，并且您可以拥有偶数个副本。</p>
<p>让我们看看这对您的应用程序有何好处。</p>
<p><strong>1.设置</strong>
假设您在 us-east-1 和 us-east-2 中设置了一个 RF 3 集群，并将领导者首选项设置为 us-east-1。 假设您想在美国中部和美国西部运行其他应用程序。 读取延迟类似于下图。
<img alt="" src="./media/chapter6/81.png" />
<strong>2.改善读取延迟</strong>
为了改善读取延迟，请在您要运行应用程序且可以接受一点陈旧情况的每个区域中设置单独的只读副本集群。</p>
<p>这使得应用程序能够从最近的副本读取数据，而不是跨区域到Tile领导者。
<img alt="" src="./media/chapter6/82.png" />
请注意，us-west 中应用程序的读取延迟已从最初的 60 毫秒大幅降至 2 毫秒，us-central 中应用程序的读取延迟也已降至 2 毫秒。</p>
<p>由于副本可能并非所有更新都是最新的，根据设计，这可能会返回稍微陈旧的数据（默认值为 30 秒，但可以配置）。</p>
<p>这仅用于读取。 所有写入仍然发送给领导者。</p>
<p><strong>3.故障转移</strong>
当某个区域中的只读副本发生故障时，应用程序会将其读取重定向到下一个最近的只读副本或领导者。
<img alt="" src="./media/chapter6/83.png" />
请注意，当 us-west 中的只读副本失败时，us-west 中的应用程序如何从 us-central 中的follower读取数据。 在这种情况下，读取延迟为 40 ms，仍然比原来的 60 ms 小很多。</p>
<p><strong>4.了解更多</strong>
读取副本架构
追随者阅读</p>
<h2 id="_197"><strong>变更数据捕获</strong></h2>
<p>捕获对数据库中数据所做的更改。
在数据库中，变更数据捕获 （CDC） 是一组软件设计模式，用于确定和跟踪已更改的数据，以便可以使用更改的数据执行操作。CDC在许多情况下都是有益的。让我们看看其中的几个。</p>
<ul>
<li>面向微服务的架构：一些微服务需要对数据进行一系列更改，在 BrightDB 中使用 CDC 可以为 CDC 订阅者提供可消费的数据更改。</li>
<li>异步复制到远程系统：远程系统可以订阅数据更改流，然后转换和使用这些更改。出于事务和报告目的维护单独的数据库实例可用于管理工作负载性能。</li>
<li>多个数据中心策略：维护多个数据中心使企业能够提供高可用性 （HA）。</li>
<li>合规性和审核 ：审核和合规性要求可能要求您使用 CDC 来维护数据更改记录。</li>
</ul>
<p><strong>一．变更数据捕获如何运作</strong>
BrightDB CDC 捕获对数据库中数据所做的更改，并将这些更改流式传输到外部进程、应用程序或其他数据库。CDC 允许您根据 BrightDB 数据库的预写日志 （WAL） 跟踪和传播 BMDBDB 数据库中的更改并将其传播到下游使用者。BMDBDB CDC 使用 Debezium 捕获上游数据库中 INSERT、UPDATE 和 DELETE 操作导致的行级更改，并使用兼容 Kafka Connect 的连接器将它们作为事件发布到 Kafka。
<img alt="" src="./media/chapter6/84.png" />
<strong>二.Debezium 连接器</strong>
要捕获 BMDBDB 中的更改并将其流式传输到外部系统，您需要一个可以读取 BMDBDB 中的更改并将其流式传输出去的连接器。为此，您可以使用 Debezium 连接器。Debezium 部署为一组兼容 Kafka Connect 的连接器，因此您首先需要定义一个 BMDBDB 连接器配置，然后通过将其添加到 Kafka Connect 来启动连接器。</p>
<p><strong>三.监测</strong> 
您可以使用 BMDBDB 提供的 http 端点监控已部署连接器的活动和状态。</p>
<h3 id="_198"><strong>概述</strong></h3>
<p>BMDBDB 使用基于哈希或范围的策略自动将用户表拆分为多个分片（也称为Tile）。表中每一行的主键唯一标识行在Tile中的位置。
每个Tile都有自己的 WAL 文件。WAL 不在内存中，但它是磁盘持久化的。每个 WAL 都保留事务（或更改）发生的顺序。混合时间戳 、操作 ID 和有关事务的其他元数据也会保留。
<img alt="" src="./media/chapter6/85.png" />
BMDBDB 通常会在一段时间后清除 WAL 段。这意味着连接器没有对数据库所做的所有更改的完整历史记录。因此，当连接器首次连接到特定的 BMDBDB 数据库时，它首先会执行每个数据库架构的一致快照。
Debezium BMDBDB 连接器捕获 BMDBDB 数据库架构中的行级更改。首次连接到 BMDBDB 集群时，连接器会拍摄所有架构的一致快照。快照完成后，连接器会持续捕获插入、更新和删除数据库内容以及提交到 BMDBDB 数据库的行级更改。
<img alt="" src="./media/chapter6/86.png" />
连接器为捕获的每个行级插入、更新和删除操作生成一个更改事件，并在单独的 Kafka 主题中发送每个表的更改事件记录。客户端应用程序读取与感兴趣的数据库表相对应的 Kafka 主题，并可以对从这些主题接收的每个行级事件做出反应。对于每个表，默认行为是连接器将所有生成的事件流式传输到该表的单独 Kafka 主题。应用程序和服务使用来自该主题的数据更改事件记录。
CDC 的核心原语是流。可以在数据库上启用和禁用流。对监视数据库表的每次更改都会以可配置格式的记录形式发出到可配置的接收器。流可扩展到任何 BMDBDB 集群，独立于其大小，旨在尽可能少地影响生产流量。
<img alt="" src="./media/chapter6/87.png" />
<img alt="" src="./media/chapter6/88.png" /></p>
<h3 id="bmdbdb-debezium"><strong>用于 BMDBDB 的 Debezium 连接器</strong></h3>
<p>BMDBDB 的 Debezium 连接器捕获 BMDBDB 数据库架构中的行级更改。</p>
<p>首次连接到 BMDBDB 集群或 universe 时，连接器会为其配置的表拍摄一致的快照。该快照完成后，连接器将持续捕获插入、更新和删除提交到 BMDBDB 数据库的数据库内容的行级更改。连接器生成数据更改事件记录，并将其流式传输到 Kafka 主题。对于每个表，默认行为是连接器将所有生成的事件流式传输到该表的单独 Kafka 主题。应用程序和服务使用来自该主题的数据更改事件记录。</p>
<h4 id="_199"><strong>概述</strong></h4>
<p>BMDBDB 的 Debezium 连接器读取 BMDBDB 生成的更改。它使用在服务器端实现的 CDC 服务 API 来获取更改。</p>
<p>连接器为捕获的每个行级插入、更新和删除操作生成一个更改事件，并在单独的 Kafka 主题中发送每个表的更改事件记录。客户端应用程序读取与感兴趣的数据库表对应的 Kafka 主题，并可以对从这些主题接收的每个行级事件做出反应。
<img alt="" src="./media/chapter6/89.png" />
BMDBDB 通常会在一段时间后清除预写日志 （WAL） 段。这意味着连接器没有对数据库所做的所有更改的完整历史记录。因此，当 BMDBDB 连接器首次连接到特定的 BMDBDB 数据库时，它首先会拍摄每个数据库架构的快照。连接器完成快照后，会从创建快照的确切点继续流式传输更改。这样，连接器从所有数据的一致视图开始，并且不会省略在拍摄快照时所做的任何更改。</p>
<p>连接器可以容忍故障。当连接器读取更改并生成事件时，它会记录每个事件的 WAL 位置。如果连接器因任何原因（包括通信故障、网络问题或崩溃）而停止，则在重新启动时，连接器会继续使用在 Kafka 端和 BMDBDB 集群上管理的称为检查点的 WAL 位置读取上次中断的 WAL。</p>
<p>使用 UTF-8 编码
Debezium 仅支持 UTF-8 字符编码的数据库。使用单字节字符编码时，无法正确处理包含扩展 ASCII 代码字符的字符串。</p>
<h4 id="_200"><strong>连接器的工作原理</strong></h4>
<p>为了以最佳方式配置和运行 Debezium BMDBDB 连接器，了解连接器如何执行快照、流式传输更改事件、确定 Kafka 主题名称以及使用元数据会很有帮助。</p>
<h5 id="_201"><strong>安全</strong></h5>
<p>目前，对于有权访问群集的任何用户，身份验证都是通过该用户完成的。为所有必需的密钥提供基于 SSL 支持的验证，并将证书传递到连接器。</p>
<p>注意
计划在将来的版本中提供每用户 CDC 权限。</p>
<h5 id="_202"><strong>快照</strong></h5>
<p>大多数 BMDBDB 服务器配置为不保留 WAL 段中数据库的完整历史记录。这意味着 YugayteDB 连接器将无法仅通过读取 WAL 来查看数据库的整个历史记录。因此，连接器首次启动时，会执行数据库的初始一致快照。可以通过将连接器配置属性snapshot.mode来设置并执行快照任务。</p>
<p>连接器完成其初始快照后，BMDBDB 连接器将继续流式传输更改。这可确保连接器不会错过任何更新。如果连接器因任何原因再次停止，则在重新启动时，连接器将继续从之前中断的位置流式传输更改。</p>
<p>连接器配置属性snapshot.mode的选项如下所示：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>never</td>
<td>连接器从不执行快照。以这种方式配置连接器时，行为如下。如果偏移量存储在服务器上，连接器将从该位置恢复流式处理。如果服务器上未存储任何偏移量，则连接器将引导Tile，这意味着它将仅从该点开始流式传输数据，然后开始流式传输。当您知道感兴趣的数据将在部署连接器之后出现时，never快照模式非常有用。</td>
</tr>
<tr>
<td>initial</td>
<td>连接器每次启动时都会执行快照。以这种方式配置连接器时，行为如下所示。如果快照中途停止，连接器将继续从该位置拍摄快照。如果之前已为给定的流 ID 完成快照，则连接器会从点检查点恢复流式传输，这些点检查点将存储在服务器上。</td>
</tr>
<tr>
<td>initial_only</td>
<td>连接器执行数据库快照，并在流式传输任何更改事件记录之前停止。如果连接器已启动，但在停止之前未完成快照，则连接器将从停止点恢复快照过程，并在快照完成时停止。</td>
</tr>
</tbody>
</table>
<h5 id="_203"><strong>流式更改</strong></h5>
<p>BMDBDB 连接器通常花费绝大部分时间从它所连接的 BMDBDB 服务器流式传输更改信息。</p>
<p>连接器会不断轮询更改信息，每当有更改时，连接器都会处理它们，将它们转换为特定格式（对于 Debezium 插件，则为 Protobuf 或 JSON），并将它们写入输出流，然后可供客户端使用。</p>
<p>Debezium BMDBDB 连接器充当 BMDBDB 客户端。当连接器收到更改时，它会将事件转换为 Debezium 创建、更新或删除包含 LSN 的事件。BMDBDB 连接器将记录中的这些更改事件转发到在同一进程中运行的 Kafka Connect 框架。Kafka Connect 进程按照更改事件记录的生成顺序异步写入相应的 Kafka 主题。</p>
<p>Kafka Connect 会定期记录另一个 Kafka 主题中的最新偏移量。偏移量表示 Debezium 在每个事件中包含的特定于源的位置信息。</p>
<p>当 Kafka Connect 正常关闭时，它会停止连接器，并将所有事件记录刷新到 Kafka。重新启动后，连接器从 BMDBDB 服务器读取上次记录的偏移量，然后向 BMDBDB 服务器发送请求，以发送在该位置之后开始的事件。</p>
<p>架构更改
BMDBDB 连接器检索架构信息作为更改事件的一部分，该事件由表的架构元数据组成。当配置的表上发生任何架构更改时，连接器将自动接收与更改相关的事件，并更新其内部架构。</p>
<h5 id="_204"><strong>主题名称</strong></h5>
<p>默认情况下，BMDBDB 连接器将表中发生的所有INSERT、UPDATE、DELETE更改事件写入特定于该表的单个 Apache Kafka 主题。连接器将事件主题更改为 serverName.schemaName.tableName。</p>
<p>主题名称的组成部分如下：</p>
<ul>
<li>serverName：连接器的逻辑名称，由配置属性database.server.name指定。</li>
<li>schemaName：发生更改事件的数据库架构的名称。</li>
<li>tableName：发生更改事件的数据库表的名称。</li>
</ul>
<p>例如，假设dbserver是连接器配置中的逻辑服务器名称，该连接器正在捕获 BMDBDB 中的更改，BMDBDB有一个数据库bmdb，和一个架构inventory，该架构中包含4个表：products、products_on_hand、customers、orders。连接器会将记录流式传输到以下四个 Kafka 主题：</p>
<ul>
<li>dbserver.inventory.products</li>
<li>dbserver.inventory.products_on_hand</li>
<li>dbserver.inventory.customers</li>
<li>dbserver.inventory.orders</li>
</ul>
<p>现在假设这些表不是特定架构的一部分，而是在默认的公共 BMDBDB 架构中创建的，则Kafka 主题的名称为：</p>
<ul>
<li>dbserver.public.products</li>
<li>dbserver.public.products_on_hand</li>
<li>dbserver.public.customers</li>
<li>dbserver.public.orders</li>
</ul>
<p>连接器应用类似的命名约定来标记其事务元数据主题.</p>
<p>如果默认主题名称不符合您的要求，您可以配置自定义主题名称。若要配置自定义主题名称，请在逻辑主题路由 SMT 中指定正则表达式。 有关使用逻辑主题路由 SMT 自定义主题命名的更多信息，请参阅 Debezium 文档主题路由.</p>
<h5 id="_205"><strong>元信息</strong></h5>
<p>除了数据更改事件之外，BMDBDB 连接器生成的每条记录都包含一些元数据。元数据包括有关哪个Tile导致发生更改事件、提交时间、表、数据库、事件偏移量的信息，例如：</p>
<div class="highlight"><pre><span></span><code>&quot;source&quot;: {
  &quot;version&quot;: &quot;1.9.5.y.21&quot;,
  &quot;connector&quot;: &quot;bmdbdb&quot;,
  &quot;name&quot;: &quot;dbserver1&quot;,
  &quot;snapshot&quot;: &quot;false&quot;,
  &quot;db&quot;: &quot;bmdb&quot;,
  &quot;sequence&quot;: &quot;[null,\&quot;1:4::0:0\&quot;]&quot;,
  &quot;schema&quot;: &quot;public&quot;,
  &quot;table&quot;: &quot;customers&quot;,
  &quot;txId&quot;: &quot;&quot;,
  &quot;lsn&quot;: &quot;1:4::0:0&quot;
}
</code></pre></div>
<ul>
<li>version是正在使用的连接器的版本号。</li>
<li>name始终默认为连接器配置属性database.server.name</li>
<li>db是连接器配置的数据库名称。</li>
<li>sequence和lsn是变更事件所属的偏移量。</li>
<li>schema是表所属的架构名称。</li>
<li>table是变更事件所属的表的名称。</li>
<li>txId，如果更改事件是任何事务的一部分，则包含事务 ID;否则它是空的。</li>
</ul>
<h5 id="_206"><strong>事务元数据</strong></h5>
<p>Debezium 可以生成表示事务边界的事件，并丰富数据更改事件消息。</p>
<p>注意
Debezium 仅注册和接收部署连接器后发生的事务的元数据。在部署连接器之前发生的事务的元数据不可用。</p>
<p>对于每个事务 ，Debezium 都会生成一个包含以下字段的事件：</p>
<ul>
<li>Status：BEGIN或END</li>
<li>Id：唯一事务标识符的字符串表示形式</li>
<li>event_count：对于事件END，事务发出的事件总数</li>
<li>data_collections：对于事件END，由data_collection和event_count对组成的数组，提供源自给定数据集合的更改所引发的事件数量
  例如：</li>
</ul>
<div class="highlight"><pre><span></span><code>{
  &quot;status&quot;: &quot;BEGIN&quot;,
  &quot;id&quot;: &quot;571&quot;,
  &quot;event_count&quot;: null,
  &quot;data_collections&quot;: null
}

{
  &quot;status&quot;: &quot;END&quot;,
  &quot;id&quot;: &quot;571&quot;,
  &quot;event_count&quot;: 2,
  &quot;data_collections&quot;: [
    {
      &quot;data_collection&quot;: &quot;s1.a&quot;,
      &quot;event_count&quot;: 1
    },
    {
      &quot;data_collection&quot;: &quot;s2.a&quot;,
      &quot;event_count&quot;: 1
    }
  ]
}
</code></pre></div>
<p>除非通过transaction.topic选项覆盖，否则事务事件将写入主题并命名为 database.server.name.transaction。</p>
<p><strong>更改数据事件扩充</strong>
启用事务元数据后，数据消息信封将使用新的事务字段进行扩充。此字段以字段组合的形式提供有关每个事件的信息：</p>
<ul>
<li>id：唯一事务标识符的字符串表示形式</li>
<li>total_order：事件在事务生成的所有事件中的绝对位置</li>
<li>data_collection_order：事件在事务发出的所有事件中的每个数据收集位置</li>
</ul>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>{
  &quot;before&quot;: null,
  &quot;after&quot;: {
    &quot;pk&quot;: &quot;2&quot;,
    &quot;aa&quot;: &quot;1&quot;
  },
  &quot;source&quot;: {
   ...
  },
  &quot;op&quot;: &quot;c&quot;,
  &quot;ts_ms&quot;: &quot;1580390884335&quot;,
  &quot;transaction&quot;: {
    &quot;id&quot;: &quot;571&quot;,
    &quot;total_order&quot;: &quot;1&quot;,
    &quot;data_collection_order&quot;: &quot;1&quot;
  }
}
</code></pre></div>
<h4 id="_207"><strong>数据更改事件</strong></h4>
<p>Debezium BMDBDB 连接器为每个行级别INSERT、UPDATE、DELETE操作生成数据更改事件。每个事件都包含一个键和一个值。键和值的结构取决于已更改的表。</p>
<p>Debezium 和 Kafka Connect 是围绕连续的事件消息流设计的。但是，这些事件的结构可能会随着时间的推移而改变，这对消费者来说可能难以处理。为了解决此问题，每个事件都包含其内容的架构。这使得每个事件都是独立的。</p>
<p>以下框架 JSON 显示了更改事件的基本四个部分。然而，您选择在应用程序中使用的 Kafka Connect 转换器的配置方式决定了这四个部分在更改事件中的表示形式。仅当您配置转换器以生成架构字段时，架构字段才会处于更改事件中。同样，仅当配置转换器以生成事件时，事件键和事件内容才会处于更改事件中。</p>
<p>如果使用 JSON 转换器并将其配置为生成所有四个基本更改事件部件，则更改事件具有以下结构：</p>
<div class="highlight"><pre><span></span><code>{
 &quot;schema&quot;: { --&gt; 1
   ...
  },
 &quot;payload&quot;: { --&gt; 2
   ...
 },
 &quot;schema&quot;: { --&gt; 3
   ...
  },
 &quot;payload&quot;: { --&gt; 4
   ...
 }
}
</code></pre></div>
<table>
<thead>
<tr>
<th>行项目</th>
<th>字段名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>schema</td>
<td>第一个模式字段是事件键的一部分。它指定了一个Kafka Connect模式，该模式描述了事件键的有效负载部分。换句话说，第一个模式字段描述被更改的表的主键结构，如果表没有主键，则描述唯一键。</td>
</tr>
<tr>
<td>2</td>
<td>payload</td>
<td>第一个有效负载字段是事件键的一部分。它具有前一个模式字段所描述的结构，并且包含已更改行的键。</td>
</tr>
<tr>
<td>3</td>
<td>schema</td>
<td>第二个模式字段是事件值的一部分。它指定了Kafka Connect模式，该模式描述了事件值的有效负载部分。换句话说，第二个模式描述被更改的行的结构。通常，此模式包含嵌套模式。</td>
</tr>
<tr>
<td>4</td>
<td>payload</td>
<td>第二个有效负载字段是事件值的一部分。它具有前一个模式字段所描述的结构，并且包含已更改行的实际数据。</td>
</tr>
</tbody>
</table>
<p>由于无效字符导致的命名冲突
BMDBDB 连接器确保所有 Kafka Connect 架构名称都遵循Avro 架构名称格式.这意味着逻辑服务器名称必须以拉丁字母或下划线（a-z、A-Z 或 <em>）开头。逻辑服务器名称中剩余的每个字符以及架构和表名称中的每个字符都必须是拉丁字母、数字或下划线（a-z、A-Z、0-9 或 </em>）。无效字符将替换为下划线字符。
如果逻辑服务器名称、架构名称或表名称包含无效字符，则可能会导致意外冲突，而唯一区分名称的字符无效，因此替换为下划线。</p>
<h5 id="_208"><strong>更改事件键</strong></h5>
<p>对于给定的表，更改事件的键具有一个结构，该结构包含创建事件时表主键中每列的字段。</p>
<p>考虑在数据库架构public中定义的表customers以及该表的更改事件键的示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE customers (
  id SERIAL,
  name VARCHAR(255),
  email TEXT,
  PRIMARY KEY(id)
);
</code></pre></div>
<p><strong>更改事件键示例</strong>
如果连接器配置属性database.server.name具有值dbserver1，则customers表的每个更改事件都具有相同的键结构，在 JSON 中如下所示：</p>
<div class="highlight"><pre><span></span><code>{
  &quot;schema&quot;: { --&gt; 1
    &quot;type&quot;: &quot;struct&quot;,
    &quot;name&quot;: &quot;dbserver1.public.customers.Key&quot;, --&gt; 2
    &quot;optional&quot;: false, --&gt; 3
    &quot;fields&quot;: [ --&gt; 4
          {
              &quot;name&quot;: &quot;id&quot;,
              &quot;index&quot;: &quot;0&quot;,
              &quot;schema&quot;: {
                  &quot;type&quot;: &quot;INT32&quot;,
                  &quot;optional&quot;: &quot;false&quot;
              }
          }
      ]
  },
  &quot;payload&quot;: { --&gt; 5
      &quot;id&quot;: {
        &quot;value&quot;:&quot;1&quot;
      }
  },
}
</code></pre></div>
<p>此更改事件键具有以下结构：</p>
<table>
<thead>
<tr>
<th>行项目</th>
<th>字段名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>schema</td>
<td>键的模式部分指定了Kafka Connect模式，该模式描述了键的有效负载部分中的内容</td>
</tr>
<tr>
<td>2</td>
<td>dbserver1.public.customers.Key</td>
<td>定义键的有效负载结构的模式的名称。此模式描述已更改的表的主键的结构。键模式名称的格式为connector-name.database-name.table-name.Key。在本例中:dbserver1是生成此事件的服务器的逻辑名称，Public是包含被修改的表的模式，Customers是更新过的表。</td>
</tr>
<tr>
<td>3</td>
<td>optional</td>
<td>指示事件键是否必须在其有效载荷字段中包含值。在本例中，需要键的有效负载中的值。</td>
</tr>
<tr>
<td>4</td>
<td>fields</td>
<td>指定有效负载中预期的每个字段，包括每个字段的名称、索引和模式。</td>
</tr>
<tr>
<td>5</td>
<td>payload</td>
<td>包含为其生成此更改事件的行的键。在本例中，key包含一个id字段，其值为1。</td>
</tr>
</tbody>
</table>
<p>注意
尽管column.exclude.list和column.include.list连接器配置属性只允许捕获表列的子集，但主键或唯一键中的所有列始终包含在事件的键中。</p>
<h5 id="_209"><strong>更改事件值</strong></h5>
<p>更改事件中的值比键稍微复杂一些。与键一样，值也有一个模式部分和一个有效负载部分。模式部分包含描述有效负载部分的Envelope结构(包括其嵌套字段)的模式。用于创建、更新或删除数据的操作的更改事件都具有具有信封结构的值有效负载。</p>
<h5 id="_210"><strong>创建事件</strong></h5>
<p>对于给定的表，更改事件具有一个结构，该结构在创建事件时为表的每个列包含一个字段。
现在假设向表中插入了一行:</p>
<div class="highlight"><pre><span></span><code>INSERT INTO customers (name, email) VALUES (&#39;Vaibhav Kushwaha&#39;, &#39;vaibhav@example.com&#39;);
</code></pre></div>
<p>下面的示例显示了连接器为在客户表中创建数据的操作生成的更改事件的值部分:</p>
<p>create事件的字段说明如下:</p>
<div class="highlight"><pre><span></span><code>{
  &quot;schema&quot;: { --&gt; 1
    &quot;type&quot;: &quot;struct&quot;,
    &quot;fields&quot;: [
      {
        &quot;type&quot;: &quot;struct&quot;,
        &quot;fields&quot;: [ --&gt; 2
          {
            &quot;type&quot;: &quot;int32&quot;,
            &quot;optional&quot;: false,
            &quot;field&quot;: &quot;id&quot;
          },
          {
            &quot;type&quot;: &quot;string&quot;,
            &quot;optional&quot;: true,
            &quot;field&quot;: &quot;name&quot;
          },
          {
            &quot;type&quot;: &quot;string&quot;,
            &quot;optional&quot;: true,
            &quot;field&quot;: &quot;email&quot;
          }
        ],
        &quot;optional&quot;: true,
        &quot;name&quot;: &quot;dbserver1.public.customers.Value&quot;,
        &quot;field&quot;: &quot;before&quot;
      },
      {
        &quot;type&quot;: &quot;struct&quot;,
        &quot;fields&quot;: [
          {
            &quot;type&quot;: &quot;int32&quot;,
            &quot;optional&quot;: false,
            &quot;field&quot;: &quot;id&quot;
          },
          {
            &quot;type&quot;: &quot;string&quot;,
            &quot;optional&quot;: true,
            &quot;field&quot;: &quot;name&quot;
          },
          {
            &quot;type&quot;: &quot;string&quot;,
            &quot;optional&quot;: true,
            &quot;field&quot;: &quot;email&quot;
          }
        ],
        &quot;optional&quot;: true,
        &quot;name&quot;: &quot;dbserver1.public.customers.Value&quot;,
        &quot;field&quot;: &quot;after&quot;
      },
      {
        &quot;type&quot;: &quot;struct&quot;,
        &quot;fields&quot;: [
          {
            &quot;type&quot;: &quot;string&quot;,
            &quot;optional&quot;: false,
            &quot;field&quot;: &quot;version&quot;
          },
          {
            &quot;type&quot;: &quot;string&quot;,
            &quot;optional&quot;: false,
            &quot;field&quot;: &quot;connector&quot;
          },
          {
            &quot;type&quot;: &quot;string&quot;,
            &quot;optional&quot;: false,
            &quot;field&quot;: &quot;name&quot;
          },
          {
            &quot;type&quot;: &quot;int64&quot;,
            &quot;optional&quot;: false,
            &quot;field&quot;: &quot;ts_ms&quot;
          },
          {
            &quot;type&quot;: &quot;string&quot;,
            &quot;optional&quot;: true,
            &quot;name&quot;: &quot;io.debezium.data.Enum&quot;,
            &quot;version&quot;: 1,
            &quot;parameters&quot;: {
              &quot;allowed&quot;: &quot;true,last,false&quot;
            },
            &quot;default&quot;: &quot;false&quot;,
            &quot;field&quot;: &quot;snapshot&quot;
          },
          {
            &quot;type&quot;: &quot;string&quot;,
            &quot;optional&quot;: false,
            &quot;field&quot;: &quot;db&quot;
          },
          {
            &quot;type&quot;: &quot;string&quot;,
            &quot;optional&quot;: true,
            &quot;field&quot;: &quot;sequence&quot;
          },
          {
            &quot;type&quot;: &quot;string&quot;,
            &quot;optional&quot;: false,
            &quot;field&quot;: &quot;schema&quot;
          },
          {
            &quot;type&quot;: &quot;string&quot;,
            &quot;optional&quot;: false,
            &quot;field&quot;: &quot;table&quot;
          },
          {
            &quot;type&quot;: &quot;string&quot;,
            &quot;optional&quot;: true,
            &quot;field&quot;: &quot;txId&quot;
          },
          {
            &quot;type&quot;: &quot;string&quot;,
            &quot;optional&quot;: true,
            &quot;field&quot;: &quot;lsn&quot;
          },
          {
            &quot;type&quot;: &quot;int64&quot;,
            &quot;optional&quot;: true,
            &quot;field&quot;: &quot;xmin&quot;
          }
        ],
        &quot;optional&quot;: false,
        &quot;name&quot;: &quot;io.debezium.connector.postgresql.Source&quot;,
        &quot;field&quot;: &quot;source&quot;
      },
      {
        &quot;type&quot;: &quot;string&quot;,
        &quot;optional&quot;: false,
        &quot;field&quot;: &quot;op&quot;
      },
      {
        &quot;type&quot;: &quot;int64&quot;,
        &quot;optional&quot;: true,
        &quot;field&quot;: &quot;ts_ms&quot;
      },
      {
        &quot;type&quot;: &quot;struct&quot;,
        &quot;fields&quot;: [
          {
            &quot;type&quot;: &quot;string&quot;,
            &quot;optional&quot;: false,
            &quot;field&quot;: &quot;id&quot;
          },
          {
            &quot;type&quot;: &quot;int64&quot;,
            &quot;optional&quot;: false,
            &quot;field&quot;: &quot;total_order&quot;
          },
          {
            &quot;type&quot;: &quot;int64&quot;,
            &quot;optional&quot;: false,
            &quot;field&quot;: &quot;data_collection_order&quot;
          }
        ],
        &quot;optional&quot;: true,
        &quot;field&quot;: &quot;transaction&quot;
      }
    ],
    &quot;optional&quot;: false,
    &quot;name&quot;: &quot;dbserver1.public.customers.Envelope&quot;
  },
  &quot;payload&quot;: { --&gt; 3
    &quot;before&quot;: null, --&gt; 4
    &quot;after&quot;: { --&gt; 5
      &quot;id&quot;: {
        &quot;value&quot;:1
      },
      &quot;name&quot;: {
        &quot;value&quot;:&quot;Vaibhav Kushwaha&quot;
      },
      &quot;email&quot;: {
        &quot;value&quot;:&quot;vaibhav@example.com&quot;
      }
    },
    &quot;source&quot;: { --&gt; 6
      &quot;version&quot;: &quot;1.9.5.y.11&quot;,
      &quot;connector&quot;: &quot;bmdbdb&quot;,
      &quot;name&quot;: &quot;dbserver1&quot;,
      &quot;ts_ms&quot;: -8898156066356,
      &quot;snapshot&quot;: &quot;false&quot;,
      &quot;db&quot;: &quot;bmdb&quot;,
      &quot;sequence&quot;: &quot;[null,\&quot;1:4::0:0\&quot;]&quot;,
      &quot;schema&quot;: &quot;public&quot;,
      &quot;table&quot;: &quot;customers&quot;,
      &quot;txId&quot;: &quot;&quot;,
      &quot;lsn&quot;: &quot;1:4::0:0&quot;,
      &quot;xmin&quot;: null
    },
    &quot;op&quot;: &quot;c&quot;, --&gt; 7
    &quot;ts_ms&quot;: 1646145062480, --&gt; 8
    &quot;transaction&quot;: null
  }
}
</code></pre></div>
<p>create 事件中的字段如下所示：</p>
<table>
<thead>
<tr>
<th>行项目</th>
<th>字段名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>schema</td>
<td>指定Kafka Connect模式，描述事件的有效负载部分。</td>
</tr>
<tr>
<td>2</td>
<td>fields</td>
<td>表模式中指定的字段。</td>
</tr>
<tr>
<td>3</td>
<td>payload</td>
<td>为其生成此更改事件的行的键。</td>
</tr>
<tr>
<td>4</td>
<td>before</td>
<td>可选字段，指定事件发生前行的状态。当创建的op字段为c时，该字段为空，因为更改事件是针对新内容的，如本例中所示。</td>
</tr>
<tr>
<td>5</td>
<td>after</td>
<td>可选字段，指定事件发生后的行状态。在本例中，该字段包含新行id、名称和电子邮件列的值。</td>
</tr>
<tr>
<td>6</td>
<td>source</td>
<td>描述事件源元数据的必选字段。此字段包含可用于将此事件与其他事件进行比较的信息，包括事件的起源、事件发生的顺序以及事件是否属于同一事务的一部分。源元数据包括:Debezium版本连接器类型和名称包含新行的数据库和表附加偏移量信息的字符串化JSON数组，其中第一个值始终是最后提交的LSN，第二个值始终是当前LSN。两个值都可以为空。模式名如果事件是快照的一部分执行操作的事务ID操作在数据库日志中的偏移量在数据库中进行更改的时间戳</td>
</tr>
<tr>
<td>7</td>
<td>op</td>
<td>返回字符串，描述导致连接器生成事件的操作类型。在本例中，c表示该操作创建了一行。有效值为:c = creater = read (仅适用于快照)u = updated = delete</td>
</tr>
<tr>
<td>8</td>
<td>ts_ms</td>
<td>可选字段，其中包含连接器处理事件的时间。该时间基于运行Kafka Connect任务的JVM中的系统时钟。在源对象中，ts_ms表示在数据库中进行更改的时间。通过比较payload.source.ts_ms、payload.ts_ms的值，可以确定源数据库更新和Debezium之间的延迟。</td>
</tr>
</tbody>
</table>
<h5 id="_211"><strong>更新事件</strong></h5>
<p>示例客户表中更新的更改事件的值与该表的创建事件具有相同的模式。同样，事件值的有效负载也具有相同的结构。但是，事件值负载在更新事件中包含不同的值。</p>
<p>注意，更新行主键/唯一键的列会更改行键的值。当一个键改变时，Debezium输出三个事件:一个DELETE事件和一个带有该行旧键的墓碑事件，然后是一个带有该行新键的事件。有关详细信息，请参阅本页上的主键更新。</p>
<p>下面的示例显示了连接器为客户表中的更新生成的事件中的更改事件值:</p>
<div class="highlight"><pre><span></span><code>UPDATE customers SET email = &#39;service@example.com&#39; WHERE id = 1;
</code></pre></div>
<p>更新事件如下所示：</p>
<div class="highlight"><pre><span></span><code>{
  &quot;schema&quot;: {...},
  &quot;payload&quot;: {
    &quot;before&quot;: null, --&gt; 1
    &quot;after&quot;: { --&gt; 2
      &quot;id&quot;: {
        &quot;value&quot;: 1
      },
      &quot;name&quot;: {
        &quot;value&quot;: &quot;Vaibhav Kushwaha&quot;
      },
      &quot;email&quot;: {
        &quot;value&quot;: &quot;service@example.com&quot;
      }
    },
    &quot;source&quot;: { --&gt; 3
      &quot;version&quot;: &quot;1.9.5.y.11&quot;,
      &quot;connector&quot;: &quot;bmdbdb&quot;,
      &quot;name&quot;: &quot;dbserver1&quot;,
      &quot;ts_ms&quot;: -8881476960074,
      &quot;snapshot&quot;: &quot;false&quot;,
      &quot;db&quot;: &quot;bmdb&quot;,
      &quot;sequence&quot;: &quot;[null,\&quot;1:5::0:0\&quot;]&quot;,
      &quot;schema&quot;: &quot;public&quot;,
      &quot;table&quot;: &quot;customers&quot;,
      &quot;txId&quot;: &quot;&quot;,
      &quot;lsn&quot;: &quot;1:5::0:0&quot;,
      &quot;xmin&quot;: null
    },
    &quot;op&quot;: &quot;u&quot;, --&gt; 4
    &quot;ts_ms&quot;: 1646149134341,
    &quot;transaction&quot;: null
  }
}
</code></pre></div>
<p>update 事件中的字段包括：</p>
<table>
    <thead>
        <tr>
            <th>行项目</th>
            <th>字段名称</th>
            <th>描述</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1</td>
            <td>before</td>
            <td>更新操作前行的值。</td>
        </tr>
        <tr>
            <td>2</td>
            <td>after</td>
            <td>指定发生更改事件后的行状态。在本例中，email的值现在已更改为service@example.com</td>
        </tr>
        <tr>
            <td>3</td>
            <td>source</td>
            <td>描述时间源元数据的必选字段。源字段结构具有与创建事件相同的字段，但有些值不同。源元数据包括:
                <br>Debezium版本
                <br>连接器类型和名称
                <br>包含新行的数据库和表
                <br>模式名
                <br>如果事件是快照的一部分(更新事件总是false)
                <br>执行操作的事务ID
                <br>操作在数据库日志中的偏移量
                <br>在数据库中进行更改的时间戳
            </td>
        </tr>
        <tr>
            <td>4</td>
            <td>op</td>
            <td>在更新事件中，该字段的值为u，表示该行因更新而更改。</td>
        </tr>
    </tbody>
</table>

<p><strong>主键更新</strong>
更改行主键字段的UPDATE操作称为主键更改。对于主键更改，连接器不发送UPDATE事件记录，而是为旧键发送DELETE事件记录，为新(更新)键发送CREATE事件记录。这些事件具有通常的结构和内容，此外，每个事件都有一个与主键更改相关的消息头:
DELETE事件记录有__debezium.newkey作为消息头。此标题的值是更新行的新主键。
CREATE事件记录有__debezium.oldkey作为消息头。这个标题的值是更新行的上一个(旧的)主键。</p>
<h5 id="_212"><strong>删除事件</strong></h5>
<p>删除更改事件中的值与同一表的创建和更新事件具有相同的模式部分。示例客户表的删除事件中的有效负载部分如下所示:</p>
<div class="highlight"><pre><span></span><code>DELETE FROM customers WHERE id = 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>{
  &quot;schema&quot;: {...},
  &quot;payload&quot;: {
    &quot;before&quot;: { --&gt; 1
      &quot;id&quot;: {
        &quot;value&quot;: 1
      },
      &quot;name&quot;: null,
      &quot;email&quot;: null
    },
    &quot;after&quot;: null, --&gt; 2
    &quot;source&quot;: {
      &quot;version&quot;: &quot;1.9.5.y.11&quot;,
      &quot;connector&quot;: &quot;bmdbdb&quot;,
      &quot;name&quot;: &quot;dbserver1&quot;,
      &quot;ts_ms&quot;: -8876894517738,
      &quot;snapshot&quot;: &quot;false&quot;,
      &quot;db&quot;: &quot;bmdb&quot;,
      &quot;sequence&quot;: &quot;[null,\&quot;1:6::0:0\&quot;]&quot;,
      &quot;schema&quot;: &quot;public&quot;,
      &quot;table&quot;: &quot;customers&quot;,
      &quot;txId&quot;: &quot;&quot;,
      &quot;lsn&quot;: &quot;1:6::0:0&quot;,
      &quot;xmin&quot;: null
    },
    &quot;op&quot;: &quot;d&quot;, --&gt; 3
    &quot;ts_ms&quot;: 1646150253203,
    &quot;transaction&quot;: null
  }
}
</code></pre></div>
<p>此事件中的字段包括：</p>
<table>
<thead>
<tr>
<th>行项目</th>
<th>字段名字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>before</td>
<td>删除事件发生前的行值。</td>
</tr>
<tr>
<td>2</td>
<td>after</td>
<td>可选字段，指定事件发生后的行状态。在删除事件中，该字段为空，表示该行不再存在。</td>
</tr>
<tr>
<td>3</td>
<td>op</td>
<td>字段值为d，表示该行被删除。</td>
</tr>
</tbody>
</table>
<p>delete更改事件记录为使用者提供处理删除该行所需的信息。</p>
<p><strong>墓碑事件</strong>
当一行被删除时，delete事件值仍然与日志压缩一起工作，因为Kafka可以删除所有具有相同键的早期消息。但是，Kafka要删除所有具有相同键的消息，消息值必须为空。为了实现这一点，BMDBDB连接器使用具有相同键但为空值的特殊墓碑事件跟踪删除事件。</p>
<p>当启用CDC时，TRUNCATE表
默认情况下，BMDBDB CDC实现不允许在名称空间上存在活动CDC流时对表进行TRUNCATE。要允许在CDC活动时截断表，请将enable_truncate_cdcsdk_table标志设置为true。</p>
<p>抑制墓碑事件
您可以使用其tombstones.on.delete属性来配置连接器是否发出墓碑事件。
是否允许连接器发出墓碑，取决于在您的环境中如何使用主题，以及接收器使用者的特征。如果接收器使用者依赖墓碑记录来指示何时删除下游数据存储中的记录，则应该配置连接器以发出它们。
默认情况下，连接器的tombstones.on.delete属性被设置为true，以便连接器在每次删除事件之后生成一个墓碑。
如果你将属性设置为false以防止连接器将墓碑记录保存到Kafka主题，那么如果你的sink没有被设计为正确处理它，那么墓碑记录的缺失可能会导致意想不到的后果。例如，Kafka在日志压缩期间依赖于墓碑来删除与已删除键相关的记录。</p>
<h4 id="_213"><strong>数据类型映射</strong></h4>
<p>BMDBDB连接器用事件表示对行所做的更改，这些事件的结构与该行所在的表类似。事件包含每个列值的字段。该值在事件中的表示方式取决于列的BMDBDB数据类型。以下部分描述连接器如何将BMDBDB数据类型映射到事件字段中的文字类型和语义类型。</p>
<ul>
<li>文字类型描述了如何使用Kafka Connect模式类型来表示值:INT8, INT16, INT32, INT64, FLOAT32, FLOAT64, BOOLEAN, STRING, BYTES, ARRAY, MAP和STRUCT。</li>
<li>语义类型描述Kafka Connect模式如何使用字段的Kafka Connect模式名称捕获字段的含义。</li>
</ul>
<h5 id="_214"><strong>默认值</strong></h5>
<p>如果BMDBDB数据库模式中的任何列都有默认值，则BMDBDB Debezium连接器将相同的值传播到Kafka模式。</p>
<h5 id="_215"><strong>基本类型</strong></h5>
<p>下表描述了BMDBDB基本数据类型的映射。</p>
<table>
<thead>
<tr>
<th>BMDBdb数据类型</th>
<th>文字类型(模式类型)</th>
<th>语义类型(模式名称)</th>
</tr>
</thead>
<tbody>
<tr>
<td>BOOLEAN</td>
<td>BOOLEAN</td>
<td>N/A</td>
</tr>
<tr>
<td>BIT(1)</td>
<td>STRING</td>
<td>N/A</td>
</tr>
<tr>
<td>BIT( &gt; 1)</td>
<td>STRING</td>
<td>N/A</td>
</tr>
<tr>
<td>VARBIT[(M)]</td>
<td>STRING</td>
<td>N/A</td>
</tr>
<tr>
<td>SMALLINT，SMALLSERIAL</td>
<td>INT16</td>
<td>N/A</td>
</tr>
<tr>
<td>INTEGER, SERIAL</td>
<td>INT32</td>
<td>N/A</td>
</tr>
<tr>
<td>BIGINT, BIGSERIAL</td>
<td>INT64</td>
<td>N/A</td>
</tr>
<tr>
<td>REAL</td>
<td>FLOAT32</td>
<td>N/A</td>
</tr>
<tr>
<td>DOUBLE PRECISION</td>
<td>FLOAT64</td>
<td>N/A</td>
</tr>
<tr>
<td>CHAR [(M)]</td>
<td>STRING</td>
<td>N/A</td>
</tr>
<tr>
<td>VARCHAR [(M)]</td>
<td>STRING</td>
<td>N/A</td>
</tr>
<tr>
<td>TEXT</td>
<td>STRING</td>
<td>N/A</td>
</tr>
<tr>
<td>TIMESTAMPTZ</td>
<td>STRING</td>
<td>io.debezium.time.ZonedTimestamp带有时区信息的时间戳的字符串表示形式，其中时区为GMT。</td>
</tr>
<tr>
<td>TIMETZ</td>
<td>STRING</td>
<td>io.debezium.time.ZonedTime带有时区信息的时间值的字符串表示形式，其中时区为GMT。</td>
</tr>
<tr>
<td>INTERVAL [P]</td>
<td>INT64</td>
<td>io.debezium.time.MicroDuration (default)使用每月平均天数的365.25 / 12.0公式计算时间间隔的大致微秒数。</td>
</tr>
<tr>
<td>INTERVAL [P]</td>
<td>STRING</td>
<td>io.debezium.time.Interval(当interval.handling.mode为string时)遵循模式的间隔值的字符串表示形式P &lt;年&gt; Y &lt;月&gt; M &gt; &lt;天DT &lt;时间&gt; H &lt;分钟&gt; M &lt;秒&gt;。例如P1Y2M3DT4H5M6.78S。</td>
</tr>
<tr>
<td>BYTEA</td>
<td>STRING</td>
<td>十六进制编码的字符串。</td>
</tr>
<tr>
<td>JSON, JSONB</td>
<td>STRING</td>
<td>io.debezium.data.Json包含JSON文档、数组或标量的字符串表示形式。</td>
</tr>
<tr>
<td>UUID</td>
<td>STRING</td>
<td>io.debezium.data.Uuid包含BMDBDB UUID值的字符串表示形式。</td>
</tr>
<tr>
<td>DATE</td>
<td>INT32</td>
<td>自UNIX纪元(1970年1月1日)以来的天数。</td>
</tr>
<tr>
<td>TIME</td>
<td>INT32</td>
<td>距离午夜几毫秒。</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>INT64</td>
<td>UNIX纪元(1970-01-01 00:00:00)以来的毫秒数。</td>
</tr>
<tr>
<td>INT4RANGE</td>
<td>STRING</td>
<td>整数范围。</td>
</tr>
<tr>
<td>INT8RANGE</td>
<td>STRING</td>
<td>bigint的范围。</td>
</tr>
<tr>
<td>NUMRANGE</td>
<td>STRING</td>
<td>数字范围。</td>
</tr>
<tr>
<td>TSRANGE</td>
<td>STRING</td>
<td>不带时区的时间戳范围的字符串表示形式。</td>
</tr>
<tr>
<td>TSTZRANGE</td>
<td>STRING</td>
<td>具有本地系统时区的时间戳范围的字符串表示形式</td>
</tr>
<tr>
<td>DATERANGE</td>
<td>STRING</td>
<td>日期范围的字符串表示形式。总是有一个唯一的上界。</td>
</tr>
<tr>
<td>ARRAY</td>
<td>ARRAY</td>
<td>N/A</td>
</tr>
<tr>
<td>ENUM</td>
<td>STRING</td>
<td>枚举标签的字符串表示形式。</td>
</tr>
</tbody>
</table>
<h5 id="_216"><strong>时间类型</strong></h5>
<p>除了BMDBDB的TIMESTAMPTZ和TIMETZ数据类型(包含时区信息)之外，时间类型的映射方式取决于time.precision.mode连接器配置属性的值。下面的部分描述了这些映射:</p>
<ul>
<li>time.precision.mode=adaptive</li>
<li>time.precision.mode=adaptive_time_microseconds</li>
<li>time.precision.mode=connect</li>
</ul>
<p>adaptive模式
当time.precision.mode属性设置为adaptive(默认值)时，连接器根据列的数据类型定义确定文字类型和语义类型。这确保了事件准确地表示数据库中的值。
下表描述了time.precision.mode为adaptive时的映射。</p>
<h2 id="_217"><strong>升级部署</strong></h2>
<p>基本流程是一次升级每个 MServer 和 DBServer，在每一步之后从 MServer 管理 UI 验证集群是否正常以及升级过程是否重新上线。</p>
<p>如果您打算循环编写此脚本，则建议在从一个进程或节点移动到另一个进程或节点之前暂停大约 60 秒。</p>
<p>您的 data/log/conf 目录通常存储在单独的位置，该位置在升级过程中保持不变，以便在升级过程中保留集群数据及其配置设置。</p>
<h3 id="bmdb_6"><strong>安装新版本的</strong> <strong>BMDB</strong></h3>
<p>在新位置安装新版本的 BMDB。 对于 CentOS，这将使用类似于以下的命令：</p>
<div class="highlight"><pre><span></span><code>wget https://downloads.bigmath.com/bigmath-$VER.tar.gz
tar xf bigmath-$VER.tar.gz -C /home/bigmath/softwarebm-$VER/
cd /home/bigmath/softwarebm-$VER/
./bin/post_install.sh
</code></pre></div>
<p>如果您使用 PostgreSQL 扩展，请确保在升级服务器之前在新的 BMDB 版本中安装扩展。 有关更多信息，请参阅安装扩展。</p>
<h3 id="mservers_1"><strong>升级MServers</strong></h3>
<p>使用以下过程升级 MServer：</p>
<p>1.停止旧版本的MServer进程，如下：</p>
<div class="highlight"><pre><span></span><code>pkill mserver
</code></pre></div>
<p>2.验证您是否位于新版本的目录中，如下所示：</p>
<div class="highlight"><pre><span></span><code>cd /home/bigmath/softwarebm-$VER/
</code></pre></div>
<p>3.启动较新版本的 MServer 进程。 有关更多信息，请参阅启动 MServer。</p>
<p>4.在 http://<any-mserver>:10000/ 中验证所有 MServer 是否都处于活动状态。</p>
<p>5.在升级下一个 MServer 之前暂停大约 60 秒。</p>
<h3 id="dbservers"><strong>升级DBServers</strong></h3>
<p>使用以下过程升级 DBServer：</p>
<p>1.停止旧版本的 dbserver 进程，如下所示：</p>
<div class="highlight"><pre><span></span><code>pkill dbserver
</code></pre></div>
<p>2.验证您是否位于新版本的目录中，如下所示：</p>
<div class="highlight"><pre><span></span><code>cd /home/bigmath/softwarebm-$VER/
</code></pre></div>
<p>3.启动较新版本的 DBServer 进程。 有关详细信息，请参阅启动 DBServer。</p>
<p>4.在 http://<any-mserver>:10000/tile-servers 中进行验证，以查看新的 DBServer 是否处于活动状态并且正在运行。</p>
<p>5.在升级下一个 DBServer 之前暂停大约 60 秒。</p>
<h3 id="autoflags"><strong>升级AutoFlags</strong></h3>
<p>新的 BMDB 功能可能需要更改通过线路发送或存储在磁盘上的数据格式。 在升级过程中，必须关闭这些功能，以防止将新数据格式发送到仍在运行旧版本的节点。 当所有 BMDB 进程都升级到新版本后，这些功能就可以安全地启用。</p>
<p>AutoFlags 简化了这个过程，这样您就不需要识别这些功能，找到它们相应的标志，或者确定将它们设置为什么值。 所有新的 AutoFlags 都可以使用单个命令提升到所需的目标值。</p>
<p>使用 bm-admin 实用程序升级新的 AutoFlags，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -mserver_addresses &lt;mserver-addresses&gt; \
    promote_auto_flags
</code></pre></div>
<p>AutoFlags 的提升是一种在线操作，不需要停止正在运行的集群或重新启动任何进程。 它也是一个幂等过程，这意味着它可以运行多次而不会产生任何副作用。</p>
<p>请注意，新的 AutoFlags 可能需要最多两倍于 FLAGS_heartbeat_interval_ms 值（以毫秒为单位）的时间才能完全传播到集群中的所有进程。</p>
<p>注：在升级AutoFlags之前，请确保集群中所有BMDB进程都已升级到新版本。 如果任何运行旧版本的进程在提升 AutoFlags 后尝试连接到集群，则可能会失败。</p>
<p><strong>示例</strong></p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -mserver_addresses ip1:11000,ip2:11000,ip3:11000 \
    promote_auto_flags
</code></pre></div>
<p>如果操作成功，您应该看到类似以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>PromoteAutoFlags status: 
New AutoFlags were promoted. Config version: 2
</code></pre></div>
<p>或</p>
<div class="highlight"><pre><span></span><code>PromoteAutoFlags status: 
No new AutoFlags to promote
</code></pre></div>
<h3 id="bsql_6"><strong>升级BSQL系统目录</strong></h3>
<p>与 PostgreSQL 类似，BMDB 将 BSQL 系统元数据（称为 BSQL 系统目录）存储在特殊表中。 元数据包括有关表、列、函数、用户等的信息。 这些表是单独存储的，集群中的每个数据库都有一个表。</p>
<p>当BMDB添加新功能时，需要将新表和函数等对象添加到系统目录中。 当您使用最新版本创建新集群时，它将使用最新的预打包 BSQL 系统目录快照进行初始化。</p>
<p>但是，BMDB 升级过程仅升级二进制文件，不会影响现有集群的 BSQL 系统目录 - 它保持与升级前相同的状态。 为了在升级时获得最新BSQL功能的好处，您需要手动升级BSQL系统目录。</p>
<p>BSQL 系统目录可通过 BSQL API 访问，并且是 BSQL 功能所必需的。 对于未启用BSQL的集群，不需要升级BSQL系统目录。</p>
<p>BSQL 系统目录升级适用于 BMDB 2.8 或更高版本的集群。</p>
<p>完成 BMDB 升级过程后，使用 bm-admin 实用程序升级 BSQL 系统目录，如下所示：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -mserver_addresses &lt;mserver-addresses&gt; \
    upgrade_bsql
</code></pre></div>
<p>期望看到以下输出：</p>
<div class="highlight"><pre><span></span><code>BSQL successfully upgraded to the latest version
</code></pre></div>
<p>在某些情况下，BSQL 升级可能需要超过 60 秒，这是 bm-admin 的默认超时值。 如果发生这种情况，请使用更大的超时值运行以下命令：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -mserver_addresses ip1:11000,ip2:11000,ip3:11000 \
    -timeout_ms 180000 \
    upgrade_bsql
</code></pre></div>
<p>升级BSQL系统目录是在线操作，不需要停止正在运行的集群。 Upgrade_bsql 是幂等的，可以多次运行，没有任何副作用。</p>
<p>集群中的并发操作可能会导致事务冲突、目录版本不匹配和读取重新启动错误。 这是预期的，应该通过重新运行upgrade_bsql 来解决。</p>
<h3 id="xdcr"><strong>升级和 xDCR</strong></h3>
<p>配置 xDCR 复制后，在升级 xDCR 复制涉及的任何集群时，需要暂时暂停复制。</p>
<p>使用以下过程升级 xDCR 复制中涉及的集群：</p>
<p>1.暂停参与复制的集群上的 xDCR 复制。 如果复制设置是双向的，请确保在两个方向上都暂停复制。</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -mserver_addresses &lt;mserver-addresses&gt; \
    -certs_dir_name &lt;cert_dir&gt; \
    set_universe_replication_enabled &lt;replication_group_name&gt; 0
</code></pre></div>
<p>期望看到以下输出：</p>
<div class="highlight"><pre><span></span><code>Replication disabled successfully
</code></pre></div>
<p>2.继续执行所有涉及的集群的升级。</p>
<p>3.使用 bm-admin 在涉及的所有集群上恢复复制。</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -mserver_addresses &lt;mserver-addresses&gt; \
    -certs_dir_name &lt;cert_dir&gt; \
    set_universe_replication_enabled &lt;replication_group_name&gt; 1
</code></pre></div>
<p>期望看到以下输出：</p>
<div class="highlight"><pre><span></span><code>Replication enabled successfully
</code></pre></div>
<p><strong>目前不支持降级。</strong></p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      © 2024 贝格迈思
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.aecac24b.min.js"></script>
      
        <script src="../../javascripts/extra.js"></script>
      
    
  </body>
</html>