
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="贝格迈思数据库使用手册">
      
      
      
      
        <link rel="prev" href="../08-AI%E7%89%B9%E6%80%A7/">
      
      
        <link rel="next" href="../09.2-CLIs/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.4.6">
    
    
      
        <title>架构 - 手册</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.35e1ed30.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.356b1318.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Ubuntu";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="mo" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="手册" class="md-header__button md-logo" aria-label="手册" data-md-component="logo">
      
  <img src="../../assets/new-logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            手册
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              架构
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/aminerdocs/docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="手册" class="md-nav__button md-logo" aria-label="手册" data-md-component="logo">
      
  <img src="../../assets/new-logo.png" alt="logo">

    </a>
    手册
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/aminerdocs/docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../01-AISQL%E7%AE%80%E4%BB%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AiSQL简介
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    快速上手
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            快速上手
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    快速安装部署
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/SQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SQL基本操作
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/BCQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BCQL基本操作
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%88%9B%E5%BB%BAJava%E7%A4%BA%E4%BE%8B%E5%BA%94%E7%94%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    创建Java示例应用程序
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    应用开发
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            应用开发
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    构建应用
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            构建应用
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/JAVA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Java
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Go/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Go
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Python/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Python
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Node.js/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Node.js
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C%2B%2B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C%23/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C#
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Ruby/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Ruby
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Rust/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Rust
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/PHP/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PHP
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%85%A8%E5%B1%80%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    构建全局应用程序
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    构建多云应用程序
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            构建多云应用程序
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    概述
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../04-%E9%83%A8%E7%BD%B2%E9%9B%86%E7%BE%A4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    部署集群
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../05-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数据迁移
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../06-%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    管理数据库
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../07-%E5%90%91%E9%87%8F%E7%89%B9%E6%80%A7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    向量特性
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../08-AI%E7%89%B9%E6%80%A7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AI特性
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" checked>
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    参考
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            参考
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    架构
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    架构
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    架构
  </a>
  
    <nav class="md-nav" aria-label="架构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    设计目标
  </a>
  
    <nav class="md-nav" aria-label="设计目标">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    一致性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#api" class="md-nav__link">
    查询API
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    性能
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    地理分布式部署
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    云原生架构
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    基本概念
  </a>
  
    <nav class="md-nav" aria-label="基本概念">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#universe" class="md-nav__link">
    Universe
  </a>
  
    <nav class="md-nav" aria-label="Universe">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    数据组织
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    组件服务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#universe-vs-cluster" class="md-nav__link">
    Universe vs. cluster
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbserver" class="md-nav__link">
    DBServer服务
  </a>
  
    <nav class="md-nav" aria-label="DBServer服务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    服务器全局块缓存
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    空间放大
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#throttled-compactions" class="md-nav__link">
    节流压缩Throttled compactions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    小型和大型压缩队列
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mserver" class="md-nav__link">
    MServer服务
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    核心功能
  </a>
  
    <nav class="md-nav" aria-label="核心功能">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#universe_1" class="md-nav__link">
    创建Universe
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    表创建
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#io" class="md-nav__link">
    写I/O路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#io_1" class="md-nav__link">
    读I/O路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    高可用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    分层架构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    查询层
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coredb" class="md-nav__link">
    CoreDB事务层
  </a>
  
    <nav class="md-nav" aria-label="CoreDB事务层">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    隔离级别
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    并发控制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    事务优先级
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    读已提交
  </a>
  
    <nav class="md-nav" aria-label="读已提交">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    语义学
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    用法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    跨功能交互
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    局限性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    注意事项
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    单行事务
  </a>
  
    <nav class="md-nav" aria-label="单行事务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reading-the-latest-data-from-a-recently-elected-leader" class="md-nav__link">
    Reading the latest data from a recently elected leader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#leader-lease" class="md-nav__link">
    Leader Lease：在网络分区的情况下读取最新数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    读取请求的安全时间戳分配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    将安全时间从领导者传播到追随者以供追随者端读取
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    分布式事务
  </a>
  
    <nav class="md-nav" aria-label="分布式事务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#provisional-records" class="md-nav__link">
    临时记录Provisional records
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transaction-status-tracking" class="md-nav__link">
    交易状态追踪Transaction status tracking
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    故障的影响
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#io_2" class="md-nav__link">
    事务I/O路径
  </a>
  
    <nav class="md-nav" aria-label="事务I/O路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    写入路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    读取路径
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coredb_1" class="md-nav__link">
    CoreDB分片层
  </a>
  
    <nav class="md-nav" aria-label="CoreDB分片层">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    哈希和范围分片
  </a>
  
    <nav class="md-nav" aria-label="哈希和范围分片">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    哈希分片
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    范围分片
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tile" class="md-nav__link">
    Tile分裂
  </a>
  
    <nav class="md-nav" aria-label="Tile分裂">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tile_1" class="md-nav__link">
    Tile分裂的方法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#colocated-tables" class="md-nav__link">
    Colocated tables
  </a>
  
    <nav class="md-nav" aria-label="Colocated tables">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    共址的好处以及用例的注意事项
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    启用共址
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    指标和视图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    限制和注意事项
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#xdcr" class="md-nav__link">
    xDCR和共址
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coredb_2" class="md-nav__link">
    CoreDB复制层
  </a>
  
    <nav class="md-nav" aria-label="CoreDB复制层">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    同步
  </a>
  
    <nav class="md-nav" aria-label="同步">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tilepeers" class="md-nav__link">
    Tile对等体peers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    主集群中的复制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    追随者阅读
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#xdcr_1" class="md-nav__link">
    xDCR
  </a>
  
    <nav class="md-nav" aria-label="xDCR">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    同步复制与异步复制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aisql-xdcr" class="md-nav__link">
    AiSQL 的 xDCR 复制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    异步复制模式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    高层实施细节
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    架构差异
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#replication-bootstrapping" class="md-nav__link">
    复制引导Replication bootstrapping
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    支持的部署场景
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    不支持的部署场景
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    局限性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    跨功能交互
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#read-replicas" class="md-nav__link">
    Read replicas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#change-data-capture-cdc" class="md-nav__link">
    Change data capture (CDC)
  </a>
  
    <nav class="md-nav" aria-label="Change data capture (CDC)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    用例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    流程架构
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coredb_3" class="md-nav__link">
    CoreDB存储层
  </a>
  
    <nav class="md-nav" aria-label="CoreDB存储层">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    持久化
  </a>
  
    <nav class="md-nav" aria-label="持久化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    存储模型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql-coredb" class="md-nav__link">
    将 SQL 行映射到 CoreDB
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#packed-row-format" class="md-nav__link">
    打包行格式Packed row format
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql" class="md-nav__link">
    BCQL 中的数据过期
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql_1" class="md-nav__link">
    BCQL 的集合类型示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql-ttl" class="md-nav__link">
    BCQL 的 TTL 示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    性能
  </a>
  
    <nav class="md-nav" aria-label="性能">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#rocksdb" class="md-nav__link">
    RocksDB 的增强
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    数据模型感知的布隆过滤器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    范围查询优化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_63" class="md-nav__link">
    高效的内存使用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_64" class="md-nav__link">
    抗扫描块缓存
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.2-CLIs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CLIs
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.3-%E9%85%8D%E7%BD%AE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    配置
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.4-BSQL/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BSQL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.5-BCQL/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BCQL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    架构
  </a>
  
    <nav class="md-nav" aria-label="架构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    设计目标
  </a>
  
    <nav class="md-nav" aria-label="设计目标">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    一致性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#api" class="md-nav__link">
    查询API
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    性能
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    地理分布式部署
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    云原生架构
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    基本概念
  </a>
  
    <nav class="md-nav" aria-label="基本概念">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#universe" class="md-nav__link">
    Universe
  </a>
  
    <nav class="md-nav" aria-label="Universe">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    数据组织
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    组件服务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#universe-vs-cluster" class="md-nav__link">
    Universe vs. cluster
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbserver" class="md-nav__link">
    DBServer服务
  </a>
  
    <nav class="md-nav" aria-label="DBServer服务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    服务器全局块缓存
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    空间放大
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#throttled-compactions" class="md-nav__link">
    节流压缩Throttled compactions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    小型和大型压缩队列
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mserver" class="md-nav__link">
    MServer服务
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    核心功能
  </a>
  
    <nav class="md-nav" aria-label="核心功能">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#universe_1" class="md-nav__link">
    创建Universe
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    表创建
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#io" class="md-nav__link">
    写I/O路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#io_1" class="md-nav__link">
    读I/O路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    高可用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    分层架构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    查询层
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coredb" class="md-nav__link">
    CoreDB事务层
  </a>
  
    <nav class="md-nav" aria-label="CoreDB事务层">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    隔离级别
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    并发控制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    事务优先级
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    读已提交
  </a>
  
    <nav class="md-nav" aria-label="读已提交">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    语义学
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    用法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    跨功能交互
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    局限性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    注意事项
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    单行事务
  </a>
  
    <nav class="md-nav" aria-label="单行事务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reading-the-latest-data-from-a-recently-elected-leader" class="md-nav__link">
    Reading the latest data from a recently elected leader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#leader-lease" class="md-nav__link">
    Leader Lease：在网络分区的情况下读取最新数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    读取请求的安全时间戳分配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    将安全时间从领导者传播到追随者以供追随者端读取
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    分布式事务
  </a>
  
    <nav class="md-nav" aria-label="分布式事务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#provisional-records" class="md-nav__link">
    临时记录Provisional records
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transaction-status-tracking" class="md-nav__link">
    交易状态追踪Transaction status tracking
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    故障的影响
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#io_2" class="md-nav__link">
    事务I/O路径
  </a>
  
    <nav class="md-nav" aria-label="事务I/O路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    写入路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    读取路径
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coredb_1" class="md-nav__link">
    CoreDB分片层
  </a>
  
    <nav class="md-nav" aria-label="CoreDB分片层">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    哈希和范围分片
  </a>
  
    <nav class="md-nav" aria-label="哈希和范围分片">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    哈希分片
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    范围分片
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tile" class="md-nav__link">
    Tile分裂
  </a>
  
    <nav class="md-nav" aria-label="Tile分裂">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tile_1" class="md-nav__link">
    Tile分裂的方法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#colocated-tables" class="md-nav__link">
    Colocated tables
  </a>
  
    <nav class="md-nav" aria-label="Colocated tables">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    共址的好处以及用例的注意事项
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    启用共址
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    指标和视图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    限制和注意事项
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#xdcr" class="md-nav__link">
    xDCR和共址
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coredb_2" class="md-nav__link">
    CoreDB复制层
  </a>
  
    <nav class="md-nav" aria-label="CoreDB复制层">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    同步
  </a>
  
    <nav class="md-nav" aria-label="同步">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tilepeers" class="md-nav__link">
    Tile对等体peers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    主集群中的复制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    追随者阅读
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#xdcr_1" class="md-nav__link">
    xDCR
  </a>
  
    <nav class="md-nav" aria-label="xDCR">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    同步复制与异步复制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aisql-xdcr" class="md-nav__link">
    AiSQL 的 xDCR 复制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    异步复制模式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    高层实施细节
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    架构差异
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#replication-bootstrapping" class="md-nav__link">
    复制引导Replication bootstrapping
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    支持的部署场景
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    不支持的部署场景
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    局限性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    跨功能交互
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#read-replicas" class="md-nav__link">
    Read replicas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#change-data-capture-cdc" class="md-nav__link">
    Change data capture (CDC)
  </a>
  
    <nav class="md-nav" aria-label="Change data capture (CDC)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    用例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    流程架构
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coredb_3" class="md-nav__link">
    CoreDB存储层
  </a>
  
    <nav class="md-nav" aria-label="CoreDB存储层">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    持久化
  </a>
  
    <nav class="md-nav" aria-label="持久化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    存储模型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql-coredb" class="md-nav__link">
    将 SQL 行映射到 CoreDB
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#packed-row-format" class="md-nav__link">
    打包行格式Packed row format
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql" class="md-nav__link">
    BCQL 中的数据过期
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql_1" class="md-nav__link">
    BCQL 的集合类型示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql-ttl" class="md-nav__link">
    BCQL 的 TTL 示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    性能
  </a>
  
    <nav class="md-nav" aria-label="性能">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#rocksdb" class="md-nav__link">
    RocksDB 的增强
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    数据模型感知的布隆过滤器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    范围查询优化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_63" class="md-nav__link">
    高效的内存使用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_64" class="md-nav__link">
    抗扫描块缓存
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


  <h1>架构</h1>

<h2 id="_1"><strong>架构</strong></h2>
<h3 id="_2"><strong>设计目标</strong></h3>
<p>BMDB 的创建是为了实现许多设计目标。</p>
<h4 id="_3"><strong>一致性</strong></h4>
<p>BMDB 支持分布式事务，同时在面对潜在故障时提供强大的一致性保证。</p>
<p>有关详细信息，请参阅以下内容：</p>
<ul>
<li>与Raft共识实现一致性</li>
<li>容错和高可用性</li>
<li>AiSQL 中的单行线性化事务</li>
<li>分布式事务的架构</li>
</ul>
<p><strong>CAP定理和裂脑</strong>
从CAP定理来看，AiSQL是一个一致性和分区容忍（CP）数据库，同时实现了非常高的可用性。 AiSQL的架构设计与另一个CP系统Google Cloud Spanner类似。 Spanner的描述也适用于AiSQL。 关键要点是没有一个系统可以提供 100% 的可用性，因此务实的问题是系统是否提供足够高的可用性，使大多数用户不再需要担心中断。 例如，考虑到应用程序的中断来源有很多，如果 AiSQL 对其停机时间的影响微不足道，那么用户不必担心它是正确的。</p>
<p>裂脑是一种当分布式系统发生网络分区时会出现数据和可用性不一致的计算场景。 对于 AiSQL，当发生网络分区时，其余（大多数用于写入确认目的）RAFT 组对等体会选举新的Tile领导者。 AiSQL 实现了领导者租约，这确保了整个分布式系统中（包括发生网络分区时）存在单个 Tile 领导者。 领导者租约的默认值为两秒，并且可以配置为使用不同的值。 这种架构确保了 AiSQL 的分布式数据库不易受到裂脑情况的影响。</p>
<p><strong>单行线性化</strong>
AiSQL 支持单行线性化写入。 线性化是最强的单行一致性模型之一，意味着每个操作似乎都是原子地发生的，并且以与这些操作的实时顺序一致的某种总线性顺序发生。 换句话说，对于单行操作，预计会出现以下情况：</p>
<ul>
<li>操作可以并发执行，但任何时间点的数据库状态都必须表现为某些完全有序、顺序执行的操作的结果。</li>
<li>如果操作 A 在操作 B 开始之前完成，则逻辑上 B 应在 A 之后生效。</li>
</ul>
<p><strong>多行 ACID 事务</strong>
AiSQL 支持具有三种隔离级别的多行事务：可串行化、快照（也称为可重复读）和读提交隔离。</p>
<p>BSQL API 分别使用 PostgreSQL 隔离级别语法 SERIALIZABLE、REPEATABLE READ 和 READ COMMITTED 支持可串行化、快照（默认）和读提交隔离。 有关更多详细信息，请参阅 BSQL 与 PostgreSQL 隔离级别。
BCQL API 仅支持使用 BEGIN TRANSACTION 语法的快照隔离（默认）。</p>
<p><strong>BSQL 与 PostgreSQL 隔离级别</strong>
READ COMMITTED 是 PostgreSQL 和 BSQL 中的默认隔离级别。 如果 bm_enable_read_commissed_isolation=true，则 READ COMMITTED 将映射到 AiSQL 事务层的 Read Commissed（即，语句会看到在开始之前已提交的所有行）。 但是，默认情况下 bm_enable_read_commissed_isolation=false，在这种情况下，AiSQL 事务层的读已提交映射到快照隔离，从而使快照隔离在 BSQL 中默认。</p>
<p>请注意，AiSQL 中的读提交支持当前处于技术预览版中。</p>
<p>请参阅隔离级别表，了解 BSQL 隔离级别如何映射到 PostgreSQL 定义的级别。</p>
<h4 id="api"><strong>查询API</strong></h4>
<p>AiSQL 支持的两个 API 是 BSQL 和 BCQL。 它们与现有 API 兼容并扩展其功能。</p>
<p><strong>BSQL</strong>
BSQL 是一个完全关系型 SQL API，与 PostgreSQL 中的 SQL 语言兼容。 它最适合需要水平写入可扩展性和全局数据分布的 RDBMS 工作负载，同时还使用关系建模功能，例如联接、分布式事务和引用完整性（例如外键）。 请注意，BSQL 重用了 PostgreSQL 开源项目的本机查询层。</p>
<p>此外：</p>
<ul>
<li>BSQL 的新更改不会破坏现有的 PostgreSQL 功能。</li>
<li>BSQL 的设计目标是随着时间的推移迁移到较新的 PostgreSQL 版本。 这意味着新功能在 AiSQL 代码库中以模块化方式实现，以实现与新 PostgreSQL 功能的快速集成作为一个持续的过程。</li>
<li>BSQL 支持广泛的 SQL 功能，例如：
  所有数据类型
  内置函数和表达式
  连接（内连接、外连接、完全外连接、交叉连接、自然连接）
  约束（主键、外键、唯一、不为空、检查）
  二级索引（包括多列、覆盖）
  分布式事务（可串行化、快照和读提交隔离）
  视图
  存储过程
  触发器</li>
</ul>
<p><strong>BCQL</strong>
BCQL 是一种半关系 SQL API，最适合需要大规模写入可扩展性和快速查询的互联网规模 OLTP 和 HTAP 应用程序。 BCQL支持分布式事务、强一致性二级索引和原生JSON列类型。 BCQL 源于 Cassandra 查询语言。</p>
<p>有关更多信息，请参阅查询层概述。</p>
<h4 id="_4"><strong>性能</strong></h4>
<p>AiSQL 采用 C++ 编写，以确保高性能和使用大内存堆 (RAM) 作为内部数据库缓存的能力，主要针对在 SSD 和非易失性内存 Express (NVMe) 驱动器上运行进行了优化。 AiSQL 的设计考虑了以下工作负载特征：</p>
<ul>
<li>高写入吞吐量</li>
<li>高客户端并发</li>
<li>高数据密度（每个节点的总数据集大小）</li>
<li>能够处理不断增长的事件数据用例</li>
</ul>
<p>有关更多信息，请参阅 AiSQL 中的高性能。</p>
<h4 id="_5"><strong>地理分布式部署</strong></h4>
<p>AiSQL 适用于universe节点跨越以下方面的部署：</p>
<ul>
<li>单可用区</li>
<li>多可用区</li>
<li>地理上重复的多个区域</li>
<li>多个云（公共云和私有云）</li>
</ul>
<p>为了提供功能，必须满足许多要求。 例如，跨多种语言的客户端驱动程序满足以下条件：
集群感知，能够无缝处理节点故障。
拓扑感知，能够无缝路由流量。</p>
<h4 id="_6"><strong>云原生架构</strong></h4>
<p>AiSQL 是一个云原生数据库，在设计时考虑了许多云原生原则。</p>
<p><strong>在商用硬件上运行</strong></p>
<ul>
<li>能够在任何公共云或本地数据中心上运行。 这包括裸机、虚拟机和容器上的商用硬件。</li>
<li>没有硬的外部依赖性。 例如，AiSQL 不依赖于原子钟，但可以使用原子钟（如果可用）。</li>
</ul>
<p><strong>Kubernetes-ready</strong>
AiSQL 作为有状态应用程序在 Kubernetes 和其他容器化环境中本地运行。</p>
<p>也可以看看：
AiSQL 架构层概述
文档数据库架构
CoreDB 中的事务
查询层设计
核心功能</p>
<h3 id="_7"><strong>基本概念</strong></h3>
<h4 id="universe"><strong>Universe</strong></h4>
<p>AiSQL universe是一组节点（虚拟机、物理机或容器），它们共同充当弹性且可扩展的分布式数据库。</p>
<p>根据业务要求和延迟考虑，Universe 可以部署为多种配置，如下所示：</p>
<ul>
<li>单一可用区。</li>
<li>一个区域内有多个可用区。</li>
<li>多个区域，具有同步和异步复制选择。</li>
</ul>
<p>请注意，有时术语“universe”和“cluster”可以互换使用。 然而，正如universe与cluster中所述，两者并不总是等效的。</p>
<h5 id="_8"><strong>数据组织</strong></h5>
<p>AiSQL Universe 可以由一个或多个命名空间组成。 这些命名空间中的每一个都可以包含一个或多个用户表。</p>
<p>AiSQL 自动在 Universe 中的节点上对这些表进行分片、复制和负载平衡，同时尊重您的意图，例如跨可用区 (AZ) 或区域放置要求、所需的复制因子等。 AiSQL 自动处理故障，例如节点、磁盘、可用区或区域故障，以及在剩余可用节点上重新分配和重新复制数据到所需级别，同时仍然遵守任何副本放置要求。</p>
<p><strong>BSQL</strong>
BSQL 中的命名空间被称为数据库，逻辑上与其他 RDBMS（例如 PostgreSQL）中的命名空间相同。</p>
<p><strong>BCQL</strong>
BCQL 中的命名空间称为键空间，逻辑上与 Apache Cassandra 的 CQL 中的键空间相同。</p>
<h5 id="_9"><strong>组件服务</strong></h5>
<p>Universe 由两组服务器组成：AiSQL Tile 服务器（DBServer）和 AiSQL 主服务器（MServer）。 DBServer 和 MServer 服务器组使用 Raft 作为构建块形成两个各自的分布式服务。 这些服务的高可用性（HA）是通过 Raft 实现中的故障检测、领导者选举和数据复制机制来实现的。</p>
<p>请注意，AiSQL 的设计目的是不存在任何单点故障。</p>
<p><strong>DBServer</strong>
DBServer 服务负责托管和提供用户数据（例如表），以及处理所有查询。</p>
<p>MServer
MServer服务负责保存系统元数据，协调系统范围的操作，例如创建、更改和删除表，以及启动负载平衡等维护操作。</p>
<p>下图描述了一个基本的四节点 AiSQL universe：</p>
<p><img alt="" src="media/chapter9/1.png" /></p>
<h5 id="universe-vs-cluster"><strong>Universe vs. cluster</strong></h5>
<p>AiSQL Universe 由一个主cluster和零个或多个只读副本cluster组成。</p>
<p>主cluster可以执行写入和读取操作。 主cluster中节点之间的复制是同步执行的。</p>
<p>只读副本cluster只能执行读取； 发送到只读副本cluster的写入会自动重新路由到 Universe 的主cluster。 这些cluster可以在远离主cluster的区域中读取时间线一致的数据。 这确保了地理分布式应用程序的低延迟读取。 数据通过主cluster的异步复制引入只读副本cluster。 换句话说，只读副本cluster中的节点充当 Raft 观察者，不参与涉及主cluster中存在的 Raft 领导者和 Raft 追随者的写入路径。</p>
<p>有关只读副本cluster的更多信息，请参阅只读副本。</p>
<h4 id="dbserver"><strong>DBServer服务</strong></h4>
<p>AiSQL Tile Server (DBServer) 服务负责 AiSQL 集群中最终用户请求的输入输出 (I/O)。 表的数据被分割（分片）为Tile。 每个Tile都由一个或多个Tile对等体组成，具体取决于复制因子。每个 DBServer 托管一个或多个Tile对等点。</p>
<p>下图描述了一个基本的四节点 AiSQL universe，其中一个表有 16 个Tile，复制因子为 3：</p>
<p><img alt="" src="media/chapter9/2.png" /></p>
<p>托管在不同DBServer上的每个Tile对应的Tile对等体形成一个Raft组并在彼此之间复制数据。 上图所示的系统包含16个独立的Raft组。 有关详细信息，请参阅复制层。</p>
<p>在每个 DBServer 中，都采用cross-Tile智能来最大限度地提高资源效率。 DBServer 有多种方式协调其托管的Tile之间的操作。</p>
<h5 id="_10"><strong>服务器全局块缓存</strong></h5>
<p>块缓存在给定 DBServer 中的不同Tile之间共享，当一个Tile比其他Tile读取更频繁时，可以实现高效的内存利用率。 例如，如果一个表与其他表相比具有大量读取的使用模式，则块缓存将自动偏向该表的块，因为块缓存在所有 Tile 对等方中都是全局的。</p>
<h5 id="_11"><strong>空间放大</strong></h5>
<p>AiSQL 的压缩是按大小分层的。 与级别压缩相比，大小分层压缩具有磁盘写入 (I/O) 放大较低的优点。 可能有人担心大小分层压缩具有更高的空间放大（它需要 50% 的空间净空）。 但在 AiSQL 中情况并非如此，因为每个表都被分成多个Tile，并且跨Tile的并发压缩被限制到特定的最大值。 AiSQL 中的典型空间放大往往在 10-20% 范围内。</p>
<h5 id="throttled-compactions"><strong>节流压缩Throttled compactions</strong></h5>
<p>压缩在给定的 DBServer 中跨Tile进行限制，以防止压缩风暴。 例如，这可以防止压缩风暴期间出现较高的前景延迟。</p>
<p>默认策略确保进行压缩是值得的。 该算法试图确保被压缩的文件在大小上不会相差太大。 例如，用 1GB 文件压缩 100GB 文件来生成 101GB 文件是没有意义的，因为这需要大量不必要的 I/O，但收益却很小。</p>
<h5 id="_12"><strong>小型和大型压缩队列</strong></h5>
<p>压缩按优先级分为大型压缩和小型压缩，并具有一定的优先级，即使在极端的 I/O 模式下也能保持系统正常运行。</p>
<p>除了压缩的节流控制之外，AiSQL 还进行了各种内部优化，以最大限度地减少压缩对前台延迟的影响。 例如，优先队列将小压缩优先于大压缩，以确保任何Tile的 SSTable 文件数量保持尽可能低。</p>
<p><strong>手动压实</strong>
AiSQL允许使用bm-admin实用程序中的compact_table命令在表上外部触发压缩。 当新数据不再进入表的系统并且您可能由于已经发生的覆盖或删除或由于 TTL 过期而需要回收磁盘空间时，这非常有用。</p>
<p><strong>基于统计的完全压缩以提高读取性能</strong>
AiSQL 跟踪一段时间内在 CoreDB 级别读取的键值对数量（由 auto_compact_stat_window_seconds DBServer 标志指定）。 如果 AiSQL 检测到Tile中的大量 CoreDB 读取跳过了逻辑删除和过时的键，那么将触发完全压缩以删除不必要的键。</p>
<p>一旦滑动窗口中满足以下所有条件，Tile上就会自动触发完全压缩：</p>
<ul>
<li>已过时（例如，由于 TTL 导致删除或删除）与活动键读取的比率达到阈值 auto_compact_percent_obsolete。</li>
<li>已读取足够的key（auto_compact_min_obsolete_keys_found）。</li>
</ul>
<p>虽然此功能与具有 TTL 的表兼容，但如果 TTL 文件过期功能处于活动状态，AiSQL 不会对具有 TTL 的表安排压缩。</p>
<p><strong>预定的全面压实</strong>
AiSQL允许使用scheduled_full_compaction_Frequency_hours和scheduled_full_compaction_jitter_factor_percentage DBServer标志自动安排对Tile中所有数据的完全压缩。 这对于定期进行大量覆盖或删除的工作负载的性能和磁盘空间回收非常有用。 这也可以与具有 TTL 的表一起使用，但与 TTL 文件过期功能不兼容。</p>
<p><strong>服务器全局内存存储限制</strong>
服务器全局内存存储限制跟踪不同Tile的内存存储并强制执行全局大小。 当Tile之间的写入速率存在偏差时，这非常有用。 例如，如果在单个 DBServer 中存在属于多个表的 Tile，并且其中一个表比其他表获得更多的写入次数，允许写入量大的表增长得更大，即使存在per-Tile内存限制。 这允许良好的写入效率。</p>
<p><strong>自动调整块缓存和内存存储的大小</strong>
块缓存和内存存储代表一些较大的内存消耗组件。 由于这些在所有Tile对等体中都是全局的，因此可以轻松地跨各种工作负载管理这些组件的内存和大小。 根据系统上可用的 RAM，DBServer 自动将总可用内存的一定百分比分配给块缓存，并将另一百分比分配给内存存储。</p>
<p><strong>在数据磁盘之间均匀分配Tile负载</strong>
在多 SSD 机器上，各个表Tile的数据 (SSTable) 和 WAL（Raft 预写日志）按每个表均匀分布在连接的磁盘上。 这种负载分布（也称为条带化）可确保每个磁盘为每个表处理均匀的负载量。</p>
<h4 id="mserver"><strong>MServer服务</strong></h4>
<p>MServer 服务保留系统元数据和记录，例如表和表相关Tile的位置、用户和角色及其相关权限等。</p>
<p>MServer 服务还负责协调后台操作，例如负载平衡或启动复制不足的数据的重新复制，以及执行各种管理操作，例如创建、更改和删除表。</p>
<p>MServer 具有高可用性，因为它与其对等方形成 Raft 组，并且它不在针对用户表的 I/O 关键路径中。</p>
<p><img alt="" src="media/chapter9/3.png" /></p>
<p><strong>MServer的功能</strong>
MServer 系统内具有许多重要功能。</p>
<p><strong>1.运行全universe范围的管理协调</strong>
此类操作的示例包括用户发出的 CREATE TABLE、ALTER TABLE 和 DROP TABLE 请求以及创建表的备份。 MServer 执行这些操作时保证该操作会传播到所有Tile，而不管托管这些Tile的 DBServer 的状态如何。 这是至关重要的，因为当这些全域范围的操作之一正在进行时，DBServer 发生故障不会因为无法将操作应用到某些Tile而影响操作的结果。</p>
<p><strong>2.系统元数据的存储</strong>
每个MServer存储系统元数据，包括有关命名空间、表、角色、权限以及Tile到DBServers的分配的信息。 这些系统记录也使用 Raft 跨 MServer 进行复制，以实现冗余。 系统元数据也由 MServer 存储为 CoreDB 表。</p>
<p><strong>3.DBServers Tile分配的权威来源</strong>
MServer 存储所有Tile以及当前托管它们的相应 DBServer。 Tile到托管 DBServer 的映射由客户端（例如 AiSQL 查询层）查询。 使用 BCQL 和 BSQL API 的 AiSQL 智能客户端的应用程序可以高效地检索数据。 智能客户端向 MServer 查询Tile到 DBServer 的映射并将其缓存。 通过这样做，智能客户端可以直接与正确的 DBServer 通信以服务各种查询，而不会产生额外的网络跃点。</p>
<p><strong>4.后台操作</strong>
某些操作在 Universe 的整个生命周期中在后台执行，不会影响前台读写性能。</p>
<p>（1）数据放置和负载平衡
MServer 领导者在 DBServer 上进行Tile的初始放置（在创建表时），以强制执行任何用户定义的数据放置约束并确保均匀负载。 此外，在 Universe 的生命周期内，随着节点的添加、故障或停用，它会继续平衡负载并自动强制执行数据放置约束。</p>
<p>（2）领导者平衡
除了确保每个 DBServer 服务的 Tile 数量在整个universe中保持平衡之外，MServer 还确保每个节点在符合条件的节点上拥有对称数量的 Tile 对等领导者。</p>
<p>（3）扩展 DBServer 故障时重新复制数据
MServer 接收来自所有 DBServer 的心跳，并跟踪它们的活跃度。 它检测是否有任何 DBServer 发生故障，并跟踪 DBServer 保持故障状态的时间间隔。 如果故障的持续时间超过阈值，则它会查找替换DBServer，将故障DBServer的Tile数据重新复制到该替换DBServer。 重新复制由 MServer 领导者以节流方式（throttled fashion）启动，以免影响 Universe 的前台操作。</p>
<h3 id="_13"><strong>核心功能</strong></h3>
<h4 id="universe_1"><strong>创建Universe</strong></h4>
<p>AiSQL Universe 的创建涉及多个步骤。</p>
<p>1.启动MServer
创建 AiSQL Universe 时，第一步是启动足够数量的 MServer（与复制因子一样多），并且每个 MServer 都了解其他的 MServer。 这些 MServer 使用通用唯一标识符 (UUID) 进行初始化，相互了解并执行领导者选举。 在此步骤结束时，其中一位MServer将自己确立为领导者。</p>
<p>2.启动 DBServer
您需要启动与节点一样多的 DBServer，并在启动时将MServer地址传递给它们。 它们开始向MServer发送心跳，传达它们还活着的事实。 心跳还传达有关 DBServer 当前托管的Tile及其负载信息，但系统中尚不存在Tile。</p>
<p>3.示例
假设在具有四个节点的 AiSQL Universe 中创建了一个表。 另外，假设该表的复制因子为3。首先，三个MServer服务器以创建模式启动。 这样做是为了防止在创建已运行的 Universe 时出现意外错误。 下图描述了 Universe 创建过程的开始：</p>
<p><img alt="" src="media/chapter9/4.png" /></p>
<p>下图描述了MServer互相学习并选举一位leader的过程：</p>
<p><img alt="" src="media/chapter9/5.png" /></p>
<p>最后，DBServer启动，它们都向MServer发送心跳，如下图所示：</p>
<p><img alt="" src="media/chapter9/6.png" /></p>
<h4 id="_14"><strong>表创建</strong></h4>
<p>在AiSQL中，用户发起的表创建由MServer领导者使用异步API处理。 一旦 MServer 领导者将表模式和执行表创建所需的所有其他信息复制到 Raft 组中的其他 MServer，以使其能够适应故障，就会返回 API 调用成功。</p>
<p>为了创建表，MServer 领导者执行许多步骤。</p>
<p><strong>1.验证</strong>
MServer领导者验证表模式并为表创建所需数量的Tile。 Tile尚未分配给 DBServer。</p>
<p><strong>2.复制</strong> 
MServer 领导者将表模式和新创建的（且尚未分配的）Tile 复制到 MServer Raft 组。 这保证了即使当前MServer Leader出现故障，建表也能成功。</p>
<p><strong>3.确认</strong> 
此时，异步建表API返回成功，因为即使当前MServer领导者失败，操作也可以继续进行。</p>
<p><strong>4.执行</strong>
MServer领导者将每个Tile分配给与表的复制因子一样多的DBServer。 Tile对等放置的方式确保实现所需的容错能力，并且 DBServer 相对于它们分配的Tile数量而言是均匀平衡的。 在某些部署场景中，将Tile分配给 DBServer 可能需要满足其他约束，例如跨多个云提供商、区域和可用区分布每个Tile的单独副本。</p>
<p><strong>5.持续监控</strong> 
MServer 领导者监视整个Tile分配操作，并向用户发出的 API 调用报告其进度和完成情况。</p>
<p>示例
假设在具有四个节点的 AiSQL Universe 中创建了一个表。 此外，假设该表有 16 个 Tile，复制因子为 3。MServer Leader 验证架构，创建 16 个 Tile（由于复制因子为 3，总共 48 个 Tile 对等体）并复制数据，使用 Raft 在大多数 MServer 上创建表所需。 下图描述了表创建过程的开始：</p>
<p><img alt="" src="media/chapter9/7.png" /></p>
<p>下图描述了新创建的Tile被分配给多个DBServer的过程：</p>
<p><img alt="" src="media/chapter9/8.png" /></p>
<p>托管在不同 DBServer 上的Tile节点形成一个 Raft 组并选举一个领导者。 对于属于该Tile的键的所有读写，由Tile-peer领导者和Raft组分别负责。 一旦分配，Tile将归 DBServer 所有，直到所有权因长期故障或未来的负载平衡事件而被 MServer 更改，如下图所示：</p>
<p><img alt="" src="media/chapter9/9.png" /></p>
<p>如果托管 Tile Leader 的 DBServer 之一发生故障，Tile Raft 组会立即重新选举 Leader 来处理 I/O。 因此，MServer 不在关键 I/O 路径中。 如果DBServer长时间处于故障状态，MServer会找到一组合适的候选者来重新复制其数据。 它以一种节流而优雅的方式做到这一点。</p>
<h4 id="io"><strong>写I/O路径</strong></h4>
<p>写 I/O 路径可以通过单键写的示例来说明，该写操作涉及由 BQL 层处理并准备由 Tile Leader 进行复制的操作。</p>
<p>有关更复杂情况的信息，例如需要原子更新的多个键的分布式事务，请参阅分布式事务。</p>
<p><strong>1.BQL层的写操作处理</strong>
用户发出的写入请求通过具有适当 API（BSQL 或 BCQL）的端口与 BQL 查询层交互。 该用户请求由 BQL 层转换为 internal key.。 如分片中所述，每个key都由一个Tile拥有。 为了确定哪个Tile拥有给定的key，BQL 层对 MServer 进行 RPC 调用。 响应被缓存以供将来使用。</p>
<p>AiSQL有一个智能客户端，可以直接缓存Tile的位置，因此可以节省额外的网络跃点，从而允许它直接将请求发送到托管Tile领导者的相应DBServer的BQL层。 如果BQL层发现Tile领导者托管在本地节点上，那么RPC调用就变成本地函数调用，并节省了序列化和反序列化请求，然后通过网络发送所需的时间。</p>
<p>然后，BQL 层将写入发送到托管Tile领导者的 DBServer。 写入由拥有key的Tile Raft 组的领导者处理。</p>
<p><strong>2.由Tile领导者准备复制操作</strong>
下图显示了Tile领导者准备复制操作的流程：</p>
<p><img alt="" src="media/chapter9/10.png" /></p>
<p>Tile Raft 组的领导者执行以下序列：</p>
<ul>
<li>验证正在执行的操作是否与当前架构兼容。</li>
<li>使用本地内存锁管理器锁定key。 请注意，追随者不存在这种锁定机制。</li>
<li>如有必要，读取数据（用于读取-修改-写入或条件更新操作）。</li>
<li>准备要写入 CoreDB 的批量更改。 这个写入批次非常接近要写入的最终一组 RocksDB 键值对，只是缺少每个键末尾的最终混合时间戳。</li>
</ul>
<p><strong>3.写操作的Raft复制</strong>
Raft复制写操作的顺序可以描述如下：</p>
<ul>
<li>领导者将批处理附加到其 Raft 日志中，并为写入操作选择混合时间戳。</li>
<li>使用 Raft 将数据复制到其对等点。</li>
<li>Raft 复制成功后，将数据应用到其本地 CoreDB 中。</li>
<li>成功响应用户。</li>
</ul>
<p>follower Tile接收使用 Raft 复制的数据，并在已知数据已提交后将其应用到本地 CoreDB 中。 领导者在后续 RPC 请求中搭载提交点，如下所示：</p>
<ul>
<li>包含写入批次的 Raft 条目被复制到Tile的大多数 Raft 组对等点。</li>
<li>在收到来自 Raft 子系统的“复制成功”回调后，领导者将批量写入应用到其本地 RocksDB。</li>
<li>领导者的下一次更新会通知追随者该条目已提交，并且追随者将批量写入应用到其 RocksDB 实例。</li>
</ul>
<p><strong>4.回应客户</strong>
Information pending.</p>
<p><strong>5.示例</strong>
假设需要将值 k 和 v 插入具有键列 K 和值列 V 的表 T1 中。下图描述了写入流程：</p>
<p><img alt="" src="media/chapter9/11.png" /></p>
<p>请注意，通过假设用户应用程序将写入查询发送到随机 AiSQL 服务器，然后该服务器适当地路由请求，已经简化了前面的情况。</p>
<p>特别是对于 BCQL，使用 AiSQL 智能客户端可以让您避免额外的网络跃点。</p>
<h4 id="io_1"><strong>读I/O路径</strong></h4>
<p>读取 I/O 路径可以通过单键读取的示例来说明，该读取涉及识别随后执行读取操作的Tile领导者。</p>
<p><strong>识别Tile领导者</strong>
用户发出的读取请求通过具有适当 API（BSQL 或 BCQL）的端口与 BQL 查询层交互。 该用户请求由 BQL 层转换为内部key，允许 BQL 层找到Tile和托管它的 DBServer。 BQL 层通过对 MServer 进行 RPC 调用来执行此操作。 响应被缓存以供将来使用。 接下来，BQL 层将读取内容发送到托管领导者 Tile 对等方的 DBServer。 读取由拥有内部key的Tile Raft 组的领导者处理。 处理读请求的Tile Raft组的领导者从其CoreDB中读取并将结果返回给用户。</p>
<p>如写入 I/O 路径中所述，AiSQL 智能客户端可以将应用程序请求直接路由到正确的 DBServer，从而避免任何额外的网络跃点或主查找。</p>
<p><strong>Tile领导者执行的读取操作</strong>
假设需要从表T1中读取主键列K的值为k的值。 表T1有一个键列K和一个值列V。下图描述了读取流程：</p>
<p><img alt="" src="media/chapter9/12.png" /></p>
<p>默认是强一致性读。</p>
<p>读取查询可能非常复杂。 BQL查询层有一个完全优化的查询引擎来处理包含表达式、内置函数调用和算术运算的查询。</p>
<h4 id="_15"><strong>高可用</strong></h4>
<p>AiSQL 是一个一致且分区容忍的数据库，同时通过拥有一个活动副本来实现非常高的可用性 (HA)，该副本准备在当前领导者发生故障后立即接管作为新的领导者并服务请求。</p>
<p>如果某个节点发生故障，则会导致其上运行的服务器中断。 它们将是 DBServer 和 MServer（如果在该节点上运行）。</p>
<p><strong>1.DBServer故障</strong>
DBServer 托管 BQL 层和Tile，其中一些Tile是主动提供 I/O 服务的Tile对等领导者，而其他Tile是复制数据的Tile对等追随者，并且是其相应领导者的活动备用设备。</p>
<p>每个 BQL 层、Tile Peer Followers 和 Tile Peer Leader 的故障均以特定方式处理。</p>
<p>（1）BQL失败
从应用程序的角度来看，BQL 是无状态的。 因此，发出请求的客户端只需将请求发送到不同节点上的 BQL。 对于智能客户端，它们基于key搜索理想的 DBServer 位置，然后将请求直接发送到该节点。</p>
<p>（2）Tile对等追随者故障
Tile同行追随者并不处于关键路径上。 它们的故障不会影响用户请求的可用性。</p>
<p>（3）Tile对等领导者失败
任何 Tile Peer Leader 的故障都会在几秒钟内自动触发新的 Raft 级 Leader 选举，并且不同 DBServer 上的另一个 Tile Peer 会取代它成为新的 Leader。 如果Tile对等领导者发生故障，不可用窗口约为3秒（假设默认心跳间隔为500毫秒）。</p>
<p><strong>2.MServer故障</strong>
MServer 不在正常 I/O 操作的关键路径中，因此它的故障不会影响正常运行的 Universe。 尽管如此，MServer 是 Raft 组的一部分，其对等点运行在不同的节点上。 这些对等点之一是活动主服务器，其他对等点是活动备用服务器。 如果活动主节点（MServer 领导者）发生故障，这些对等点会检测到领导者故障并重新选举新的 MServer 领导者，该新 MServer 领导者会在故障发生后的几秒内成为活动主节点。</p>
<h3 id="_16"><strong>分层架构</strong></h3>
<p>AiSQL 架构遵循分层设计。 逻辑层是 AiSQL 查询层和 CoreDB 分布式文档存储，如下图所示：</p>
<p><img alt="" src="media/chapter9/13.png" /></p>
<p>有关详细信息，请参阅以下内容：
AiSQL 设计目标
文档数据库架构
CoreDB 中的事务
查询层设计
核心功能</p>
<p><strong>1.AiSQL 查询层</strong>
AiSQL 查询层（BQL）是 AiSQL 的上层。 应用程序使用客户端驱动程序直接与 BQL 交互。 该层处理特定于 API 的方面，例如查询和命令编译，以及运行时（数据类型表示、内置操作等）。 BQL 的设计考虑到了可扩展性，允许添加新的 API。</p>
<p>BQL 支持两种类型的分布式 SQL API：AiSQL SQL (BSQL) 和 AiSQL Cloud QL (BCQL)。</p>
<p>（1）BSQL
BSQL是一个分布式SQL API，是通过复用PostgreSQL语言层代码构建的。 它是一个与 PostgreSQL 有线格式兼容的无状态 SQL 查询引擎。</p>
<p>（2）BCQL
BCQL 是一种半关系语言，源于 Cassandra 查询语言。 它是一种类似 SQL 的语言，专门用于了解跨节点的数据集群。</p>
<p>有关详细信息，请参阅查询层设计。</p>
<p><strong>2.CoreDB</strong>
CoreDB 是一个分布式文档存储，具有以下属性：</p>
<ul>
<li>写入一致性强</li>
<li>对失败具有极高的弹性</li>
<li>自动分片和负载均衡</li>
<li>可用区、区域和云感知的数据放置策略</li>
<li>可调读取一致性</li>
</ul>
<p>CoreDB 中的数据存储在表中。 每个表由行组成，每行包含一个键和一个document。</p>
<p>（1）分片Sharding
数据存储在 CoreDB 的表内。 CoreDB表通常被分片为多个Tile，这些Tile的分片是透明的。</p>
<p>有关更多信息，请参阅 CoreDB 分片。</p>
<p>（2）复制
每个由用户数据组成的Tile都会使用Raft共识算法根据某个复制因子进行复制。 复制在Tile级别执行，即使在出现故障的情况下也能确保单行线性化。</p>
<p>有关更多信息，请参阅 CoreDB 复制。</p>
<p>（3）持久化
为了持久保存数据，使用了日志结构的行和面向文档的存储。 它包括一些用于有效处理不断增长的数据集的优化。</p>
<p>有关更多信息，请参阅 CoreDB 持久性。</p>
<p>（4）事务
CoreDB 支持单行和多行事务，因此允许修改多个键，同时保留原子性、一致性、隔离性和持久性 (ACID) 属性。</p>
<p>有关详细信息，请参阅以下内容：
CoreDB 隔离级别
单行事务
多行事务</p>
<h3 id="_17"><strong>查询层</strong></h3>
<p>AiSQL 有一个可扩展的查询层，它实现了以下 API：</p>
<ul>
<li>BSQL，与 PostgreSQL 线兼容的分布式 SQL API。</li>
<li>BCQL 是一种为高性能和大规模而构建的半关系 API，其根源于 Cassandra 查询语言。</li>
</ul>
<p>AiSQL 查询层（BQL）是 AiSQL 的上层。 应用程序使用客户端驱动程序直接与 BQL 交互。 该层处理特定于 API 的方面，例如查询和命令编译，以及运行时功能，例如数据类型表示、内置操作等。 BQL 的设计考虑到了可扩展性，允许添加新的 API。 目前，BQL支持两种类型的分布式SQL API：BSQL和BCQL。</p>
<p><img alt="" src="media/chapter9/14.png" /></p>
<p>如上图所示，每个 DBServer 都配置为在不同端口上支持两种类型的查询语言：端口 2521 是 BSQL 的默认端口，9542 是 BCQL 的默认端口。</p>
<p>从应用程序的角度来看，BQL 是无状态的，客户端可以在适当的端口上连接到一个或多个 DBServer，以对 AiSQL 集群执行操作。</p>
<p>每个 DBServer 内部的 BQL 实现了每个受支持的 API 所需的一些特定于 API 的方面，但最终它负责复制存储层的数据以及使用 CoreDB 检索数据，CoreDB 是 AiSQL 常见的底层强一致性分布式存储。 以下是 BQL 中每个 API 的一些子组件：</p>
<ul>
<li>语句缓存，用于缓存准备好的语句的编译或执行计划，以避免与重复解析语句相关的开销。</li>
<li>命令解析器和执行层。</li>
<li>特定于语言的内置操作、数据类型编码等。</li>
</ul>
<h3 id="coredb"><strong>CoreDB事务层</strong></h3>
<p>CoreDB 是 AiSQL 的分布式文档存储，负责事务、分片、复制和持久化。
AiSQL的分布式事务架构基于原子性、一致性、隔离性和持久性（ACID）原则，并受到Google Spanner的启发。</p>
<h4 id="_18"><strong>概述</strong></h4>
<p>事务和强一致性是任何 RDBMS 的基本要求。 CoreDB 专为强一致性而设计。 它支持任何规模的跨行、多个Tile和多个节点的完全分布式原子性、一致性、隔离性、持久性 (ACID) 事务。 事务可以跨 CoreDB 中的表。</p>
<p>事务是作为单个逻辑工作单元执行的一系列操作。 由于在事务内应用操作而导致的数据库中间状态对其他并发事务不可见，并且如果发生阻止事务完成的故障，则所有步骤都不会影响数据库。</p>
<p>请注意，CoreDB 内的所有更新操作都被视为事务，包括仅更新一行的操作，以及更新驻留在不同节点上的多行的操作。 如果启用自动提交模式，则每条语句都作为一个事务执行。</p>
<p><strong>1.时间同步</strong>
AiSQL 集群中的事务可能需要更新跨集群中节点的多行。 为了符合 ACID，该事务所做的各种更新应该在固定时间立即可见，而不管集群中的哪个节点读取更新。 为了实现这一点，集群的节点必须就全局时间概念达成一致，这要求所有节点都能够访问高可用且全局同步的时钟。 Google Cloud Spanner 使用的 TrueTime 就是此类具有严格误差范围的时钟的一个示例。 然而，这种类型的时钟在许多部署中并不可用。 物理时钟（或挂钟）无法在节点之间完美同步，也无法对事件进行排序以建立节点之间的因果关系。</p>
<p><strong>混合逻辑时钟</strong>
AiSQL 使用混合逻辑时钟 (HLC)，通过将使用 NTP 粗略同步的物理时钟与跟踪因果关系的 Lamport 时钟相结合来解决该问题。</p>
<p>AiSQL 集群中的每个节点首先计算其表示为元组（物理时间组件、逻辑组件）的 HLC。 任何节点上生成的 HLC 都是严格单调的，并且作为元组进行比较。 比较两个 HLC 时，物理时间部分优先于逻辑部分。</p>
<ul>
<li>物理时间组件：AiSQL 使用节点的物理时钟（Linux 中的 CLOCK_REALTIME）来初始化其 HLC 的物理时间组件。 一旦初始化，物理时间分量只能更新为更高的值。</li>
<li>逻辑分量：对于给定的物理时间分量，HLC 的逻辑分量是单调递增的数字，提供在同一物理时间中发生的事件的排序。 它最初设置为 0。如果物理时间组件在任何点更新，逻辑组件将重置为 0。</li>
</ul>
<p>在两个节点之间的任何 RPC 通信中，都会交换 HLC 值。 HLC 较低的节点将其 HLC 更新为较高的值。 如果节点上的物理时间超过其 HLC 的物理时间分量，则后者将更新为物理时间，并将逻辑分量设置为 0。因此，节点上的 HLC 单调递增。</p>
<p>相同的 HLC 用于确定读取点，以确定哪些更新应对最终客户端可见。 如果更新已安全地复制到大多数节点上，根据 Raft 协议，客户端可以确认该更新操作成功，并且可以安全地为该 HLC 之前的所有读取提供服务。 这构成了 AiSQL 中无锁多版本并发控制的基础。</p>
<p><strong>2.多版本并发控制</strong>
AiSQL内部使用多版本并发控制（MVCC）来维护数据一致性，无需锁定行。 每个事务都处理数据库中截至某个混合时间戳的数据版本。 这可以防止事务读取并发运行的事务所做的中间更新，其中一些事务可能正在更新相同的行。 然而，每个事务都可以看到自己的更新，从而为每个数据库会话提供事务隔离。 使用 MVCC 可以最大限度地减少执行多个并发事务期间的锁争用。</p>
<p><strong>使用混合时间的MVCC</strong>
AiSQL 实现 MVCC 并在内部跟踪与同一键对应的值的多个版本（例如，特定行中的特定列），如 RocksDB 之上的持久性中所述。 每个键的最后部分是一个时间戳，它可以快速导航到 RocksDB 键值存储中特定版本的键。</p>
<p>MVCC使用的时间戳来自混合时间算法，这是一种分布式时间戳分配算法，结合了本地实时（物理）时钟和Lamport时钟的优点。 混合时间算法确保由“A 在同一服务器上 B 之前发生”或“A 在一台服务器上发生，然后将 RPC 发送到 B 发生的另一台服务器”形式的因果链连接的事件始终被分配，且按升序排列的混合时间戳。 这是通过使用大多数 RPC 请求传播混合时间戳，并始终将接收服务器上的混合时间更新为观察到的最高值（包括服务器上的当前物理时间）来实现的。 AiSQL 事务模型的多个方面都依赖于混合时间的这些属性。 考虑以下示例：</p>
<ul>
<li>即使有领导者更改，分配给同一Tile中已提交 Raft 日志条目的混合时间戳始终不断增加。 这是因为新领导者始终拥有先前领导者的所有已提交条目，并且它确保在附加新条目之前使用最后提交条目的时间戳更新其混合时钟。 此属性简化了选择安全混合时间来选择单片读取请求的逻辑。</li>
<li>尝试在特定混合时间从 Tile 读取数据的请求需要确保时间戳值低于读取时间戳的 Tile 中不会发生任何更改，这可能会导致结果集不一致。 在跨多个Tile的事务读取期间，需要在特定时间戳处从Tile读取数据。 由于读取时间戳被选为处理读取请求的 DBServer 上的当前混合时间，因此该条件变得更容易满足，因此正在读取的数据片的领导者上的混合时间立即更新为以下值： 至少与读取时间戳一样高。 那么读请求只需要等待 Raft 队列中时间戳值低于读时间戳的相关条目被复制并应用到 RocksDB 中，然后就可以继续处理读请求了。</li>
</ul>
<p><strong>支持的隔离级别</strong></p>
<ul>
<li>AiSQL 支持以下事务隔离级别：</li>
<li>已提交读，映射到同名的 SQL 隔离级别。</li>
<li>可串行化，映射到同名的 SQL 隔离级别。</li>
<li>快照，映射到 SQL 隔离级别 REPEATABLE READ。</li>
</ul>
<p>有关更多信息，请参阅 AiSQL 中的隔离级别。</p>
<p><strong>显式锁定</strong>
与 PostgreSQL 一样，AiSQL 提供了各种行级锁模式来控制对表中数据的并发访问。 在 MVCC 未提供所需行为的情况下，这些模式可用于应用程序控制的锁定。 有关更多信息，请参阅 AiSQL 中的显式锁定。</p>
<p><strong>3.交易执行路径</strong>
最终用户语句无缝映射到 AiSQL 内的一种事务类型。</p>
<p><strong>（1）单行事务</strong>
AiSQL 的事务管理器自动检测更新单行的事务（而不是跨Tile或节点更新行的事务）。 为了实现高性能，对单行的更新直接更新该行，而无需使用单行事务路径（也称为快速路径）与事务状态表进行交互。 有关详细信息，请参阅单行事务 I/O 路径。</p>
<p>由于单行事务不必更新事务状态表，因此其性能远高于分布式事务。</p>
<p>INSERT、UPDATE 和 DELETE 单行 SQL 语句映射到单行事务。。</p>
<p><strong>INSERT语句</strong>
所有单行 INSERT 语句：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO table (columns) VALUES (values);
</code></pre></div>
<p><strong>UPDATE语句</strong>
指定所有主键的单行 UPDATE 语句：</p>
<div class="highlight"><pre><span></span><code>UPDATE table SET column = &lt;new_value&gt; WHERE &lt;all_primary_key_values_are_specified&gt;;
</code></pre></div>
<p>使用 UPDATE .. ON CONFLICT 的单行 upsert 语句：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO table (columns) VALUES (values)
    ON CONFLICT DO UPDATE
    SET &lt;values&gt;;
</code></pre></div>
<p>如果对现有行执行更新，则它们应与 INSERT 子句中指定的值集匹配。</p>
<p><strong>DELETE语句</strong>
指定所有主键的单行 DELETE 语句：</p>
<div class="highlight"><pre><span></span><code>DELETE FROM table WHERE &lt;all_primary_key_values_are_specified&gt;;
</code></pre></div>
<p>（2）分布式事务
影响分布在多个Tile（在最一般情况下将托管在不同节点上）的一组行的事务使用分布式事务路径来执行事务。 在 AiSQL 中实现分布式事务需要使用事务管理器，它可以协调事务中包含的各种操作，并最终根据需要提交或中止事务。 有关详细信息，请参阅分布式事务 I/O 路径。</p>
<h4 id="_19"><strong>隔离级别</strong></h4>
<p>事务隔离是处理数据库中并发事务的基础。 SQL-92 标准定义了四个事务隔离级别（按严格程度降序排列）：可串行化、可重复读取、已提交读和未提交读。</p>
<p>AiSQL 支持以下三种最严格的事务隔离级别：</p>
<ul>
<li>已提交读，它映射到同名的 SQL 隔离级别。 此隔离级别保证每个语句都可以看到在发出之前已提交的所有数据（这也隐式意味着该语句可以看到一致的快照）。 此外，此隔离级别在内部处理读取重新启动和冲突错误。 换句话说，客户端不会看到读取重新启动和冲突错误（除非有例外）。</li>
<li>可串行化，映射到同名的 SQL 隔离级别。 此隔离级别保证事务以相当于串行（顺序）调度的方式运行。</li>
<li>快照，映射到 SQL 可重复读隔离级别。 此隔离级别保证事务中进行的所有读取都看到数据库的一致快照，并且仅当事务本身所做的更新与该快照之后提交的事务所做的任何并发更新没有冲突时，事务本身才能成功提交。</li>
</ul>
<p>BSQL 和 BCQL API 之间的事务隔离级别支持有所不同：</p>
<ul>
<li>BSQL 支持可串行化、快照和读已提交隔离级别。</li>
<li>BCQL 仅支持使用 BEGIN TRANSACTION 语法的快照隔离。</li>
</ul>
<p>与 PostgreSQL 类似，您可以为 BSQL 指定“未提交读”，但其行为与“已提交读”相同。</p>
<p>已提交读承诺支持当前处于技术预览版中。 仅当 DBServer 标志 bm_enable_read_comfilled_isolation 设置为 true 时才支持此级别。 默认情况下，此标志为 false，在这种情况下，AiSQL 事务层的读已提交隔离级别将回退到更严格的快照隔离。 BSQL API 的默认隔离级别本质上是快照，因为已提交读（BSQL API 和 PostgreSQL 语法默认值）映射到快照隔离。</p>
<p><strong>1.CoreDB中的内部锁定</strong>
为了支持三种隔离级别，锁管理器内部支持以下三种类型的锁：</p>
<ul>
<li>
<p>可串行读锁由可串行事务对其读取的值进行锁定，以保证在事务提交之前这些值不会被修改。</p>
</li>
<li>
<p>可串行化事务在其写入的值上获取可串行化写锁。</p>
</li>
<li>快照隔离写锁由快照隔离（以及已提交的读）事务对其修改的值进行获取。</li>
</ul>
<p>下面的矩阵显示了这些类型的锁之间的高层冲突：</p>
<table>
<thead>
<tr>
<th></th>
<th>快照隔离写</th>
<th>可串行写</th>
<th>可串行读</th>
</tr>
</thead>
<tbody>
<tr>
<td>快照隔离写</td>
<td>×冲突</td>
<td>×冲突</td>
<td>×冲突</td>
</tr>
<tr>
<td>可串行写</td>
<td>×冲突</td>
<td>√不冲突</td>
<td>×冲突</td>
</tr>
<tr>
<td>可串行读</td>
<td>×冲突</td>
<td>×冲突</td>
<td>√不冲突</td>
</tr>
</tbody>
</table>
<p>也就是说，可串行读取会锁定写入者，但允许其他并发读取者。 可串行化写入锁会按预期阻止读取器，但不会阻止其他可串行化写入器。 最后，快照隔离写入锁会阻塞所有其他读取器和写入器。</p>
<p>由于可串行化写锁不会阻塞其他可串行化写入者，因此在可串行化隔离级别允许并发盲写。 盲写是对该事务先前未读取过的位置的写入。 假设没有其他冲突，两个可串行化的事务盲目地写入同一位置可以并行进行； 之后该位置的值将是最后提交的事务写入的值。</p>
<p>尽管为了简单起见这里将其描述为单独的锁类型，但快照隔离写锁类型实际上在内部实现为其他两种锁类型的组合。 也就是说，获取单个快照隔离写锁相当于同时获取可序列化读锁和可序列化写锁。</p>
<p><strong>2.锁定粒度</strong>
可以在多个粒度级别上进行锁定。 例如，可以在整个表、单行或单行的单列级别获取可串行化的读锁。 这样的锁将阻止以该粒度或更细粒度获取写锁的尝试。 因此，例如，在行级别获取的读锁将阻止写入整行或该行中的任何列的尝试。</p>
<p>除了上述粒度级别之外，CoreDB 中还可以在主键列的前缀处进行锁定，将哈希列视为单个单元。 例如，如果您通过以下方式创建了 BSQL 表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test (h1 INT, h2 INT, r1 INT, r2 INT, v INT w INT PRIMARY KEY ((h1,h2) HASH, r1 ASC, r2 ASC));
</code></pre></div>
<p>那么以下任何对象都可以被锁定：</p>
<ul>
<li>整个Tile</li>
<li>h1=2、h2=3 的所有行</li>
<li>所有具有 h1=2、h2=3、r1=4 的行</li>
<li>h1=2、h2=3、r1=4、r2=5 的行</li>
<li>h1=2、h2=3、r1=4、r2=5 的行的第 v 列</li>
</ul>
<p>对于BCQL，粒度存在于列级别以下； 例如，只能锁定map数据类型的一列的一个键。</p>
<p><strong>3.高效检测不同粒度锁之间的冲突</strong>
处理不同粒度的锁的直接方法是拥有从可锁定对象到锁类型的映射。 然而，这对于检测冲突来说效率太低：例如，尝试在Tile级别添加锁将需要检查该Tile中的每一行和每一列的锁。</p>
<p>为了提高冲突检测效率，AiSQL 为每个可锁定对象存储有关其子对象上的任何锁定的额外信息。 特别是，它不仅对 X 进行锁定，还对 X 进行普通锁定，并对包含 X 的所有对象进行该锁定的较弱版本。普通锁定称为强锁定，较弱的变体称为弱锁定。</p>
<p>例如，假设 AiSQL 仅具有Tile级和行级粒度。 要在行级别（例如在Tile b 的r 行上）获取可串行化写锁，需要在行级别（在r 上）获取强写锁，并在Tile 级别（在b 上）获取弱写锁。 为了在Tile级别获取可串行化的读锁（也假设在b上），AiSQL只需在Tile级别获取强读锁（在b上）。</p>
<p>使用以下冲突规则，AiSQL 可以仅根据两个原始锁在任何可锁定对象上的强/弱锁是否会发生冲突来决定它们是否会发生冲突：</p>
<ul>
<li>两个强锁发生冲突当且仅当它们冲突时忽略它们的强度
  例如，前面矩阵中的可串行化写入与可串行化读取冲突</li>
<li>两个弱锁永远不会冲突</li>
<li>强锁与弱锁冲突当且仅当它们冲突且忽略它们的强度</li>
</ul>
<p>也就是说，对于每个有两个锁的可锁定对象，它们在上述规则下会发生冲突吗？ 不需要枚举任何对象的子对象。</p>
<p>考虑我们的示例，其中具有行级别的可串行化写锁和Tile级别的可串行化读锁。 在Tile级别检测到冲突是因为b上的强读弱写锁冲突，因为普通的读锁和写锁冲突。</p>
<p>如果涉及到同一个Tile中不同行的两个行级快照隔离写锁怎么办？ 未检测到冲突，因为Tile级锁较弱，而强行级锁位于不同的行上。 如果它们涉及同一行，则将检测到冲突，因为两个强快照隔离写锁发生冲突。</p>
<p>包括强/弱的区别，完整的冲突矩阵变为：</p>
<table>
<thead>
<tr>
<th></th>
<th>强快照隔离写</th>
<th>弱快照隔离写</th>
<th>强可串行化写</th>
<th>弱可串行化写</th>
<th>强可串行化读</th>
<th>弱可串行化读</th>
</tr>
</thead>
<tbody>
<tr>
<td>强快照隔离写</td>
<td>×冲突</td>
<td>×冲突</td>
<td>×冲突</td>
<td>×冲突</td>
<td>×冲突</td>
<td>×冲突</td>
</tr>
<tr>
<td>弱快照隔离写</td>
<td>×冲突</td>
<td>√不冲突</td>
<td>×冲突</td>
<td>√不冲突</td>
<td>×冲突</td>
<td>√不冲突</td>
</tr>
<tr>
<td>强可串行化写</td>
<td>×冲突</td>
<td>×冲突</td>
<td>√不冲突</td>
<td>√不冲突</td>
<td>×冲突</td>
<td>×冲突</td>
</tr>
<tr>
<td>弱可串行化写</td>
<td>×冲突</td>
<td>√不冲突</td>
<td>√不冲突</td>
<td>√不冲突</td>
<td>×冲突</td>
<td>√不冲突</td>
</tr>
<tr>
<td>强可串行化读</td>
<td>×冲突</td>
<td>×冲突</td>
<td>×冲突</td>
<td>×冲突</td>
<td>√不冲突</td>
<td>√不冲突</td>
</tr>
<tr>
<td>弱可串行化读</td>
<td>×冲突</td>
<td>√不冲突</td>
<td>×冲突</td>
<td>√不冲突</td>
<td>√不冲突</td>
<td>√不冲突</td>
</tr>
</tbody>
</table>
<h4 id="_20"><strong>并发控制</strong></h4>
<p>数据库中的并发控制可确保多个事务可以同时执行，同时保持数据完整性。 在两个或多个事务可以同时访问相同数据的环境中，并发控制对于正确性至关重要。</p>
<p>AiSQL 提供了两种策略来处理并发事务之间的冲突，如以下各节所述。</p>
<p>有关行级显式锁定子句如何与这些并发控制策略配合使用的信息，请参阅行级显式锁定子句。</p>
<p><strong>1.冲突失败</strong>
这是默认的并发控制策略，适用于可重复读和可串行化隔离级别。 它不适用于读已提交隔离。</p>
<p>在此模式下，事务会被分配随机优先级，但存在一些例外情况，如事务优先级中所述。</p>
<p>如果发生冲突，则优先级较低的事务将被中止。 当事务 T1 尝试以与其他并发事务冲突的模式读取、写入或锁定行时，有两种可能性：</p>
<ul>
<li>成功：如果 T1 的优先级高于所有其他冲突事务，T1 将中止它们并取得进展。</li>
<li>失败：如果任何其他冲突事务的优先级等于或高于 T1，T1 将中止自身。</li>
</ul>
<p>假设您有一个表，其中包含一些数据。 以下示例描述了发生冲突时的成功和失败的方法。</p>
<div class="highlight"><pre><span></span><code>create table test (k int primary key, v int);
insert into test values (1, 1);
</code></pre></div>
<p><strong>成功示例</strong></p>
<table>
    <thead>
        <tr>
            <th>会话1</th>
            <th>会话2</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td></td>
            <td>SET bm_transaction_priority_upper_bound = 0.4;
            </td>
        </tr>
        <tr>
            <td>SET bm_transaction_priority_lower_bound = 0.6;</td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td>begin transaction isolation level repeatable read;
                <br> select * from test where k=1 for update;
                <br> k | v
                <br>---+---
                <br>1 | 1
                <br>(1 row)
            </td>
        </tr>
        <tr>
            <td>begin transaction isolation level repeatable read;
                <br>
                <br>select * from test where k=1 for update;
                <br>
                <br>k | v
                <br>---+---
                <br>1 | 1
                <br>(1 row)
            </td>
        </tr>
        <tr>
            <td></td>
            <td>select * from test;
                <br>
                <br>ERROR: Operation expired: Heartbeat:Transaction 13fb5a0a-012d-4821-ae1d-5f7780636dd4 expiredor aborted by a conflict: 40001
                <br>
                <br>rollback;
            </td>
        </tr>
        <tr>
            <td>commit;</td>
            <td></td>
        </tr>
    </tbody>
</table>

<p><strong>失败示例</strong></p>
<table>
    <thead>
        <tr>
            <th>会话1</th>
            <th>会话2</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td></td>
            <td>
                <code>SET bm_transaction_priority_upper_bound = 0.6;</code>
            </td>
        </tr>
        <tr>
            <td>
                <code>SET bm_transaction_priority_upper_bound = 0.4;</code>
            </td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <code>begin transaction isolation level repeatable read;
                <br>
                <br>select * from test where k=1 for update;
                <br>
                <br>k | v
                <br>---+---
                <br>1 | 1
                <br>(1 row)</code>
            </td>
        </tr>
        <tr>
            <td><code>begin transaction isolation level repeatable read;
                <br>
                <br>select * from test where k=1 for update;
                <br>
                <br>ERROR: All transparent retries exhausted. could not serializeaccess due to concurrent update
                <br>
                <br>rollback;</code>
            </td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td><code>commit;</code></td>
        </tr>
    </tbody>
</table>

<p><strong>尽力内部重试事务中的第一个语句</strong>
请注意，我们在前面的示例中看到错误消息“所有透明重试已耗尽”，因为如果事务 T1 在执行第一个语句时发现另一个具有相同或更高优先级的并发冲突事务，则 T1 将在给出之前以指数退避执行几次重试 预计另一笔事务将在一段时间内完成。 重试次数可通过 bsql_max_write_restart_attempts DBServer 标志进行配置，指数退避参数与性能调优中描述的参数相同。</p>
<p>每次重试都将使用较新的数据库快照，以防止冲突发生。 这样做是因为如果新快照的读取时间高于较早冲突事务 T2 的提交时间，则与 T2 的冲突本质上将无效，因为 T1 和 T2 将不再“并发”。</p>
<p>请注意，如果从 BSQL 发送到客户端代理的数据量超过 dbserver 标志 bsql_output_buffer_size，则不会执行重试。</p>
<p><strong>2.冲突等待</strong>
等待冲突是技术预览。
这种并发控制方式仅适用于BSQL，并提供与PostgreSQL相同的语义。</p>
<p>在此模式下，事务不分配优先级。 如果当事务 T1 尝试以与其他几个并发事务冲突的模式读取、写入或锁定行时发生冲突，T1 将等待，直到所有冲突事务通过提交或回滚完成。 一旦所有冲突事务完成，T1 将：</p>
<ul>
<li>如果冲突事务未提交任何与 T1 冲突的永久修改，则取得进展。</li>
<li>否则中止。</li>
</ul>
<p>可以通过设置 DBServer 标志 enable_wait_queues=true 来启用冲突等待行为，这将允许使用内存中的等待队列，该队列在检测到事务之间存在冲突时提供等待语义。 需要滚动重启才能使该标志生效。 如果没有设置此标志，事务默认在基于优先级的冲突失败模式下运行。</p>
<p>因为只有当冲突事务没有提交任何冲突的永久修改时，T1 才能取得进展，因此行为中存在一些复杂性。 下面的示例部分详细介绍了可能的详尽案例列表。</p>
<p>读提交隔离的语义仅对等待冲突行为才有意义。 有关详细信息，请参阅与并发控制的交互。</p>
<p>尽力内部重试也适用于等待冲突策略
冲突失败中描述的尽力内部重试也适用于冲突等待策略。 AiSQL 提供了 PostgreSQL 不支持的附加增强功能。
在事务 T1（正在等待其他事务）解除阻塞后，可能会出现一些冲突的修改被提交到数据库的情况。 在这种情况下，T1 必须中止。 但是，如果它仍然是 T1 中执行的第一条语句，则将使用稍后的数据库快照执行尽力内部重试，以可能取得进展。</p>
<p><strong>例子</strong>
以下示例描述了详细说明等待冲突行为的不同用例。</p>
<p>请注意，这些示例要求您设置 DBServer 标志enable_wait_queues=true。
另外，设置 DBServer 标志 bsql_max_write_restart_attempts=0 以禁用冲突时内部查询层重试。 这样做是为了单独说明 Wait-on-Conflict 并发控制语义，而无需查询层重试。 不建议在生产中禁用这些重试。
需要重新启动才能使这些标志生效。</p>
<p>首先设置您将在本节所有示例中使用的表。</p>
<div class="highlight"><pre><span></span><code>create table test (k int primary key, v int);
insert into test values (1, 1);
insert into test values (2, 2);
</code></pre></div>
<p><strong>（1）两个显式行级锁之间的冲突</strong></p>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin transaction isolation level repeatable read;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin transaction isolation level repeatable read;</code></td>
</tr>
<tr>
<td><code>select * from test where k=1 for update;</code>  <code>k | v---+---1 | 1(1 row)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>select * from test where k=1 for update;</code>  <code>(waits)</code></td>
</tr>
<tr>
<td><code>commit;</code> (OR) <code>rollback;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>k | v---+---1 | 1(1 row)</code> <code>commit;</code></td>
</tr>
</tbody>
</table>
<p><strong>（2）显式行级锁定后跟冲突的写入</strong></p>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin transaction isolation level repeatable read;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin transaction isolation level repeatable read;</code></td>
</tr>
<tr>
<td><code>select * from test where k=1 for share;</code>  <code>k | v---+---1 | 1(1 row)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>update test set v=1 where k=1;</code> <code>(waits)</code></td>
</tr>
<tr>
<td><code>commit;</code> (OR) <code>rollback;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>UPDATE 1</code></td>
</tr>
<tr>
<td></td>
<td><code>commit;</code></td>
</tr>
</tbody>
</table>
<p><strong>（3）写入后跟有冲突的显式行级锁</strong></p>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin transaction isolation level repeatable read;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin transaction isolation level repeatable read;</code></td>
</tr>
<tr>
<td><code>update test set v=1 where k=1;</code> <code>UPDATE 1</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>select * from test where k=1 for share;</code> <code>(waits)</code></td>
</tr>
<tr>
<td><code>rollback;</code> (OR) <code>commit;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>k | v---+---1 | 1(1 row)</code> <code>commit;</code> (OR) <code>ERROR: All transparent retries exhausted. could not serializeaccess due to concurrent updaterollback;</code></td>
</tr>
</tbody>
</table>
<p><strong>（4）写入后跟有冲突的写入</strong></p>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin transaction isolation level repeatable read;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin transaction isolation level repeatable read;</code></td>
</tr>
<tr>
<td><code>update test set v=1 where k=1;</code> <code>UPDATE 1</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>update test set v=1 where k=1;</code> <code>(waits)</code></td>
</tr>
<tr>
<td><code>rollback;</code> (OR) <code>commit;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>UPDATE 1</code> <code>commit;</code> (OR) <code>ERROR: All transparent retries exhausted. Operation failed.Try again: Value write after transaction start: { days: 19299time: 17:07:42.577762 } &gt;= { days: 19299 time: 17:07:40.561842 }:kConflict</code> <code>rollback;</code></td>
</tr>
</tbody>
</table>
<p><strong>（5）允许插队等待</strong>
即使事务确实与等待事务冲突但不与任何活动事务冲突，事务也可以插队。</p>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
<th>会话3</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin transaction isolation level repeatable read;</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin transaction isolation level repeatable read;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>begin transaction isolation level repeatable read;</code></td>
</tr>
<tr>
<td><code>select * from test where k=1 for share;</code>  <code>k | v---+---1 | 1(1 row)</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>select * from test where k=1 for update;</code>  <code>(waits for T1 to end...)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>select * from test where k=1 for share;</code>  <code>k | v---+---1 | 1(1 row)</code> （不等待 T2，即使它与 T2 正在等待的显式行级锁冲突）</td>
</tr>
<tr>
<td><code>commit;</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>commit;</code></td>
</tr>
<tr>
<td></td>
<td><code>k | v---+---1 | 1(1 row)</code> <code>commit;</code></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>（6）写冲突的子事务回滚</strong>
假设事务 T1 被另一个事务 T2 的某些操作阻塞。 如果该阻塞操作是稍后回滚的子事务的一部分，则 T1 可以继续：</p>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin transaction isolation level repeatable read;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin transaction isolation level repeatable read;</code></td>
</tr>
<tr>
<td><code>savepoint a;</code> <code>update test set v=1 where k=1;</code> <code>UPDATE 1</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>update test set v=1 where k=1;</code> <code>(waits)</code></td>
</tr>
<tr>
<td><code>rollback to savepoint a;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>UPDATE 1</code> <code>commit;</code></td>
</tr>
<tr>
<td><code>commit;</code></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>（7）分布式死锁检测</strong>
在冲突等待模式下，事务可能会互相等待并导致死锁。 设置DBServer标志enable_deadlock_detection=true会在后台运行分布式死锁检测算法来检测和打破死锁。 始终建议在enable_wait_queues=true 时保持死锁检测，除非绝对确定应用程序或工作负载行为不会导致死锁。 需要滚动重新启动才能使更改生效。</p>
<p>将enable_deadlock_detection = true添加到dbserver标志列表中并重新启动集群。</p>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin transaction isolation level repeatable read;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin transaction isolation level repeatable read;</code></td>
</tr>
<tr>
<td><code>update test set v=2 where k=1;</code> <code>UPDATE 1</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>update test set v=4 where k=2;</code> <code>UPDATE 1</code></td>
</tr>
<tr>
<td><code>update test set v=6 where k=2;</code> <code>(waits)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>update test set v=6 where k=1;</code> <code>ERROR: Internal error: Transaction 00da00cd-87fa-431b-9521-253582fb23fewas aborted while waiting for locks</code></td>
</tr>
<tr>
<td><code>commit;</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>（8）指标
所有指标均以每台Tile为单位。
<strong>直方图</strong>
wait_queue_pending_time_waiting (ms)：仍在等待的事务在等待队列中的时间量
wait_queue_finished_waiting_latency (ms)：未阻塞事务在等待队列中花费的时间量
wait_queue_blockers_per_waiter：等待队列中等待等待的阻塞者数量</p>
<p>计数器
wait_queue_waiters_per_blocker：等待队列中卡在特定阻塞器上的等待者数量
wait_queue_num_waiters：等待队列中阻塞在阻塞器上的等待者数量
wait_queue_num_blockers：等待队列中跟踪的唯一阻塞程序的数量</p>
<h4 id="_21"><strong>事务优先级</strong></h4>
<p>使用“冲突时失败张”并发控制策略时，会为事务分配优先级，以帮助决定在发生冲突时应中止哪些事务。</p>
<p>有两个优先级桶，每个优先级桶的优先级范围都在 [0, 1] 中，如下所示：</p>
<ul>
<li>高优先级存储桶：如果事务中的第一条语句使用 SELECT 获取 FOR UPDATE/FOR SHARE/FOR NO KEY UPDATE 显式行锁，则将从该存储桶中为其分配优先级。</li>
<li>普通优先级存储桶：所有其他事务都从该存储桶中分配优先级。</li>
</ul>
<p>请注意，高优先级存储桶中具有任何优先级 P1 的事务可以中止普通优先级存储桶中具有任何优先级 P2 的事务。 例如，高优先级存储桶中优先级为 0.1 的事务可以中止普通优先级存储桶中优先级为 0.9 的事务。</p>
<p>优先级是从适用的存储桶中随机选择的。 但是，您可以使用以下两个 BSQL 参数来控制分配给特定会话中事务的优先级：</p>
<ul>
<li>bm_transaction_priority_lower_bound</li>
<li>bm_transaction_priority_upper_bound</li>
</ul>
<p>这些参数有助于设置事务应从适用存储桶接收的随机分配优先级的下限和上限。 这些参数接受 [0, 1] 范围内的实数数据类型值。 另请注意，相同的边界适用于两个存储桶。</p>
<p>所有单分片事务在普通优先级存储桶中的优先级均为 1。</p>
<p>bm_get_current_transaction_priority 函数可用于获取当前活动事务的事务优先级。 它输出一对<priority>（bucket），其中<priority>是[0, 1]之间的实数数据类型，精度为9个十进制单位，<bucket>是Normal或High。</p>
<p>注:作为例外，如果为事务分配了可能的最高优先级，即高优先级存储桶中的优先级为 1，则该函数将返回最高优先级事务，而不返回任何实际值。</p>
<p>在事务真正开始之前，事务的优先级为 0.000000000（普通优先级事务）。</p>
<p>例子
以下示例演示如何设置事务优先级并获取当前事务优先级。
1.创建一个表并插入一些数据。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test (k INT PRIMARY KEY, v INT);
INSERT INTO test VALUES (1, 1);
</code></pre></div>
<p>2.设置事务的下限值和上限值，如下所示：</p>
<div class="highlight"><pre><span></span><code>SET bm_transaction_priority_lower_bound = 0.4;
SET bm_transaction_priority_upper_bound = 0.6;
</code></pre></div>
<p>3.在普通优先级桶中创建事务如下：</p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT bm_get_current_transaction_priority(); -- 0 due to an optimization which doesn&#39;t really start a real transaction internally unless a write occurs
</code></pre></div>
<div class="highlight"><pre><span></span><code>    bm_get_current_transaction_priority
-------------------------------------------
 0.000000000 (Normal priority transaction)
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM test;
</code></pre></div>
<div class="highlight"><pre><span></span><code> k | v
---+---
 1 | 1
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT bm_get_current_transaction_priority(); -- still 0 due to the optimization which doesn&#39;t really start a real transaction internally unless a write occurs
</code></pre></div>
<div class="highlight"><pre><span></span><code>    bm_get_current_transaction_priority
-------------------------------------------
 0.000000000 (Normal priority transaction)
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO test VALUES (2, &#39;2&#39;); -- perform a write which starts a real     transaction
SELECT bm_get_current_transaction_priority(); -- non-zero now
</code></pre></div>
<div class="highlight"><pre><span></span><code>    bm_get_current_transaction_priority
-------------------------------------------
 0.537144608 (Normal priority transaction)
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>COMMIT;
</code></pre></div>
<p>4.在高优先级桶中创建事务如下：</p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM test WHERE k = 1 FOR UPDATE; -- starts a transaction in a high-priority bucket
</code></pre></div>
<div class="highlight"><pre><span></span><code> k | v
---+---
 1 | 1
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT bm_get_current_transaction_priority();
</code></pre></div>
<div class="highlight"><pre><span></span><code>   bm_get_current_transaction_priority
-----------------------------------------
 0.412004009 (High priority transaction)
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>COMMIT;
</code></pre></div>
<p>5.创建具有最高优先级的事务</p>
<div class="highlight"><pre><span></span><code>SET bm_transaction_priority_upper_bound = 1;
SET bm_transaction_priority_lower_bound = 1;
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM test WHERE k = 1 FOR UPDATE;
</code></pre></div>
<div class="highlight"><pre><span></span><code> k | v
---+---
 1 | 1
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT bm_get_current_transaction_priority();
</code></pre></div>
<div class="highlight"><pre><span></span><code> bm_get_current_transaction_priority
-------------------------------------
 Highest priority transaction
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>COMMIT;
</code></pre></div>
<h4 id="_22"><strong>读已提交</strong></h4>
<p>已提交读是 PostgreSQL 中的三个隔离级别之一，也是其默认级别。 此隔离级别的一个独特属性是，对于使用此隔离运行的事务，客户端不需要重试或处理应用程序逻辑中的串行化错误 (40001)。</p>
<p>另外两个隔离级别（可串行化和可重复读取）要求应用程序具有针对串行化错误的重试逻辑。 PostgreSQL 中的读提交通过允许单个语句在不一致的快照上工作来解决冲突（换句话说，从该语句的快照开始读取非冲突的行，但冲突解决是通过读取并尝试重新执行或锁定该行的最新版本快照来完成）。</p>
<p>BSQL支持读提交隔离级别，其行为与PostgreSQL的读提交级别相同。</p>
<h5 id="_23"><strong>语义学</strong></h5>
<p>以下两个关键语义将 PostgreSQL 中的已提交读隔离与可重复读区分开来：</p>
<ul>
<li>每个语句应该能够读取在该语句发出之前提交的所有内容。 换句话说，每个语句都在该语句发出时的最新数据库快照上运行。</li>
<li>客户端在读已提交隔离级别中永远不会遇到串行化错误 (40001)。 为了实现这一点，PostgreSQL 根据一组规则重新评估冲突行的语句。</li>
</ul>
<p><strong>1.读取重启错误</strong>
除了这两个关键要求之外，对于读已提交隔离级别还有一个特定于 BSQL 的额外要求：确保外部客户端不会面临由时钟偏差引起的 kReadRestart 错误，时钟偏差是分布式数据库中固有的，因为数据分布在分布式数据库中多个物理节点。 PostgreSQL 不需要定义有关读取重新启动错误的语义，因为它是一个没有时钟偏差的单节点数据库。 当存在时钟偏差时，在像 AiSQL 这样的分布式数据库中可能会出现以下情况：
（1）客户端通过连接到 AiSQL 集群中节点 N1 上的 BSQL 来启动分布式事务，并发出一条语句，从集群中不同物理 DBServer 上的多个分片中读取数据。 对于此发出的语句，数据读取时间点（这个时间点定义读取数据的哪个快照）是根据存储该分片的DBServer M的当前时间选取的。 根据场景的不同，节点N2的时间可能与 N1 相同，也可能不同，但这与本讨论无关。 将 T1 视为所选的读取时间。
（2）节点 N1 可能从不同物理 DBServer 上的许多分片收集数据。 在这个过程中，它会向许多其他节点发出读取数据的请求。
（3）假设节点 N1 从节点 N2 读取数据，则数据可能已经以写入时间戳 T2 (&gt; T1) 写入节点 N2 上，但该数据是在发出读取之前写入的。 如果节点 N2 上的物理时钟跑在节点N1之前，则这可能是由时钟偏差引起的，导致过去完成的写入操作的写入时间戳仍晚于 T1。</p>
<p>请注意，由于时钟同步算法，集群中所有节点之间的时钟偏差始终处于 max_clock_skew_usec 范围内。</p>
<p>（4）对于写入时间戳晚于 T1 + max_clock_skew 的写入，数据库可以确保这些写入是在选择读取时间戳之后完成的。 但对于写入时间戳在 T1 和 T1 + max_clock_skew 之间的写入，节点 N2 可能会发现自己处于不明确的情况，如下所示：</p>
<ul>
<li>即使客户端在写入数据后从不同的节点发出读取，它也应该返回数据，因为需要维护以下保证：数据库应该始终返回过去提交的数据（过去是指用户感知的过去，而不是基于机器时钟）。</li>
<li>如果写入是在将来执行的（即选择读取点之后）并且写入时间戳晚于读取点，则不应返回数据。 因为如果允许的话，将来写入的所有内容都被琐碎的读取到。 请注意，后一个条件很重要，因为如果写入时间戳早于读取点，则可以返回选择读取点后写入的数据（这不会破坏一致性或隔离保证）。</li>
</ul>
<p>（5）如果节点 N2 在范围 (T1, T1+max_clock_skew] 中发现写入，节点 N2 会引发读取重新启动错误来避免同时出现下面2种矛盾的场景：
A.应始终能够读取较早提交的内容
B.避免读取实际写入的较晚的数据</p>
<p>一些分布式数据库通过使用算法来维持对时钟偏差的严格限制来处理这种由于时钟偏差而产生的特定不确定性，然后采取保守的方法，在确认客户端对每个写入数据的事务的提交请求之前等待时钟偏差。然而，AiSQL 使用各种内部机制来减少这种歧义的范围，如果在极少数情况下仍然存在歧义，则会向客户端显示读取重新启动错误。</p>
<p>对于读提交隔离，AiSQL 具有更强大的机制来确保歧义始终在内部得到解决，并且读重新启动错误不会出现在客户端上。 在读提交事务中，客户端不必为读重启错误（类似于串行化错误）添加任何重试逻辑。</p>
<p><strong>2处理串行化错误</strong>
为了处理数据库中的串行化错误而不将其呈现给客户端，PostgreSQL 根据语句类型采取许多步骤。</p>
<p>（1）UPDATE, DELETE, SELECT FOR UPDATE, FOR SHARE, FOR NO KEY UPDATE, FOR KEY SHARE</p>
<ul>
<li>如果主题行被其他并发事务以冲突的方式更新或删除，请等待冲突事务提交或回滚，然后执行验证步骤。</li>
<li>如果主题行已被其他并发事务以冲突的方式更新或删除，请执行验证步骤。</li>
<li>如果主题行已被其他并发事务以冲突的方式锁定，请等待它们提交或回滚，然后执行验证步骤。</li>
</ul>
<p>请注意，如果两个事务的读取时间到提交时间范围重叠，则它们是并发的。 如果事务尚未提交，则关闭范围为当前时间。 此外，对于已提交读隔离，每个语句都有一个读取时间，而不是整个事务的读取时间。</p>
<p>验证步骤
验证步骤如下：、
A.读取冲突行的最新版本并适当锁定它。 最新版本也可能有不同的主键。 PostgreSQL 通过跟踪行的更新链（甚至跨主键更改）来找到它。 请注意，锁定是必要的，以便在再次重新评估该行并可能在步骤 C 中更新/获取该行的锁定时，不会在此行上看到另一个冲突。如果锁定面临冲突，它将等待并恢复遍历 一旦解锁，链条就会进一步延伸。
B.如果删除了行的更新版本，请忽略它。
C.如果 WHERE 子句在行的更新版本上计算为 true，则对该行的更新版本应用更新、删除或获取锁定。</p>
<p>（2）INSERT</p>
<ul>
<li>ON CONFLICT DO UPDATE：如果发生冲突，则等待冲突事务提交或回滚。
  如果所有冲突事务都回滚，则照常进行。
  提交任何冲突事务时，按照验证步骤 1 中所述遍历更新链，并重新评估该行的最新版本是否存在任何冲突。 如果没有冲突，则插入原始行。 否则，对行的最新版本执行 DO UPDATE 部分。</li>
<li>ON CONFLICT DO NOTHING：如果发生冲突，则不采取任何行动。
  请注意，PostgreSQL 中的上述方法可能会导致两种不同的可见语义。 一种是常见情况； 另一种是在实践中永远看不到的退化情况，但仍然是可能的，并且仍然坚持读提交隔离的语义。 常见的情况如下：</li>
</ul>
<p>CREATE TABLE test (k int primary key, v int);
INSERT INTO test VALUES (2, 5);</p>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin transaction isolation level read committed;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin transaction isolation level read committed;</code></td>
</tr>
<tr>
<td><code>insert into test values (5, 5);</code> <code>INSERT 0 1</code> <code>update test set v=10 where k=2;</code> <code>UPDATE 1</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>update test set v=100 where v&gt;=5;</code> <code>(waits)</code></td>
</tr>
<tr>
<td><code>COMMIT;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>UPDATE 1</code> <code>select * from test;</code> <code>k | v---+-----5 | 52 | 100(2 rows)</code></td>
</tr>
</tbody>
</table>
<p>如上所示，事务 2 的 UPDATE 首先选择仅包含行 (2, 5) 的数据库的最新快照。 该行满足 UPDATE 语句的 WHERE 子句，因此事务 2 尝试将 v 的值从 5 更新到 100。但是，由于事务 1 中现有的写入冲突，它会等待事务 1 结束。 事务 1 提交后，它仅重新读取冲突行的最新版本，并重新评估 WHERE 子句。 新行 (2, 10) 仍然满足该子句，因此值更新为 100。请注意，新插入的行 (5, 5) 不会更新，即使它满足事务 2 的 UPDATE 的 WHERE 子句， 因为它不是事务 2 的 UPDATE 语句最初选择的快照的一部分。 因此，很明显，为了避免串行化错误，PostgreSQL 允许单个语句在不一致的快照上运行，例如：在语句启动时选择一个快照来读取所有数据，并且该行的最新版本是 仅在需要时用于每个冲突行。</p>
<p>可能发生的另一种退化场景与事务 2 中 UPDATE 的输出不同：</p>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>update test set v=10 where k=2;</code> <code>UPDATE 1</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>update test set v=100 where v&gt;=5;</code> <code>(some processing before snapshot is picked, but feels like postgreSQL is waiting due to a conflict)</code></td>
</tr>
<tr>
<td><code>COMMIT;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>UPDATE 2</code> <code>select * from test;</code> <code>k | v---+-----5 | 1002 | 100(2 rows)</code></td>
</tr>
</tbody>
</table>
<p>上述结果可以通过以下步骤发生：在客户端 1 提交之前，客户端 2 上的 PostgreSQL 正忙于其他处理，并且只有在客户端 1 提交之后，客户端 2 上的事务才能根据语句的当前时间选择快照。 这导致两行都作为快照的一部分被读取并更新，而没有任何可观察到的冲突。 两种结果都是有效的并且满足读提交隔离级别的语义。 从理论上讲，用户无法弄清楚将看到哪一个，因为用户无法区分由于等待冲突事务而导致的暂停或由于数据库繁忙或缓慢而导致的暂停。 在第二种情况下，整个语句在单个快照上运行，并且更容易推理输出。</p>
<p>这两种可能性表明，客户端的应用程序逻辑不能依赖于常见情况总是发生的期望。 鉴于此，AiSQL 提供了更强有力的保证，即每个语句始终仅在单个快照上运行，即使在某些行冲突的情况下也不允许出现不一致。 这导致 AiSQL 总是返回类似于上面示例中的第二个结果的输出，这也更容易推理。</p>
<p><strong>3.与并发控制的交互</strong>
读提交隔离的语义仅遵循等待冲突并发控制策略。 这是因为读提交事务在发生冲突时必须等待其他事务提交或回滚，然后执行重新检查步骤才能取得进展。</p>
<p>由于冲突时失败并发控制策略对于已提交读没有意义，即使设置此策略在集群上使用（通过设置 DBServer 标志enable_wait_queues=false），已提交读隔离中的事务仍将 提供等待冲突语义。 为了在没有等待队列的情况下提供等待冲突语义，AiSQL 依赖于无限期重试回退机制，在检测到冲突时具有指数延迟。 重试是在语句级别。 每次重试都将使用较新的数据库快照，以防止冲突发生。 这样做是因为如果新快照的读取时间高于较早冲突事务 T2 的提交时间，则与 T2 的冲突本质上将无效，因为 T1 的语句并且 T2 将不再“并发”。</p>
<p>然而，当读提交隔离提供冲突等待语义而不需要等待队列时，存在以下限制：</p>
<ul>
<li>您可能必须手动调整指数退避参数以提高性能，如性能调整中所述。</li>
<li>您的应用程序可能必须依赖语句超时来避免死锁。</li>
<li>由于重试退避机制，争用过程中可能存在不公平现象，导致P99时延较高。</li>
</ul>
<h5 id="_24"><strong>用法</strong></h5>
<p>通过设置 DBServer 标志 bm_enable_read_commissed_isolation=true，BSQL 中的语法读提交隔离映射到 CoreDB 中的读提交实现。 如果设置为 false，则它具有将 BSQL 上的语法读取已提交映射到 CoreDB 中的快照隔离的早期行为，这意味着它的行为类似于可重复读取。</p>
<p>设置标志后，可以使用以下方式启动读已提交事务：</p>
<div class="highlight"><pre><span></span><code>1.START TRANSACTION isolation level read committed [read write | read only];
</code></pre></div>
<div class="highlight"><pre><span></span><code>2.BEGIN [TRANSACTION] isolation level read committed [read write | read only];
</code></pre></div>
<div class="highlight"><pre><span></span><code>3.BEGIN [TRANSACTION]; SET TRANSACTION ISOLATION LEVEL READ COMMITTED; (this will be supported after #12494 is resolved)
</code></pre></div>
<div class="highlight"><pre><span></span><code>4.BEGIN [TRANSACTION]; SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL READ COMMITTED;
</code></pre></div>
<h5 id="_25"><strong>示例</strong></h5>
<p>首先创建要在所有示例中使用的表，如下所示</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test (k int primary key, v int);
</code></pre></div>
<p><strong>1.没有显式锁定的 SELECT 行为</strong></p>
<div class="highlight"><pre><span></span><code>TRUNCATE TABLE test;
INSERT INTO test VALUES (1, 5);
</code></pre></div>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin transaction isolation level read committed;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin transaction isolation level read committed;</code></td>
</tr>
<tr>
<td><code>select * from test where v=5;</code> <code>k | v---+---1 | 5(1 row)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>insert into test values (2, 5);</code> <code>INSERT 0 1</code></td>
</tr>
<tr>
<td><code>select * from test where v=5;</code> <code>k | v---+---1 | 5(1 row)</code> <code>insert into test values (3, 5);</code> <code>INSERT 0 1</code> <code>select * from test where v=5;</code> <code>k | v---+---1 | 53 | 5(2 rows)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>commit;</code></td>
</tr>
<tr>
<td><code>select * from test where v=5;</code> <code>k | v---+---1 | 52 | 53 | 5(3 rows)</code> <code>commit;</code></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>2.UPDATE行为</strong></p>
<div class="highlight"><pre><span></span><code>TRUNCATE TABLE test;
INSERT INTO test VALUES (0, 5), (1, 5), (2, 5), (3, 5), (4, 1);
</code></pre></div>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin transaction isolation level read committed;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin transaction isolation level read committed;</code> <code>insert into test values (5, 5);</code> <code>INSERT 0 1</code> <code>update test set v=10 where k=4;</code> <code>UPDATE 1</code> <code>delete from test where k=3;</code> <code>DELETE 1</code> <code>update test set v=10 where k=2;</code> <code>UPDATE 1</code> <code>update test set v=1 where k=1;</code> <code>UPDATE 1</code> <code>update test set k=10 where k=0;</code> <code>UPDATE 1</code></td>
</tr>
<tr>
<td><code>update test set v=100 where v&gt;=5;</code> <code>(waits)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>commit;</td>
</tr>
<tr>
<td><code>UPDATE 4</code> <code>select * from test;</code> <code>k | v----+-----5 | 1001 | 110 | 1004 | 1002 | 100(5 rows)</code> <code>commit;</code></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>3.SELECT FOR UPDATE行为</strong></p>
<div class="highlight"><pre><span></span><code>TRUNCATE TABLE test;
INSERT INTO test VALUES (0, 5), (1, 5), (2, 5), (3, 5), (4, 1);
</code></pre></div>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin transaction isolation level read committed;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin transaction isolation level read committed;</code> <code>insert into test values (5, 5);</code> <code>INSERT 0 1</code> <code>update test set v=10 where k=4;</code> <code>UPDATE 1</code> <code>delete from test where k=3;</code> <code>DELETE 1</code> <code>update test set v=10 where k=2;</code> <code>UPDATE 1</code> <code>update test set v=1 where k=1;</code> <code>UPDATE 1</code> <code>update test set k=10 where k=0;</code> <code>UPDATE 1</code></td>
</tr>
<tr>
<td><code>select * from test where v&gt;=5 for update;</code> <code>(waits)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>commit;</code></td>
</tr>
<tr>
<td><code>k | v----+----5 | 510 | 54 | 102 | 10(4 rows)</code> <code>commit;</code></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>4.INSERT行为</strong>
插入刚刚被另一个事务更改的新key，如下所示：
TRUNCATE TABLE test;
INSERT INTO test VALUES (1, 1);</p>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin transaction isolation level read committed;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin transaction isolation level read committed;</code> <code>update test set k=2 where k=1;</code> <code>UPDATE 1</code></td>
</tr>
<tr>
<td><code>insert into test values (2, 1);</code> <code>(waits)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>commit;</code></td>
</tr>
<tr>
<td><code>ERROR: duplicate key value violates unique constraint "test_pkey"</code> <code>rollback;</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>插入刚刚被另一个事务更改的新key，带ON CONFLICT 选项：
TRUNCATE TABLE test;
INSERT INTO test VALUES (1, 1);</p>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin transaction isolation level read committed;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin transaction isolation level read committed;</code> <code>update test set k=2 where k=1;</code> <code>UPDATE 1</code></td>
</tr>
<tr>
<td><code>insert into test values (2, 1) on conflict (k) do update set v=100;</code> <code>(waits)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>commit;</code></td>
</tr>
<tr>
<td><code>INSERT 0 1</code> <code>select * from test;</code> <code>k | v---+-----2 | 100(1 row)</code> <code>commit;</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>插入已被另一个事务删除的旧key，如下所示：
TRUNCATE TALE test;
INSERT INTO test VALUES (1, 1);</p>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin transaction isolation level read committed;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin transaction isolation level read committed;</code> <code>update test set k=2 where k=1;</code> <code>UPDATE 1</code></td>
</tr>
<tr>
<td><code>insert into test values (1, 1);</code> <code>(waits)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>commit;</code></td>
</tr>
<tr>
<td><code>INSERT 0 1</code> <code>select * from test;</code> <code>k | v---+---1 | 12 | 1(2 rows)</code> <code>commit;</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>插入已被另一个事务删除的旧key，带ON CONFLICT 选项：
TRUNCATE TABLE test;
INSERT INTO test VALUES (1, 1);</p>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin transaction isolation level read committed;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin transaction isolation level read committed;</code> <code>update test set k=2 where k=1;</code> <code>UPDATE 1</code></td>
</tr>
<tr>
<td><code>insert into test values (1, 1) on conflict (k) do update set v=100;</code> <code>(waits)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>commit;</code></td>
</tr>
<tr>
<td><code>INSERT 0 1</code> <code>select * from test;</code> <code>k | v---+-----1 | 12 | 1(2 rows)</code> <code>commit;</code></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>5.避免读已提交事务中的死锁</strong>
当未启用等待队列时，即DBServer GFlag enable_wait_queues=false时，配置语句超时以避免死锁。 可以使用statement_timeout BSQL 参数为每个会话设置不同的语句超时。 此外，通过在集群启动时设置 bsql_pg_conf_csv DBServer GFlag 中的 statements_timeout BSQL 参数，可以将单个语句超时全局应用于所有会话。</p>
<p>使用等待队列时，可以使用 DBServer GFlag enable_deadlock_detection=true 启用自动死锁检测和解决。 强烈建议在使用等待队列时使用此设置。</p>
<div class="highlight"><pre><span></span><code>truncate table test;
insert into test values (1, 5);
insert into test values (2, 5);
</code></pre></div>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin transaction isolation level read committed;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>begin transaction isolation level read committed;</code> <code>set statement_timeout=2000;</code></td>
</tr>
<tr>
<td><code>update test set v=5 where k=1;</code> <code>UPDATE 1</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>update test set v=5 where k=2;</code> <code>UPDATE 1</code></td>
</tr>
<tr>
<td><code>update test set v=5 where k=2;</code> <code>(waits)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>update test set v=5 where k=1;</code> <code>ERROR: cancelling statement due to statement timeout</code> <code>rollback;</code></td>
</tr>
<tr>
<td><code>UPDATE 1</code> <code>commit;</code></td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="_26"><strong>跨功能交互</strong></h5>
<p>已提交读与以下功能交互：
Follower 读取：当启用 follower 读取并且事务块显式标记为 READ ONLY 时，读已提交事务中每个语句的读取点将选择为 Now() - bm_follower_read_staleness_ms。</p>
<h5 id="_27"><strong>局限性</strong></h5>
<p>BEGIN 后立即发出 SET TRANSACTION ISOLATION LEVEL ... 语句； 或BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED; 如果 DBServer GFlag bm_enable_read_commissed_isolation=true 将会失败，并且会发出以下错误：</p>
<p>错误：不得在子事务中调用设置事务隔离级别
有关更多详细信息，请参阅#12494。</p>
<p>如果查询的响应大小超过 DBServer GFlag bsql_output_buffer_size（默认值为 256KB），则读重新启动和序列化错误不会在读提交隔离中进行内部处理（请参阅#11572）。</p>
<p>当处于读提交隔离状态的函数或过程中发生冲突或读重新启动时，非事务性副作用可能会多次发生。 这是因为在读提交隔离中，数据库中的重试逻辑将撤消作为该语句的一部分完成的所有工作，并重新尝试整个客户端发出的语句。 （参见#12958）</p>
<p>当enable_wait_queues = false时，读提交隔离具有以下附加限制（请参阅冲突等待和与并发控制的交互）：</p>
<p>您可能必须手动调整指数退避参数以提高性能，如性能调整中所述。
您的应用程序可能必须依赖语句超时来避免死锁。
由于重试退避机制，争用过程中可能存在不公平现象，导致P99时延较高。</p>
<h5 id="_28"><strong>注意事项</strong></h5>
<p>此隔离级别允许幻读和不可重复读（如没有显式锁定的 SELECT 行为所示）。</p>
<p>添加这个新的隔离级别不会影响现有隔离级别的性能。</p>
<p><strong>性能调优</strong>
如果读已提交隔离级别中的语句面临冲突，则会使用指数退避重试，直到语句超时。 以下参数控制退避：</p>
<p>retry_max_backoff 是重试之间的最大退避时间（以毫秒为单位）。
retry_min_backoff 是重试之间的最小退避时间（以毫秒为单位）。
retry_backoff_multiplier 是用于计算下一次重试退避的乘数。
您可以在每个会话的基础上设置这些参数，或者在集群启动时在 bsql_pg_conf_csv DBServer 标志中设置这些参数。</p>
<p>如果启用了“冲突等待”并发控制策略，则无需手动调整这些参数来提高性能。 仅当所有冲突事务都已提交或回滚时，语句才会重新启动，而不是使用指数退避重试。</p>
<h4 id="_29"><strong>单行事务</strong></h4>
<p>AiSQL 为涉及同一分片（分区、Tile）中的单行或多行的突变提供原子性、一致性、隔离性、持久性 (ACID) 语义。 这些突变仅在分布式共识节点之间产生一次网络往返。</p>
<p>即使是单行或单个分片中的读取-修改-写入操作（如下所示），在 AiSQL 中也只产生一次往返：</p>
<div class="highlight"><pre><span></span><code>   UPDATE table SET x = x + 1 WHERE ...
   INSERT ... IF NOT EXISTS
   UPDATE ... IF EXISTS
</code></pre></div>
<p>请注意，这与 Apache Cassandra 不同，后者使用称为轻量级事务的概念来实现这些读取-修改-写入操作的正确性，并导致 4 网络往返延迟。</p>
<h5 id="reading-the-latest-data-from-a-recently-elected-leader"><strong>Reading the latest data from a recently elected leader</strong></h5>
<p>在稳定状态下，当领导者追加和复制日志条目时，最新的多数复制条目正是已提交的条目。 然而，领导者更换后，情况变得更加复杂。 当Tile中选举出新的领导者时，它会将无操作条目附加到Tile的 Raft 日志中并复制它，如 Raft 协议中所述。 在复制此无操作条目之前，Tile被视为无法读取最新值并接受读取-修改-写入操作。 这是因为新的tablet领导者需要能够保证所有之前Raft提交的条目都应用于RocksDB和其他持久化和内存中的数据结构，并且只有在知道新领导者的所有条目之后才有可能日志已提交。</p>
<h5 id="leader-lease"><strong>Leader Lease：在网络分区的情况下读取最新数据</strong></h5>
<p>领导者租约是Tile领导者在一定的短时间内建立其权限的一种机制，以避免以下不一致的情况：</p>
<ul>
<li>
<p>领导者与其追随者通过网络隔离。</p>
</li>
<li>
<p>选出了新的领导人。</p>
</li>
<li>
<p>客户端写入一个新值，新的领导者复制它。</p>
</li>
<li>
<p>客户端从旧领导者那里读取过时的值。</p>
</li>
</ul>
<p><img alt="" src="media/chapter9/15.png" /></p>
<p>AiSQL中的leader租约机制可以防止这种不一致，如下：</p>
<ul>
<li>对于每个领导者到跟随者的消息（Raft 术语中的 AppendEntries），无论是复制新条目还是空心跳消息，领导者都会以时间间隔形式发送领导者租约请求（例如，“我想要 2 秒的租约”） ）。 租约期限通常是系统范围的参数。 对于每个对等点，领导者还跟踪与每个待处理请求相对应的租约到期时间（例如，发送请求的时间加上租约持续时间），该时间以所谓的本地单调时间（CLOCK_MONOTONIC）存储。 为此，领导者将自己视为同伴的特例。 然后，当领导者收到来自追随者的响应时，它会维护在请求发送时存储的这些过期时间的多数复制水印。 领导者采用这个多数复制水印作为其租约到期时间，并在决定是否可以服务一致的读取请求或接受写入时使用它。</li>
<li>当跟随者收到前面描述的 Raft RPC 时，它会读取当前单调时钟的值，将提供的租约间隔添加到该值中，并记住该租约到期时间（也是根据其本地单调时间）。 如果该追随者成为新的领导者，则在任何潜在的旧领导者的租约到期之前，不允许提供一致的读取或接受写入。</li>
<li>为了保证任何新领导者都知道任何旧领导者的租约到期，还需要另一位逻辑。 每个 Raft 组成员都会记录它所知道的旧领导者的最新过期时间（以该服务器的本地单调时间为单位）。 每当服务器响应 RequestVote RPC 时，它都会在其响应中包含任何已知旧领导者租约的最大剩余时间。 这与接收服务器上领导者 AppendEntries 请求中的租约期限类似地进行处理：自收到此请求以来，至少必须经过这个时间量，然后接收者才能为最新请求提供服务，以防它成为领导者 。 需要这部分算法，以便可以证明新领导者将始终了解任何旧领导者的多数复制租约。 这类似于Raft的正确性证明：总有一个服务器（投票者）收到旧领导者的租约请求并投票给新领导者，因为两个多数必须重叠。</li>
</ul>
<p>请注意，此领导者租用实现不依赖于任何类型的时钟同步，因为仅通过网络发送时间间隔，并且每个服务器根据其本地单调时钟进行操作。 以下是时钟实现的两个要求：</p>
<ul>
<li>不同服务器之间的有界单调时钟漂移率。 例如，如果使用每秒漂移率小于 500μs 的标准 Linux 假设，则可以通过将前面提到的所有延迟乘以 1.001 来计算。</li>
<li>单调时钟不会冻结。 例如，如果在暂时冻结的虚拟机上运行，则当虚拟机再次开始运行时，管理程序需要从硬件时钟刷新虚拟机的时钟。</li>
</ul>
<p>Leader 租用机制保证在任何时间点，任何 Tablet 的 Raft 组中最多有一台服务器认为自己是最新的 Leader，可以为一致的读取提供服务或接受写入请求</p>
<h5 id="_30"><strong>读取请求的安全时间戳分配</strong></h5>
<p>每个读取请求都会分配一个特定的多版本并发控制 (MVCC) 时间戳或混合时间（例如，称为 ht_read），这允许对同一组键的写入操作与读取并行发生。 然而，至关重要的是，截至该时间戳的数据库视图不会因同时发生的写入而更新。 也就是说，一旦为读请求选择了ht_read，就不能为对同一组键的进一步写入分配早于或与ht_read相同的时间戳。 正如已经提到的，严格增加的混合时间被分配给任何给定片的 Raft 日志条目。 因此，安全分配 ht_read 的一种方法是使用最后提交记录的混合时间。 由于提交的 Raft 日志记录永远不会被未来的领导者覆盖，并且每个新的领导者都会读取最后一个日志条目并更新其混合时间，因此所有未来的记录都将具有严格的较晚的混合时间。</p>
<p>但是，通过这种保守的时间戳分配方法，如果此特定Tile上没有写入工作负载，ht_read 可以保持不变。 如果使用生存时间 (TTL)，这会导致客户端观察到的异常：就客户端而言，在新记录写入Tile之前，过期值不会消失。 然后，许多旧的过期值可能会突然消失。 为了防止这种异常情况，需要将读取时间戳指定为接近当前混合时间（反过来又接近物理时间），以保留自然的 TTL 语义。 应尝试选择 ht_read 作为可能的最新时间戳，这样可以保证 table 中所有未来的写入操作都将具有严格晚于该时间的混合时间，即使在领导者更改期间也是如此。</p>
<p>这需要引入混合时间领导者租赁的概念，类似于前面讨论的绝对时间领导者租赁。 对于向关注者发出的每个 Raft AppendEntries 请求，无论是常规请求还是空请求或心跳请求，tablet 领导者都会计算混合时间租约到期时间（例如，称为 ht_lease_exp），并将其发送给关注者。 ht_lease_exp 通常计算为当前混合时间加上固定配置的持续时间（例如，2 秒）。 通过回复，追随者承认旧领导者对分配任何混合时间（包括 ht_lease_exp）的专有权力。 与常规租赁类似，这些混合时间租赁通过投票进行传播。 领导者维护一个多数复制水印，并认为自己已经复制了混合时间领导者租约到期的特定值（如果它向大多数 Raft 组成员发送了该值或更大的 ht_lease_exp 值）。 为此，领导者始终被认为已向自身复制了无限的领导者租约。</p>
<p><strong>安全时间的定义</strong>
假设当前多数复制混合时间领导者租约到期称为replicated_ht_lease_exp。 然后，读取请求的安全时间戳可以计算为以下最大值：
最后提交的 Raft 条目的混合时间。
以下之一：
如果Raft日志中有未提交的条目，则第一个未提交条目的混合时间的最小值 - ε，其中ε是混合时间和replicated_ht_lease_exp之间的最小可能差异。
如果Raft日志中没有未提交的条目，则当前混合时间和replicated_ht_lease_exp中的最小值。</p>
<p>换句话说，最后提交的条目的混合时间始终可以安全读取，但对于后来的混合时间，多数复制的混合时间领导者租约是上限。 这是因为，只有当 ht&lt;replicated_ht_lease_exp 时，才能保证未来的领导者不会提交混合时间早于 ht 的条目。</p>
<p>请注意，当从单个tablet读取时，无需等待所选的ht_read变得可以安全读取，因为它已经被选择了。 但是，如果决定跨多个Tile读取一致的数据视图，则可以在其中一个Tile上选择 ht_read，并且需要等待该时间戳在第二个Tile上安全读取。 这通常发生得非常快，因为第二个tablet的leader上的混合时间会立即用第一个tablet的leader传播的混合时间更新，并且在常见情况下，需要等待混合时间早于的待处理Raft日志条目 ht_read 被提交。</p>
<h5 id="_31"><strong>将安全时间从领导者传播到追随者以供追随者端读取</strong></h5>
<p>AiSQL 支持从追随者读取，以满足需要极低读取延迟的用例，而这种延迟只能通过在最靠近客户端的数据中心提供读取请求来实现。 这是以可能稍微陈旧的结果为代价的，这是您必须做出的权衡。 与强一致的领导者端读取类似，追随者端读取操作也必须选择一个安全的读取时间戳。</p>
<p>如前所述，“安全读取时间”意味着未来的写入不应更改截至读取时间戳的数据视图。 然而，只有领导者才能使用前面描述的算法计算安全读取时间。 因此，最新的安全时间通过 AppendEntries RPC 从领导者传播到追随者。 例如，由分区追随者处理的追随者端读取将看到数据的冻结快照，包括指定 TTL 且未超时的值。 当分区修复后，追随者开始接收来自领导者的更新，并可以返回非常接近最新的读取结果。</p>
<h4 id="_32"><strong>分布式事务</strong></h4>
<p>AiSQL 支持基于原子性、一致性、隔离性、持久性 (ACID) 原则的分布式事务，可修改多个分片中的多行。 这可以在 BCQL 和 BSQL 上下文中实现强一致的二级索引以及多表和多行 ACID 操作。</p>
<p>熟悉了上述概念后，请参阅事务I/O路径来大致了解分布式事务的生命周期。</p>
<h5 id="provisional-records"><strong>临时记录Provisional records</strong></h5>
<p>正如 AiSQL 将单分片 ACID 事务写入的值存储到 CoreDB 中一样，它需要将分布式事务写入的未提交的值存储在类似的持久数据结构中。 如果按照之前的常规值写入 CoreDB，会造成客户端通过不同的Tile服务器，在不同的时间点看到本不应该看到的、部分事务完成的数据，从而破坏原子性。 因此，AiSQL 将临时记录写入这样的Tile：这个Tile存放当前事务尝试修改的key（也即Tile Leader）。 这些事务被称为临时记录，而不是常规（永久）记录，因为在事务提交之前它们对读者来说是不可见的。</p>
<p>临时记录存储在同一 Tablet Peer 中的单独 RocksDB 实例中。 与其他可能的设计选项（例如将临时记录与常规记录内联存储，或者将它们与常规记录一起放在同一个 RocksDB 实例中）相比，所选择的方法具有以下优点：</p>
<ul>
<li>扫描所有临时记录非常简单，这有助于清理中止或放弃的事务。</li>
<li>在读取路径期间，需要以与常规记录非常不同的方式处理临时记录，并将它们放在 RocksDB 键空间的单独部分中可以简化读取路径。</li>
<li>将临时记录存储在单独的 RocksDB 实例中允许每个实例具有不同的存储、压缩和刷新策略。</li>
</ul>
<p><strong>临时记录的编码详细信息</strong>
临时记录对应的 RocksDB 键值对共有三种类型，省略了将这些记录放在 RocksDB 中所有常规记录之前的一字节前缀，如下图所示：</p>
<p><img alt="" src="media/chapter9/16.png" /></p>
<p><strong>1.主要临时记录Primary provisional records</strong></p>
<div class="highlight"><pre><span></span><code>DocumentKey, SubKey1, ..., SubKeyN, LockType, ProvisionalRecordHybridTime -&gt; TxnId, Value
</code></pre></div>
<p>DocumentKey、SubKey1、...、SubKey 组件与 CoreDB 对特定子文档（例如，行、列或集合类型列中的元素）的路径编码中的组件与 RocksDB 键完全匹配。</p>
<p>这些主要临时记录中的每一个也充当持久性可撤销锁。 与每个Tile的锁管理器维护的阻塞内存锁相比，存在一些相似之处和差异。 这些持久锁可以是与内存中仅领导者锁相同的任何类型（SI 写入、可串行化写入和读取，以及用于处理嵌套文档更改的单独的强和弱分类）。 然而，与领导者端内存锁不同，临时记录代表的锁可以被另一个冲突事务撤销。 冲突解决子系统确保对于任何两个冲突事务，至少其中一个被中止。</p>
<p>例如，假设快照隔离事务将行 row1 中的列 col1 设置为 value1。 那么DocumentKey就是row1，SubKey1就是col1。 假设临时记录以混合时间戳1516847525206000写入tablet，事务ID为7c98406e-2373-499d-88c2-25d72a4a178c。 RocksDB 中会有以下临时记录值：</p>
<div class="highlight"><pre><span></span><code>row1, WeakSIWrite, 1516847525206000 -&gt; 7c98406e-2373-499d-88c2-25d72a4a178c
row1, col1, StrongSIWrite, 1516847525206000 -&gt; 7c98406e-2373-499d-88c2-25d72a4a178c, value1
</code></pre></div>
<p>WeakSIWrite 锁类型用于行（正在写入的列的父级），而 StrongSIWrite 锁类型用于列本身。 该列的临时记录也是存储事务写入的列值的位置。</p>
<p><strong>2.事务元数据记录</strong></p>
<div class="highlight"><pre><span></span><code>TxnId -&gt; StatusTabletId, IsolationLevel, Priority
</code></pre></div>
<ul>
<li>StatusTabletId：是跟踪此事务状态的Tile的 ID。 与保存用户数据的表和Tile的情况不同（从键到Tile使用基于哈希的映射），没有确定的方法通过事务 ID 计算事务状态Tile  ID，因此必须将此信息显式传递给所有处理特定事务的组件。</li>
<li>隔离级别：快照隔离或可串行化隔离。</li>
<li>优先级：当使用 Fail-on-Conflict 并发控制策略时，此优先级是在事务创建期间随机分配的。</li>
</ul>
<p><strong>3.按事务 ID 索引的临时记录键</strong></p>
<div class="highlight"><pre><span></span><code>TxnId, HybridTime -&gt; primary provisional record key
</code></pre></div>
<p>此映射可以查找属于特定事务的所有临时 RocksDB 记录。 这在清理已提交或中止的事务时使用。 请注意，由于可以为具有相同混合时间戳的同一事务写入属于主临时记录的多个 RocksDB 键值对，因此在混合时间的编码表示的末尾使用递增计数器（称为写入 ID），以便 获取此反向索引的唯一 RocksDB 键。 此写入 ID 在临时记录的编码详细信息中的图中所示的 T130.0、T130.1 中显示为 .0、.1 等。</p>
<h5 id="transaction-status-tracking"><strong>交易状态追踪Transaction status tracking</strong></h5>
<p>原子性意味着事务写入的所有值要么都是可见的，要么都是不可见的。 AiSQL 已经通过 Raft 复制单分片更新并将其作为一批写入应用到底层 CoreDB 存储引擎，从而提供了单分片更新的原子性。 可以重复使用相同的方法来使事务状态更改原子化。 事务的状态在所谓的事务状态表中进行跟踪。 该表实际上只是系统中的另一个分片表，尽管它不使用 RocksDB，而是将所有数据存储在内存中，并由 Raft WAL 支持。 事务ID（全局唯一ID）作为表中的键，更新事务状态是基本的单分片ACID操作。 通过将表中该事务的状态记录的状态设置为已提交，作为该事务的一部分写入的所有值都将变得原子可见。</p>
<p>交易状态记录包含特定交易 ID 的以下字段：</p>
<p><strong>状态</strong>：待处理、已提交或中止。 所有事务一开始都处于待处理状态，然后进展到已提交或中止状态，在这种状态下它们将永久保留，直到被清理。</p>
<p>提交事务后，将设置以下两个字段：
<strong>提交混合时间戳</strong>。 在将事务提交条目附加到其 Raft 日志时，选择该时间戳作为事务状态表的当前混合时间。 然后，它用作常规记录的最终 MVCC 时间戳，在应用和清理临时记录时替换事务的临时记录。
<strong>参与的Tile的 ID 列表</strong>。 事务提交后，事务写入的最终一组Tile就已知。 管理事务的tablet 服务器将此列表作为提交消息的一部分发送到事务状态tablet，并且事务状态tablet 确保向所有参与的tablet 通知事务的已提交状态。 此过程可能需要多次重试，并且只有重试完成后才能清除事务记录。</p>
<h5 id="_33"><strong>故障的影响</strong></h5>
<p>临时记录被写入负责在事务中修改key的所有Tile副本。 当拥有已接收或即将接收临时记录的tablet的节点发生故障时，将在几秒（~2s）内为该tablet选举一个新的leader，如Leader Failure中所述。 查询层等待领导者选举发生，然后事务与新当选的领导者进一步进行。 在这种情况下，完成事务所需的时间会随着领导者选举所需的时间而增加。</p>
<p>事务管理器（通常是客户端连接的节点）将心跳发送到维护事务信息的事务状态Tile。 当管理器发生故障时，这些心跳会停止，临时记录会在一定时间后过期。 此时，状态Tile会自动取消该事务，因此相关的临时记录将不再阻止等待相同键的冲突事务。 连接到失败管理器的客户端会收到类似于以下内容的错误消息：</p>
<div class="highlight"><pre><span></span><code>FATAL:  57P01: terminating connection due to unexpected postmaster exit
FATAL:  XX000: Network error: recvmsg error: Connection refused
</code></pre></div>
<p>由于客户端不知道事务 ID，因为客户端到事务 ID 的映射无法重新生成，因此客户端有责任重新启动事务。 其他有事务被失败的管理器写入的临时记录阻塞的客户端将不得不等待事务由于心跳超时而过期，然后才能正常进行。</p>
<h4 id="io_2"><strong>事务I/O路径</strong></h4>
<p>有关 AiSQL 分布式事务实现中使用的常见概念的概述，请参阅分布式事务。</p>
<p>事务的写入路径用于修改多个键，读取路径用于从多个Tile读取一致的值组合。</p>
<h5 id="_34"><strong>写入路径</strong></h5>
<p>写入路径可以通过单个分布式只写事务的生命周期来演示。 假设需要修改键为k1和k2的行。 如果它们属于同一片，则事务可以作为单分片事务执行，在这种情况下，两个更新将作为同一 Raft 日志记录的一部分进行复制，从而确保原子性。 然而，在最一般的情况下，这些键将属于不同的Tile，这是工作假设。</p>
<p>下图描述了分布式只写事务的高级步骤，不包括任何冲突解决：</p>
<p><img alt="" src="media/chapter9/17.png" /></p>
<p><strong>1.客户请求事务</strong>
客户端向 AiSQL Tablet 服务器发送请求，需要分布式事务。 以下示例使用 CQL 的扩展：</p>
<div class="highlight"><pre><span></span><code>START TRANSACTION;
UPDATE t1 SET v = &#39;v1&#39; WHERE k = &#39;k1&#39;;
UPDATE t2 SET v = &#39;v2&#39; WHERE k = &#39;k2&#39;;
COMMIT;
</code></pre></div>
<p>接收事务写入请求的tablet 服务器负责驱动该事务中涉及的所有步骤。 事务步骤的编排由称为事务管理器的组件执行。 每笔交易都由一个事务管理器处理。</p>
<p><strong>2.创建事务记录</strong>
分配事务 ID 并选择事务状态Tile来跟踪具有以下字段的事务状态记录：</p>
<ul>
<li>状态可以是待处理、已提交或中止。</li>
<li>提交混合时间戳（如果已提交）。</li>
<li>参与Tile的 ID 列表（如果已提交）。
  选择事务状态tablet的方式是有意义的，这样事务管理器的tablet服务器也是其Raft组的领导者，因为这可以减少查询和更新事务状态时的RPC延迟。 但在最一般的情况下，事务状态Tile可能不会托管在启动事务的同一Tile服务器上。</li>
</ul>
<p><strong>3.写入临时记录</strong>
临时记录被写入包含需要修改的行的Tile。 这些临时记录包含事务ID、需要写入的值以及临时混合时间戳，该临时混合时间戳不是最终提交时间戳，并且通常对于同一事务内的不同临时记录来说是不同的。 相比之下，整个事务只有一个提交混合时间戳。</p>
<p>在写入临时记录时，可能会遇到与其他事务的冲突。 在这种情况下，事务必须中止并重新启动。 这些重新启动对于客户端来说仍然是透明的，直到重试一定次数为止。</p>
<p><strong>4.提交事务</strong>
当事务管理器写入所有临时记录后，它通过向事务状态Tile发送 RPC 请求来提交事务。 仅当事务尚未因冲突而中止时，提交操作才能成功。 提交操作的原子性和持久性由事务状态tablet的Raft组保证。 一旦提交操作完成，所有临时记录立即对客户端可见。</p>
<p>事务管理器发送到状态tablet的提交请求包括参与事务的所有tablet的tablet ID列表。 此时，无法将新的Tile添加到该组中。 状态Tile需要此信息来协调清理参与Tile中的临时记录。</p>
<p><strong>5.将响应发送回客户端</strong>
YQL 引擎将响应发送回客户端。 如果任何客户端（相同或不同）发送对已写入键的读取请求，则新值一定会反映在响应中，因为事务已提交。 数据库的这一属性有时称为“读取您自己的写入”保证。</p>
<p><strong>6.异步应用和清理临时记录</strong>
在收到事务的提交消息并成功将事务状态的更改复制到 Raft 组中后，事务状态 Tablet 会协调此步骤。 事务状态Tile已经知道哪些Til正在参与此事务，因此它会向它们发送清理请求。 每个参与的tablet都会在其Raft日志中记录一个特殊的“apply”记录，其中包含事务ID和提交时间戳。 当该记录在参与的tablet中进行Raft复制时，tablet会删除属于该事务的临时记录，并将具有正确提交时间戳的常规记录写入其RocksDB数据库。 这些记录实际上与常规单行操作写入的记录没有区别。</p>
<p>一旦所有参与的Tile都成功处理了这些应用请求，状态Tile就可以删除事务状态记录，因为尚未清除临时记录的参与Tile的所有副本（例如，慢速追随者）将根据本地可用的信息来执行此操作。 状态记录的删除是通过将特殊的“applied everywhere”条目写入状态Tile的 Raft 日志来实现的。 在此之后不久，作为旧 Raft 日志常规垃圾收集的一部分，属于该事务的 Raft 日志条目将从状态表的 Raft 日志中清除。</p>
<h5 id="_35"><strong>读取路径</strong></h5>
<p>AiSQL 是一个多版本并发控制 (MVCC) 数据库，这意味着它在内部跟踪同一值的多个版本。 读操作不占用任何锁。 相反，它们依赖 MVCC 时间戳来读取数据的一致快照。 长时间运行的读取操作（无论是单分片还是跨分片）可以与修改同一键的写入操作同时进行。</p>
<p>如单行事务中所述，最新读取是从单个Tile（分片）执行的，键的最新值是 Raft 领导者已知的最后提交的 Raft 日志记录写入的值。 但是，为了从不同的Tile读取多个键，必须确保读取的值来自数据库的最新一致快照。 以下阐明了所选快照的这些属性：
<strong>一致性快照</strong>：快照必须完整地显示任何事务的记录，或者根本不显示它们。 它不能包含事务写入的一半值而忽略另一半。 通过在特定混合时间（ht_read）执行所有读取并忽略具有较晚混合时间的任何记录来确保快照一致性。
<strong>最近的快照</strong>：快照包含任何客户端可能已经看到的任何值，这意味着在启动此读取操作之前写入或读取的所有值。 这还包括客户端应用程序的其他组件可能已写入数据库或从数据库读取的所有先前写入的值。 执行当前读取的客户端可能依赖于结果集中这些值的存在，因为客户端应用程序的那些其他组件可能已通过异步通信通道将此数据传送到当前客户端。 为了保证快照是最近的，当确定选择的混合时间太早时，需要重新启动读操作，即有一些记录在读操作发起之前本来可以写入，但存在混合时间 晚于当前设置的 ht_read。</p>
<p>下图描述了该过程：</p>
<p><img alt="" src="media/chapter9/18.png" /></p>
<p><strong>1.处理客户端请求并初始化读事务</strong>
客户端对 BCQL、YEDIS 或 BSQL API 的请求到达 Tablet 服务器的 YQL 引擎。 YQL引擎检测到查询请求来自多个tablet的行并启动只读事务。 为该请求选择混合时间ht_read，该时间可以是YQL引擎的tablet服务器上的当前混合时间，也可以是所涉及的tablet之一上的安全时间。 后一种情况至少会减少该Tile的等待安全时间，因此性能更好。 通常，由于 AiSQL 负载平衡策略，接收请求的 YQL 引擎还托管请求正在读取的一些Tile，从而允许实现性能更高的第二个选项，而无需额外的 RPC 往返。</p>
<p>此外，还会选择一个名为 global_limit 的时间点，计算公式为：physical_time + max_clock_skew，这有助于确定在读取请求开始后是否明确写入了特定记录。 max_clock_skew 是不同 AiSQL 服务器之间时钟偏差的全局配置界限。</p>
<p><strong>2.在特定混合时间从所有Tile读取</strong>
YQL引擎向所有需要读取事务的tablet发送请求。 根据安全时间的定义，每个tablet等待ht_read成为安全读取时间，然后开始从其本地CoreDB执行其部分读取请求。</p>
<p>当tablet服务器看到具有混合时间ht_record的相关记录时，它会执行以下逻辑：</p>
<ul>
<li>如果 ht_record ≤ ht_read，则将该记录包含在结果中。</li>
<li>如果 ht_record &gt;define_future_ht，则从结果中排除该记录。 define_future_ht 表示混合时间，混合时间晚于该时间的记录肯定是在读取请求开始后写入的。 目前，define_future_ht 可以假设为 global_limit。</li>
<li>如果ht_read &lt; ht_record ≤define_future_ht，则不知道该记录是在读请求开始之前还是之后写入的。 但不能从结果中省略它，因为如果它实际上是在读取请求之前写入的，则可能会产生客户端观察到的不一致。 因此，整个读取操作必须使用 ht_read = ht_record 的更新值重新启动。</li>
</ul>
<p>为了防止这些读取重新启动的无限循环，依赖于Tile的混合时间值 local_limit 将返回到 YQL 引擎，计算为该Tile中的当前安全时间。 现在已知，在读取请求开始之前不可能写入混合时间晚于 local_limit 的任何记录（常规或临时）。 因此，如果在稍后尝试在同一事务中读取该tablet时观察到混合时间晚于local_limittablet的记录，则不必重新启动读取事务，并且在future上设置definitely_future_ht = min(global_limit, local_limit) 尝试。</p>
<p><strong>3.Tile查询事务状态</strong>
当每个参与的tablet从其本地CoreDB读取时，它可能会遇到尚不知道最终事务状态和提交时间的临时记录。 在这些情况下，它将向交易状态Tile发送事务状态请求。 如果提交了事务，则将其视为 CoreDB 已包含混合时间等于事务提交时间的永久记录。 临时记录的清理是独立且异步进行的。</p>
<p><strong>4.Tile应 YQL</strong>
每个Tile对 YQL 的响应包含以下信息：</p>
<ul>
<li>是否需要读取重启。</li>
<li>local_limit 用于限制此Tile引起的未来读取重新启动。</li>
<li>从此Tile读取的实际值。</li>
</ul>
<p><strong>5.YQL 将响应发送给客户端</strong>
一旦来自所有参与Tile的所有读取操作成功并且确定不需要重新启动读取事务，就会使用适当的有线协议将响应发送到客户端。</p>
<h3 id="coredb_1"><strong>CoreDB分片层</strong></h3>
<p>分布式SQL数据库需要自动拆分表中的数据并将其分布到节点上。 这称为数据分片，可以通过不同的策略来实现，每种策略都有自己的权衡。 AiSQL 的分片架构受到 Google Spanner 的启发。</p>
<p>数据分片通过水平分区数据来帮助实现可扩展性和地理分布。 SQL表根据特定的分片策略被分解为多组行。 这些行集合中的每一个都称为一个分片。 这些分片分布在无共享架构中的多个服务器节点（容器、虚拟机、裸机）上。 这可确保分片不会因单个节点上可用的计算、存储和网络资源而成为瓶颈。 高可用性是通过跨多个节点复制每个分片来实现的。 然而，应用程序将 SQL 表作为一个逻辑单元进行交互，并且与分片的物理位置无关。</p>
<p>CoreDB 本身支持范围和哈希分片。</p>
<h4 id="_36"><strong>哈希和范围分片</strong></h4>
<p>分片是将大表分解为更小的块（称为分片）的过程，这些块分布在多个服务器上。 分片也称为水平分区，分片本质上是一个水平数据分区，包含总数据集的子集，因此负责服务整体工作负载的一部分。 这个想法是将无法容纳在单个节点上的数据分布到数据库节点集群上。 水平和垂直之间的区别来自于数据库的传统表格视图。 数据库可以垂直拆分，其中不同的表列存储在单独的数据库中，也可以水平拆分，其中同一表的行存储在多个数据库节点中。</p>
<p>用户表由 CoreDB 作为多个分片隐式管理。 这些碎片称为Tile。 表中每一行的主键唯一地确定托管该行的tablet（也就是说，对于每个键，只有一个tablet拥有它），如下图所示：</p>
<p><img alt="" src="media/chapter9/19.png" /></p>
<p>AiSQL目前支持两种数据分片方式：哈希（也称为一致性哈希)分片和范围分片。</p>
<h5 id="_37"><strong>哈希分片</strong></h5>
<p>通过哈希分片，数据使用分片算法均匀且随机地分布在分片上。 表的每一行都被放入一个分片中，该分片是通过计算该行的分片列值的哈希值确定的，如下图所示：</p>
<p><img alt="" src="media/chapter9/20.png" /></p>
<p>哈希分片 AiSQL 表的哈希空间是从 0x0000 到 0xFFFF 的 2 字节范围。 因此，这样的表最多可以有 64K 个Tile。 即使对于非常大的数据集或集群大小，这在实践中也应该足够了。 例如，对于具有 16 个Tile的表，整个哈希空间 [0x0000 到 0xFFFF] 被分为 16 个子范围，每个Tile一个：[0x0000, 0x1000)、[0x1000, 0x2000)、...、[0xF000, 0xFFFF]。 通过将主键转换为内部键及其哈希值来处理读取和写入操作，并确定操作应路由到哪个Tile，如下图所示：</p>
<p><img alt="" src="media/chapter9/21.png" /></p>
<p>最终用户的插入、更新、更新插入是通过将主键序列化和散列成字节序列并确定它们所属的tablet来处理的。 假设用户尝试将具有值 v 的键 k 插入表 T 中。下图演示了如何确定拥有上一个表的键的Tile：</p>
<p><img alt="" src="media/chapter9/22.png" /></p>
<p><strong>1.示例</strong>
以下示例显示了使用哈希分片创建的 BSQL 表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE customers (
    customer_id bpchar NOT NULL,
    company_name character varying(40) NOT NULL,
    contact_name character varying(30),
    contact_title character varying(30),
    address character varying(60),
    city character varying(15),
    region character varying(15),
    postal_code character varying(10),
    country character varying(15),
    phone character varying(24),
    fax character varying(24),
    PRIMARY KEY (customer_id HASH)
);
</code></pre></div>
<p>以下示例显示了仅使用哈希分片创建的 BCQL 表（不需要用于设置哈希分片的显式语法）：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE items (
    supplier_id INT,
    item_id INT,
    supplier_name TEXT STATIC,
    item_name TEXT,
    PRIMARY KEY((supplier_id), item_id)
);
</code></pre></div>
<p><strong>2.优点</strong>
这种分片策略非常适合大规模可扩展的工作负载，因为它将数据均匀地分布在集群中的所有节点上，同时保留了向集群中添加节点的便利性。 算法哈希分片在跨节点分发数据方面也非常有效，但分发策略取决于节点数量。 通过一致的哈希分片，分片的数量远多于节点的数量，并且维护一个显式的映射表来跟踪分片到节点的分配。 添加新节点时，可以将现有节点中的分片子集有效地移至新节点，而无需重新分配大量数据。</p>
<p><strong>3.缺点</strong>
执行范围查询可能效率低下。 此类查询的示例是查找大于下限或小于上限的行（与点查找相反）。</p>
<h5 id="_38"><strong>范围分片</strong></h5>
<p>范围分片涉及将表的行拆分为连续的范围，这些范围遵循基于主键列值的表排序顺序。 范围分片的表通常从单个分片开始。 当数据插入到表中时，它会被动态地分割成多个分片，因为我们并不总是能够提前知道表中键的分布。 下图演示了范围分片背后的基本思想：</p>
<p><img alt="" src="media/chapter9/23.png" /></p>
<p><strong>1.示例</strong>
以下示例显示了使用范围分片创建的 BSQL 表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE order_details (
    order_id smallint NOT NULL,
    product_id smallint NOT NULL,
    unit_price real NOT NULL,
    quantity smallint NOT NULL,
    discount real NOT NULL,
    PRIMARY KEY (order_id ASC, product_id),
    FOREIGN KEY (product_id) REFERENCES products,
    FOREIGN KEY (order_id) REFERENCES orders
);
</code></pre></div>
<p>BCQL表不能通过范围分片创建。 它们只能通过哈希分片创建</p>
<p><strong>2.优点</strong>
范围分片允许通过主键值有效地查询一系列行。 此类查询的示例是查找位于下限和上限之间的所有键。</p>
<p><strong>3.缺点</strong>
在规模上，范围分片在实践中会导致许多问题，其中一些问题与线性哈希分片类似。</p>
<p>首先，当从单个分片开始时意味着只有一个节点正在处理所有用户查询。 这通常会导致数据库预热问题，即使集群中有多个节点，所有查询也都由单个节点处理。 用户必须等待足够的分割发生并且这些分片重新分配才能使用集群中的所有节点，从而在生产工作负载中产生问题。 在某些情况下，可以通过将表预先分割成多个分片来提前知道键的分布，从而缓解这种情况，但这在实践中很难。</p>
<p>其次，跨所有分片的全局排序键通常会产生热点，一些分片的活动明显多于其他分片，并且托管这些分片的节点相对于其他节点变得过载。 虽然通过主动负载平衡可以在一定程度上缓解热点问题，但这在实践中并不总是有效，因为当热点分片在节点之间重新分配时，工作负载可能会发生变化并引入新的热点。</p>
<h4 id="tile"><strong>Tile分裂</strong></h4>
<h5 id="_39"><strong>概述</strong></h5>
<p>Tile分割是通过在添加数据之前预分割表或在运行时更改Tile数量来对 Universe 中的数据进行重新分片。 目前，AiSQL universe中存在三种压片分裂机制。</p>
<p><strong>1.范围扫描</strong>
当需要扫描一定范围的数据时，数据按照自然排序顺序存储（也称为范围分片）。 在这种情况下，通常不可能提前预测良好的分割边界。 考虑以下示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE census_stats (
    age INTEGER,
    user_id INTEGER,
    ...
    );
</code></pre></div>
<p>在这个例子中，提前选择分割点是很困难的。 数据库无法推断表中年龄值的范围（通常在 1 到 100 范围内）。 并且表中行的分布（即为每个age值插入多少user_id行以进行均匀分布的数据分割）是无法预测的。</p>
<p><strong>2.低基数主键Low-cardinality primary keys</strong>
在主键或辅助索引基数较低的用例中，散列无效。 例如，如果主键或索引是性别列的表，只有两个值（男或女），则哈希分片不会有效。 然而，使用整个机器集群来最大化服务吞吐量非常重要。</p>
<p><strong>3.小表逐渐变成大表Small tables that become very large</strong>
有些表一开始就很小，只有几个分片。 如果这些表变得非常大，节点就会不断添加到 Universe 中。 有可能节点数量超过tablet数量。 为了有效地重新平衡集群，需要进行tablet分割。</p>
<h5 id="tile_1"><strong>Tile分裂的方法</strong></h5>
<p>CoreDB 允许使用以下三种机制通过拆分 Tablet 来重新分片：</p>
<ul>
<li>预分割tablet：在CoreDB中创建的所有表都可以在创建时分割成所需数量的tablet。</li>
<li>手动拆分tablet：运行中的集群中的tablet可以由您在运行时手动拆分。</li>
<li>自动tablet分割：正在运行的集群中的tablet会由数据库根据某种策略自动分割。</li>
</ul>
<p><strong>1.预裂片Presplitting tablets</strong>
在创建时，您可以将表预先拆分为所需数量的Tile。 AiSQL支持范围分片和散列分片BSQL表以及散列分片BCQL表的预分割片。 可以通过以下两种方式之一指定Tile的数量：</p>
<ul>
<li>
<p>Desired number of tablets, when the table is created with the desired number of tablets.</p>
</li>
<li>
<p>Desired number of tablets per node, when the total number of tablets the table is split into is computed as follows:</p>
</li>
</ul>
<p>num_tablets_in_table = num_tablets_per_node * num_nodes_at_table_creation_time</p>
<p>要将表预分割为所需数量的Tile，您需要每个Tile的开始键和结束键。 这使得哈希分片和范围分片表的预分割略有不同。</p>
<p><strong>（1）哈希分片表</strong>
由于哈希分片的工作原理是在主键列的全部或子集上应用哈希函数，因此哈希分片键的字节空间是提前已知的。 例如，如果您使用 2 字节哈希，则字节空间将为 [0x0000, 0xFFFF]，如下图所示：</p>
<p><img alt="" src="media/chapter9/24.png" /></p>
<p>在上图中，BSQL 表被分为 16 个分片。 这可以通过使用 SPLIT INTO 16 TABLETS 子句作为 CREATE TABLE 语句的一部分来实现，如下所示：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE customers (
    customer_id bpchar NOT NULL,
    company_name character varying(40) NOT NULL,
    contact_name character varying(30),
    contact_title character varying(30),
    address character varying(60),
    city character varying(15),
    region character varying(15),
    postal_code character varying(10),
    country character varying(15),
    phone character varying(24),
    fax character varying(24),
    PRIMARY KEY (customer_id HASH)
) SPLIT INTO 16 TABLETS;
</code></pre></div>
<p>有关相关 BSQL API 的信息，请参阅以下内容：</p>
<p>CREATE TABLE ... SPLIT INTO 和示例，Create a table specifying the number of tablets。
CREATE INDEX ... SPLIT INTO 和示例， Create an index specifying the number of tablets。
有关相关 BCQL API 的信息，请参阅以下内容：</p>
<p>CREATE TABLE ...WITH tablets和示例，Create a table specifying the number of tablets。</p>
<p><strong>（2）范围分片表</strong>
在范围分片的 BSQL 表中，每个片的开始键和结束键无法立即得知，因为这取决于列类型和预期用途。 例如，如果主键是百分比 NUMBER 列，其中值的范围在 [0, 100] 范围内，则对整个 NUMBER 空间进行预分割将不会有效。</p>
<p>因此，为了预分割范围分片表，您必须显式指定分割点，如下例所示：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE customers (
    customer_id bpchar NOT NULL,
    company_name character varying(40) NOT NULL,
    contact_name character varying(30),
    contact_title character varying(30),
    address character varying(60),
    city character varying(15),
    region character varying(15),
    postal_code character varying(10),
    country character varying(15),
    phone character varying(24),
    fax character varying(24),
    PRIMARY KEY (customer_id ASC)
) SPLIT AT VALUES ((1000), (2000), (3000), ... );
</code></pre></div>
<p>有关相关 BSQL API 的信息，请参阅 CREATE TABLE ... SPLIT AT VALUES 以与范围分片表一起使用</p>
<p><strong>2.手动Tile分割</strong>
假设有一个表，其中预先存在的数据分布在一定数量的Tile上。 可以手动拆分此表中的部分或全部Tile。</p>
<p>请注意，误用或过度使用手动Tile拆分（例如，拆分流量较少的Tile）可能会导致创建大量不同大小和流量速率的Tile。 这无法轻易解决，因为当前不支持Tile合并.</p>
<p><strong>（1）创建示例 BSQL 表</strong>
创建一个三节点本地集群，如下：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-dev-ctl --rf=3 create --bsql_num_shards_per_dbserver=1
</code></pre></div>
<p>创建一个示例表并插入一些数据，如下：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE t (k VARCHAR, v TEXT, PRIMARY KEY (k)) SPLIT INTO 1 TABLETS;
</code></pre></div>
<p>在此表中插入一些示例数据（100000 行），如下所示：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO t (k, v)
    SELECT i::text, left(md5(random()::text), 4)
    FROM generate_series(1, 100000)  s(i);
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT count(*) FROM t;
</code></pre></div>
<p>输出如下：</p>
<div class="highlight"><pre><span></span><code>count
--------
100000
(1 row)
</code></pre></div>
<p><strong>（2）验证表只有一个Tile</strong>
要验证表 t 是否只有一个tablet，请使用以下 bm-admin list_tablets 命令列出表 t 的所有tablet：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin --mserver_addresses 127.0.0.1:11000 list_tablets bsql.bigmath t
</code></pre></div>
<p>预期输出如下：</p>
<div class="highlight"><pre><span></span><code>Tablet UUID                       Range                         Leader
9991368c4b85456988303cd65a3c6503  key_start: &quot;&quot; key_end: &quot;&quot;     127.0.0.1:21000
</code></pre></div>
<p>记下Tile UUID 以供以后使用。</p>
<p><strong>（3）手动刷新tablet</strong>
Tile应该在磁盘上保留一些数据。 如果插入少量数据，它仍然只能存在于内存缓冲区中。 为了确保磁盘上存在 SST 数据文件，可以通过运行以下 dbserver-ctl 命令手动刷新该表的数据块：</p>
<div class="highlight"><pre><span></span><code>./bin/dbserver-ctl \
    --server_address=127.0.0.1:21000,127.0.0.2:21000,127.0.0.3:21000 \
    flush_tablet 9991368c4b85456988303cd65a3c6503
</code></pre></div>
<p><strong>（4）手动拆分Tile</strong>
该表的tablet可以通过运行以下bm-admin split_tablet命令手动拆分为两个tablet：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    --mserver_addresses 127.0.0.1:11000,127.0.0.2:11000,127.0.0.3:11000 \
    split_tablet 9991368c4b85456988303cd65a3c6503
</code></pre></div>
<p>拆分后，您预计会看到表 t 的两个Tile，如以下输出所示：</p>
<div class="highlight"><pre><span></span><code>Tablet UUID                       Range                                 Leader
20998f68c3fa4d299e8af7c04410e230  key_start: &quot;&quot; key_end: &quot;\177\377&quot;     127.0.0.1:21000
a89ecb84ad1b488b893b6e7762a6ca2a  key_start: &quot;\177\377&quot; key_end: &quot;&quot;     127.0.0.3:21000
</code></pre></div>
<p>原Tile 9991368c4b85456988303cd65a3c6503已不存在； 它已被两个新Tile取代。</p>
<p>Tile领导者现在分布在两个节点上，以便在集群的节点之间均匀平衡表的Tile。</p>
<p><strong>3.自动Tile分割</strong>
自动数据片分割可以在达到指定大小阈值时自动在线且透明地重新分片集群中的数据。</p>
<p>架构设计详情请参见Tablet拆分数据自动重新分片。</p>
<p><strong>（1）启用自动Tile分割</strong>
启用自动 Tablet 拆分后，新创建的哈希分片表默认每个节点有一个 Tablet。</p>
<p>另外，从2.14.10版本开始，对于2个CPU核心以下的服务器，新建表每个集群1个tablet，4个CPU核心以下的服务器每个集群2个tablet。</p>
<p>从版本 2.18.0 开始，默认打开自动平板分割。</p>
<p>要控制自动Tile分割，请使用 mserver --enable_automatic_tablet_splitting 标志并指定关联的标志来配置Tile何时应分割，并使用 dbserver --enable_automatic_tablet_splitting。 AiSQL 集群的所有 mserver 和 dbserver 配置上的标志必须匹配。</p>
<p>注：除非在表创建期间显式指定表分区，否则新创建的具有范围分片的表的每个集群始终有一个tablet。</p>
<p>自动数据片分割分三个阶段进行，具体取决于每个节点的分片数量。 随着分片数量的增加，分割tablet的阈值大小也会增加，如下：</p>
<p><strong>Low phase</strong>
在低阶段，每个节点的分片数少于tablet_split_low_phase_shard_count_per_node（默认为8）。 在此阶段，AiSQL 拆分大于tablet_split_low_phase_size_threshold_bytes（默认为512 MB）的tablet。</p>
<p>High phase
在高阶段，每个节点的分片数少于tablet_split_high_phase_shard_count_per_node（默认为24）。 在此阶段，AiSQL 拆分大于tablet_split_high_phase_size_threshold_bytes（默认为10 GB）的tablet。</p>
<p>Final phase
当分片数量超过高阶段数量（由tablet_split_high_phase_shard_count_per_node确定，默认为24）时，AiSQL会分割大于tablet_force_split_threshold_bytes（默认为100 GB）的片剂。 这将持续下去，直到达到每个表的tablet_split_limit_per_table 片数限制（默认为256 片；如果设置为0，则没有限制）。</p>
<p><strong>（2）分裂后压实</strong>
一旦在一个tablet上执行了分割，生成的两个tablet就需要完全压缩，以便从每个tablet中删除不必要的数据。 这些分割后压缩会显着增加 CPU 和磁盘使用率，从而影响性能。 为了限制影响，默认情况下允许的同时Tile分割数量是保守的。</p>
<p>如果由于自动数据片分割而导致性能受到影响，可以使用以下标志进行调整：
<strong>MServer 标志：</strong></p>
<ul>
<li>Outstanding_tablet_split_limit 默认将未完成的 Tablet 拆分总数限制为 1。 执行分割后压缩的Tile将计入此限制。</li>
<li>Outstanding_tablet_split_limit_per_dbserver 默认情况下将每个节点未完成的tablet split 总数限制为1。 执行分割后压缩的Tile将计入此限制。</li>
</ul>
<p><strong>bm-dbserver标志：</strong></p>
<ul>
<li>post_split_trigger_compaction_pool_max_threads 表示每个节点专用于分割后压缩任务的线程数。 默认情况下，此值限制为 1。增加此值可能会更快地完成数据块分割，但需要更多的 CPU 和磁盘资源。</li>
<li>post_split_trigger_compaction_pool_max_queue_size 表示每个节点可以同时排队的未完成的分割后压缩任务的数量，默认限制为 16。</li>
</ul>
<p>当启用自动tablet分割时，automatic_compaction_extra_priority为较小的压缩提供额外的压缩优先级。 这可以防止较小的压缩因较大的分割后压缩而缺乏资源。 默认情况下设置为 50（建议的最大值），并且可以减少到 0。</p>
<p><strong>（3）带有自动数据片分割的 YCSB 工作负载示例</strong>
在以下示例中，创建了一个三节点集群并使用 YCSB 工作负载来演示在 BSQL 数据库中使用自动 Tablet 拆分：
创建一个三节点集群，如下：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-dev-ctl --rf=3 create --mserver_flags &quot;enable_automatic_tablet_splitting=true,tablet_split_low_phase_size_threshold_bytes=30000000&quot; --dbserver_flags &quot;memstore_size_mb=10&quot;
</code></pre></div>
<p>创建工作负载表，如下：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -c &quot;CREATE DATABASE ycsb;&quot;

./bin/sqlsh -d ycsb -c &quot;CREATE TABLE usertable (
        YCSB_KEY TEXT,
        FIELD0 TEXT, FIELD1 TEXT, FIELD2 TEXT, FIELD3 TEXT,
        FIELD4 TEXT, FIELD5 TEXT, FIELD6 TEXT, FIELD7 TEXT,
        FIELD8 TEXT, FIELD9 TEXT,
        PRIMARY KEY (YCSB_KEY ASC));&quot;
</code></pre></div>
<p>在 ~/code/YCSB/db-local.properties 中创建 YCSB 的属性文件并添加以下内容：</p>
<div class="highlight"><pre><span></span><code>db.driver=org.postgresql.Driver
db.url=jdbc:postgresql://127.0.0.1:2521/ycsb;jdbc:postgresql://127.0.0.2:2521/ycsb;jdbc:postgresql://127.0.0.3:2521/ycsb
db.user=bigmath
db.passwd=
core_workload_insertion_retry_limit=10
</code></pre></div>
<p>开始为工作负载加载数据，如下所示：</p>
<div class="highlight"><pre><span></span><code>~/code/YCSB/bin/ycsb load jdbc -s -P ~/code/YCSB/db-local.properties -P ~/code/YCSB/workloads/workloada -p recordcount=500000 -p operationcount=1000000 -p threadcount=4
</code></pre></div>
<p>使用 AiSQL Web 界面（http://localhost:10000/tile-servers 和 http://127.0.0.1:20000/tablets）监控Tile拆分。</p>
<p>运行工作负载，如下所示：</p>
<div class="highlight"><pre><span></span><code>~/code/YCSB/bin/ycsb run jdbc -s -P ~/code/YCSB/db-local.properties -P ~/code/YCSB/workloads/workloada -p recordcount=500000 -p operationcount=1000000 -p threadcount=4
</code></pre></div>
<p>获取工作负载运行阶段访问的tablet列表，如下：</p>
<div class="highlight"><pre><span></span><code>diff -C1 after-load.json after-run.json | grep tablet_id | sort | uniq
</code></pre></div>
<p>可以将访问的Tile列表与 http://127.0.0.1:20000/tablets 进行比较，以确保没有访问任何预分割Tile。</p>
<h4 id="colocated-tables"><strong>Colocated tables</strong></h4>
<p>AiSQL 支持共址 SQL 表。 这允许共址表中密切相关的数据一起驻留在称为“共址Tile”的单个父Tile中。 共址可减少跨网络的额外行程，有助于优化低延迟、高性能数据访问。 它还减少了为每个关系（表、索引等）创建Tile的开销以及每个节点的存储量。</p>
<p>请注意，共址Tile中的所有数据仍然根据集群的复制因子跨节点复制。</p>
<h5 id="_40"><strong>共址的好处以及用例的注意事项</strong></h5>
<p>共址对于高性能、实时数据处理很有意义，其中低延迟和快速访问数据至关重要。共址具有以下优点：</p>
<ul>
<li>改进的性能和可扩展性：使用单个tablet而不是为每个关系创建一个tablet可以减少存储和计算开销。</li>
<li>更快地访问数据：通过将单个数据库中多个表的所有数据存储在单个tablet中，您可以避免节点间通信和数据转移的开销，从而更快地访问数据。 例如，当跨多个共址表的数据位于本地并且您不再需要通过网络读取数据时，联接速度会提高。</li>
</ul>
<p><strong>1.何时使用共址</strong>
使用共址集群的决定应基于您的用例的具体要求，包括预期的性能、数据大小、可用性和持久性要求。 以下场景可能会受益于共址：
<strong>（1）需要 HA 或地理分布的小型数据集</strong>
具有较小数据集的应用程序可能具有以下模式和要求：</p>
<ul>
<li>整个数据集的大小很小。 通常，整个数据库的大小小于 50 GB。</li>
<li>它们需要在单个数据库中创建大量表、索引和其他关系。</li>
<li>需要高可用性和/或地理数据分布。</li>
<li>扩展数据集或 IOPS 数量并不是迫在眉睫的问题。</li>
</ul>
<p>在这种情况下，不希望将小数据集分布在多个节点上，因为这可能会由于更多的网络跃点（例如，联接）而影响某些查询的性能。</p>
<p><strong>（2）大型数据集 - 一些大表和许多小表</strong>
具有大型数据集的应用程序可能具有以下特征：</p>
<ul>
<li>大量的表和索引。</li>
<li>少数表预计会变大，因此需要进行扩展。</li>
<li>其余的表仍然很小。</li>
</ul>
<p>这里只需要对少数大表进行分片和扩容。 所有其他表都受益于共址，因为涉及这些表的查询不需要网络跃点。</p>
<p><strong>（3）扩展数据库数量，每个数据库都有一个小数据集</strong>
在某些场景下，集群中的数据库数量快速增长，而每个数据库的规模却很小。 这是面向微服务的架构的特征，其中每个微服务都需要自己的数据库。 一个例子是多租户 SaaS 服务，其中为每个客户创建一个数据库。 最终结果是出现大量小型数据库，并且需要扩展托管数据库的数量。 共址表允许将每个数据库中的整个数据集托管在一个Tile中，从而通过添加更多节点来实现集群中数据库数量的可扩展性。</p>
<p>将所有数据集中在一个Tile中需要一些权衡。 它可能会导致资源利用方面的潜在瓶颈。 最终，数据集的大小只是确定共址数据库是否适合您的用例时需要考虑的因素之一。</p>
<h5 id="_41"><strong>启用共址</strong></h5>
<p>可以在集群、数据库或表级别启用共址。 对于共址集群，默认情况下，集群中创建的所有数据库都将启用共址。 您还可以选择将单个数据库配置为共址，以确保数据库表中的所有数据都存储在节点上的单个共址Tile上。 当进行实时数据处理或查询大量数据时，这尤其有用。</p>
<p><strong>1.集群</strong>
要为集群中的所有数据库启用共址，请在创建集群时将 MServer 和 DBServer 服务的以下标志设置为 true，如下所示：</p>
<div class="highlight"><pre><span></span><code>bsql_colocate_database_by_default = true
</code></pre></div>
<p>您也可以在创建集群后设置此标志，但需要重新启动 MServer 和 DBServer。</p>
<p>注意：对于 AiSQL Managed，您当前无法启用集群共址。 可为单个数据库启用共址。</p>
<p><strong>2.数据库</strong>
您可以在非共址集群中创建共址数据库。 默认情况下，在此数据库中创建的表是共址的。 也就是说，数据库中的所有表共享一个tablet。 要启用此功能，请在创建数据库时运行以下命令：</p>
<div class="highlight"><pre><span></span><code>CREATE DATABASE &lt;name&gt; with COLOCATION = true
</code></pre></div>
<p>对于支持共址的集群，您可以使用以下语法选择将特定数据库从共址中选择出来，设置不共址：</p>
<div class="highlight"><pre><span></span><code>CREATE DATABASE &lt;name&gt; with COLOCATION = false
</code></pre></div>
<p><strong>3.表</strong>
默认情况下，共址数据库中的所有表都是共址的。 创建表时无需启用共址。 您可以选择将特定表从共址数据库中的共址中选择出来，设置为不共址。 为此，请使用以下命令：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE &lt;name&gt; (columns) WITH (COLOCATION = false);
</code></pre></div>
<p>请注意，您无法在非共址数据库中创建共址表。</p>
<p><strong>更改表共址</strong>
要从共址中删除单个表（例如，如果它增加超过特定大小），您可以使用 CREATE TABLE AS SELECT 创建表的副本，并将共置设置为 false。 请执行下列操作：
（1）重命名您的共址表以确保不会有进一步的更改修改该表或其内容。
（2）使用 CREATE TABLE AS SELECT 从原始共址表创建新的非共址表。 您可以选择使用与原始表相同的名称。
（3）可选，在确认对新的非共址表进行读取和写入后，删除原始共址表。</p>
<p>您可以使用相同的过程将非共址表添加到共址数据库中的共址。</p>
<p>注：更改表共址需要在创建新表期间需要一些停机时间。 此过程所需的时间取决于共址更改的表的大小。</p>
<h5 id="_42"><strong>指标和视图</strong></h5>
<p>要查看表大小等指标，请使用父共址表的名称。 共址表名称的格式为 <colocation table object ID>.colocation.parent.tablename。 共址中的所有表共享相同的指标值，这些值显示在每个指标的共址表下。 表和Tile指标可在 DBServer 端点 (<node-ip>:20000) 以及 AiSQL Anywhere 中每个 Universe 的“指标”部分中获得。</p>
<h5 id="_43"><strong>限制和注意事项</strong></h5>
<p>不允许使用表空间创建共址表。 这将在未来的版本中得到支持。
表指标的指标（例如表大小）可用于共址Tile，而不适用于作为共址一部分的单个共址表。
对于共址表禁用Tile拆分。
您无法使用 2.18.0 版本中的 AiSQL Anywhere UI 为共址表配置 xDCR 复制。 此功能将在未来版本中提供。</p>
<p><strong>共址表和非共址表之间的语义差异</strong>
同一共址数据库中不同表上的并发 DML 和 DDL， 将中止 DML。 对于分布式、非共址表来说，情况并非如此。 对于共址表，如果另一个会话持有表上的行级锁，则 TRUNCATE / DROP 操作可能会因冲突而中止。</p>
<h5 id="xdcr"><strong>xDCR和共址</strong></h5>
<p>v2.18.0 中的共址表仅通过 bm-admin 支持 xDCR。 要为共址表设置 xDCR，给定表的共址 ID 需要在源 Universe 和目标 Universe 上匹配。</p>
<p>要为共址表设置 xDCR，请执行以下操作：</p>
<p>1.使用显式指定的共址 ID 在源 Universe 上的共址数据库中创建表。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE &lt;name&gt; WITH (COLOCATION = true, COLOCATION_ID = 20000)
</code></pre></div>
<p>2.使用相同的共址 ID 在目标 Universe 上的共址数据库中创建表。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE &lt;name&gt; WITH (COLOCATION = true, COLOCATION_ID = 20000)
</code></pre></div>
<p>3.获取共址数据库的父表 UUID。</p>
<div class="highlight"><pre><span></span><code>./bm-admin -mserver_addresses &lt;source_mserver_addresses&gt; list_tables include_table_id | grep -i &lt;database_name&gt; | grep -i &quot;colocation.parent.uuid&quot;
</code></pre></div>
<div class="highlight"><pre><span></span><code>col_db.00004000000030008000000000004004.colocation.parent.tablename 00004000000030008000000000004004.colocation.parent.uuid
</code></pre></div>
<p>4.使用 bm-admin 为父共址表设置复制。</p>
<div class="highlight"><pre><span></span><code>./bm-admin -mserver_addresses &lt;target_mserver_addresses&gt; setup_universe_replication &lt;replication_group_name&gt; &lt;source_mserver_addresses&gt; &lt;parent_colocated_table_uuid&gt;
</code></pre></div>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>./bm-admin -mserver_addresses 127.0.0.2 setup_universe_replication A1-B2 127.0.0.1 00004000000030008000000000004004.colocation.parent.uuid
</code></pre></div>
<div class="highlight"><pre><span></span><code>Replication setup successfully
</code></pre></div>
<p>如果将新的共址表添加到具有匹配共址 ID 的源和目标 Universe 上的同一共址数据库中，则它们会自动包含在复制中。</p>
<p>有关如何为非共址表设置 xDCR 的信息，请参阅 xDCR 部署。</p>
<h3 id="coredb_2"><strong>CoreDB复制层</strong></h3>
<p>本节介绍复制在 CoreDB 中的工作原理。 CoreDB 表中的数据被拆分为多个Tile。 默认情况下，每个Tile都会使用 Raft 算法在各个节点或故障域（例如可用区/机架/区域/云提供商）之间进行同步复制。</p>
<p>AiSQL 还提供其他高级复制功能。 其中包括两种形式的异步数据复制：</p>
<ul>
<li>xDCR：数据在不同的 AiSQL Universe 之间异步复制，跨两个 Universe 的单向复制（主从）或双向复制。</li>
<li>只读副本：universe中的异步副本称为只读副本。</li>
</ul>
<p>AiSQL同步复制架构的灵感来自于Google Spanner。</p>
<p>AiSQL xDCR 复制架构的灵感来自于 Oracle、MySQL 和 PostgreSQL 等 RDBMS 数据库。</p>
<h4 id="_44"><strong>同步</strong></h4>
<p>使用Raft分布式共识协议，CoreDB自动在主集群上同步复制数据，以便在发生故障时保持数据一致性并避免操作员干预。</p>
<h5 id="_45"><strong>概念</strong></h5>
<p>许多概念是复制的核心。</p>
<p><strong>1.故障域</strong>
故障域由一组容易出现相关故障的节点组成。 以下是故障域的示例：</p>
<ul>
<li>可用区或机架Zones or racks</li>
<li>区域或数据中心Regions or datacenters</li>
<li>云提供商</li>
</ul>
<p>数据通常跨故障域复制，以便能够应对一个故障域中所有节点的中断。</p>
<p><strong>2.容错能力</strong>
AiSQL Universe 的容错性 (FT) 是指它在继续保持数据正确性的同时能够承受的最大节点故障数。</p>
<p><strong>3.复制因子</strong>
AiSQL 跨节点（或故障域）复制数据以容忍故障。 复制因子 (RF) 是 AiSQL Universe 中数据的副本数量。 FT 和 RF 是相关的。 为了实现 k 个节点的 FT，universe必须配置为 (2k + 1) 的 RF。</p>
<h5 id="tilepeers"><strong>Tile对等体peers</strong></h5>
<p>CoreDB 中的数据复制是在Tile级别上实现的，使用Tile对等体，每个表分片为一组Tile，如下图所示：</p>
<p><img alt="" src="media/chapter9/25.png" /></p>
<p>每个tablet由一组tablet对等体组成，每个tablet都存储属于该tablet的数据的一个副本。 一个Tile有与复制因子一样多的Tile对等体，它们形成一个 Raft 组。 Tile对等点托管在不同的节点上，以允许数据冗余以防止节点故障。 Tile对等体之间的数据复制是高度一致的。</p>
<p>下图描述了属于名为tablet 1的tablet的三个tablet对等点。tablet对等点托管在不同的DBServer上，并形成一个Raft组，用于领导者选举、故障检测和预写日志的复制。</p>
<p><img alt="" src="media/chapter9/26.png" /></p>
<p><strong>Raft复制</strong>
一旦Tile启动，它就会使用 Raft 协议选举其中一个Tile作为Tile领导者。 Tablet Leader 负责通过将用户发出的写入转换为 CoreDB 的文档存储层来处理面向用户的写入请求。 此外，Tile领导者使用Raft在Tile同行之间进行复制，以实现强一致性。 除了tablet领导者之外，Raft组中剩余的tablet对等体被称为tablet追随者。</p>
<p>CoreDB 更新集取决于用户发出的写入，并且涉及锁定一组键以建立严格的更新顺序，并可选择读取旧值以在读取-修改-写入操作的情况下进行修改和更新。 Raft 日志用于确保Tile的数据库状态机在Tile对等体之间进行复制，即使在出现故障或成员资格更改的情况下，也能保证严格的排序和正确性。 这对于实现强一致性至关重要。</p>
<p>当Raft日志被复制到大多数tablet-peers并在大多数上成功持久化后，写入将被应用到CoreDB文档存储层，随后可供读取。 当写入被文档存储层持久化到磁盘上后，可以从 Raft 日志中清除写入条目。 这是作为受控后台操作执行的，不会对前台操作产生任何影响。</p>
<h5 id="_46"><strong>主集群中的复制</strong></h5>
<p>数据副本可以跨多个故障域放置。 以下具有三个可用区（zone）且复制因子假设为 3 的多可用区（zone）部署示例演示了如何在集群中执行跨故障域的复制。</p>
<p><strong>1.多可用区部署</strong>
在多可用区部署的情况下，节点中每个Tile中的数据使用 Raft 共识算法跨多个可用区进行复制。 属于给定tablet的行的所有读取和写入查询均由该tablet的领导者处理，如下图所示：</p>
<p><img alt="" src="media/chapter9/27.png" /></p>
<p>作为Raft复制的一部分，每个tablet对等体首先选举一个tablet领导者负责服务读取和写入。 不同Zone之间的Tablet Leader的分布是由用户指定的数据放置策略决定的，在前面的场景中，该策略确保在稳定状态下，每个Zone拥有相同数量的Tablet Leader。 下图显示了Tile领导者的分散情况：</p>
<p><img alt="" src="media/chapter9/28.png" /></p>
<p>2.容忍（一个）可用区中断
一旦发生区域中断，AiSQL 就会假设该区域中的所有节点同时变得不可用。 这导致三分之一的Tile（其Tile领导者位于刚刚发生故障的区域）无法满足任何请求。 另外三分之二的Tile不受影响。 对于受影响的三分之一，AiSQL 自动执行故障转移到其他两个区域中的实例。 再次，进行故障转移的Tile均匀分布在剩余的两个区域中，如下图所示：</p>
<p><img alt="" src="media/chapter9/29.png" /></p>
<p>追随者失败不会影响读写。 只有Tile领导者提供读取和写入服务。</p>
<p>3.可用区中断时的 RPO 和 RTO
每个Tile的恢复点目标 (RPO) 均为 0，这意味着在故障转移到另一个区域时不会丢失任何数据。 恢复时间目标 (RTO) 为 3 秒，这是完成故障转移并在新区域之外运行的时间窗口，如下图所示：</p>
<p><img alt="" src="media/chapter9/30.png" /></p>
<h5 id="_47"><strong>追随者阅读</strong></h5>
<p>只有Tile领导者可以处理面向用户的写入和读取请求。 请注意，虽然这是强一致性读取的情况，但 AiSQL 提供了具有宽松保证的追随者读取，这在某些部署模型中是需要的。 所有其他Tile对等点都称为追随者，仅复制数据。 它们可用作热备用，可以在领导者发生故障时快速接管。</p>
<h4 id="xdcr_1"><strong>xDCR</strong></h4>
<p>独立 AiSQL Universe 之间的异步复制.</p>
<h5 id="_48"><strong>同步复制与异步复制</strong></h5>
<p>AiSQL的同步复制可用于容忍丢失整个数据中心或区域。 它在分布于多个（三个或更多）数据中心的单一universe中复制数据，因此一个数据中心的丢失不会影响 Raft 共识算法的可用性、持久性或强一致性。</p>
<p>然而，以这种方式使用同步复制有两个重要的缺点：</p>
<ul>
<li>
<p>高写入延迟：每次写入必须在至少两个数据中心之间达成共识，这意味着数据中心之间至少有一次往返。 这可能会在多区域部署中增加数十甚至数百毫秒的额外延迟。</p>
</li>
<li>
<p>需要至少三个数据中心：由于共识需要奇数个故障域，因此必须使用至少三个数据中心，这会增加运营成本。</p>
</li>
</ul>
<p>作为替代方案，AiSQL 提供异步复制，可在两个或多个单独的 Universe 之间复制数据。 它没有同步复制的缺点：因为它是在后台完成的，所以不会影响写入延迟，并且因为它不使用共识，所以不需要第三个数据中心。</p>
<p>然而，异步复制也有其自身的缺点，包括：</p>
<ul>
<li>故障时数据丢失：当Universe发生故障时，其中尚未复制的数据将丢失。 丢失的数据量取决于复制延迟，通常为亚秒级。</li>
<li>事务性的限制：由于universe中的事务无法相互协调，因此要么必须限制事务的类型，要么必须失去某些一致性和隔离性。</li>
</ul>
<h5 id="aisql-xdcr"><strong>AiSQL 的 xDCR 复制</strong></h5>
<p>xDCR复制是AiSQL为灾难恢复而实现的异步复制。 它允许您在 Universe 之间设置一个或多个单向复制流。 请注意，xDCR 只能用于在两个不同 Universe 中的主集群之间进行复制； 它不能用于在同一universe中的集群之间进行复制。 （有关universe和cluster之间区别的更多信息，请参阅universe与cluster）</p>
<p>对于每个流，数据从源（也称为生产者）Universe 复制到目标（也称为消费者）Universe。 复制是在 CoreDB 级别完成的，源 Universe 中新提交的写入会异步复制到目标 Universe。 BSQL 和 BCQL 均受支持。</p>
<p>可以使用多个流； 例如，两个Universe之间的两个单向流（每个方向一个）会产生双向复制，其中在一个Universe中写入的任何内容都将复制到另一个Universe - 数据仅异步复制一次以避免无限循环。 </p>
<p>尽管为了简单起见，我们将描述整个 Universe 之间的流，但流实际上由一对表之间的流组成，每个 Universe 中有一个，仅允许复制某些命名空间或表。</p>
<p>xDCR 比假设的方案更灵活，当主副本丢失时，只读副本将提升为完整副本，因为它不需要两个 Universe 紧密耦合。 例如，使用xDCR，同一个表可以在两个universe中以不同的方式拆分为Tile。 xDCR 还允许双向复制，这是使用只读副本无法实现的，因为只读副本无法进行写入。</p>
<h5 id="_49"><strong>异步复制模式</strong></h5>
<p>因为在丢失多少一致性和允许哪些事务之间存在有用的权衡，所以 AiSQL 提供了两种不同的异步复制模式：</p>
<ul>
<li>非事务复制：允许所有事务，但会丢失一些一致性</li>
<li>事务复制：保留一致性，但目标universe事务必须是只读的</li>
</ul>
<p><strong>1.非事务性复制</strong>
在这里，每个事务在源 Universe 中提交后，其写入都会独立复制到目标 Universe，并在目标 Universe 中应用与源 Universe 上相同的时间戳。 目标端不会采取或兑现任何锁定。</p>
<p>请注意，就目标universe而言，写入通常是在过去写入的。 这违反了 AiSQL 提供一致读取的先决条件（请参阅有关安全时间戳的讨论）。 因此，对目标universe的读取不再是强一致的，而是最终一致的。</p>
<p>如果目标 Universe 和源 Universe 都写入相同的键，则最后一个写入者获胜。 决定因素是每个universe更新的底层混合时间。</p>
<p>由于复制滞后，在源 Universe 上完成写入后立即在目标 Universe 中完成的读取可能看不到该写入。 另一种说法是，目标 Universe 中的读取不会等待源 Universe 中的最新数据变得可见</p>
<p><strong>影响事务的不一致</strong>
由于写入是独立复制的，因此随着时间的推移，来自源 Universe 的事务变得可见。 这意味着目标 Universe 中的事务可以看到非重复读取和幻像读取，无论其声明的隔离级别是什么。 实际上，目标 Universe 上的所有事务都处于 SQL-92 隔离级别 READ COMMITTED，这仅保证事务永远不会读取未提交的数据。 与正常的 AiSQL READ COMMITTED 级别不同，这并不能保证语句将看到一致的快照或在该语句发出之前已提交的所有数据。</p>
<p>如果源 Universe 死亡，则目标 Universe 可能会处于不一致状态，其中某些源 Universe 事务仅将部分写入应用于目标 Universe（这些称为撕裂事务）。 这种不一致不会随着时间的推移自动修复，可能需要手动解决。</p>
<p>请注意，这些不一致仅限于从源 Universe 写入和复制的表/行：任何不与此类行交互的目标事务都不会受到影响。</p>
<p><strong>2.事务复制</strong>
这种模式是前一种模式的延伸。 为了恢复一致性，我们还禁止对目标 Universe 进行写入，并导致读取时间距过去足够远的时间（通常为 250 毫秒），使得来自源 Universe 的所有相关数据都已被复制。</p>
<p>特别是，我们选择从 T 开始读取的时间，以便来自将在时间 T 或之前提交的所有源事务的所有写入都已复制到目标 Universe。 换句话说，我们在过去足够远的时间读到，在该时间或之前不可能有新的传入源提交。 这将恢复一致的读取并确保源 Universe 事务结果以原子方式可见。 请注意，我们不会等待任何当前正在进行的源universe事务。</p>
<p>为了知道何时读取，我们维护了一个名为 xDCR 安全时间的安全时间模拟，它是 xDCR 事务复制当前安全读取的最新时间，以保证一致性和原子性。 xDCR 安全时间随着复制的进行而提前，但由于当前的复制滞后而落后于实时时间。 这意味着，例如，如果我们在源 Universe 中于下午 2 点写入并在目标 Universe 中于下午 2:01 读取，并且复制延迟为 5 分钟，则读取将在下午 1:56 读取，并且不会看到写。 假设复制延迟保持在五分钟，我们直到下午 2:06 才能在目标 Universe 中看到写入。</p>
<p>如果源 Universe 死亡，那么我们可以使用 AiSQL 的时间点恢复 (PITR) 功能将其回退到最新的 xDCR 安全时间（示例中为下午 1:56），从而丢弃目标 Universe 中的所有不完整信息。 结果将是通过应用源 Universe 事务的前缀而产生的完全一致的数据库，即那些在 xDCR 安全时间或之前提交的事务。 与非事务复制不同，因此不需要处理撕裂的事务。</p>
<p>目前还不清楚如何使用这种通过仅在过去的安全时间读取来保持一致性的策略来最好地支持目标universe中的写入：目标更新事务似乎需要从过去读取但在现在写入； 因此，它必须至少等待复制延迟，以确保在该时间间隔内不会发生来自源 Universe 的干扰写入。 因此，此类交易会很慢并且容易中止。</p>
<p>因此，使用 xDCR 事务复制时当前不允许目标写入。 这意味着事务复制模式无法支持双向复制。</p>
<p>目标universe只读事务仍然被允许； 它们在过去拍摄的单个一致快照上以可串行化的隔离级别运行。</p>
<h5 id="_50"><strong>高层实施细节</strong></h5>
<p>在较高级别上，xDCR 复制是通过在目标 Universe 中设置轮询器来实现的，这些轮询器轮询源 Universe Tablet 服务器以了解最近的更改。 每个轮询器独立工作并轮询一个源Tile，将收到的更改分发到一组目标Tile中。</p>
<p>轮询的Tile仅检查其 Raft 日志以确定最近发生了哪些更改，而不是查看其 RocksDB 实例。 传入的轮询请求指定要开始收集更改的 Raft 日志条目 ID，响应包括一批更改和下次继续的 Raft 日志条目 ID。</p>
<p>轮询器偶尔会检查他们处理的最后一批更改的继续 Raft ID； 这确保每个更改至少被处理一次。</p>
<p><strong>1.源Tile和目标Tile之间的映射</strong>
在简单的情况下，我们可以将轮询器与轮询相应源Tile的每个目标Tile相关联。</p>
<p>但是，在一般情况下，源 Universe 和目标 Universe 中表的 Tablet 数量可能不同。 即使Tablet的数量相同，由于过去发生在不同地方的Tablet分裂，它们也可能具有不同的分片边界。</p>
<p>这意味着每个目标Tile可能需要来自多个源Tile的更改，并且多个目标Tile可能需要来自同一源Tile的更改。 为了避免对同一个源tablet进行多次冗余的跨universe读取，每个源tablet只有一个轮询器读取； 如果多个目标Tile需要源Tile的更改，则分配给该源Tile的轮询器会将更改分发到相关的目标Tile。</p>
<p>下图显示了一张表的情况：</p>
<p><img alt="" src="media/chapter9/31.png" /></p>
<p>此处，源 Universe 位于左侧，具有三个 dbserver（白色框），每个 dbserver 包含一个表（内部框)以及显示的表范围。 目标universe位于右侧，少了一台 dbserver 和Tile。 如您所见，顶级源 Tablet 的数据由顶级目标 dbserver 中运行的轮询器在两个目标 Tablet 之间分割，其余源 Tablet 的数据由另一个目标 dbserver 中运行的轮询器复制到第二个目标 Tablet。 为简单起见，此处仅显示Tile领导者 - 轮询器仅在领导者处运行并进行轮询。</p>
<p>Tablet 分裂会生成一个 Raft 日志条目，该日志条目会被复制到目标端，以便在源 Tablet 分裂时可以根据需要更新轮询器到源 Tablet 的映射。</p>
<p><strong>2.单分片事务</strong>
这些都很简单：当其中一个事务提交时，会生成一个 Raft 日志条目，其中包含该事务的所有写入及其提交时间。 当轮询器请求更改时，该条目又用于生成一批更改的一部分。</p>
<p>收到更改后，轮询器会检查每个写入以查看写入的键，以确定哪个目标Tile覆盖了表的该部分。 然后轮询器将写入转发到适当的Tile。 写入的提交时间将被保留，并且写入将被标记为外部，这可以防止它们被 xDCR 进一步复制，无论是向前复制到其他集群还是在双向情况下返回到它们来自的集群。</p>
<p><strong>3.分布式事务</strong>
这些比较复杂，因为它们涉及多个 Raft 记录和事务状态表。 稍微简化一下，每次这些事务之一进行临时写入时，都会在相应的Tile上创建一个 Raft 条目，并且在事务提交后，在所有涉及的Tile上都会创建一个 Raft 条目以应用该事务。 这里应用事务意味着将其写入从临时写入转换为常规写入。</p>
<p>临时写入的处理方式与单分片事务情况下的正常写入类似，但被写入临时记录而不是正常写入。 使用与通常的临时记录格式不同的特殊惰性格式。 这既节省了空间，因为目标端不需要的原始锁定信息被省略，并且防止临时记录与目标读取或锁定路径交互。 这确保了事务不会影响目标端的事务。</p>
<p>应用 Raft 条目还会生成轮询器收到的更改。 当轮询器收到应用条目时，它会向它处理的所有目标Tile发送指令以应用给定的事务。 目标Tile上的事务应用程序与源 Universe 上的事务应用程序类似，但由于临时记录格式不同而存在其他差异。 它将临时写入转换为常规写入，再次在与源 Universe 相同的提交时间并将它们标记为外部。 此时，事务对此Tile的写入对读取可见。</p>
<p>由于轮询器独立运行，并且对多个Tile的写入/应用不是作为一组原子完成的，因此从单个事务（甚至是单分片事务）到多个Tile的写入可能在不同时间变得可见。</p>
<p>当源事务提交时，它会被延迟地应用于相关的tablet。 这意味着，即使事务 X 在事务 Y 之前提交，但在某些Tile上，X 的应用程序 Raft 条目可能会发生在 Y 的应用程序 Raft 条目之后。 如果发生这种情况，来自 X 的写入可能会在 Y 之后在目标 Universe 中变得可见。 这就是为什么非事务模式读取仅最终一致而不是时间线一致的原因。</p>
<p><strong>4.事务模式</strong>
xDCR 安全时间是由目标universe主领导者为每个数据库计算的，作为该数据库中任何 Tablet 已达到的最小 xDCR 应用程序时间。 轮询器使用来自源tablet 服务器的信息来确定该时间，其形式为“一旦您完全应用了此之前的所有更改，则此tablet 的xDCR 应用程序时间将为T”。</p>
<p>当源tablet服务器确定没有涉及该tablet的活动事务可以在T之前提交并且涉及在T之前提交的该tablet的所有事务具有先前已作为更改发送的应用程序Raft条目时，源tablet服务器发送此类信息。 它还定期（当前为 250 毫秒）检查缺少应用 Raft 条目的已提交事务，并为它们生成此类条目； 这有助于 xDCR 安全时间提前得更快。</p>
<h5 id="_51"><strong>架构差异</strong></h5>
<p>xDCR 复制不支持在具有不同架构的表的两个副本之间进行复制。 例如，您无法将表复制到缺少列或列具有不同类型的表的版本。</p>
<p>更巧妙的是，此限制扩展到隐藏模式元数据，例如将列 ID 分配给列。 仅仅因为两个表在 BSQL 中显示相同的模式并不意味着它们的模式实际上是相同的。 因此，在实践中，目标表模式需要从源表的模式复制； 有关如何完成此操作的信息，请参阅复制引导。</p>
<p>由于此限制，当在 Universe 之间复制行时，xDCR 不需要对行内容进行深度转换（例如，删除列或转换键和值内的列 ID）。 避免深度翻译可以简化代码并降低复制成本。</p>
<p><strong>支持架构更改</strong>
如今，这是一个手动过程，必须在一侧手动进行完全相同的架构更改，然后在另一侧进行。 当检测到架构差异时，给定表的复制会自动暂停，并在架构再次相同时恢复。</p>
<p>正在进行的工作 #11537 将实现这一自动化：对源 Universe 进行的架构更改将自动复制到目标 Universe 并进行，从而允许复制继续运行而无需操作员干预。</p>
<h5 id="replication-bootstrapping"><strong>复制引导Replication bootstrapping</strong></h5>
<p>xDCR 复制会将源 Universe 上所做的更改复制到目标 Universe。 如果源 Universe 开始为空，这很好，但如果我们想要开始复制已包含数据的 Universe 该怎么办？</p>
<p>在这种情况下，我们需要通过首先将源 Universe 复制到目标 Universe 来引导复制过程。</p>
<p>如今，这是通过备份源 Universe 并将其恢复到目标 Universe 来完成的。 除了复制所有数据之外，这还会复制表架构，以便它们在两侧相同。 在备份完成之前，当前的 Raft 日志 ID 会被保存，以便在从备份完成之前的时间恢复后可以开始复制。 这可确保复制备份期间写入源 Universe 的任何数据。</p>
<p>正在进行的工作#17862 将使用在源 Universe 和目标 Universe 之间直接复制 RocksDB 文件来取代此处的备份和恢复。 这将提高性能和灵活性，并且无需使用 S3 等外部存储来设置复制。</p>
<h5 id="_52"><strong>支持的部署场景</strong></h5>
<p>xDCR目前支持主动-被动和主动-主动部署。</p>
<p><strong>1.主动-被动</strong>
此处，从源 Universe 到目标 Universe 的复制是单向的。 目标 Universe 通常位于与源 Universe 不同的数据中心或区域中。 目标 Universe 是被动的，因为它不接受来自更高层服务的写入。</p>
<p>通常，此类部署用于提供来自目标 Universe 的低延迟读取以及灾难恢复目的。 当主要用于灾难恢复目的时，这些部署也称为主动-备用，因为如果源 Universe 丢失，目标 Universe 会随时接管。</p>
<p>此处可以使用事务模式或非事务模式，但通常首选事务模式，因为如果源 Universe 丢失，它可以提供一致性。</p>
<p>下图显示了主动-被动部署示例：</p>
<p><img alt="" src="media/chapter9/32.png" /></p>
<p><strong>2.主动-主动</strong>
数据复制可以在两个 Universe 之间双向进行，在这种情况下，两个 Universe 都可以执行读取和写入操作。 对任何 Universe 的写入都会异步复制到另一个 Universe，并带有更新时间戳。 如果相同的键在相似的时间在两个 Universe 中更新，则会导致具有较大时间戳的写入成为最新写入。 在这种情况下，Universe 都是活动的，这种部署模式称为多主部署或双活部署。</p>
<p>多主部署是使用非事务模式的两个源-目标单向复制流在内部构建的。 特别注意确保分配时间戳以保证最后写入者获胜语义，并且从复制流到达的数据不会被重新复制。</p>
<p>下图显示了主动-主动部署示例：</p>
<p><img alt="" src="media/chapter9/33.png" /></p>
<h5 id="_53"><strong>不支持的部署场景</strong></h5>
<p>AiSQL 尚不支持许多部署方案。</p>
<p><strong>1.广播</strong>
此拓扑涉及一个源 Universe 向多个目标 Universe 发送数据。 有关详细信息，请参阅#11535。</p>
<p><strong>2.合并</strong>
此拓扑涉及多个源 Universe 将数据发送到一个中央目标 Universe。 有关详细信息，请参阅#11535。</p>
<p><strong>3.更复杂的拓扑</strong>
除了传统的 1:1 拓扑以及之前描述的 1:N 和 N:1 拓扑之外，还有许多其他当前不支持的所需配置，例如：</p>
<ul>
<li>Daisy chaining，涉及连接一系列作为源和目标的 Universe，例如：A &lt;-&gt; B &lt;-&gt; C</li>
<li>环，涉及将一系列universe连接成一个环，例如：A &lt;-&gt; B &lt;-&gt; C &lt;-&gt; A
  一旦广播和整合用例得到解决，其中一些拓扑可能会自然变得可用，从而允许一个 Universe 同时成为多个其他 Universe 的源和目标。 有关详细信息，请参阅#11535</li>
</ul>
<h5 id="_54"><strong>局限性</strong></h5>
<p>除了可能的部署之外，当前的 xDCR 实现还存在许多限制。</p>
<p><strong>1.数据库触发器不会针对复制数据触发</strong>
由于 xDCR 复制绕过查询层，因此不会在复制记录的目标端触发任何数据库触发器，这可能会导致意外行为。</p>
<p><strong>2.无法在主动-主动中强制执行约束</strong>
同样，无法检查主动-主动设置中是否违反唯一约束。 例如，在不同的 Universe 中可能存在两个冲突的写入，这两个写入一起将违反唯一约束并导致主表包含两行，但索引仅包含一行，从而导致不一致的状态。</p>
<p>因此，使用主动-主动的应用程序应避免使用 UNIQUE 索引和约束以及主键中的串行列：因为两个 Universe 生成相同的序列号，这可能会导致行冲突。 建议使用 UUID 代替。</p>
<p>将来，可能会默认检测到此类不安全约束并发出警告。 这在 #11539 中进行了跟踪。</p>
<p>请注意，如果您尝试同时将两个 Universe 上的同一行插入到没有主键的表中，那么最终会得到具有相同数据的两行。 这是预期的 PostgresSQL 行为——没有主键的表可以有多行包含相同的数据。</p>
<p><strong>3.非事务模式一致性问题</strong>
使用非事务模式与从另一个 Universe 复制的数据进行交互时：</p>
<ul>
<li>读取只有最终一致</li>
<li>最后一位写入者赢得写入</li>
<li>事务仅限于隔离级别 SQL-92 READ COMMITTED</li>
<li>失去一个universe后，另一个universe可能会留下交易被撕裂的情况。</li>
</ul>
<p><strong>4.事务模式的限制</strong>
通过事务模式，</p>
<ul>
<li>目标 Universe 中不允许写入</li>
<li>不支持主动-主动</li>
<li>尚不支持 BCQL
  当源Universe丢失时，必须做出明确的决定以切换到备用Universe，并且必须运行时间点恢复； 预计这会将恢复时间增加一分钟左右。</li>
</ul>
<p><strong>5.引导复制</strong>
目前，您有责任确保目标 Universe 具有足够新的更新，以便可以安全地恢复复制（有关说明，请参阅引导目标 Universe）。 将来，引导目标universe将是自动化的，这在#11538中进行了跟踪。
Bootstrap 目前依赖于 AiSQL 的底层备份和恢复（BAR）机制。 这意味着它也继承了 BAR 的所有限制。 对于BSQL来说，目前BAR的范围是数据库级别的，而复制的范围是表级别的。 这意味着，当您引导目标 Universe 时，您会自动将源数据库中的任何表带到目标数据库，甚至是您可能不打算实际配置复制的表。 这在 #11536 中进行了跟踪。</p>
<p><strong>6.DDL 更改</strong>
目前，DDL 更改不会自动复制。 您有责任将 CREATE TABLE、ALTER TABLE 和 CREATE INDEX 等命令应用到目标 Universe。
不支持删除表。 您必须首先禁用该表的复制。
不支持截断表。 由于这两个功能的运行级别，这是一个潜在的限制。 也就是说，复制是在 Raft WAL 文件之上实现的，而截断是在 RocksDB SST 文件之上实现的。
将来，将有可能将 DDL 更改安全地传播到其他universe。 这在 #11537 中进行了跟踪。</p>
<p><strong>7.Kubernetes</strong> 
从技术上讲，可以使用 Kubernetes 部署的 Universe 来设置 xDCR 复制。 但是，源和目标必须能够通过直接引用另一个universe中的 Pod 进行通信。 实际上，这要么意味着两个 Universe 必须属于同一个 Kubernetes 集群，要么两个 Kubernetes 集群必须在它们之间正确设置 DNS 和路由。
根据 #2422，目前不支持拥有两个 AiSQL Universe，每个都在自己的独立 Kubernetes 集群中，通过负载均衡器相互通信。</p>
<h5 id="_55"><strong>跨功能交互</strong></h5>
<p>支持多种跨功能的交互。</p>
<p><strong>支持的:</strong></p>
<ul>
<li>客户端和内部 RPC 流量均支持 TLS。 Universe 还可以配置不同的证书。</li>
<li>支持 RPC 压缩。 请注意，在启用压缩算法之前，两个 Universe 的版本都必须支持压缩。</li>
<li>支持静态加密。 请注意，从技术上讲，Universe 可以使用不同的密钥管理服务 (KMS) 配置。 但是，为了引导目标 Universe，依赖于备份和恢复流程。 因此，继承了这一限制，这要求正在恢复的 Universe 至少可以访问与进行备份的 KMS 相同的 KMS。 这意味着源和目标都必须有权访问相同的 KMS 配置。</li>
<li>支持 BSQL 共址。</li>
<li>支持 BSQL 地理分区。 请注意，您必须在所有新分区上手动配置复制，因为 DDL 更改不会自动复制。</li>
<li>源 Universe 和目标 Universe 可以具有不同数量的Tile。</li>
<li>源 Universe 和目标 Universe 均支持 Tablet 拆分。</li>
</ul>
<h4 id="read-replicas"><strong>Read replicas</strong></h4>
<p>将数据异步复制到一个或多个只读副本集群</p>
<p>除了基于共识的核心分布式复制之外，CoreDB 还扩展了 Raft，添加了只读副本（也称为观察者节点），这些副本不参与写入，但以异步方式获取时间线一致的数据副本。</p>
<p>只读副本是 Universe 中主数据的只读扩展。 通过只读副本，Universe 的主要数据可以跨一个区域（region）中的多个可用区（zone）或附近的区域（region）进行复制。 读取副本不会增加写入延迟，因为写入不会同步将数据复制到它们。 相反，数据会异步复制到只读副本。</p>
<p>远程数据中心的节点可以通过只读方式添加。 这通常用于某些工作负载无法容忍基于分布式共识写入的延迟的情况。</p>
<p><strong>1.复制因子</strong>
每个 AiSQL Universe 都包含一个主数据集群和一个或多个只读副本集群。 因此，每个只读副本集群可以独立地拥有自己的复制因子。</p>
<p>只读副本集群的复制因子也可以是偶数。 例如，复制因子为 2 的只读副本集群是完全有效的。 这是因为只读副本不参与 Raft 共识操作，因此不需要奇数个副本来保证正确性。</p>
<p><strong>2.写入只读副本</strong>
应用程序可以向只读副本发送写入请求，但这些写入请求在内部重定向到主机群对应的Tile leader。 这是可能的，因为只读副本了解 Universe 的拓扑。</p>
<p><strong>3.架构变更</strong>
由于只读副本是 Raft 复制级别的扩展，因此架构更改会透明地应用于这些副本。 无需在只读副本集群上单独执行DDL操作。</p>
<p><strong>4.读取副本与最终一致性</strong>
只读节点（或时间线一致节点）仍然严格优于最终一致性，因为对于后者，应用程序的数据视图可以及时来回移动并且难以编程。</p>
<h4 id="change-data-capture-cdc"><strong>Change data capture (CDC)</strong></h4>
<p>AiSQL 中的更改数据捕获 (CDC) 提供的技术可确保由于插入、更新和删除等操作而导致的任何数据更改都被识别、捕获并自动应用于另一个数据存储库实例，或者可供应用程序和应用程序使用。</p>
<h5 id="_56"><strong>用例</strong></h5>
<p>CDC 在许多场景中都很有用。</p>
<p><strong>1.面向微服务的架构</strong>
某些微服务需要对数据进行一系列更改，并且在 AiSQL 中使用 CDC 可以为 CDC 订阅者提供可使用的数据更改。</p>
<p>2.异步复制到远程系统
远程系统可以订阅数据更改流，然后转换并使用这些更改。 出于事务和报告目的维护单独的数据库实例可用于管理工作负载性能。</p>
<p><strong>3.多种数据中心策略</strong>
维护多个数据中心使企业能够提供以下功能：</p>
<ul>
<li>高可用性 (HA) — 冗余系统有助于确保您的操作几乎不会失败。</li>
<li>地理冗余——地理上分散的服务器提供了应对灾难性事件和自然灾害的弹性。</li>
</ul>
<p><strong>4.合规与审计</strong>
审核和合规性要求可能要求您使用 CDC 来维护数据更改记录。</p>
<h5 id="_57"><strong>流程架构</strong></h5>
<p>下图描述了 CDC 流程架构</p>
<p><img alt="" src="media/chapter9/34.png" /></p>
<p>每个DBServer都有一个无状态的CDC服务。 CDC服务提供的主要API如下：</p>
<ul>
<li>createCDCSDKStream：用于在数据库上创建流的 API。</li>
<li>getChangesCDCSDK：客户端获取最新的更改集的API。</li>
</ul>
<p><strong>1.CDC 流</strong>
创建新的 CDC 流会返回流 UUID。 这是通过 bm-admin 工具实现的。</p>
<p><strong>2.Debezium</strong>
为了使用 CDC 生成的事件，使用 Debezium 作为连接器。 Debezium是一个开源分布式平台，需要使用流ID指向数据库。 有关如何为 AiSQL CDC 设置 Debezium 的信息，请参阅 Debezium 集成。</p>
<p><strong>3.将更改推送到外部系统</strong>
使用 AiSQL 的 Debezium 连接器，更改从 AiSQL 推送到 Kafka 主题，然后任何最终用户应用程序都可以使用该主题来处理和分析记录。</p>
<p><strong>4.CDC保证</strong>
CDC做出以下保证。</p>
<p>（1）每Tile订购的交付保证
同一Tile中一行或多行的所有数据更改均按其发生的顺序接收。 然而，由于问题的分布式性质，无法保证跨Tile的顺序。</p>
<p>考虑以下场景：</p>
<ul>
<li>两行正在同时更新。</li>
<li>这两行属于不同的Tile。</li>
<li>第一行 row #1 在时间 t1 更新，第二行 row #2 在时间 t2 更新。
  在这种情况下，CDC 可以在推送对应于行 #1 的较早更新之前，将对应于行 #2 更改的较晚更新推送到 Kafka。</li>
</ul>
<p>（2）至少一次交付
行的更新至少推送一次。 通过至少一次传递，您永远不会丢失消息，但是该消息可能会多次传递给 CDC 使用者。 如果Tile领导者发生变化，则可能会发生这种情况，其中旧领导者已将更改推送到 Kafka，但最新推送的操作 ID 未在 CDC 元数据中更新。</p>
<p>例如，CDC 客户端在时间 t1 和 t3 接收到行的更改。 客户端有可能再次收到这些更新。</p>
<p>（3）流中没有间隙
当您收到时间戳 t 的行的更改时，您不会收到该行较早时间戳中以前未见过的更改。 这保证了接收任何更改意味着已接收到该行的所有早期更改。</p>
<h3 id="coredb_3"><strong>CoreDB存储层</strong></h3>
<p>CoreDB 是 AiSQL 的分布式文档存储，负责事务、分片、复制和持久化。</p>
<h4 id="_58"><strong>持久化</strong></h4>
<p>使用 Raft 在大多数 AiSQL Tile对等体之间复制数据后，数据将应用于每个Tile对等体的本地 CoreDB 文档存储层。</p>
<h5 id="_59"><strong>存储模型</strong></h5>
<p>该存储层是一个持久的 key-to-object （或文档）存储。 下图描述了并非每个元素始终存在的存储模型：</p>
<p><img alt="" src="media/chapter9/35.png" /></p>
<p>1.CoreDB key
CoreDB 文档模型中的键是复合键，由零个或多个哈希组织的组件后跟零个或多个有序（范围)组件组成。 这些组件按照其数据类型特定的排序顺序存储，键的每个有序组件都支持升序和降序排序。 如果存在任何哈希列，则它们前面是哈希列值的 16 位哈希值。</p>
<p>如果正在使用colocation，则该键将以其所引用的表的托管 ID 为前缀（图中未显示）； 这将来自同一个Tile中的不同表的数据分开。</p>
<p>2.CoreDB value
CoreDB 文档数据模型中的值可以是以下类型：</p>
<ul>
<li>原始类型，例如int32、int64、double、text、timestamp等。</li>
<li>非原始类型（排序映射），其中对象将标量键映射到可以是标量映射或排序映射的值。
  该模型允许多层嵌套，并对应于类似 JSON 的格式。 其他数据结构（例如列表、排序集等）是使用带有特殊键编码的 CoreDB 对象类型来实现的。 在 CoreDB 中，每次更新的混合时间戳都会被仔细记录，使得恢复任何文档在过去某个时刻的状态成为可能。 只要在旧值可见的快照中没有事务读取，覆盖或删除的数据版本就会被垃圾收集</li>
</ul>
<p>（1）编码文档Encoding documents
文档使用基于 RocksDB 的无类型键值存储进行存储。 文档将转换为多个键值对以及时间戳。 由于文档分布在许多不同的键值上，因此可以部分修改它们而不会产生开销。</p>
<p>以下示例显示了存储在 CoreDB 中的文档：</p>
<div class="highlight"><pre><span></span><code>DocumentKey1 = {
  SubKey1 = {
    SubKey2 = Value1
    SubKey3 = Value2
  },
  SubKey4 = Value3
}
</code></pre></div>
<p>RocksDB 中存储的键由多个组件组成，其中第一个组件是文档键，后面是几个标量组件，最后是 MVCC 时间戳（按相反顺序排序）。 DocumentKey、SubKey 和 Value 中的每个组件都是 PrimitiveValue，它们是可以在字节数组中进行编码和解码的类型值对。 当对键中的原始值进行编码时，对值使用二进制可比较的编码，因此编码的排序顺序与值的排序顺序相同</p>
<p>（2）更新和删除
假设“编码文档”中的示例中提供的文档完全是在时间 T10 编写的。 该文档在内部使用五个 RocksDB 键值对存储，如下所示：</p>
<div class="highlight"><pre><span></span><code>DocumentKey1, T10 -&gt; {} // This is an init marker
DocumentKey1, SubKey1, T10 -&gt; {}
DocumentKey1, SubKey1, SubKey2, T10 -&gt; Value1
DocumentKey1, SubKey1, SubKey3, T10 -&gt; Value2
DocumentKey1, SubKey4, T10 -&gt; Value3
</code></pre></div>
<p>通过在相应值处写入单个墓碑标记来执行文档和子文档的删除。 在压缩期间，覆盖或删除的值将被清除以回收空间。</p>
<h5 id="sql-coredb"><strong>将 SQL 行映射到</strong> <strong>CoreDB</strong></h5>
<p>对于 BSQL 和 BCQL 表，每一行都是 CoreDB 中的一个文档。</p>
<p><strong>1.主键列</strong>
文档键包含完整的主键，其中列值按以下顺序组织：
（1）如果存在任何散列列，则存储散列列值的 16 位散列。
（2）存储哈希列。
（3）存储聚类（范围）列。</p>
<p>BSQL 或 BCQL 支持的每种数据类型都由唯一的字节表示。 类型前缀也出现在主键哈希或范围组件中。</p>
<p><strong>2.非主键列</strong>
非主键列对应于文档中的子文档。 子文档键对应列ID。 我们在 BSQL（或 BCQL）中支持的每种数据类型都有一个唯一的字节。 这些值以相应的字节为前缀。 如果列是非原始类型（例如映射或集合），则相应的子文档是对象。</p>
<p>二进制可比较编码用于将每个 BCQL 类型的值转换为添加到键值存储中的字符串</p>
<h5 id="packed-row-format"><strong>打包行格式Packed row format</strong></h5>
<p>打包行格式支持目前处于抢先体验阶段。</p>
<p>用户表对应的一行在CoreDB中存储为多个键值对。 例如一行有一个主键K，n个非键列，即K(主键)| C1（列）| C2 | …………| Cn，将存储为 n 个键值对 - <K, C1> <K, C2> .... <K, Cn>。</p>
<p>使用打包行格式，它将存储为单个键值对：<K，packed{C1，C2 ... Cn}>。</p>
<p>虽然 UDT（用户定义类型）可用于在应用程序级别实现打包行格式，但对打包行格式的本机支持具有以下优点：</p>
<ul>
<li>更低的存储占用空间。</li>
<li>高效的 INSERT，尤其是当表具有大量列时。</li>
<li>更快的多列读取，因为读取需要获取更少的键值对。</li>
<li>UDT 需要重写应用程序，因此不一定适合所有用例，例如延迟敏感的更新工作负载。</li>
</ul>
<p>可以使用打包行标志Packed row flags启用打包行格式。</p>
<p><strong>1.设计</strong>
以下是打包行格式的设计方面：</p>
<ul>
<li>插入：整行存储为单个键值对。</li>
<li>更新：如果更新了某些列，则每个此类列更新都会作为键值对存储在 CoreDB 中（与没有打包行时相同）。 但是，如果更新所有非键列，则该行将以打包格式存储为单个键值对。 该方案同时采用高效更新和高效存储。</li>
<li>查询：扫描需要从打包插入以及非打包更新（如果有）构造行。</li>
<li>点查找：点查找将与没有打包行一样快，从根本上讲，我们仍然会从 CoreDB 中查找单个键值对。</li>
<li>压缩：如果行由于更新而具有解压片段，则压缩会生成该行的压缩版本。</li>
<li>向后兼容性：读取代码也可以解释非打包格式。 写入/更新也可以产生非打包格式。 一旦一行被打包，就无法解包。</li>
</ul>
<p><strong>2.性能数据</strong>
使用不同配置测试打包行功能显示出显着的性能提升：
使用打包行对具有 100 万行的表进行顺序扫描速度提高了 2 倍。
使用打包行批量摄取 100 万行的速度提高了 2 倍。</p>
<p><strong>3.局限性</strong>
打包行功能适用于 BSQL API，使用 BSQL 特定的 GFlags 和大多数交叉功能，如备份和恢复、模式更改等，但受到当前正在开发的某些已知限制：</p>
<p>#15143 共置和 xDCR - 以正在处理的打包行格式传播 xDCR 中共置表的架构更改存在一些限制。
#14369 BCQL 的打包行支持有限，并且仍在强化中。</p>
<h5 id="bcql"><strong>BCQL 中的数据过期</strong></h5>
<p>在BCQL中，TTL有两种类型：表TTL和列级TTL。 列 TTL 使用与 Redis 相同的编码与值一起存储。 表的 TTL 不存储在 CoreDB 中（相反，它作为表架构的一部分存储在主服务器的系统目录中）。 如果列的值中不存在 TTL，则表 TTL 将充当默认值。</p>
<p>此外，BCQL 在使用插入和更新创建的行之间存在区别。 AiSQL 使用“活跃度列”（用户不可见的特殊系统列）来跟踪这种差异（以及行级 TTL）。 它是为插入添加的，但不是为更新添加的，这确保即使仅在插入时删除所有非主键列，该行也存在</p>
<h5 id="bcql_1"><strong>BCQL 的集合类型示例</strong></h5>
<p>考虑以下 BCQL 表架构：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE msgs (user_id text,
                   msg_id int,
                   msg text,
                   msg_props map&lt;text, text&gt;,
      PRIMARY KEY ((user_id), msg_id));
</code></pre></div>
<p><strong>1.插入一行</strong></p>
<div class="highlight"><pre><span></span><code>T1: INSERT INTO msgs (user_id, msg_id, msg, msg_props)
      VALUES (&#39;user1&#39;, 10, &#39;msg1&#39;, {&#39;from&#39; : &#39;a@b.com&#39;, &#39;subject&#39; : &#39;hello&#39;});
</code></pre></div>
<p>CoreDB 中的条目类似于以下内容：</p>
<div class="highlight"><pre><span></span><code>(hash1, &#39;user1&#39;, 10), liveness_column_id, T1 -&gt; [NULL]
(hash1, &#39;user1&#39;, 10), msg_column_id, T1 -&gt; &#39;msg1&#39;
(hash1, &#39;user1&#39;, 10), msg_props_column_id, &#39;from&#39;, T1 -&gt; &#39;a@b.com&#39;
(hash1, &#39;user1&#39;, 10), msg_props_column_id, &#39;subject&#39;, T1 -&gt; &#39;hello&#39;
</code></pre></div>
<p><strong>2.更新列的子集</strong>
以下示例更新列的子集：</p>
<div class="highlight"><pre><span></span><code>T2: UPDATE msgs
       SET msg_props = msg_props + {&#39;read_status&#39; : &#39;true&#39;}
     WHERE user_id = &#39;user1&#39;, msg_id = 10
</code></pre></div>
<p>CoreDB 中的条目类似于以下内容：</p>
<div class="highlight"><pre><span></span><code>(hash1, &#39;user1&#39;, 10), liveness_column_id, T1 -&gt; [NULL]
(hash1, &#39;user1&#39;, 10), msg_column_id, T1 -&gt; &#39;msg1&#39;
(hash1, &#39;user1&#39;, 10), msg_props_column_id, &#39;from&#39;, T1 -&gt; &#39;a@b.com&#39;
(hash1, &#39;user1&#39;, 10), msg_props_column_id, &#39;read_status&#39;, T2 -&gt; &#39;true&#39;
(hash1, &#39;user1&#39;, 10), msg_props_column_id, &#39;subject&#39;, T1 -&gt; &#39;hello&#39;
</code></pre></div>
<p><strong>3.更新整行</strong>
以下示例更新整行：</p>
<div class="highlight"><pre><span></span><code>T3: INSERT INTO msgs (user_id, msg_id, msg, msg_props)
        VALUES (‘user1’, 20, &#39;msg2&#39;, {&#39;from&#39; : &#39;c@d.com&#39;, &#39;subject&#39; : &#39;bar&#39;});
</code></pre></div>
<p>CoreDB 中的条目类似于以下内容：</p>
<div class="highlight"><pre><span></span><code>(hash1, &#39;user1&#39;, 10), liveness_column_id, T1 -&gt; [NULL]
(hash1, &#39;user1&#39;, 10), msg_column_id, T1 -&gt; &#39;msg1&#39;
(hash1, &#39;user1&#39;, 10), msg_props_column_id, &#39;from&#39;, T1 -&gt; &#39;a@b.com&#39;
(hash1, &#39;user1&#39;, 10), msg_props_column_id, &#39;read_status&#39;, T2 -&gt; &#39;true&#39;
(hash1, &#39;user1&#39;, 10), msg_props_column_id, &#39;subject&#39;, T1 -&gt; &#39;hello&#39;
**(hash1, &#39;user1&#39;, 20), liveness_column_id, T3 -&gt; [NULL]**
**(hash1, &#39;user1&#39;, 20), msg_column_id, T3 -&gt; &#39;msg2&#39;**
**(hash1, &#39;user1&#39;, 20), msg_props_column_id, &#39;from&#39;, T3 -&gt; &#39;c@d.com&#39;**
**(hash1, &#39;user1&#39;, 20), msg_props_column_id, &#39;subject&#39;, T3 -&gt; &#39;bar&#39;**
</code></pre></div>
<p><strong>4.删除一行</strong>
以下示例从行中删除单个列：</p>
<div class="highlight"><pre><span></span><code>T4: DELETE msg_props
      FROM msgs
     WHERE user_id = &#39;user1&#39;
       AND msg_id = 10;
</code></pre></div>
<p>尽管在前面的示例中要删除的列是非原始列（映射），但此操作仅涉及在正确级别添加删除标记，并且不会产生任何读取开销。 此时 CoreDB 中的逻辑布局应类似于以下内容：</p>
<div class="highlight"><pre><span></span><code>(hash1, &#39;user1&#39;, 10), liveness_column_id, T1 -&gt; [NULL]
(hash1, &#39;user1&#39;, 10), msg_column_id, T1 -&gt; &#39;msg1&#39;
(hash1, &#39;user1&#39;, 10), msg_props_column_id, T4 -&gt; [DELETE]
(hash1, &#39;user1&#39;, 10), msg_props_column_id, &#39;from&#39;, T1 -&gt; &#39;a@b.com&#39;
(hash1, &#39;user1&#39;, 10), msg_props_column_id, &#39;read_status&#39;, T2 -&gt; &#39;true&#39;
(hash1, &#39;user1&#39;, 10), msg_props_column_id, &#39;subject&#39;, T1 -&gt; &#39;hello&#39;
(hash1, &#39;user1&#39;, 20), liveness_column_id, T3 -&gt; [NULL]
(hash1, &#39;user1&#39;, 20), msg_column_id, T3 -&gt; &#39;msg2&#39;
(hash1, &#39;user1&#39;, 20), msg_props_column_id, &#39;from&#39;, T3 -&gt; &#39;c@d.com&#39;
(hash1, &#39;user1&#39;, 20), msg_props_column_id, &#39;subject&#39;, T3 -&gt; &#39;bar&#39;
</code></pre></div>
<p>以删除线字体显示的键值对将被逻辑删除。 前面的 CoreDB 布局不是物理布局，因为写入以日志结构的方式发生。</p>
<p>当发生压缩时，与已删除列对应的键值对的空间将被回收，如下所示：</p>
<div class="highlight"><pre><span></span><code>(hash1, &#39;user1&#39;, 10), liveness_column_id, T1 -&gt; [NULL]
(hash1, &#39;user1&#39;, 10), msg_column_id, T1 -&gt; &#39;msg1&#39;
(hash1, &#39;user1&#39;, 20), liveness_column_id, T3 -&gt; [NULL]
(hash1, &#39;user1&#39;, 20), msg_column_id, T3 -&gt; &#39;msg2&#39;
(hash1, &#39;user1&#39;, 20), msg_props_column_id, &#39;from&#39;, T3 -&gt; &#39;c@d.com&#39;
(hash1, &#39;user1&#39;, 20), msg_props_column_id, &#39;subject&#39;, T3 -&gt; &#39;bar&#39;
T5: DELETE FROM msgs    // Delete entire row corresponding to msg_id 10
     WHERE user_id = &#39;user1&#39;
            AND msg_id = 10;

(hash1, &#39;user1&#39;, 10), T5 -&gt; [DELETE]
(hash1, &#39;user1&#39;, 10), liveness_column_id, T1 -&gt; [NULL]
(hash1, &#39;user1&#39;, 10), msg_column_id, T1 -&gt; &#39;msg1&#39;
(hash1, &#39;user1&#39;, 20), liveness_column_id, T3 -&gt; [NULL]
(hash1, &#39;user1&#39;, 20), msg_column_id, T3 -&gt; &#39;msg2&#39;
(hash1, &#39;user1&#39;, 20), msg_props_column_id, &#39;from&#39;, T3 -&gt; &#39;c@d.com&#39;
(hash1, &#39;user1&#39;, 20), msg_props_column_id, &#39;subject&#39;, T3 -&gt; &#39;bar&#39;
</code></pre></div>
<h5 id="bcql-ttl"><strong>BCQL 的 TTL 示例</strong></h5>
<p>以下是BCQL中使用的两种TTL类型：</p>
<ul>
<li>表级 TTL：BCQL 允许在表级指定 TTL 属性。 在这种情况下，RocksDB 中的 TTL 不是按键值对存储的； 相反，TTL 会在读取时和压缩期间隐式强制执行以回收空间。</li>
<li>行级和列级 TTL：BCQL 允许在每个 INSERT 和 UPDATE 操作的级别指定 TTL 属性。 在这种情况下，TTL 将作为 RocksDB 值的一部分存储。
  以下示例演示了行级 TTL 的使用：</li>
</ul>
<div class="highlight"><pre><span></span><code>CREATE TABLE page_views (page_id text,
                         views int,
                         category text,
     PRIMARY KEY ((page_id)));
</code></pre></div>
<p><strong>1.插入带有 TTL 的行</strong>
以下示例插入具有 TTL 的行：</p>
<div class="highlight"><pre><span></span><code>T1: INSERT INTO page_views (page_id, views)
        VALUES (&#39;abc.com&#39;, 10)
        USING TTL 86400
</code></pre></div>
<p>CoreDB 中的条目应类似于以下内容：</p>
<div class="highlight"><pre><span></span><code>(hash1, &#39;abc.com&#39;), liveness_column_id, T1 -&gt; (TTL = 86400) [NULL]
(hash1, &#39;abc.com&#39;), views_column_id, T1 -&gt; (TTL = 86400) 10
</code></pre></div>
<p><strong>2.使用 TTL 更新行</strong>
以下示例使用 TTL 更新行：</p>
<div class="highlight"><pre><span></span><code>T2: UPDATE page_views
     USING TTL 3600
       SET category = &#39;news&#39;
     WHERE page_id = &#39;abc.com&#39;;
</code></pre></div>
<p>CoreDB 中的条目应类似于以下内容：</p>
<div class="highlight"><pre><span></span><code>(hash1, &#39;abc.com&#39;), liveness_column_id, T1 -&gt; (TTL = 86400) [NULL]
(hash1, &#39;abc.com&#39;), views_column_id, T1 -&gt; (TTL = 86400) 10
**(hash1, &#39;abc.com&#39;), category_column_id, T2 -&gt; (TTL = 3600) &#39;news&#39;**
</code></pre></div>
<h4 id="_60"><strong>性能</strong></h4>
<p>CoreDB 使用 RocksDB 的定制版本，RocksDB 是一种基于日志结构合并树 (LSM) 的键值存储。</p>
<p><img alt="" src="media/chapter9/36.png" /></p>
<h5 id="rocksdb"><strong>RocksDB 的增强</strong></h5>
<p>对 RocksDB 进行的定制增强了可扩展性并提高了性能。</p>
<p><strong>1.高效的文档建模</strong>
其中一项增强功能的目标是在键值存储之上实现灵活的数据模型，并在此数据模型上实现高效的操作，如下所示：</p>
<ul>
<li>对行或集合的一部分进行细粒度更新，而不会导致整个行或集合的读取-修改-写入损失。</li>
<li>在任意嵌套级别删除或覆盖行、集合或对象，而不会产生读取惩罚以确定需要删除哪些特定的键值对集。</li>
<li>强制执行行级和对象级基于 TTL 的过期。</li>
</ul>
<p>需要与底层 RocksDB 键值存储的读取层和压缩层进行更紧密的耦合。 RocksDB 用作仅追加存储，并且操作（例如行或集合删除）被建模为特殊删除标记的插入。 这允许通过向 RocksDB 添加一个键值对来有效地删除整个子文档。 读取hooks会自动识别这些标记并抑制过期数据。 子文档中的过期值将通过定制的压缩 hooks进行清理和垃圾收集。</p>
<p><strong>2.Raft 与 RocksDB WAL 日志</strong>
CoreDB 使用 Raft 进行复制。 对分布式系统的更改已经记录或记录为 Raft 日志的一部分。 当大多数对等点接受更改时，它会应用于每个 Tablet 对等点的 CoreDB，但 RocksDB（在 CoreDB 下）中额外的预写日志记录 (WAL) 机制是不必要的，并且会增加开销。 为了确保正确性，除了禁用 RocksDB 中的 WAL 机制之外，AiSQL 还跟踪数据从 RocksDB 的 memtable 刷新到 SSTable 文件的 Raft 序列 ID。 这确保了 Raft WAL 日志可以被正确地垃圾收集。 它还允许在服务器崩溃或重新启动时重播 Raft WAL 日志中的最少数量的记录。</p>
<p><strong>3.更高层的MVCC</strong>
CoreDB中的多版本并发控制（MVCC）是在更高层完成的，没有使用RocksDB的MVCC机制。</p>
<p>系统中记录的突变使用 YBase 层维护的混合时间戳进行版本控制。 因此，RocksDB 中使用序列 ID 实现的 MVCC 概念是不必要的，只会增加开销。 AiSQL不使用RocksDB的序列ID； 相反，它使用作为编码键一部分的混合时间戳来实现 MVCC。</p>
<p><strong>4.备份和快照</strong>
备份和快照需要是更高级别的操作，考虑 CoreDB 以及 Raft 日志中的数据，以获得系统状态的一致剪切。</p>
<h5 id="_61"><strong>数据模型感知的布隆过滤器</strong></h5>
<p>RocksDB 中 CoreDB 存储的键由多个组件组成，其中第一个组件是文档键，后面是一些标量组件，最后是时间戳（按相反顺序排序）。</p>
<p>布隆过滤器需要知道应将键的哪些组件添加到布隆中，以便在读取操作期间仅搜索 LSM 存储中的相关 SSTable 文件。</p>
<p>在传统的键值存储中，范围扫描不使用布隆过滤器，因为落在范围内的确切键是未知的。 然而，实现了数据模型感知的布隆过滤器，其中共享相同哈希组件的键内的范围扫描也可以从布隆过滤器中受益。 例如，扫描以获取行中的所有列或集合的所有元素也可以受益于布隆过滤器。</p>
<h5 id="_62"><strong>范围查询优化</strong></h5>
<p>CoreDB 中复合键的有序（或范围）组件通常具有自然顺序。 例如，它可能是表示消息 ID（对于消息传递应用程序）或时间戳（对于 IoT 时间序列）的 int。 通过对 LSM 存储中的每个 SSTable 文件保留有关键的这些组件的最小值和最大值的提示，范围查询可以在读取操作期间智能地删除不相关 SSTable 文件的查找。</p>
<p>考虑以下示例：</p>
<div class="highlight"><pre><span></span><code>SELECT message_txt
  FROM messages
WHERE user_id = 17
  AND message_id &gt; 50
  AND message_id &lt; 100;
</code></pre></div>
<p>以下示例说明了时间序列应用：</p>
<div class="highlight"><pre><span></span><code>SELECT metric_value
  FROM metrics
WHERE metric_name = ’system.cpu’
  AND metric_timestamp &lt; ?
  AND metric_timestamp &gt; ?
</code></pre></div>
<h5 id="_63"><strong>高效的内存使用</strong></h5>
<p>在两种情况下，以服务器全局方式跨组件使用内存会带来好处。</p>
<p><strong>1.服务器全局块缓存</strong>
共享块缓存用于 DBServer 托管的所有Tile的 CoreDB 和 RocksDB 实例。 这样可以最大限度地利用内存资源，并避免创建缓存孤岛，每个缓存孤岛都需要针对不同的用户表准确调整大小。</p>
<p><strong>2.服务器全局内存存储限制</strong>
虽然可以配置每个内存存储的刷新大小，但实际上，由于当用户创建新表或在服务器之间移动表的Tile时，内存存储的数量可能会随着时间而变化，因此增强了存储引擎以强制执行全局内存存储阈值。 当达到这样的阈值时，选择要刷新的内存存储会考虑哪些内存存储携带最旧的记录（由混合时间戳确定），因此会保留 Raft 日志并防止它们被垃圾收集。</p>
<h5 id="_64"><strong>抗扫描块缓存</strong></h5>
<p>CoreDB 增强了 RocksDB 的块缓存，使其具有抗扫描能力。 其动机是防止长时间运行的扫描（例如，由于偶尔的大型查询或后台 Spark 作业）等操作用质量较差的数据污染整个缓存并擦除有用的数据。</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      © 2024 贝格迈思
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.aecac24b.min.js"></script>
      
        <script src="../../javascripts/extra.js"></script>
      
    
  </body>
</html>