
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="贝格迈思数据库使用手册">
      
      
      
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.4.6">
    
    
      
        <title>应用开发 - 手册</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.35e1ed30.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.356b1318.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Ubuntu";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="mo" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="手册" class="md-header__button md-logo" aria-label="手册" data-md-component="logo">
      
  <img src="../../assets/new-logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            手册
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              应用开发
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/aminerdocs/docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="手册" class="md-nav__button md-logo" aria-label="手册" data-md-component="logo">
      
  <img src="../../assets/new-logo.png" alt="logo">

    </a>
    手册
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/aminerdocs/docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../01-AISQL%E7%AE%80%E4%BB%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AiSQL简介
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    快速上手
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            快速上手
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    快速安装部署
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/SQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SQL基本操作
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/BCQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BCQL基本操作
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%88%9B%E5%BB%BAJava%E7%A4%BA%E4%BE%8B%E5%BA%94%E7%94%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    创建Java示例应用程序
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    应用开发
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            应用开发
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    构建应用
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            构建应用
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/JAVA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Java
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Go/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Go
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Python/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Python
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Node.js/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Node.js
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C%2B%2B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C%23/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C#
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Ruby/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Ruby
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Rust/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Rust
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/PHP/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PHP
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%85%A8%E5%B1%80%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    构建全局应用程序
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    构建多云应用程序
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            构建多云应用程序
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    概述
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../04-%E9%83%A8%E7%BD%B2%E9%9B%86%E7%BE%A4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    部署集群
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../05-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数据迁移
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../06-%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    管理数据库
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../07-%E5%90%91%E9%87%8F%E7%89%B9%E6%80%A7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    向量特性
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../08-AI%E7%89%B9%E6%80%A7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AI特性
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    参考
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            参考
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.1-%E6%9E%B6%E6%9E%84/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    架构
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.2-CLIs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CLIs
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.3-%E9%85%8D%E7%BD%AE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    配置
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.4-BSQL/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BSQL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.5-BCQL/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BCQL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    构建应用
  </a>
  
    <nav class="md-nav" aria-label="构建应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#java" class="md-nav__link">
    JAVA
  </a>
  
    <nav class="md-nav" aria-label="JAVA">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    构建并运行应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    分析应用程序逻辑
  </a>
  
    <nav class="md-nav" aria-label="分析应用程序逻辑">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#main" class="md-nav__link">
    main
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#createdatabase" class="md-nav__link">
    createDatabase
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#selectaccounts" class="md-nav__link">
    selectAccounts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transfermoneybetweenaccounts" class="md-nav__link">
    transferMoneyBetweenAccounts
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#go" class="md-nav__link">
    Go
  </a>
  
    <nav class="md-nav" aria-label="Go">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    构建并运行应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    分析应用程序逻辑
  </a>
  
    <nav class="md-nav" aria-label="分析应用程序逻辑">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#main_1" class="md-nav__link">
    main
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#createdatabase_1" class="md-nav__link">
    createDatabase
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#selectaccounts_1" class="md-nav__link">
    selectAccounts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transfermoneybetweenaccounts_1" class="md-nav__link">
    transferMoneyBetweenAccounts
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#python" class="md-nav__link">
    Python
  </a>
  
    <nav class="md-nav" aria-label="Python">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    构建并运行应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    分析应用程序逻辑
  </a>
  
    <nav class="md-nav" aria-label="分析应用程序逻辑">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#main_2" class="md-nav__link">
    main
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#createdatabase_2" class="md-nav__link">
    createDatabase
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#select_accounts" class="md-nav__link">
    select_accounts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transfer_money_between_accounts" class="md-nav__link">
    transfer_money_between_accounts
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodejs" class="md-nav__link">
    Node.js
  </a>
  
    <nav class="md-nav" aria-label="Node.js">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    构建并运行应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    分析应用程序逻辑
  </a>
  
    <nav class="md-nav" aria-label="分析应用程序逻辑">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#connect" class="md-nav__link">
    connect
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#createdatabase_3" class="md-nav__link">
    createDatabase
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#selectaccounts_2" class="md-nav__link">
    selectAccounts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transfermoneybetweenaccounts_2" class="md-nav__link">
    transferMoneyBetweenAccounts
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c" class="md-nav__link">
    C
  </a>
  
    <nav class="md-nav" aria-label="C">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    构建并运行应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    分析应用程序逻辑
  </a>
  
    <nav class="md-nav" aria-label="分析应用程序逻辑">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#connect_1" class="md-nav__link">
    connect
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#createdatabase_4" class="md-nav__link">
    createDatabase
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#selectaccounts_3" class="md-nav__link">
    selectAccounts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transfermoneybetweenaccounts_3" class="md-nav__link">
    transferMoneyBetweenAccounts
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c_1" class="md-nav__link">
    C++
  </a>
  
    <nav class="md-nav" aria-label="C++">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    构建并运行应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    分析应用程序逻辑
  </a>
  
    <nav class="md-nav" aria-label="分析应用程序逻辑">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#connect_2" class="md-nav__link">
    connect
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#createdatabase_5" class="md-nav__link">
    createDatabase
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#selectaccounts_4" class="md-nav__link">
    selectAccounts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transfermoneybetweenaccounts_4" class="md-nav__link">
    transferMoneyBetweenAccounts
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c_2" class="md-nav__link">
    C#
  </a>
  
    <nav class="md-nav" aria-label="C#">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    构建并运行应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    分析应用程序逻辑
  </a>
  
    <nav class="md-nav" aria-label="分析应用程序逻辑">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#connect_3" class="md-nav__link">
    connect
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#createdatabase_6" class="md-nav__link">
    createDatabase
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#selectaccounts_5" class="md-nav__link">
    selectAccounts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transfermoneybetweenaccounts_5" class="md-nav__link">
    transferMoneyBetweenAccounts
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ruby" class="md-nav__link">
    Ruby
  </a>
  
    <nav class="md-nav" aria-label="Ruby">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    构建并运行应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    分析应用程序逻辑
  </a>
  
    <nav class="md-nav" aria-label="分析应用程序逻辑">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#connect_4" class="md-nav__link">
    connect
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create_database" class="md-nav__link">
    create_database
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#select_accounts_1" class="md-nav__link">
    select_accounts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transfer_money_between_accounts_1" class="md-nav__link">
    transfer_money_between_accounts
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rust" class="md-nav__link">
    Rust
  </a>
  
    <nav class="md-nav" aria-label="Rust">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    分析应用程序逻辑
  </a>
  
    <nav class="md-nav" aria-label="分析应用程序逻辑">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#connect_5" class="md-nav__link">
    connect
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create_database_1" class="md-nav__link">
    create_database
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#select_accounts_2" class="md-nav__link">
    select_accounts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transfer_money_between_accounts_2" class="md-nav__link">
    transfer_money_between_accounts
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#php" class="md-nav__link">
    PHP
  </a>
  
    <nav class="md-nav" aria-label="PHP">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    运行应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    分析应用程序逻辑
  </a>
  
    <nav class="md-nav" aria-label="分析应用程序逻辑">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#connect_6" class="md-nav__link">
    connect
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create_database_2" class="md-nav__link">
    create_database
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#select_accounts_3" class="md-nav__link">
    select_accounts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transfer_money_between_accounts_3" class="md-nav__link">
    transfer_money_between_accounts
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    构建全局应用程序
  </a>
  
    <nav class="md-nav" aria-label="构建全局应用程序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    对全局应用程序的需求
  </a>
  
    <nav class="md-nav" aria-label="对全局应用程序的需求">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    应用程序设计模式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    应用程序体系结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    可用性体系结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    数据访问架构
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    选择正确的模式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    设计模式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    图例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    构建多云应用程序
  </a>
  
    <nav class="md-nav" aria-label="构建多云应用程序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    概述
  </a>
  
    <nav class="md-nav" aria-label="概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    多云需求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    构建多云应用程序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    混合云
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    云间迁移
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    多云设置
  </a>
  
    <nav class="md-nav" aria-label="多云设置">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    拓扑结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#universe" class="md-nav__link">
    设置多云universe
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    多云应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    混合云
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    故障转移
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    多云迁移
  </a>
  
    <nav class="md-nav" aria-label="多云迁移">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    两个云间迁移
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    从传统数据中心迁移
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    混合云
  </a>
  
    <nav class="md-nav" aria-label="混合云">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    混合云的优点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    混合云部署模式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    故障转移
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    常见模式
  </a>
  
    <nav class="md-nav" aria-label="常见模式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    概述
  </a>
  
    <nav class="md-nav" aria-label="概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    时间序列数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    键值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_63" class="md-nav__link">
    宽列
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_64" class="md-nav__link">
    时间序列
  </a>
  
    <nav class="md-nav" aria-label="时间序列">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_65" class="md-nav__link">
    按时间排序的订单
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_66" class="md-nav__link">
    按每个实体的时间排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_67" class="md-nav__link">
    自动数据过期
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_68" class="md-nav__link">
    分区
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_69" class="md-nav__link">
    键值
  </a>
  
    <nav class="md-nav" aria-label="键值">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_70" class="md-nav__link">
    存储用户数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_71" class="md-nav__link">
    适用举例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_72" class="md-nav__link">
    学习应用程序开发
  </a>
  
    <nav class="md-nav" aria-label="学习应用程序开发">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_73" class="md-nav__link">
    数据建模
  </a>
  
    <nav class="md-nav" aria-label="数据建模">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_74" class="md-nav__link">
    键空间、表、行和列
  </a>
  
    <nav class="md-nav" aria-label="键空间、表、行和列">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_75" class="md-nav__link">
    键空间
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_76" class="md-nav__link">
    表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_77" class="md-nav__link">
    行
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_78" class="md-nav__link">
    列
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_79" class="md-nav__link">
    主键
  </a>
  
    <nav class="md-nav" aria-label="主键">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_80" class="md-nav__link">
    分区键列（必需）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_81" class="md-nav__link">
    集群键列（可选）
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_82" class="md-nav__link">
    二级索引
  </a>
  
    <nav class="md-nav" aria-label="二级索引">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_83" class="md-nav__link">
    二级索引的优势
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_84" class="md-nav__link">
    强制列值的唯一性
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_85" class="md-nav__link">
    文档
  </a>
  
    <nav class="md-nav" aria-label="文档">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#apache-cassandrajson" class="md-nav__link">
    与Apache Cassandra的JSON支持的比较
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_86" class="md-nav__link">
    数据类型
  </a>
  
    <nav class="md-nav" aria-label="数据类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jsonb" class="md-nav__link">
    JSONB
  </a>
  
    <nav class="md-nav" aria-label="JSONB">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_87" class="md-nav__link">
    建表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_88" class="md-nav__link">
    插入数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_89" class="md-nav__link">
    检索属性的子集
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_90" class="md-nav__link">
    按属性值（字符串）查询
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_91" class="md-nav__link">
    按属性值（映射）查询
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_92" class="md-nav__link">
    按属性值（数组）查询
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql-vs-nosql" class="md-nav__link">
    SQL vs NoSQL
  </a>
  
    <nav class="md-nav" aria-label="SQL vs NoSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sqlnosql" class="md-nav__link">
    统一SQL和NoSQL
  </a>
  
    <nav class="md-nav" aria-label="统一SQL和NoSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_93" class="md-nav__link">
    数据库特征
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_94" class="md-nav__link">
    操作特性
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_95" class="md-nav__link">
    核心功能
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_96" class="md-nav__link">
    线性扩展
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_97" class="md-nav__link">
    高性能
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_98" class="md-nav__link">
    事务
  </a>
  
    <nav class="md-nav" aria-label="事务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_99" class="md-nav__link">
    概述
  </a>
  
    <nav class="md-nav" aria-label="概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql" class="md-nav__link">
    BSQL
  </a>
  
    <nav class="md-nav" aria-label="BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_100" class="md-nav__link">
    概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_101" class="md-nav__link">
    典型命令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_102" class="md-nav__link">
    并发控制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_103" class="md-nav__link">
    失败时重试
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_104" class="md-nav__link">
    高性能调优
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_105" class="md-nav__link">
    可观测性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_106" class="md-nav__link">
    会话级设置
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql" class="md-nav__link">
    BCQL
  </a>
  
    <nav class="md-nav" aria-label="BCQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_107" class="md-nav__link">
    事务属性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cqlsh" class="md-nav__link">
    cqlsh使用示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#java_1" class="md-nav__link">
    JAVA使用示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_108" class="md-nav__link">
    关于线性化的注意事项
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql_1" class="md-nav__link">
    BSQL中的事务重试
  </a>
  
    <nav class="md-nav" aria-label="BSQL中的事务重试">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_109" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_110" class="md-nav__link">
    自动重试
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_111" class="md-nav__link">
    客户端重试
  </a>
  
    <nav class="md-nav" aria-label="客户端重试">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#40001-serializationfailure" class="md-nav__link">
    40001 - SerializationFailure
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#savepoints" class="md-nav__link">
    Savepoints
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_112" class="md-nav__link">
    不可重试的错误
  </a>
  
    <nav class="md-nav" aria-label="不可重试的错误">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#25001-specify-transaction-isolation-level" class="md-nav__link">
    25001 - Specify transaction isolation level
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25006-modify-a-row-in-a-read-only-transaction" class="md-nav__link">
    25006 - Modify a row in a read-only transaction
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25p02-infailedsqltransaction" class="md-nav__link">
    25P02 - InFailedSqlTransaction
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql_2" class="md-nav__link">
    BSQL中的性能调优
  </a>
  
    <nav class="md-nav" aria-label="BSQL中的性能调优">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_113" class="md-nav__link">
    快速单行事务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_114" class="md-nav__link">
    最大限度地减少冲突错误
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_115" class="md-nav__link">
    处理空闲应用程序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_116" class="md-nav__link">
    大型扫描和批处理作业
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_117" class="md-nav__link">
    乐观并发控制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_118" class="md-nav__link">
    存储过程：最大限度地减少往返
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_119" class="md-nav__link">
    全局应用程序的性能调优
  </a>
  
    <nav class="md-nav" aria-label="全局应用程序的性能调优">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#leader" class="md-nav__link">
    将Leader放在一个区域
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#follower" class="md-nav__link">
    follower读
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_120" class="md-nav__link">
    使用重复索引
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_121" class="md-nav__link">
    错误码
  </a>
  
    <nav class="md-nav" aria-label="错误码">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#25001-active-sql-transaction" class="md-nav__link">
    25001: Active SQL transaction
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25006-read-only-sql-transaction" class="md-nav__link">
    25006: Read only SQL transaction
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25p01-no-active-sql-transaction" class="md-nav__link">
    25P01: No active SQL transaction
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25p02-in-failed-sql-transaction" class="md-nav__link">
    25P02: In failed SQL transaction
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25p03-idle-in-transaction-session-timeout" class="md-nav__link">
    25P03: Idle in transaction session timeout
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#40001-serialization-failure" class="md-nav__link">
    40001: Serialization failure
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2d000-invalid-transaction-termination" class="md-nav__link">
    2D000: Invalid transaction termination
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3b001-invalid-savepoint-specification" class="md-nav__link">
    3B001: Invalid savepoint specification
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_122" class="md-nav__link">
    文本搜索
  </a>
  
    <nav class="md-nav" aria-label="文本搜索">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_123" class="md-nav__link">
    概述
  </a>
  
    <nav class="md-nav" aria-label="概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_124" class="md-nav__link">
    模式匹配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_125" class="md-nav__link">
    相似性搜索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_126" class="md-nav__link">
    全文搜索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_127" class="md-nav__link">
    拼音搜索
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_128" class="md-nav__link">
    模式匹配
  </a>
  
    <nav class="md-nav" aria-label="模式匹配">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_129" class="md-nav__link">
    部署
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_130" class="md-nav__link">
    后缀匹配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_131" class="md-nav__link">
    前缀匹配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#infix" class="md-nav__link">
    Infix匹配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_132" class="md-nav__link">
    不区分大小写的匹配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regex" class="md-nav__link">
    Regex匹配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_133" class="md-nav__link">
    单个字符匹配
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_134" class="md-nav__link">
    相似性搜索
  </a>
  
    <nav class="md-nav" aria-label="相似性搜索">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_135" class="md-nav__link">
    部署
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#levenshtein" class="md-nav__link">
    Levenshtein
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trigrams" class="md-nav__link">
    Trigrams
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_136" class="md-nav__link">
    全文搜索
  </a>
  
    <nav class="md-nav" aria-label="全文搜索">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_137" class="md-nav__link">
    部署
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_138" class="md-nav__link">
    分析文档
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_139" class="md-nav__link">
    分析搜索查询
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_140" class="md-nav__link">
    搜索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_141" class="md-nav__link">
    排名结果
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_142" class="md-nav__link">
    突出显示匹配项
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_143" class="md-nav__link">
    搜索多个列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_144" class="md-nav__link">
    存储已处理的文档
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gin" class="md-nav__link">
    使用GIN索引优化查询
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_145" class="md-nav__link">
    拼音搜索
  </a>
  
    <nav class="md-nav" aria-label="拼音搜索">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_146" class="md-nav__link">
    部署
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#soundex" class="md-nav__link">
    Soundex
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#metaphone" class="md-nav__link">
    Metaphone
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#double-metaphone" class="md-nav__link">
    Double Metaphone
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_147" class="md-nav__link">
    聚集
  </a>
  
    <nav class="md-nav" aria-label="聚集">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcql_1" class="md-nav__link">
    BCQL
  </a>
  
    <nav class="md-nav" aria-label="BCQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_148" class="md-nav__link">
    统计
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_149" class="md-nav__link">
    数字聚合函数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_150" class="md-nav__link">
    批处理操作
  </a>
  
    <nav class="md-nav" aria-label="批处理操作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcql_2" class="md-nav__link">
    BCQL
  </a>
  
    <nav class="md-nav" aria-label="BCQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_151" class="md-nav__link">
    插入数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_152" class="md-nav__link">
    查询数据
  </a>
  
    <nav class="md-nav" aria-label="查询数据">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_153" class="md-nav__link">
    范围查询
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#in" class="md-nav__link">
    IN
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#java_2" class="md-nav__link">
    Java应用示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#date-and-time" class="md-nav__link">
    Date and time
  </a>
  
    <nav class="md-nav" aria-label="Date and time">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_3" class="md-nav__link">
    BSQL
  </a>
  
    <nav class="md-nav" aria-label="BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_154" class="md-nav__link">
    介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_155" class="md-nav__link">
    特殊值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_156" class="md-nav__link">
    格式化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_157" class="md-nav__link">
    时区
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#timestamps" class="md-nav__link">
    Timestamps
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_158" class="md-nav__link">
    日期和时间间隔
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_159" class="md-nav__link">
    截断操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_160" class="md-nav__link">
    整合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-datestyle" class="md-nav__link">
    歧义-使用DateStyle
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_161" class="md-nav__link">
    日志
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_162" class="md-nav__link">
    结论
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_163" class="md-nav__link">
    字符串和文本
  </a>
  
    <nav class="md-nav" aria-label="字符串和文本">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_4" class="md-nav__link">
    BSQL
  </a>
  
    <nav class="md-nav" aria-label="BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_164" class="md-nav__link">
    介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_165" class="md-nav__link">
    字符数据类型
  </a>
  
    <nav class="md-nav" aria-label="字符数据类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_166" class="md-nav__link">
    转换
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_167" class="md-nav__link">
    文本使用
  </a>
  
    <nav class="md-nav" aria-label="文本使用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_168" class="md-nav__link">
    更改文本的显示
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_169" class="md-nav__link">
    解析原始文本
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_170" class="md-nav__link">
    填充与截断
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_171" class="md-nav__link">
    转义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_172" class="md-nav__link">
    编码和转换文本
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_173" class="md-nav__link">
    连接字符串
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_174" class="md-nav__link">
    分析用户输入
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_175" class="md-nav__link">
    替换文本
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_176" class="md-nav__link">
    提取文本
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_177" class="md-nav__link">
    正则表达式
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_178" class="md-nav__link">
    获取有关文本的信息
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_179" class="md-nav__link">
    高级应用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ttl" class="md-nav__link">
    数据过期的TTL
  </a>
  
    <nav class="md-nav" aria-label="数据过期的TTL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcql_3" class="md-nav__link">
    BCQL
  </a>
  
    <nav class="md-nav" aria-label="BCQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_180" class="md-nav__link">
    介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ttl_1" class="md-nav__link">
    表级TTL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ttl_2" class="md-nav__link">
    行级TTL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ttl_3" class="md-nav__link">
    列级TTL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ttl_4" class="md-nav__link">
    TTL的有效数据过期
  </a>
  
    <nav class="md-nav" aria-label="TTL的有效数据过期">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcql_4" class="md-nav__link">
    新BCQL数据集配置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql_5" class="md-nav__link">
    现有BCQL数据集配置
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_181" class="md-nav__link">
    最佳做法和故障排除
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ttl_5" class="md-nav__link">
    TTL相关命令和功能
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_182" class="md-nav__link">
    最佳实践
  </a>
  
    <nav class="md-nav" aria-label="最佳实践">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_5" class="md-nav__link">
    BSQL
  </a>
  
    <nav class="md-nav" aria-label="BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_183" class="md-nav__link">
    使用应用程序模式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_184" class="md-nav__link">
    共址
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_185" class="md-nav__link">
    使用覆盖索引加快读取速度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_186" class="md-nav__link">
    使用部分索引加快写入速度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_187" class="md-nav__link">
    具有唯一索引的不同键
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_188" class="md-nav__link">
    具有服务器级缓存的快序列
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_189" class="md-nav__link">
    快速单行事务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_190" class="md-nav__link">
    使用分区快速删除旧数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_191" class="md-nav__link">
    为分区键使用正确的数据类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_192" class="md-nav__link">
    尽可能使用多行插入
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upsert" class="md-nav__link">
    UPSERT 尽可能的多行
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_193" class="md-nav__link">
    使用智能驱动程序实现负载平衡和故障切换
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_194" class="md-nav__link">
    使用连接池扩展应用程序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql_6" class="md-nav__link">
    使用BSQL连接管理器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_195" class="md-nav__link">
    重复使用预编译语句的查询计划
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_196" class="md-nav__link">
    大型扫描和批处理作业
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_1" class="md-nav__link">
    JSONB数据类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_197" class="md-nav__link">
    跨分片并行
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#az" class="md-nav__link">
    单一可用性区域（AZ）部署
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_198" class="md-nav__link">
    行大小限制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_199" class="md-nav__link">
    列大小限制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#truncatedelete" class="md-nav__link">
    TRUNCATE表而不是DELETE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_200" class="md-nav__link">
    表和索引的数量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_201" class="md-nav__link">
    每台服务器的分片
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cicd" class="md-nav__link">
    CI和CD集成测试的设置
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql_6" class="md-nav__link">
    BCQL
  </a>
  
    <nav class="md-nav" aria-label="BCQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_202" class="md-nav__link">
    全局二级索引
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_203" class="md-nav__link">
    唯一索引
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_204" class="md-nav__link">
    覆盖索引
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#update-if-exists-" class="md-nav__link">
    使用UPDATE IF EXISTS的原子读-修改-写操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_2" class="md-nav__link">
    JSONB
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_205" class="md-nav__link">
    递增和递减数字类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ttl_6" class="md-nav__link">
    使用TTL自动使旧记录过期
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bmdb" class="md-nav__link">
    使用BMDB驱动程序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql_7" class="md-nav__link">
    利用BCQL客户端中的连接池
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_206" class="md-nav__link">
    使用预编译语句
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_207" class="md-nav__link">
    使用批处理提高吞吐量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_208" class="md-nav__link">
    列和行大小
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_209" class="md-nav__link">
    不要使用大型集合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_210" class="md-nav__link">
    具有许多元素的集合
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#partition_hash" class="md-nav__link">
    将partition_hash用于大型表扫描
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#truncatedelete_1" class="md-nav__link">
    TRUNCATE表而不是DELETE
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_211" class="md-nav__link">
    驱动与对象关系映射
  </a>
  
    <nav class="md-nav" aria-label="驱动与对象关系映射">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_212" class="md-nav__link">
    概述
  </a>
  
    <nav class="md-nav" aria-label="概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_213" class="md-nav__link">
    支持的库
  </a>
  
    <nav class="md-nav" aria-label="支持的库">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#java_3" class="md-nav__link">
    Java
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#go_1" class="md-nav__link">
    Go
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#python_1" class="md-nav__link">
    Python
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodejs_1" class="md-nav__link">
    Node.js
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c_3" class="md-nav__link">
    C
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c_4" class="md-nav__link">
    C++
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c_5" class="md-nav__link">
    C#
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ruby_1" class="md-nav__link">
    Ruby
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rust_1" class="md-nav__link">
    Rust
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#php_1" class="md-nav__link">
    PHP
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scala" class="md-nav__link">
    Scala
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql_7" class="md-nav__link">
    BSQL智能驱动程序
  </a>
  
    <nav class="md-nav" aria-label="BSQL智能驱动程序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_214" class="md-nav__link">
    主要功能
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_215" class="md-nav__link">
    概述
  </a>
  
    <nav class="md-nav" aria-label="概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_216" class="md-nav__link">
    使用外部负载平衡器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_217" class="md-nav__link">
    智能驱动的优势
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bmdb_1" class="md-nav__link">
    使用BMDB智能驱动程序
  </a>
  
    <nav class="md-nav" aria-label="使用BMDB智能驱动程序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_218" class="md-nav__link">
    支持集群的连接负载平衡
  </a>
  
    <nav class="md-nav" aria-label="支持集群的连接负载平衡">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_219" class="md-nav__link">
    启用负载平衡
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_220" class="md-nav__link">
    服务器刷新间隔
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_221" class="md-nav__link">
    拓扑感知连接负载平衡
  </a>
  
    <nav class="md-nav" aria-label="拓扑感知连接负载平衡">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_222" class="md-nav__link">
    拓扑键
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_223" class="md-nav__link">
    回退拓扑密钥
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_224" class="md-nav__link">
    连接池
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#java_4" class="md-nav__link">
    Java
  </a>
  
    <nav class="md-nav" aria-label="Java">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_225" class="md-nav__link">
    概述
  </a>
  
    <nav class="md-nav" aria-label="概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_226" class="md-nav__link">
    支持的项目
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_227" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_228" class="md-nav__link">
    应用连接
  </a>
  
    <nav class="md-nav" aria-label="应用连接">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_8" class="md-nav__link">
    BSQL
  </a>
  
    <nav class="md-nav" aria-label="BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb-jdbc" class="md-nav__link">
    BMDB JDBC智能驱动程序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#postgresql-jdbc" class="md-nav__link">
    PostgreSQL JDBC驱动
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#vertx-pg-client" class="md-nav__link">
    Vert.x Pg Client
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql_8" class="md-nav__link">
    BCQL
  </a>
  
    <nav class="md-nav" aria-label="BCQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb-java-310" class="md-nav__link">
    BMDB Java驱动 (3.10)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bmdb-java-415" class="md-nav__link">
    BMDB Java驱动 (4.15)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#orm" class="md-nav__link">
    使用ORM
  </a>
  
    <nav class="md-nav" aria-label="使用ORM">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#hibernate-orm" class="md-nav__link">
    Hibernate ORM
  </a>
  
    <nav class="md-nav" aria-label="Hibernate ORM">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#crud" class="md-nav__link">
    CRUD操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ebean-orm" class="md-nav__link">
    Ebean ORM
  </a>
  
    <nav class="md-nav" aria-label="Ebean ORM">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#crud_1" class="md-nav__link">
    CRUD操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mybatis" class="md-nav__link">
    MyBatis
  </a>
  
    <nav class="md-nav" aria-label="MyBatis">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#crud_2" class="md-nav__link">
    CRUD操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#go_2" class="md-nav__link">
    Go
  </a>
  
    <nav class="md-nav" aria-label="Go">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_229" class="md-nav__link">
    概述
  </a>
  
    <nav class="md-nav" aria-label="概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_230" class="md-nav__link">
    支持的项目
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_231" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_232" class="md-nav__link">
    应用连接
  </a>
  
    <nav class="md-nav" aria-label="应用连接">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_9" class="md-nav__link">
    BSQL
  </a>
  
    <nav class="md-nav" aria-label="BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb-pgx" class="md-nav__link">
    BMDB PGX智能驱动程序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pgx" class="md-nav__link">
    PGX 驱动
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pq" class="md-nav__link">
    PQ 驱动
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql_9" class="md-nav__link">
    BCQL
  </a>
  
    <nav class="md-nav" aria-label="BCQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb-go" class="md-nav__link">
    BMDB GO驱动
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#orm_1" class="md-nav__link">
    使用ORM
  </a>
  
    <nav class="md-nav" aria-label="使用ORM">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#gorm-orm" class="md-nav__link">
    GORM ORM
  </a>
  
    <nav class="md-nav" aria-label="GORM ORM">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#crud_3" class="md-nav__link">
    CRUD 操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg-orm" class="md-nav__link">
    PG ORM
  </a>
  
    <nav class="md-nav" aria-label="PG ORM">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#crud_4" class="md-nav__link">
    CRUD 操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#python_2" class="md-nav__link">
    Python
  </a>
  
    <nav class="md-nav" aria-label="Python">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_233" class="md-nav__link">
    概述
  </a>
  
    <nav class="md-nav" aria-label="概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_234" class="md-nav__link">
    支持的项目
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_235" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_236" class="md-nav__link">
    应用连接
  </a>
  
    <nav class="md-nav" aria-label="应用连接">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_10" class="md-nav__link">
    BSQL
  </a>
  
    <nav class="md-nav" aria-label="BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb-psycopg2" class="md-nav__link">
    BMDB Psycopg2 智能驱动程序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#postgresql-psycopg2" class="md-nav__link">
    PostgreSQL Psycopg2 驱动
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aiopg" class="md-nav__link">
    aiopg
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql_10" class="md-nav__link">
    BCQL
  </a>
  
    <nav class="md-nav" aria-label="BCQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb-python" class="md-nav__link">
    BMDB Python 驱动
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#orm_2" class="md-nav__link">
    使用ORM
  </a>
  
    <nav class="md-nav" aria-label="使用ORM">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sql-alchemy-orm" class="md-nav__link">
    SQL Alchemy ORM
  </a>
  
    <nav class="md-nav" aria-label="SQL Alchemy ORM">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#crud_5" class="md-nav__link">
    CRUD操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#django-orm" class="md-nav__link">
    Django ORM
  </a>
  
    <nav class="md-nav" aria-label="Django ORM">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#crud_6" class="md-nav__link">
    CRUD操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_237" class="md-nav__link">
    # 添加依赖项
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bmdborm" class="md-nav__link">
    # 实现BMDB的ORM映射
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_238" class="md-nav__link">
    # 运行应用程序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodejs_2" class="md-nav__link">
    Node.js
  </a>
  
    <nav class="md-nav" aria-label="Node.js">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_239" class="md-nav__link">
    概述
  </a>
  
    <nav class="md-nav" aria-label="概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_240" class="md-nav__link">
    支持的项目
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_241" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_242" class="md-nav__link">
    应用连接
  </a>
  
    <nav class="md-nav" aria-label="应用连接">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_11" class="md-nav__link">
    BSQL
  </a>
  
    <nav class="md-nav" aria-label="BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb-node-postgres" class="md-nav__link">
    BMDB node-postgres智能驱动程序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#postgresql-node-postgres" class="md-nav__link">
    PostgreSQL node-postgres驱动程序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql_11" class="md-nav__link">
    BCQL
  </a>
  
    <nav class="md-nav" aria-label="BCQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb-nodejs" class="md-nav__link">
    BMDB Node.js 驱动
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c_6" class="md-nav__link">
    C
  </a>
  
    <nav class="md-nav" aria-label="C">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_243" class="md-nav__link">
    概述
  </a>
  
    <nav class="md-nav" aria-label="概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_244" class="md-nav__link">
    支持的项目
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_245" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_246" class="md-nav__link">
    应用连接
  </a>
  
    <nav class="md-nav" aria-label="应用连接">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_12" class="md-nav__link">
    BSQL
  </a>
  
    <nav class="md-nav" aria-label="BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#libpq-c" class="md-nav__link">
    libpq C驱动程序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c_7" class="md-nav__link">
    C++
  </a>
  
    <nav class="md-nav" aria-label="C++">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_247" class="md-nav__link">
    概述
  </a>
  
    <nav class="md-nav" aria-label="概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_248" class="md-nav__link">
    支持的项目
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_249" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_250" class="md-nav__link">
    应用连接
  </a>
  
    <nav class="md-nav" aria-label="应用连接">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_13" class="md-nav__link">
    BSQL
  </a>
  
    <nav class="md-nav" aria-label="BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#libpqxx-c" class="md-nav__link">
    libpqxx C++驱动程序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql_12" class="md-nav__link">
    BCQL
  </a>
  
    <nav class="md-nav" aria-label="BCQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb-c" class="md-nav__link">
    BMDB C++ 驱动程序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c_8" class="md-nav__link">
    C#
  </a>
  
    <nav class="md-nav" aria-label="C#">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_251" class="md-nav__link">
    概述
  </a>
  
    <nav class="md-nav" aria-label="概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_252" class="md-nav__link">
    支持的项目
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_253" class="md-nav__link">
    应用连接
  </a>
  
    <nav class="md-nav" aria-label="应用连接">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_14" class="md-nav__link">
    BSQL
  </a>
  
    <nav class="md-nav" aria-label="BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb-npgsql" class="md-nav__link">
    BMDB Npgsql 智能驱动程序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#postgresql-npgsql-driver" class="md-nav__link">
    PostgreSQL Npgsql Driver
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql_15" class="md-nav__link">
    BSQL
  </a>
  
    <nav class="md-nav" aria-label="BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb-c_1" class="md-nav__link">
    BMDB C# 驱动程序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#orm_3" class="md-nav__link">
    使用ORM
  </a>
  
    <nav class="md-nav" aria-label="使用ORM">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#entity-framework-orm" class="md-nav__link">
    Entity Framework ORM
  </a>
  
    <nav class="md-nav" aria-label="Entity Framework ORM">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#crud_7" class="md-nav__link">
    CRUD 操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ruby_2" class="md-nav__link">
    Ruby
  </a>
  
    <nav class="md-nav" aria-label="Ruby">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_254" class="md-nav__link">
    概述
  </a>
  
    <nav class="md-nav" aria-label="概述">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_255" class="md-nav__link">
    支持的项目
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_256" class="md-nav__link">
    应用连接
  </a>
  
    <nav class="md-nav" aria-label="应用连接">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_16" class="md-nav__link">
    BSQL
  </a>
  
    <nav class="md-nav" aria-label="BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pg-gem" class="md-nav__link">
    Pg Gem驱动程序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql_13" class="md-nav__link">
    BCQL
  </a>
  
    <nav class="md-nav" aria-label="BCQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bmdb-ruby" class="md-nav__link">
    BMDB Ruby驱动程序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_257" class="md-nav__link">
    # 安装驱动
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ruby_3" class="md-nav__link">
    # 创建示例 Ruby 应用程序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_258" class="md-nav__link">
    # 运行应用程序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#orm_4" class="md-nav__link">
    使用 ORM
  </a>
  
    <nav class="md-nav" aria-label="使用 ORM">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#crud_8" class="md-nav__link">
    CRUD 操作
  </a>
  
    <nav class="md-nav" aria-label="CRUD 操作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#orm-examples" class="md-nav__link">
    克隆 orm-examples 存储库
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_259" class="md-nav__link">
    生成并运行应用程序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_260" class="md-nav__link">
    向应用程序发送请求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_261" class="md-nav__link">
    查询结果
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_262" class="md-nav__link">
    真实示例
  </a>
  
    <nav class="md-nav" aria-label="真实示例">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_263" class="md-nav__link">
    物联网车辆管理应用程序
  </a>
  
    <nav class="md-nav" aria-label="物联网车辆管理应用程序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_264" class="md-nav__link">
    概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_265" class="md-nav__link">
    场景
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_266" class="md-nav__link">
    应用程序体系结构
  </a>
  
    <nav class="md-nav" aria-label="应用程序体系结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#confluent-kafka-ksql-bmdbcky-stack" class="md-nav__link">
    Confluent Kafka, KSQL, 与BMDB(CKY Stack)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#spark-kafka-bmdbsky-stack" class="md-nav__link">
    Spark, Kafka, 与BMDB(SKY Stack)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#data-store" class="md-nav__link">
    Data store
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#data-producer" class="md-nav__link">
    Data producer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#data-processor" class="md-nav__link">
    Data processor
  </a>
  
    <nav class="md-nav" aria-label="Data processor">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ksql" class="md-nav__link">
    KSQL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#apache-spark-streaming" class="md-nav__link">
    Apache Spark streaming
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#data-dashboard" class="md-nav__link">
    Data dashboard
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_267" class="md-nav__link">
    总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_268" class="md-nav__link">
    服务质量
  </a>
  
    <nav class="md-nav" aria-label="服务质量">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_269" class="md-nav__link">
    速率限制连接
  </a>
  
    <nav class="md-nav" aria-label="速率限制连接">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_270" class="md-nav__link">
    限制每个租户的连接
  </a>
  
    <nav class="md-nav" aria-label="限制每个租户的连接">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_271" class="md-nav__link">
    设置数据库和用户
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_272" class="md-nav__link">
    限制每个数据库的连接数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_273" class="md-nav__link">
    测试连接限制
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_274" class="md-nav__link">
    写繁重的工作负载
  </a>
  
    <nav class="md-nav" aria-label="写繁重的工作负载">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_275" class="md-nav__link">
    确定写入暂停的原因
  </a>
  
    <nav class="md-nav" aria-label="确定写入暂停的原因">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#flushes" class="md-nav__link">
    Flushes滞后
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_276" class="md-nav__link">
    压实滞后
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#wal" class="md-nav__link">
    WAL写入太慢
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iops" class="md-nav__link">
    磁盘IOPS或带宽有限
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_277" class="md-nav__link">
    写入限制触发器
  </a>
  
    <nav class="md-nav" aria-label="写入限制触发器">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_278" class="md-nav__link">
    停止写入触发器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_279" class="md-nav__link">
    慢速写入触发器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_280" class="md-nav__link">
    准入控制触发和执行
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_281" class="md-nav__link">
    事务优先级
  </a>
  
    <nav class="md-nav" aria-label="事务优先级">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_282" class="md-nav__link">
    示例
  </a>
  
    <nav class="md-nav" aria-label="示例">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_283" class="md-nav__link">
    并发操作之间的事务优先级
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_284" class="md-nav__link">
    显示交易优先级类型
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_285" class="md-nav__link">
    云原生开发
  </a>
  
    <nav class="md-nav" aria-label="云原生开发">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#codespaces" class="md-nav__link">
    Codespaces
  </a>
  
    <nav class="md-nav" aria-label="Codespaces">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_286" class="md-nav__link">
    要求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_287" class="md-nav__link">
    启动应用程序入门
  </a>
  
    <nav class="md-nav" aria-label="启动应用程序入门">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_288" class="md-nav__link">
    初始化基本项目结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#crud-api" class="md-nav__link">
    完成CRUD API
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_289" class="md-nav__link">
    初始化代码空间
  </a>
  
    <nav class="md-nav" aria-label="初始化代码空间">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_290" class="md-nav__link">
    设置代码空间环境
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_291" class="md-nav__link">
    自定义代码空间环境
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_292" class="md-nav__link">
    总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gitpod" class="md-nav__link">
    Gitpod
  </a>
  
    <nav class="md-nav" aria-label="Gitpod">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_293" class="md-nav__link">
    要求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_294" class="md-nav__link">
    启动应用程序入门
  </a>
  
    <nav class="md-nav" aria-label="启动应用程序入门">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_295" class="md-nav__link">
    初始化基本项目结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#crud-api_1" class="md-nav__link">
    完成CRUD API
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gitpod_1" class="md-nav__link">
    初始化Gitpod
  </a>
  
    <nav class="md-nav" aria-label="初始化Gitpod">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#gitpod_2" class="md-nav__link">
    设置Gitpod环境
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gitpod_3" class="md-nav__link">
    自定义Gitpod环境
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_296" class="md-nav__link">
    总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#orms" class="md-nav__link">
    驱动和ORMs
  </a>
  
    <nav class="md-nav" aria-label="驱动和ORMs">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jdbc-drivers" class="md-nav__link">
    JDBC Drivers
  </a>
  
    <nav class="md-nav" aria-label="JDBC Drivers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_297" class="md-nav__link">
    下载驱动依赖
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_298" class="md-nav__link">
    基础知识
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_299" class="md-nav__link">
    示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_300" class="md-nav__link">
    其他示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodejs-drivers" class="md-nav__link">
    Node.js Drivers
  </a>
  
    <nav class="md-nav" aria-label="Node.js Drivers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_301" class="md-nav__link">
    下载驱动依赖
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_302" class="md-nav__link">
    基础知识
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_303" class="md-nav__link">
    示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c-drivers" class="md-nav__link">
    C# Drivers
  </a>
  
    <nav class="md-nav" aria-label="C# Drivers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_304" class="md-nav__link">
    下载驱动依赖
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_305" class="md-nav__link">
    基础知识
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#go-drivers" class="md-nav__link">
    Go Drivers
  </a>
  
    <nav class="md-nav" aria-label="Go Drivers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_306" class="md-nav__link">
    导入驱动包
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_307" class="md-nav__link">
    基础知识
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pgxpool-api" class="md-nav__link">
    使用 pgxpool API
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ssltls" class="md-nav__link">
    配置 SSL/TLS
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_308" class="md-nav__link">
    事务和隔离级别
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#python-drivers" class="md-nav__link">
    Python Drivers
  </a>
  
    <nav class="md-nav" aria-label="Python Drivers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_309" class="md-nav__link">
    下载驱动依赖
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_310" class="md-nav__link">
    基础知识
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_311" class="md-nav__link">
    示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rust-drivers" class="md-nav__link">
    Rust Drivers
  </a>
  
    <nav class="md-nav" aria-label="Rust Drivers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_312" class="md-nav__link">
    导入驱动程序依赖项
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_313" class="md-nav__link">
    基础知识
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_314" class="md-nav__link">
    示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ssltls_1" class="md-nav__link">
    配置 SSL/TLS
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#client-drivers-for-bsql" class="md-nav__link">
    Client drivers for BSQL
  </a>
  
    <nav class="md-nav" aria-label="Client drivers for BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#c_9" class="md-nav__link">
    C
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c_10" class="md-nav__link">
    C++
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#java_5" class="md-nav__link">
    Java
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#php_2" class="md-nav__link">
    PHP
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#python_3" class="md-nav__link">
    Python
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ruby_4" class="md-nav__link">
    Ruby
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rust_2" class="md-nav__link">
    Rust
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#client-drivers-for-bcql" class="md-nav__link">
    Client drivers for BCQL
  </a>
  
    <nav class="md-nav" aria-label="Client drivers for BCQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cc" class="md-nav__link">
    C/C++
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c_11" class="md-nav__link">
    C＃
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#go_3" class="md-nav__link">
    Go
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#java_6" class="md-nav__link">
    Java
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nodejs_3" class="md-nav__link">
    Node.js
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#python_4" class="md-nav__link">
    Python
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ruby_5" class="md-nav__link">
    Ruby
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scala_1" class="md-nav__link">
    Scala
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_315" class="md-nav__link">
    第三方工具
  </a>
  
    <nav class="md-nav" aria-label="第三方工具">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#apache-superset" class="md-nav__link">
    Apache Superset
  </a>
  
    <nav class="md-nav" aria-label="Apache Superset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_316" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#superset-aisql" class="md-nav__link">
    将 Superset 连接到 AiSQL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_317" class="md-nav__link">
    进一步使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#arctype" class="md-nav__link">
    Arctype
  </a>
  
    <nav class="md-nav" aria-label="Arctype">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_318" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#arctype_1" class="md-nav__link">
    安装Arctype
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_319" class="md-nav__link">
    创建数据库连接
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_320" class="md-nav__link">
    进一步使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbeaver" class="md-nav__link">
    DBeaver
  </a>
  
    <nav class="md-nav" aria-label="DBeaver">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_321" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql_17" class="md-nav__link">
    创建BSQL连接
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbschema" class="md-nav__link">
    DbSchema
  </a>
  
    <nav class="md-nav" aria-label="DbSchema">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_322" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbschema_1" class="md-nav__link">
    安装 DbSchema
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_323" class="md-nav__link">
    创建数据库连接
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_324" class="md-nav__link">
    进一步使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#metabase" class="md-nav__link">
    Metabase
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pgadmin" class="md-nav__link">
    pgAdmin
  </a>
  
    <nav class="md-nav" aria-label="pgAdmin">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_325" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pgadmin_1" class="md-nav__link">
    安装pgAdmin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pgadmin_2" class="md-nav__link">
    配置pgAdmin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_326" class="md-nav__link">
    进一步使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql-workbenchj" class="md-nav__link">
    SQL Workbench/J
  </a>
  
    <nav class="md-nav" aria-label="SQL Workbench/J">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_327" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql-workbenchj_1" class="md-nav__link">
    安装 SQL Workbench/J
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql-workbenchj_2" class="md-nav__link">
    配置 SQL Workbench/J
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_328" class="md-nav__link">
    进一步使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tableplus" class="md-nav__link">
    TablePlus
  </a>
  
    <nav class="md-nav" aria-label="TablePlus">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_329" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tableplus_1" class="md-nav__link">
    安装TablePlus
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_330" class="md-nav__link">
    创建连接
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bsql_18" class="md-nav__link">
    BSQL连接管理池
  </a>
  
    <nav class="md-nav" aria-label="BSQL连接管理池">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_331" class="md-nav__link">
    主要特征
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql_19" class="md-nav__link">
    使用 BSQL 连接管理器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="_1"><strong>应用开发</strong></h1>
<h2 id="_2"><strong>构建应用</strong></h2>
<p>应用程序使用API（也称为客户端驱动程序）连接到BMDB并与之交互。由于BMDB BSQL API与PostgreSQL兼容，并且BCQL API源于Apache Cassandra CQL，因此BMDB支持许多第三方驱动程序。
本节中的教程展示了，如何使用可用的驱动程序和ORM，将应用程序连接到BMDB。</p>
<h3 id="java"><strong>JAVA</strong></h3>
<p>以下教程显示了一个小型Java应用程序，该应用程序使用BMDB JDBC驱动程序连接到BMDB 集群，并执行基本的SQL操作。</p>
<h4 id="_3"><strong>先决条件</strong></h4>
<p>安装Java Development Kit (JDK) 1.8或更高版本。Linux和macOS的JDK安装程序可以从Oracle、Adoptium (OpenJDK)或Azul Systems (OpenJDK)下载，macOS上的Homebrew用户可以使用brew install openjdk进行安装。
安装Apache Maven 3.3或更高版本。 
从GitLab克隆应用程序
将示例应用程序克隆到您的计算机：</p>
<div class="highlight"><pre><span></span><code>git clone https://gitlab.bigmath.com/bigmath-Samples/bigmath-simple-java-app.git &amp;&amp; cd bigmath-simple-java-app
</code></pre></div>
<h4 id="_4"><strong>构建并运行应用</strong></h4>
<p>首先构建应用</p>
<div class="highlight"><pre><span></span><code>mvn clean package
</code></pre></div>
<p>启动应用</p>
<div class="highlight"><pre><span></span><code>java -cp target/bigmath-simple-java-app-1.0-SNAPSHOT.jar SampleApp
</code></pre></div>
<p>如果您在沙盒或单节点集群上运行应用程序，则驱动程序会显示一条警告，表明负载平衡失败,并将恢复到常规连接。</p>
<p>您应该可以看到类似的如下输出：</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt;&gt; Successfully connected to BMDB!
&gt;&gt;&gt;&gt; Successfully created DemoAccount table.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 10000
name = John, age = 28, country = Canada, balance = 9000

&gt;&gt;&gt;&gt; Transferred 800 between accounts.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 9200
name = John, age = 28, country = Canada, balance = 9800
</code></pre></div>
<h4 id="_5"><strong>分析应用程序逻辑</strong></h4>
<p>打开application/src/main/java/文件夹中的SampleApp.java文件，查看方法</p>
<h5 id="main"><strong>main</strong></h5>
<p>main方法通过BMDB JDBC驱动程序与集群建立连接。</p>
<div class="highlight"><pre><span></span><code>BMClusterAwareDataSource ds = new BMClusterAwareDataSource();

ds.setUrl(&quot;jdbc:bm-ctlb://&quot; + settings.getProperty(&quot;host&quot;) + &quot;:&quot;
    + settings.getProperty(&quot;port&quot;) + &quot;/bigmath&quot;);
ds.setUser(settings.getProperty(&quot;dbUser&quot;));
ds.setPassword(settings.getProperty(&quot;dbPassword&quot;));

// Additional SSL-specific settings. See the source code for details.

Connection conn = ds.getConnection();
</code></pre></div>
<h5 id="createdatabase"><strong>createDatabase</strong></h5>
<p>createDatabase方法使用PostgreSQL兼容的DDL命令来创建示例数据库。</p>
<div class="highlight"><pre><span></span><code>Statement stmt = conn.createStatement();

stmt.execute(&quot;CREATE TABLE IF NOT EXISTS &quot; + TABLE_NAME +
    &quot;(&quot; +
    &quot;id int PRIMARY KEY,&quot; +
    &quot;name varchar,&quot; +
    &quot;age int,&quot; +
    &quot;country varchar,&quot; +
    &quot;balance int&quot; +
    &quot;)&quot;);

stmt.execute(&quot;INSERT INTO &quot; + TABLE_NAME + &quot; VALUES&quot; +
    &quot;(1, &#39;Jessica&#39;, 28, &#39;USA&#39;, 10000),&quot; +
    &quot;(2, &#39;John&#39;, 28, &#39;Canada&#39;, 9000)&quot;);
</code></pre></div>
<h5 id="selectaccounts"><strong>selectAccounts</strong></h5>
<p>selectAccounts方法使用SQL SELECT语句查询分布式数据。</p>
<div class="highlight"><pre><span></span><code>Statement stmt = conn.createStatement();

ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM &quot; + TABLE_NAME);

while (rs.next()) {
    System.out.println(String.format(&quot;name = %s, age = %s, country = %s, balance = %s&quot;,
        rs.getString(2), rs.getString(3),
        rs.getString(4), rs.getString(5)));
}
</code></pre></div>
<h5 id="transfermoneybetweenaccounts"><strong>transferMoneyBetweenAccounts</strong></h5>
<p>transferMoneyBetweenAccounts 方法使用一致性分布式事务更新您的数据。</p>
<div class="highlight"><pre><span></span><code>Statement stmt = conn.createStatement();

try {
    stmt.execute(
        &quot;BEGIN TRANSACTION;&quot; +
            &quot;UPDATE &quot; + TABLE_NAME + &quot; SET balance = balance - &quot; + amount + &quot;&quot; + &quot; WHERE name = &#39;Jessica&#39;;&quot; +
            &quot;UPDATE &quot; + TABLE_NAME + &quot; SET balance = balance + &quot; + amount + &quot;&quot; + &quot; WHERE name = &#39;John&#39;;&quot; +
            &quot;COMMIT;&quot;
    );
} catch (SQLException e) {
    if (e.getSQLState().equals(&quot;40001&quot;)) {
        System.err.println(&quot;The operation is aborted due to a concurrent transaction that is&quot; +
            &quot; modifying the same set of rows. Consider adding retry logic for production-grade applications.&quot;);
        e.printStackTrace();
    } else {
        throw e;
    }
}
</code></pre></div>
<h3 id="go"><strong>Go</strong></h3>
<p>下面的教程展示了一个小型Go应用程序，它使用Go PostgreSQL驱动程序连接到BMDB集群，并执行基本的SQL操作。</p>
<h4 id="_6"><strong>先决条件</strong></h4>
<p>Go 版本：1.17.6
从GitLab克隆应用程序
将示例应用程序克隆到您的计算机：</p>
<div class="highlight"><pre><span></span><code>git clone https://gitlab.bigmath.com/bigmath-Samples/bigmath-simple-go-app.git &amp;&amp; cd bigmath-simple-go-app
</code></pre></div>
<h4 id="_7"><strong>构建并运行应用</strong></h4>
<p>首先初始化GO111MODULE变量</p>
<div class="highlight"><pre><span></span><code>mvn export GO111MODULE=auto
</code></pre></div>
<p>导入Go PostgreSQL驱动</p>
<div class="highlight"><pre><span></span><code>go get gitlab.bigmath.com/lib/pq
</code></pre></div>
<p>运行应用</p>
<div class="highlight"><pre><span></span><code>go run sample-app.go
</code></pre></div>
<p>您应该可以看到类似的如下输出：</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt;&gt; Successfully connected to BMDB!
&gt;&gt;&gt;&gt; Successfully created table DemoAccount.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 10000
name = John, age = 28, country = Canada, balance = 9000
&gt;&gt;&gt;&gt; Transferred 800 between accounts.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 9200
name = John, age = 28, country = Canada, balance = 9800
</code></pre></div>
<h4 id="_8"><strong>分析应用程序逻辑</strong></h4>
<p>打开bigmath-simple-go-app文件夹中的sample-app.go文件，查看方法</p>
<h5 id="main_1"><strong>main</strong></h5>
<p>main方法通过Go PostgreSQL驱动程序与集群建立连接。</p>
<div class="highlight"><pre><span></span><code>psqlInfo := fmt.Sprintf(&quot;host=%s port=%d user=%s password=%s dbname=%s&quot;,
    host, port, dbUser, dbPassword, dbName)

if sslMode != &quot;&quot; {
    psqlInfo += fmt.Sprintf(&quot; sslmode=%s&quot;, sslMode)

    if sslRootCert != &quot;&quot; {
        psqlInfo += fmt.Sprintf(&quot; sslrootcert=%s&quot;, sslRootCert)
    }
}

db, err := sql.Open(&quot;postgres&quot;, psqlInfo)
</code></pre></div>
<h5 id="createdatabase_1"><strong>createDatabase</strong></h5>
<p>createDatabase方法使用PostgreSQL兼容的DDL命令来创建一个示例数据库。</p>
<div class="highlight"><pre><span></span><code>Statement stmt = conn.createStatement();

stmt := `DROP TABLE IF EXISTS DemoAccount`
_, err := db.Exec(stmt)
checkIfError(err)

stmt = `CREATE TABLE DemoAccount (
                      id int PRIMARY KEY,
                      name varchar,
                      age int,
                      country varchar,
                      balance int)`

_, err = db.Exec(stmt)
checkIfError(err)

stmt = `INSERT INTO DemoAccount VALUES
              (1, &#39;Jessica&#39;, 28, &#39;USA&#39;, 10000),
              (2, &#39;John&#39;, 28, &#39;Canada&#39;, 9000)`

_, err = db.Exec(stmt)
checkIfError(err)
</code></pre></div>
<h5 id="selectaccounts_1"><strong>selectAccounts</strong></h5>
<p>selectAccounts方法使用SQL SELECT语句查询分布式数据。 </p>
<div class="highlight"><pre><span></span><code>rows, err := db.Query(&quot;SELECT name, age, country, balance FROM DemoAccount&quot;)
checkIfError(err)

defer rows.Close()

var name, country string
var age, balance int

for rows.Next() {
    err = rows.Scan(&amp;name, &amp;age, &amp;country, &amp;balance)
    checkIfError(err)

    fmt.Printf(&quot;name = %s, age = %v, country = %s, balance = %v\n&quot;,
        name, age, country, balance)
}
</code></pre></div>
<h5 id="transfermoneybetweenaccounts_1"><strong>transferMoneyBetweenAccounts</strong></h5>
<p>transferMoneyBetweenAccounts方法使用一致性分布式事务更新您的数据。</p>
<div class="highlight"><pre><span></span><code>tx, err := db.Begin()
checkIfError(err)

_, err = tx.Exec(`UPDATE DemoAccount SET balance = balance - $1 WHERE name = &#39;Jessica&#39;`, amount)
if checkIfTxAborted(err) {
    return
}
_, err = tx.Exec(`UPDATE DemoAccount SET balance = balance + $1 WHERE name = &#39;John&#39;`, amount)
if checkIfTxAborted(err) {
    return
}

err = tx.Commit()
if checkIfTxAborted(err) {
    return
}
</code></pre></div>
<h3 id="python"><strong>Python</strong></h3>
<p>以下教程显示了一个小型Python应用程序，该应用程序使用Python psycopg2 PostgreSQL数据库适配器连接到BMDB集群，并执行基本的SQL操作。</p>
<h4 id="_9"><strong>先决条件</strong></h4>
<p>Python 3.6或更高版本（如果在Apple silicon上运行macOS，则为Python 3.9.7或更高）。</p>
<p>从GitLab克隆应用程序：</p>
<div class="highlight"><pre><span></span><code>git clone https://gitlab.bigmath.com/bigmath-Samples/bigmath-simple-python-app.git &amp;&amp; cd bigmath-simple-python-app
</code></pre></div>
<h4 id="_10"><strong>构建并运行应用</strong></h4>
<p>安装psycopg2 PostgreSQL数据库适配器。</p>
<div class="highlight"><pre><span></span><code>pip3 install psycopg2-binary
</code></pre></div>
<p>启动应用</p>
<div class="highlight"><pre><span></span><code>python3 sample-app.py
</code></pre></div>
<p>您应该可以看到类似的如下输出：</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt;&gt; Successfully connected to BMDB!
&gt;&gt;&gt;&gt; Successfully created table DemoAccount.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 10000
name = John, age = 28, country = Canada, balance = 9000
&gt;&gt;&gt;&gt; Transferred 800 between accounts.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 9200
name = John, age = 28, country = Canada, balance = 9800
</code></pre></div>
<p>您已经成功地执行了一个基本Python应用程序。</p>
<h4 id="_11"><strong>分析应用程序逻辑</strong></h4>
<p>打开bigmath-simple-python-app文件夹中的sample-app.py文件，查看方法</p>
<h5 id="main_2"><strong>main</strong></h5>
<p>main方法通过Python PostgreSQL驱动程序与集群建立连接。</p>
<div class="highlight"><pre><span></span><code>try:
    if conf[&#39;sslMode&#39;] != &#39;&#39;:
        bm = psycopg2.connect(host=conf[&#39;host&#39;], port=conf[&#39;port&#39;], database=conf[&#39;dbName&#39;],
                                user=conf[&#39;dbUser&#39;], password=conf[&#39;dbPassword&#39;],
                                sslmode=conf[&#39;sslMode&#39;], sslrootcert=conf[&#39;sslRootCert&#39;],
                                connect_timeout=10)
    else:
        bm = psycopg2.connect(host=conf[&#39;host&#39;], port=conf[&#39;port&#39;], database=conf[&#39;dbName&#39;],
                                user=conf[&#39;dbUser&#39;], password=conf[&#39;dbPassword&#39;],
                                connect_timeout=10)
except Exception as e:
    print(&quot;Exception while connecting to BMDB&quot;)
    print(e)
    exit(1)
</code></pre></div>
<h5 id="createdatabase_2"><strong>createDatabase</strong></h5>
<p>createDatabase方法使用PostgreSQL兼容的DDL命令来创建一个示例数据库。</p>
<div class="highlight"><pre><span></span><code>try:
    with bm.cursor() as bm_cursor:
        bm_cursor.execute(&#39;DROP TABLE IF EXISTS DemoAccount&#39;)

        create_table_stmt = &quot;&quot;&quot;
            CREATE TABLE DemoAccount (
                id int PRIMARY KEY,
                name varchar,
                age int,
                country varchar,
                balance int
            )&quot;&quot;&quot;
        bm_cursor.execute(create_table_stmt)

        insert_stmt = &quot;&quot;&quot;
            INSERT INTO DemoAccount VALUES
                    (1, &#39;Jessica&#39;, 28, &#39;USA&#39;, 10000),
                    (2, &#39;John&#39;, 28, &#39;Canada&#39;, 9000)&quot;&quot;&quot;
        bm_cursor.execute(insert_stmt)
    bm.commit()
except Exception as e:
    print(&quot;Exception while creating tables&quot;)
    print(e)
    exit(1)
</code></pre></div>
<h5 id="select_accounts"><strong>select_accounts</strong></h5>
<p>select_accounts方法使用SQL SELECT语句查询分布式数据。</p>
<div class="highlight"><pre><span></span><code>with bm.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as bm_cursor:
        bm_cursor.execute(&quot;SELECT name, age, country, balance FROM DemoAccount&quot;)
        results = bm_cursor.fetchall()
        for row in results:
            print(&quot;name = {name}, age = {age}, country = {country}, balance = {balance}&quot;.format(**row))
</code></pre></div>
<h5 id="transfer_money_between_accounts"><strong>transfer_money_between_accounts</strong></h5>
<p>transfer_money_between_accounts方法使用一致性分布式事务更新您的数据。</p>
<div class="highlight"><pre><span></span><code>try:
    with bm.cursor() as bm_cursor:
        bm_cursor.execute(&quot;UPDATE DemoAccount SET balance = balance - %s WHERE name = &#39;Jessica&#39;&quot;, [amount])
        bm_cursor.execute(&quot;UPDATE DemoAccount SET balance = balance + %s WHERE name = &#39;John&#39;&quot;, [amount])
    bm.commit()
except (Exception, psycopg2.DatabaseError) as e:
    print(&quot;Exception while transferring money&quot;)
    print(e)
    if e.pgcode == 40001:
        print(&quot;The operation is aborted due to a concurrent transaction that is modifying the same set of rows.&quot; +
                &quot;Consider adding retry logic for production-grade applications.&quot;)
    exit(1)
</code></pre></div>
<h3 id="nodejs"><strong>Node.js</strong></h3>
<p>以下教程显示了一个小型Node.js应用程序，该应用程序使用node-postgres模块连接到BMDB集群，并执行基本的SQL操作。</p>
<h4 id="_12"><strong>先决条件</strong></h4>
<p>Node.js的最后版本。</p>
<p>从GitLab克隆应用程序：</p>
<div class="highlight"><pre><span></span><code>git clone https://gitlab.bigmath.com/bigmath-Samples/bigmath-simple-node-app.git &amp;&amp; cd bigmath-simple-node-app
</code></pre></div>
<h4 id="_13"><strong>构建并运行应用</strong></h4>
<p>安装 node-postgres模块。</p>
<div class="highlight"><pre><span></span><code>npm install pg
</code></pre></div>
<p>安装async 实用程序</p>
<div class="highlight"><pre><span></span><code>npm install --save async
</code></pre></div>
<p>启动应用</p>
<div class="highlight"><pre><span></span><code>node sample-app.js
</code></pre></div>
<p>您应该可以看到类似的如下输出：</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt;&gt; Successfully connected to BMDB!
&gt;&gt;&gt;&gt; Successfully created table DemoAccount.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 10000
name = John, age = 28, country = Canada, balance = 9000
&gt;&gt;&gt;&gt; Transferred 800 between accounts.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 9200
name = John, age = 28, country = Canada, balance = 9800
</code></pre></div>
<p>您已经成功地执行了一个基本Python应用程序。</p>
<h4 id="_14"><strong>分析应用程序逻辑</strong></h4>
<p>打开bigmath-simple-node-app文件夹中的sample-app.js文件，查看方法</p>
<h5 id="connect"><strong>connect</strong></h5>
<p>connect方法通过node-postgres驱动程序与集群建立连接。</p>
<div class="highlight"><pre><span></span><code>try {
    client = new pg.Client(config);

    await client.connect();

    console.log(&#39;&gt;&gt;&gt;&gt; Connected to BMDB!&#39;);

    callbackHadler();
} catch (err) {
    callbackHadler(err);
}
</code></pre></div>
<h5 id="createdatabase_3"><strong>createDatabase</strong></h5>
<p>createDatabase方法使用PostgreSQL兼容的DDL命令来创建一个示例数据库。</p>
<div class="highlight"><pre><span></span><code>try {
    var stmt = &#39;DROP TABLE IF EXISTS DemoAccount&#39;;

    await client.query(stmt);

    stmt = `CREATE TABLE DemoAccount (
        id int PRIMARY KEY,
        name varchar,
        age int,
        country varchar,
        balance int)`;

    await client.query(stmt);

    stmt = `INSERT INTO DemoAccount VALUES
        (1, &#39;Jessica&#39;, 28, &#39;USA&#39;, 10000),
        (2, &#39;John&#39;, 28, &#39;Canada&#39;, 9000)`;

    await client.query(stmt);

    console.log(&#39;&gt;&gt;&gt;&gt; Successfully created table DemoAccount.&#39;);

    callbackHadler();
} catch (err) {
    callbackHadler(err);
}
</code></pre></div>
<h5 id="selectaccounts_2"><strong>selectAccounts</strong></h5>
<p>selectAccounts方法使用SQL SELECT语句查询分布式数据。 </p>
<div class="highlight"><pre><span></span><code>try {
    const res = await client.query(&#39;SELECT name, age, country, balance FROM DemoAccount&#39;);
    var row;

    for (i = 0; i &lt; res.rows.length; i++) {
        row = res.rows[i];

        console.log(&#39;name = %s, age = %d, country = %s, balance = %d&#39;,
            row.name, row.age, row.country, row.balance);
    }

    callbackHadler();
} catch (err) {
    callbackHadler(err);
}
</code></pre></div>
<h5 id="transfermoneybetweenaccounts_2"><strong>transferMoneyBetweenAccounts</strong></h5>
<p>transferMoneyBetweenAccounts方法使用一致性分布式事务更新您的数据。</p>
<div class="highlight"><pre><span></span><code>try {
    await client.query(&#39;BEGIN TRANSACTION&#39;);

    await client.query(&#39;UPDATE DemoAccount SET balance = balance - &#39; + amount + &#39; WHERE name = \&#39;Jessica\&#39;&#39;);
    await client.query(&#39;UPDATE DemoAccount SET balance = balance + &#39; + amount + &#39; WHERE name = \&#39;John\&#39;&#39;);
    await client.query(&#39;COMMIT&#39;);

    console.log(&#39;&gt;&gt;&gt;&gt; Transferred %d between accounts.&#39;, amount);

    callbackHadler();
} catch (err) {
    callbackHadler(err);
}
</code></pre></div>
<h3 id="c"><strong>C</strong></h3>
<p>以下教程显示了一个小型C应用程序，该应用程序使用libpq 驱动程序连接到BMDB集群，并执行基本的SQL操作。</p>
<h4 id="_15"><strong>先决条件</strong></h4>
<ul>
<li>
<p>32位(x86)或64位(x64)体系结构的计算机。（使用Rosetta 构建和运行在苹果silicon上。）</p>
</li>
<li>
<p>gcc 4.1.2或更新版本，或clang 3.4或更新版本。</p>
</li>
<li>
<p>OpenSSL 1.1.1或更高版本（由libpq用于建立安全的SSL连接）。</p>
</li>
<li>
<p>libpq。macOS上的Homebrew用户可以使用brew install libpq进行安装。您可以从PostgreSQL Downloads中下载PostgreSQL二进制文件和源代码。</p>
</li>
</ul>
<p>从GitLab克隆应用程序：</p>
<div class="highlight"><pre><span></span><code>git clone https://gitlab.bigmath.com/bigmath-Samples/bigmath-simple-c-app.git &amp;&amp; cd bigmath-simple-c-app
</code></pre></div>
<h4 id="_16"><strong>构建并运行应用</strong></h4>
<p>使用gcc或clang构建应用程序。</p>
<div class="highlight"><pre><span></span><code>gcc sample-app.c -o sample-app -I&lt;path-to-libpq&gt;/libpq/include -L&lt;path-to-libpq&gt;/libpq/lib -lpq
</code></pre></div>
<p>将＜path-to-libpq＞替换为libpq 安装的路径；例如/usr/local/opt。 </p>
<p>启动应用</p>
<div class="highlight"><pre><span></span><code>./sample-app
</code></pre></div>
<p>您应该可以看到类似的如下输出：</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt;&gt; Successfully connected to BMDB!
&gt;&gt;&gt;&gt; Successfully created table DemoAccount.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 10000
name = John, age = 28, country = Canada, balance = 9000
&gt;&gt;&gt;&gt; Transferred 800 between accounts.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 9200
name = John, age = 28, country = Canada, balance = 9800
</code></pre></div>
<p>您已经成功地执行了一个基本C应用程序。</p>
<h4 id="_17"><strong>分析应用程序逻辑</strong></h4>
<p>打开bigmath-simple-c-app文件夹中的sample-app.c文件，查看方法</p>
<h5 id="connect_1"><strong>connect</strong></h5>
<p>connect方法通过libpq驱动程序与集群建立连接。</p>
<div class="highlight"><pre><span></span><code>PQinitSSL(1);

conn = PQconnectdb(CONN_STR);

if (PQstatus(conn) != CONNECTION_OK) {
    printErrorAndExit(conn, NULL);
}

printf(&quot;&gt;&gt;&gt;&gt; Successfully connected to BMDB!\n&quot;);

return conn;
</code></pre></div>
<h5 id="createdatabase_4"><strong>createDatabase</strong></h5>
<p>createDatabase方法使用PostgreSQL兼容的DDL命令来创建一个示例数据库。</p>
<div class="highlight"><pre><span></span><code>res = PQexec(conn, &quot;DROP TABLE IF EXISTS DemoAccount&quot;);

if (PQresultStatus(res) != PGRES_COMMAND_OK) {
    printErrorAndExit(conn, res);
}

res = PQexec(conn, &quot;CREATE TABLE DemoAccount ( \
                    id int PRIMARY KEY, \
                    name varchar, \
                    age int, \
                    country varchar, \
                    balance int)&quot;);

if (PQresultStatus(res) != PGRES_COMMAND_OK) {
    printErrorAndExit(conn, res);
}

res = PQexec(conn, &quot;INSERT INTO DemoAccount VALUES \
                    (1, &#39;Jessica&#39;, 28, &#39;USA&#39;, 10000), \
                    (2, &#39;John&#39;, 28, &#39;Canada&#39;, 9000)&quot;);

if (PQresultStatus(res) != PGRES_COMMAND_OK) {
    printErrorAndExit(conn, res);
}
</code></pre></div>
<h5 id="selectaccounts_3"><strong>selectAccounts</strong></h5>
<p>selectAccounts方法使用SQL SELECT语句查询分布式数据。 </p>
<div class="highlight"><pre><span></span><code>res = PQexec(conn, &quot;SELECT name, age, country, balance FROM DemoAccount&quot;);

if (PQresultStatus(res) != PGRES_TUPLES_OK) {
    printErrorAndExit(conn, res);
}

for (i = 0; i &lt; PQntuples(res); i++) {
    printf(&quot;name = %s, age = %s, country = %s, balance = %s\n&quot;,
        PQgetvalue(res, i, 0), PQgetvalue(res, i, 1), PQgetvalue(res, i, 2), PQgetvalue(res, i, 3));
}
</code></pre></div>
<h5 id="transfermoneybetweenaccounts_3"><strong>transferMoneyBetweenAccounts</strong></h5>
<p>transferMoneyBetweenAccounts方法使用一致性分布式事务更新您的数据。</p>
<div class="highlight"><pre><span></span><code>res = PQexec(conn, &quot;BEGIN TRANSACTION&quot;);
if (PQresultStatus(res) != PGRES_COMMAND_OK) {
    printErrorAndExit(conn, res);
}

res = PQexec(conn, &quot;UPDATE DemoAccount SET balance = balance - 800 WHERE name = \&#39;Jessica\&#39;&quot;);
if (PQresultStatus(res) != PGRES_COMMAND_OK) {
    printErrorAndExit(conn, res);
}

res = PQexec(conn, &quot;UPDATE DemoAccount SET balance = balance + 800 WHERE name = \&#39;John\&#39;&quot;);
if (PQresultStatus(res) != PGRES_COMMAND_OK) {
    printErrorAndExit(conn, res);
}

res = PQexec(conn, &quot;COMMIT&quot;);
if (PQresultStatus(res) != PGRES_COMMAND_OK) {
    printErrorAndExit(conn, res);
}
</code></pre></div>
<h3 id="c_1"><strong>C++</strong></h3>
<p>以下教程显示了一个小型C++应用程序，该应用程序使用libpqxx驱动程序连接到BMDB集群，并执行基本的SQL操作。</p>
<h4 id="_18"><strong>先决条件</strong></h4>
<ul>
<li>32位(x86)或64位(x64)体系结构的计算机。（使用Rosetta 构建和运行在苹果silicon上。）</li>
<li>gcc 4.1.2或更新版本，或clang 3.4或更新版本。</li>
<li>OpenSSL 1.1.1或更高版本（由libpqxx用于建立安全的SSL连接）。</li>
<li>libpq。macOS上的Homebrew用户可以使用brew install libpq进行安装。您可以从PostgreSQL Downloads中下载PostgreSQL二进制文件和源代码。</li>
<li>libpqxx. macOS上的Homebrew用户可以使用brew install libpqxx进行安装。参考构建libpqxx来构建自己的驱动。</li>
</ul>
<p>从GitLab克隆应用程序：</p>
<div class="highlight"><pre><span></span><code>git clone https://gitlab.bigmath.com/AiSQL-Samples/bigmath-simple-cpp-app.git &amp;&amp; cd bigmath-simple-cpp-app
</code></pre></div>
<h4 id="_19"><strong>构建并运行应用</strong></h4>
<p>使用gcc或clang构建应用程序。</p>
<div class="highlight"><pre><span></span><code>g++ -std=c++17 sample-app.cpp -o sample-app -lpqxx -lpq \
-I&lt;path-to-libpq&gt;/libpq/include -I&lt;path-to-libpqxx&gt;/libpqxx/include \
-L&lt;path-to-libpq&gt;/libpq/lib -L&lt;path-to-libpqxx&gt;/libpqxx/lib
</code></pre></div>
<p>将＜path-to-libpq＞替换为libpq 安装的路径；＜path-to-libpqxx＞替换为libpqxx 安装的路径。例如/usr/local/opt。 </p>
<p>启动应用</p>
<div class="highlight"><pre><span></span><code>./sample-app 
</code></pre></div>
<p>您应该可以看到类似的如下输出：</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt;&gt; Successfully connected to BMDB!
&gt;&gt;&gt;&gt; Successfully created table DemoAccount.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 10000
name = John, age = 28, country = Canada, balance = 9000
&gt;&gt;&gt;&gt; Transferred 800 between accounts.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 9200
name = John, age = 28, country = Canada, balance = 9800
</code></pre></div>
<p>您已经成功地执行了一个基本C++应用程序。</p>
<h4 id="_20"><strong>分析应用程序逻辑</strong></h4>
<p>打开bigmath-simple-cpp-app文件夹中的sample-app.cpp文件，查看方法</p>
<h5 id="connect_2"><strong>connect</strong></h5>
<p>connect方法通过libpqxx 驱动程序与集群建立连接。</p>
<div class="highlight"><pre><span></span><code>std::string url = &quot;host=&quot; + HOST + &quot; port=&quot; + PORT + &quot; dbname=&quot; + DB_NAME +
    &quot; user=&quot; + USER + &quot; password=&quot; + PASSWORD;

if (SSL_MODE != &quot;&quot;) {
    url += &quot; sslmode=&quot; + SSL_MODE;

    if (SSL_ROOT_CERT != &quot;&quot;) {
        url += &quot; sslrootcert=&quot; + SSL_ROOT_CERT;
    }
}

std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt; Connecting to BMDB!&quot; &lt;&lt; std::endl;

pqxx::connection *conn = new pqxx::connection(url);

std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt; Successfully connected to BMDB!&quot; &lt;&lt; std::endl;
</code></pre></div>
<h5 id="createdatabase_5"><strong>createDatabase</strong></h5>
<p>createDatabase方法使用PostgreSQL兼容的DDL命令来创建一个示例数据库。</p>
<div class="highlight"><pre><span></span><code>pqxx::work txn(*conn);

txn.exec(&quot;DROP TABLE IF EXISTS DemoAccount&quot;);

txn.exec(&quot;CREATE TABLE DemoAccount ( \
            id int PRIMARY KEY, \
            name varchar, \
            age int, \
            country varchar, \
            balance int)&quot;);

txn.exec(&quot;INSERT INTO DemoAccount VALUES \
            (1, &#39;Jessica&#39;, 28, &#39;USA&#39;, 10000), \
            (2, &#39;John&#39;, 28, &#39;Canada&#39;, 9000)&quot;);

txn.commit();
</code></pre></div>
<h5 id="selectaccounts_4"><strong>selectAccounts</strong></h5>
<p>selectAccounts方法使用SQL SELECT语句查询分布式数据。 </p>
<div class="highlight"><pre><span></span><code>res = txn.exec(&quot;SELECT name, age, country, balance FROM DemoAccount&quot;);

for (auto row: res) {
    std::cout
        &lt;&lt; &quot;name=&quot; &lt;&lt; row[&quot;name&quot;].c_str() &lt;&lt; &quot;, &quot;
        &lt;&lt; &quot;age=&quot; &lt;&lt; row[&quot;age&quot;].as&lt;int&gt;() &lt;&lt; &quot;, &quot;
        &lt;&lt; &quot;country=&quot; &lt;&lt; row[&quot;country&quot;].c_str() &lt;&lt; &quot;, &quot;
        &lt;&lt; &quot;balance=&quot; &lt;&lt; row[&quot;balance&quot;].as&lt;int&gt;() &lt;&lt; std::endl;
}
</code></pre></div>
<h5 id="transfermoneybetweenaccounts_4"><strong>transferMoneyBetweenAccounts</strong></h5>
<p>transferMoneyBetweenAccounts方法使用一致性分布式事务更新您的数据。</p>
<div class="highlight"><pre><span></span><code>try {
    pqxx::work txn(*conn);

    txn.exec(&quot;UPDATE DemoAccount SET balance = balance -&quot; + std::to_string(amount)
        + &quot; WHERE name = \&#39;Jessica\&#39;&quot;);

    txn.exec(&quot;UPDATE DemoAccount SET balance = balance +&quot; + std::to_string(amount)
        + &quot; WHERE name = \&#39;John\&#39;&quot;);

    txn.commit();

    std::cout &lt;&lt; &quot;&gt;&gt;&gt;&gt; Transferred &quot; &lt;&lt; amount &lt;&lt; &quot; between accounts.&quot; &lt;&lt; std::endl;
} catch (pqxx::sql_error const &amp;e) {
    if (e.sqlstate().compare(&quot;40001&quot;) == 0) {
        std::cerr &lt;&lt; &quot;The operation is aborted due to a concurrent transaction that is modifying the same set of rows.&quot;
                    &lt;&lt; &quot;Consider adding retry logic for production-grade applications.&quot; &lt;&lt; std::endl;
    }
    throw e;
}
</code></pre></div>
<h3 id="c_2"><strong>C#</strong></h3>
<p>以下教程显示了一个小型C#应用程序，该应用程序使用Npgsql驱动程序连接到BMDB集群，并执行基本的SQL操作。</p>
<h4 id="_21"><strong>先决条件</strong></h4>
<p>.NET 6.0 SDK或更新版本。</p>
<p>从GitLab克隆应用程序：</p>
<div class="highlight"><pre><span></span><code>git clone https://gitlab.bigmath.com/bigmath-Samples/bigmath-simple-csharp-app.git &amp;&amp; cd bigmath-simple-csharp-app
</code></pre></div>
<p>bigmath-simple-csharp-app.csproj文件中需要引用驱动程序的包</p>
<div class="highlight"><pre><span></span><code>&lt;PackageReference Include=&quot;npgsql&quot; Version=&quot;6.0.3&quot; /&gt;
</code></pre></div>
<h4 id="_22"><strong>构建并运行应用</strong></h4>
<p>构建并运行应用程序。</p>
<div class="highlight"><pre><span></span><code>dotnet run 
</code></pre></div>
<p>您应该可以看到类似的如下输出：</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt;&gt; Successfully connected to BMDB!
&gt;&gt;&gt;&gt; Successfully created table DemoAccount.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 10000
name = John, age = 28, country = Canada, balance = 9000
&gt;&gt;&gt;&gt; Transferred 800 between accounts.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 9200
name = John, age = 28, country = Canada, balance = 9800
</code></pre></div>
<p>您已经成功地执行了一个基本C#应用程序。</p>
<h4 id="_23"><strong>分析应用程序逻辑</strong></h4>
<p>打开bigmath-simple-csharp-app文件夹中的sample-app.cs文件，查看方法</p>
<h5 id="connect_3"><strong>connect</strong></h5>
<p>connect方法通过Npgsql 驱动程序与集群建立连接。为了避免对映射类型进行额外的系统表查询，ServerCompatibilityMode 设置为NoTypeLoading。</p>
<div class="highlight"><pre><span></span><code>NpgsqlConnectionStringBuilder urlBuilder = new NpgsqlConnectionStringBuilder();
urlBuilder.Host = &quot;&quot;;
urlBuilder.Port = 2521;
urlBuilder.Database = &quot;bigmath&quot;;
urlBuilder.Username = &quot;&quot;;
urlBuilder.Password = &quot;&quot;;
urlBuilder.SslMode = SslMode.VerifyFull;
urlBuilder.RootCertificate = &quot;&quot;;

urlBuilder.ServerCompatibilityMode = ServerCompatibilityMode.NoTypeLoading;

NpgsqlConnection conn = new NpgsqlConnection(urlBuilder.ConnectionString);

conn.Open();
</code></pre></div>
<h5 id="createdatabase_6"><strong>createDatabase</strong></h5>
<p>createDatabase方法使用PostgreSQL兼容的DDL命令来创建一个示例数据库。</p>
<div class="highlight"><pre><span></span><code>NpgsqlCommand query = new NpgsqlCommand(&quot;DROP TABLE IF EXISTS DemoAccount&quot;, conn);
query.ExecuteNonQuery();

query = new NpgsqlCommand(&quot;CREATE TABLE DemoAccount (&quot; +
            &quot;id int PRIMARY KEY,&quot; +
            &quot;name varchar,&quot; +
            &quot;age int,&quot; +
            &quot;country varchar,&quot; +
            &quot;balance int)&quot;, conn);
query.ExecuteNonQuery();

query = new NpgsqlCommand(&quot;INSERT INTO DemoAccount VALUES&quot; +
            &quot;(1, &#39;Jessica&#39;, 28, &#39;USA&#39;, 10000),&quot; +
            &quot;(2, &#39;John&#39;, 28, &#39;Canada&#39;, 9000)&quot;, conn);
query.ExecuteNonQuery();
</code></pre></div>
<h5 id="selectaccounts_5"><strong>selectAccounts</strong></h5>
<p>selectAccounts方法使用SQL SELECT语句查询分布式数据。 </p>
<div class="highlight"><pre><span></span><code>NpgsqlCommand query = new NpgsqlCommand(&quot;SELECT name, age, country, balance FROM DemoAccount&quot;, conn);

NpgsqlDataReader reader = query.ExecuteReader();

while (reader.Read())
{
    Console.WriteLine(&quot;name = {0}, age = {1}, country = {2}, balance = {3}&quot;,
        reader.GetString(0), reader.GetInt32(1), reader.GetString(2), reader.GetInt32(3));
}
</code></pre></div>
<h5 id="transfermoneybetweenaccounts_5"><strong>transferMoneyBetweenAccounts</strong></h5>
<p>transferMoneyBetweenAccounts方法使用一致性分布式事务更新您的数据。</p>
<div class="highlight"><pre><span></span><code>try
{
    NpgsqlTransaction tx = conn.BeginTransaction();

    NpgsqlCommand query = new NpgsqlCommand(&quot;UPDATE DemoAccount SET balance = balance - &quot; +
        amount + &quot; WHERE name = \&#39;Jessica\&#39;&quot;, conn, tx);
    query.ExecuteNonQuery();

    query = new NpgsqlCommand(&quot;UPDATE DemoAccount SET balance = balance + &quot; +
        amount + &quot; WHERE name = \&#39;John\&#39;&quot;, conn, tx);
    query.ExecuteNonQuery();

    tx.Commit();

    Console.WriteLine(&quot;&gt;&gt;&gt;&gt; Transferred &quot; + amount + &quot; between accounts&quot;);

} catch (NpgsqlException ex)
{
    if (ex.SqlState != null &amp;&amp; ex.SqlState.Equals(&quot;40001&quot;))
    {
        Console.WriteLine(&quot;The operation is aborted due to a concurrent transaction that is modifying the same set of rows.&quot; +
                &quot;Consider adding retry logic for production-grade applications.&quot;);
    }

    throw ex;
}
</code></pre></div>
<h3 id="ruby"><strong>Ruby</strong></h3>
<p>以下教程显示了一个小型Ruby应用程序，该应用程序使用Ruby Pg驱动程序连接到BMDB集群，并执行基本的SQL操作。</p>
<h4 id="_24"><strong>先决条件</strong></h4>
<ul>
<li>Ruby 3.1 或更新版本。</li>
<li>OpenSSL 1.1.1或更高版本（由libpq和pg用于建立安全的SSL连接）。</li>
<li>libpq. macOS上的Homebrew用户可以使用brew install libpq进行安装。您可以从PostgreSQL Downloads中下载PostgreSQL二进制文件和源代码。</li>
<li>Ruby pg. 要安装Ruby pg，请运行以下命令：</li>
</ul>
<div class="highlight"><pre><span></span><code>gem install pg -- --with-pg-include=&lt;path-to-libpq&gt;/libpq/include --with-pg-lib=&lt;path-to-libpq&gt;/libpq/lib
</code></pre></div>
<p>将＜path-to-libpq＞替换为libpq 安装的路径；例如/usr/local/opt。 </p>
<p>从GitLab克隆应用程序：</p>
<div class="highlight"><pre><span></span><code>git clone https://gitlab.bigmath.com/bigmath-Samples/bigmath-simple-ruby-app.git &amp;&amp; cd bigmath-simple-ruby-app
</code></pre></div>
<h4 id="_25"><strong>构建并运行应用</strong></h4>
<p>确认程序文件可执行。</p>
<div class="highlight"><pre><span></span><code>chmod +x sample-app.rb 
</code></pre></div>
<p>运行应用程序。</p>
<div class="highlight"><pre><span></span><code>./sample-app.rb 
</code></pre></div>
<p>您应该可以看到类似的如下输出：</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt;&gt; Successfully connected to BMDB!
&gt;&gt;&gt;&gt; Successfully created table DemoAccount.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 10000
name = John, age = 28, country = Canada, balance = 9000
&gt;&gt;&gt;&gt; Transferred 800 between accounts.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 9200
name = John, age = 28, country = Canada, balance = 9800
</code></pre></div>
<p>您已经成功地执行了一个基本Ruby应用程序。</p>
<h4 id="_26"><strong>分析应用程序逻辑</strong></h4>
<p>打开bigmath-simple-ruby-app 文件夹中的sample-app.rb文件，查看方法</p>
<h5 id="connect_4"><strong>connect</strong></h5>
<p>connect方法通过libpqxx驱动程序与集群建立连接。</p>
<div class="highlight"><pre><span></span><code>conn = PG.connect(
    host: &#39;&#39;,
    port: &#39;2521&#39;,
    dbname: &#39;bigmath&#39;,
    user: &#39;&#39;,
    password: &#39;&#39;,
    sslmode: &#39;verify-full&#39;,
    sslrootcert: &#39;&#39;
    );
</code></pre></div>
<h5 id="create_database"><strong>create_database</strong></h5>
<p>create_database方法使用PostgreSQL兼容的DDL命令来创建一个示例数据库。</p>
<div class="highlight"><pre><span></span><code>conn.exec(&quot;DROP TABLE IF EXISTS DemoAccount&quot;);

conn.exec(&quot;CREATE TABLE DemoAccount ( \
            id int PRIMARY KEY, \
            name varchar, \
            age int, \
            country varchar, \
            balance int)&quot;);

conn.exec(&quot;INSERT INTO DemoAccount VALUES \
            (1, &#39;Jessica&#39;, 28, &#39;USA&#39;, 10000), \
            (2, &#39;John&#39;, 28, &#39;Canada&#39;, 9000)&quot;);
</code></pre></div>
<h5 id="select_accounts_1"><strong>select_accounts</strong></h5>
<p>select_accounts方法使用SQL SELECT语句查询分布式数据。 </p>
<div class="highlight"><pre><span></span><code>begin
    puts &quot;&gt;&gt;&gt;&gt; Selecting accounts:\n&quot;;

    rs = conn.exec(&quot;SELECT name, age, country, balance FROM DemoAccount&quot;);

    rs.each do |row|
        puts &quot;name=%s, age=%s, country=%s, balance=%s\n&quot; % [row[&#39;name&#39;], row[&#39;age&#39;], row[&#39;country&#39;], row[&#39;balance&#39;]];
    end

ensure
    rs.clear if rs
end
</code></pre></div>
<h5 id="transfer_money_between_accounts_1"><strong>transfer_money_between_accounts</strong></h5>
<p>transferMoneyBetweenAccounts方法使用一致性分布式事务更新您的数据。</p>
<div class="highlight"><pre><span></span><code>begin
    conn.transaction do |txn|
        txn.exec_params(&quot;UPDATE DemoAccount SET balance = balance - $1 WHERE name = \&#39;Jessica\&#39;&quot;, [amount]);
        txn.exec_params(&quot;UPDATE DemoAccount SET balance = balance + $1 WHERE name = \&#39;John\&#39;&quot;, [amount]);
    end

    puts &quot;&gt;&gt;&gt;&gt; Transferred %s between accounts.\n&quot; % [amount];

rescue PG::TRSerializationFailure =&gt; e
    puts &quot;The operation is aborted due to a concurrent transaction that is modifying the same set of rows. \
            Consider adding retry logic for production-grade applications.&quot;;
    raise
end
</code></pre></div>
<h3 id="rust"><strong>Rust</strong></h3>
<p>以下教程显示了一个小型Rust应用程序，该应用程序使用Rust-Postgres驱动程序连接到BMDB集群，并执行基本的SQL操作。</p>
<h4 id="_27"><strong>先决条件</strong></h4>
<p>Rust开发环境。该示例应用程序是为Rust 1.58创建的，但应适用于早期和更高版本。</p>
<p>从GitLab克隆应用程序：</p>
<div class="highlight"><pre><span></span><code>git clone https://gitlab.bigmath.com/bigmath-Samples/bigmath-simple-rust-app.git &amp;&amp; cd bigmath-simple-rust-app
</code></pre></div>
<h4 id="_28"><strong>分析应用程序逻辑</strong></h4>
<p>打开bigmath-simple-rust-app/src 文件夹中的sample-app.rs 文件，查看方法</p>
<h5 id="connect_5"><strong>connect</strong></h5>
<p>connect方法通过Rust-Postgres驱动程序与集群建立连接。</p>
<div class="highlight"><pre><span></span><code>let mut cfg = Config::new();

cfg.host(HOST).port(PORT).dbname(DB_NAME).
    user(USER).password(PASSWORD).ssl_mode(SSL_MODE);

let mut builder = SslConnector::builder(SslMethod::tls())?;
builder.set_ca_file(SSL_ROOT_CERT)?;
let connector = MakeTlsConnector::new(builder.build());

let client = cfg.connect(connector)?;
</code></pre></div>
<h5 id="create_database_1"><strong>create_database</strong></h5>
<p>create_database方法使用PostgreSQL兼容的DDL命令来创建一个示例数据库。</p>
<div class="highlight"><pre><span></span><code>client.execute(&quot;DROP TABLE IF EXISTS DemoAccount&quot;, &amp;[])?;

client.execute(&quot;CREATE TABLE DemoAccount (
                id int PRIMARY KEY,
                name varchar,
                age int,
                country varchar,
                balance int)&quot;, &amp;[])?;

client.execute(&quot;INSERT INTO DemoAccount VALUES
                (1, &#39;Jessica&#39;, 28, &#39;USA&#39;, 10000),
                (2, &#39;John&#39;, 28, &#39;Canada&#39;, 9000)&quot;, &amp;[])?;
</code></pre></div>
<h5 id="select_accounts_2"><strong>select_accounts</strong></h5>
<p>select_accounts方法使用SQL SELECT语句查询分布式数据。 </p>
<div class="highlight"><pre><span></span><code>for row in client.query(&quot;SELECT name, age, country, balance FROM DemoAccount&quot;, &amp;[])? {
    let name: &amp;str = row.get(&quot;name&quot;);
    let age: i32 = row.get(&quot;age&quot;);
    let country: &amp;str = row.get(&quot;country&quot;);
    let balance: i32 = row.get(&quot;balance&quot;);

    println!(&quot;name = {}, age = {}, country = {}, balance = {}&quot;,
        name, age, country, balance);
}
</code></pre></div>
<h5 id="transfer_money_between_accounts_2"><strong>transfer_money_between_accounts</strong></h5>
<p>transfer_money_between_accounts方法使用一致性分布式事务更新您的数据。</p>
<div class="highlight"><pre><span></span><code>let mut txn = client.transaction()?;

let exec_txn = || -&gt; Result&lt;(), DBError&gt; {
    txn.execute(&quot;UPDATE DemoAccount SET balance = balance - $1 WHERE name = \&#39;Jessica\&#39;&quot;, &amp;[&amp;amount])?;
    txn.execute(&quot;UPDATE DemoAccount SET balance = balance + $1 WHERE name = \&#39;John\&#39;&quot;, &amp;[&amp;amount])?;
    txn.commit()?;

    Ok(())
};
</code></pre></div>
<h3 id="php"><strong>PHP</strong></h3>
<p>以下教程显示了一个小型PHP应用程序，该应用程序使用php-pgsql 驱动程序连接到BMDB集群，并执行基本的SQL操作。</p>
<h4 id="_29"><strong>先决条件</strong></h4>
<ul>
<li>PHP运行时。示例应用程序是使用PHP8.1创建的，但应该可以与早期和更高版本一起使用。</li>
<li>php-pgsql驱动</li>
<li>Ubuntu用户可以使用sudo apt-get install php-pgsql命令安装驱动程序。</li>
<li>CentOS用户可以使用sudo yum install php-pgsql命令安装驱动程序。</li>
</ul>
<p>从GitLab克隆应用程序：</p>
<div class="highlight"><pre><span></span><code>git clone https://gitlab.bigmath.com/bigmath-Samples/bigmath-simple-php-app.git &amp;&amp; cd bigmath-simple-php-app
</code></pre></div>
<h4 id="_30"><strong>运行应用</strong></h4>
<p>运行应用程序。</p>
<div class="highlight"><pre><span></span><code>php sample-app.php 
</code></pre></div>
<p>您应该可以看到类似的如下输出：</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt;&gt; Successfully connected to BMDB!
&gt;&gt;&gt;&gt; Successfully created table DemoAccount.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 10000
name = John, age = 28, country = Canada, balance = 9000
&gt;&gt;&gt;&gt; Transferred 800 between accounts.
&gt;&gt;&gt;&gt; Selecting accounts:
name = Jessica, age = 28, country = USA, balance = 9200
name = John, age = 28, country = Canada, balance = 9800
</code></pre></div>
<p>您已经成功地执行了一个基本PHP应用程序。</p>
<h4 id="_31"><strong>分析应用程序逻辑</strong></h4>
<p>打开bigmath-simple-php-app文件夹中的sample-app.php文件，查看方法</p>
<h5 id="connect_6"><strong>connect</strong></h5>
<p>connect方法通过php-pgsql驱动程序与集群建立连接。</p>
<div class="highlight"><pre><span></span><code>$conn = new PDO(&#39;pgsql:host=&#39; . HOST . &#39;;port=&#39; . PORT . &#39;;dbname=&#39; . DB_NAME .
                &#39;;sslmode=&#39; . SSL_MODE . &#39;;sslrootcert=&#39; . SSL_ROOT_CERT,
                USER, PASSWORD,
                array(PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION,
                        PDO::ATTR_EMULATE_PREPARES =&gt; true,
                        PDO::ATTR_PERSISTENT =&gt; true));
</code></pre></div>
<h5 id="create_database_2"><strong>create_database</strong></h5>
<p>create_database方法使用PostgreSQL兼容的DDL命令来创建一个示例数据库。</p>
<div class="highlight"><pre><span></span><code>$conn-&gt;exec(&#39;DROP TABLE IF EXISTS DemoAccount&#39;);

$conn-&gt;exec(&#39;CREATE TABLE DemoAccount (
                id int PRIMARY KEY,
                name varchar,
                age int,
                country varchar,
                balance int)&#39;);

$conn-&gt;exec(&quot;INSERT INTO DemoAccount VALUES
                (1, &#39;Jessica&#39;, 28, &#39;USA&#39;, 10000),
                (2, &#39;John&#39;, 28, &#39;Canada&#39;, 9000)&quot;);
</code></pre></div>
<h5 id="select_accounts_3"><strong>select_accounts</strong></h5>
<p>select_accounts方法使用SQL SELECT语句查询分布式数据。 </p>
<div class="highlight"><pre><span></span><code>$query = &#39;SELECT name, age, country, balance FROM DemoAccount&#39;;

foreach ($conn-&gt;query($query) as $row) {
    print &#39;name=&#39; . $row[&#39;name&#39;] . &#39;, age=&#39; . $row[&#39;age&#39;] . &#39;, country=&#39; . $row[&#39;country&#39;] . &#39;, balance=&#39; . $row[&#39;balance&#39;] . &quot;\n&quot;;
}
</code></pre></div>
<h5 id="transfer_money_between_accounts_3"><strong>transfer_money_between_accounts</strong></h5>
<p>transfer_money_between_accounts方法使用一致性分布式事务更新您的数据。</p>
<div class="highlight"><pre><span></span><code>try {
    $conn-&gt;beginTransaction();
    $conn-&gt;exec(&quot;UPDATE DemoAccount SET balance = balance - &quot; . $amount . &quot; WHERE name = &#39;Jessica&#39;&quot;);
    $conn-&gt;exec(&quot;UPDATE DemoAccount SET balance = balance + &quot; . $amount . &quot; WHERE name = &#39;John&#39;&quot;);
    $conn-&gt;commit();
    print &quot;&gt;&gt;&gt;&gt; Transferred &quot; . $amount . &quot; between accounts\n&quot;;
} catch (PDOException $e) {
    if ($e-&gt;getCode() == &#39;40001&#39;) {
        print &quot;The operation is aborted due to a concurrent transaction that is modifying the same set of rows.
                Consider adding retry logic for production-grade applications.\n&quot;;
    }

    throw $e;
}
</code></pre></div>
<h2 id="_32"><strong>构建全局应用程序</strong></h2>
<p>互联网和云技术已经彻底改变了人们的互动和操作方式，云引入了跨多个地理位置分发和复制数据的可能性，访问和维护全局分布的数据需要新的全局应用程序。</p>
<h3 id="_33"><strong>对全局应用程序的需求</strong></h3>
<p>使应用程序全局化的原因与采用分布式数据库的原因相同：</p>
<ul>
<li>业务连续性和灾难恢复。公共云已经取得了长足的进步，但区域和区域停机仍然相当常见，每年发生一到两次（例如，参见AWS停机和谷歌停机）。要向用户提供不间断的服务，您需要在多个位置运行应用程序。</li>
<li>用于法规遵从性的数据驻留。为了遵守数据保护法（例如GDPR），您需要确保公民的数据存储在其所在国家的服务器上。这意味着您需要设计相应的应用程序，以便在不同地区间拆分数据。</li>
<li>将数据移动到离用户更近的位置。在设计具有全局影响力的应用程序（例如，电子邮件、电子商务或奥运会等广播活动）时，您需要考虑用户的位置。如果您的应用程序托管在中国的数据中心，欧洲的用户在尝试访问您的应用软件时可能会遇到高延迟。为了提供最佳的用户体验，您需要在离用户更近的地方运行应用程序。 </li>
</ul>
<h4 id="_34"><strong>应用程序设计模式</strong></h4>
<p>在多个数据中心中运行应用程序并在这些数据中心之间拆分数据，这不是一项微不足道的任务。在设计全局应用程序时，您需要回答以下问题：</p>
<ul>
<li>应用程序的多个实例将如何在不同的域（区域/数据中心）中运行？</li>
<li>应用程序实例是相同的还是不同的？</li>
<li>这些应用程序将如何跨地理位置部署？</li>
<li>每个实例是在整个数据集上操作，还是仅在数据的一个子集上操作？</li>
<li>是否允许冲突的应用程序更新？如果是，如何处理这些问题？</li>
<li>应用程序将如何发展？</li>
<li>在默认域出现故障时，应用程序将如何运行？</li>
</ul>
<p>为了帮助您回答这些问题，请使用以下体系结构概念为您的应用程序选择合适的设计模式。</p>
<h4 id="_35"><strong>应用程序体系结构</strong></h4>
<p>根据应用程序实例运行的位置和活动的应用程序实例，从以下应用程序体系结构中进行选择：</p>
<ul>
<li>单活-一个区域（或默认域）中只有一个应用程序实例处于活动状态。数据必须放置在该应用程序附近。失败时，应用程序将移动到另一个区域</li>
<li>多活-应用程序在不同的区域运行，并在整个数据集上运行。</li>
<li>只读多活-只有一个应用程序实例处于活动状态，而其他应用程序实例可以提供过时的读取。</li>
<li>分区多活-多个应用程序在多个区域中运行，仅对一个子集的数据进行操作 </li>
</ul>
<h4 id="_36"><strong>可用性体系结构</strong></h4>
<p>根据应用程序实例是在整个数据集上运行还是仅在一个子集上运行，以及应用程序在默认域故障中的移动方式，从以下可用性体系结构中进行选择：</p>
<ul>
<li>跟随应用程序—只有一个应用程序实例处于活动状态，而其他实例（一个或多个）可以提供过时的读取。</li>
<li>地理本地数据集-应用程序作用于地理位置的本地数据。出现故障时，应用程序不会移动</li>
</ul>
<h4 id="_37"><strong>数据访问架构</strong></h4>
<p>根据应用程序应该读取最新数据还是旧数据，从以下数据访问体系结构中进行选择：</p>
<ul>
<li>一致性读-无论延迟或位置如何，都可以从真实的来源进行读取。</li>
<li>Follower读-延时读，以实现更低的延迟读取。</li>
<li>副本读—允许旧数据的读取，但有旧数据的界限 </li>
</ul>
<h3 id="_38"><strong>选择正确的模式</strong></h3>
<p>根据上一节中描述的体系结构，使用以下矩阵选择设计模式 </p>
<table>
<thead>
<tr>
<th>模式类型</th>
<th>应用程序遵循</th>
<th>地理本地数据集</th>
</tr>
</thead>
<tbody>
<tr>
<td>单活</td>
<td>全局数据库 双活单主</td>
<td></td>
</tr>
<tr>
<td>多活</td>
<td>全局数据库 重复索引</td>
<td>双活多主</td>
</tr>
<tr>
<td>只读多活</td>
<td>延迟优化的地理分区</td>
<td>局部优化的地理分区</td>
</tr>
<tr>
<td>分区多活</td>
<td>一致性读 Follower读 副本读</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="_39"><strong>设计模式</strong></h3>
<p>下表总结了可用于应用程序的设计模式。使用这些经过验证的模式来解决常见问题并加快应用程序开发。</p>
<table>
<thead>
<tr>
<th>模式名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>全局数据库</td>
<td>分布在多个地区的单个数据库分布在多个（3个或更多）地区或区域中的数据库。失败时，另一个地区/区域中的复制副本将在几秒钟内升级为领导者，而不会丢失任何数据。应用程序从真正的来源进行读取，可能具有较高的延迟。</td>
</tr>
<tr>
<td>重复索引</td>
<td>任意地方数据都一致在多个区域中使用与表相同的架构设置覆盖索引，以在本地立即读取一致性的数据。</td>
</tr>
<tr>
<td>双活单主</td>
<td>可以提供读取服务的辅助数据库设置第二个异步填充的集群，以便在主集群出现故障时开始提供数据服务。</td>
</tr>
<tr>
<td>双活多主</td>
<td>两个集群一起提供数据服务。两个或多个区域，手动故障切换，几秒钟的数据丢失（非零RPO），低读/写延迟，事务保证的一些警告。</td>
</tr>
<tr>
<td>延迟优化的地理分区</td>
<td>快速本地访问对数据进行分区并放置，以便可以更快地访问属于附近用户的数据。</td>
</tr>
<tr>
<td>局部优化的地理分区</td>
<td>遵守当地法律对数据进行分区并放置数据，使属于不同用户的行位于他们各自的国家/地区。</td>
</tr>
<tr>
<td>Follower读</td>
<td>快速、旧数据的读取从本地追随者那里读取，而不是去找其他地区的领导者进行读取。</td>
</tr>
<tr>
<td>读副本</td>
<td>从只读群集快速读取建立一个单独的追随者集群，进行本地读取，而不是去找不同地区的领导者进行读取。</td>
</tr>
</tbody>
</table>
<h3 id="_40"><strong>图例</strong></h3>
<p>本节中的所有插图都使用以下图例来表示Tile的领导者和追随者、云区域和区域以及应用程序。</p>
<p><img alt="" src="./media/chapter3/1.png" /></p>
<h2 id="_41"><strong>构建多云应用程序</strong></h2>
<h3 id="_42"><strong>概述</strong></h3>
<p>大多数组织选择单一的云提供商（或私有数据中心）来部署其应用程序。但这可能会导致供应商锁定，云提供商的功能集和增长可能会成为增长的瓶颈。 
<img alt="" src="./media/chapter3/2.png" /></p>
<h4 id="_43"><strong>多云需求</strong></h4>
<p>采用多云策略的主要目标是为您提供针对每个特定工作负载使用最佳计算环境的灵活性。多云策略有多种好处，包括以下方面：
* 避免供应商锁定。摆脱依赖单一提供商的限制，获得在任何地方构建基础设施的自由。
* 特定于应用程序的优化。根据应用程序的需求与不同云的特定功能和特性对齐。您可以考虑速度、性能、可靠性、地理位置、安全性和合规性等因素，从而调整您的云环境以最适合您的独特需求。
* 将成本降至最低。通过利用各种云提供商提供的最佳定价和性能组合的优势来降低成本。
* 高可用性。一个云提供商的中断不一定意味着应用程序中断，因为流量可以无缝重定向到另一个准备好的云，从而确保不间断的操作。
* 更接近用户。并非所有云提供商的数据中心都靠近不同地区的用户。通过从不同的云提供商中选择数据中心，您可以为所有用户提供更好的体验。
* 数据合规性。当地数据保护法要求公民数据存储在本国。如果一个云提供商在您需要的地区没有数据中心，另一个提供商可能会有。
* 灵活性。如果您无法在特定的地理位置使用当前的云提供商，那么准备好多云会使切换到另一个提供商变得更简单。 </p>
<h4 id="_44"><strong>构建多云应用程序</strong></h4>
<p>虽然多云方法提供了许多优势，但管理复杂性的提高以及跨多个云实现一致性的性能和可靠性带来了巨大挑战。
AiSQL旨在应对这些挑战。多云管理功能已直接集成到AiSQL、AiSQL Anywhere和AiSQL Managed中。此集成提供了数据库在所有云环境中的全面可见性，使您能够监控成本和使用情况，实施一致性的安全控制和策略，并无缝管理工作负载。</p>
<p>设置：要了解如何在不同的云上设置AiSQL，请参阅<a href="#_多云设置">多云设置</a>。</p>
<p>部署：设置好多云后，您需要根据可用性和数据访问需求，为应用程序选择合适的设计模式。有关更多详细信息，请参阅<a href="#_构建全局应用程序">全局应用程序</a>。</p>
<h4 id="_45"><strong>混合云</strong></h4>
<p>从私有数据中心到公共云不是瞬时的，这需要花费大量的时间和计划。第一步是将一些选定的应用程序移动到公共云，同时将其余应用程序保留在私有数据中心。 
这种混合方法在现代设施设置中越来越普遍。在云迁移过程中，经常采用混合云实现，以逐步、有条理地转换其应用程序和数据。混合云环境能够继续使用本地服务，同时利用公共云提供商提供的灵活数据存储和应用程序访问选项的优点。 
要了解如何在混合云环境中设置AiSQL，请参阅<a href="#_混合云_1">混合云</a>。</p>
<h4 id="_46"><strong>云间迁移</strong></h4>
<p>根据您的应用程序或组织的需要，您可能希望从一个云提供商迁移到另一个，或者从本地数据中心迁移到公共云。考虑到不同云提供商之间的差异，这可能是一项艰巨的任务。
AiSQL提供了基本的模式来实现无缝迁移。您可以设置两个独立的Universe，并从旧的数据中心复制到新的数据中心。或者，您可以在所有数据中心中设置全局数据库，然后使用数据放置策略将数据库配置为仅使用特定的数据中心。有关更多详细信息，请参见<a href="#_多云迁移">多云迁移</a>。 </p>
<h3 id="_47"><strong>多云设置</strong></h3>
<p>您可以创建一个跨越多个地理区域和云提供商的多云AiSQL universe，以下部分描述了如何使用bm-ctl或AiSQL Anywhere中的传统提供商来设置多云universe。 </p>
<h4 id="_48"><strong>拓扑结构</strong></h4>
<p>例如，您可以在AWS（us-west）、GCP（us-central）和Azure（us-east）之间建立一个6节点的universe ，复制因子为5。 
<img alt="" src="./media/chapter3/3.png" />VPC对等：尽管在当前示例中，您不必设置VPC 对等，但为了使不同的云能够相互通信，您需要通过VPN隧道设置多云VPC 对等。详细信息请参见设置VPC对等。 </p>
<h4 id="universe"><strong>设置多云universe</strong></h4>
<p>例如，在AWS、GCP和Azure中设置一个6节点的universe，每个universe有2个节点。</p>
<ol>
<li>第一个云- AWS
如果本地universe当前正在运行，请首先将其销毁。
首先，创建单个节点，如下所示： </li>
</ol>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl start \
                --advertise_address=127.0.0.1 \
                --base_dir=/tmp/ydb-aws-1 \
                --cloud_location=aws.us-west-2.us-west-2a;
</code></pre></div>
<p>在macOS上，额外的节点需要配置环回地址，如下所示：</p>
<div class="highlight"><pre><span></span><code>sudo ifconfig lo0 alias 127.0.0.2
</code></pre></div>
<p>如下开启第二个节点：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl start \
                --advertise_address=127.0.0.2 \
                --base_dir=/tmp/ydb-aws-2 \
                --cloud_location=aws.us-west-2.us-west-2a \
                --join=127.0.0.1
</code></pre></div>
<ol>
<li>第二个云 - GCP</li>
</ol>
<p>在macOS上，节点需要配置环回地址，如下所示：</p>
<div class="highlight"><pre><span></span><code>sudo ifconfig lo0 alias 127.0.0.3
sudo ifconfig lo0 alias 127.0.0.4
</code></pre></div>
<p>按如下方式启动第一个节点：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl start \
                --advertise_address=127.0.0.3 \
                --base_dir=/tmp/ydb-gcp-1 \
                --cloud_location=gcp.us-central-1.us-central-1a \
                --join=127.0.0.1
</code></pre></div>
<p>按如下方式启动第二个节点：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl start \
                --advertise_address=127.0.0.4 \
                --base_dir=/tmp/ydb-gcp-2 \
                --cloud_location=gcp.us-central-1.us-central-1a \
                --join=127.0.0.1
</code></pre></div>
<ol>
<li>第三个云 - Azure
在macOS上，节点需要配置环回地址，如下所示：</li>
</ol>
<div class="highlight"><pre><span></span><code>sudo ifconfig lo0 alias 127.0.0.5
sudo ifconfig lo0 alias 127.0.0.6
</code></pre></div>
<p>按如下方式启动第一个节点：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl start \
                --advertise_address=127.0.0.5 \
                --base_dir=/tmp/ydb-azu-1 \
                --cloud_location=azu.us-east-1.us-east-1a \
                --join=127.0.0.1
</code></pre></div>
<p>按如下方式启动第二个节点：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl start \
                --advertise_address=127.0.0.6 \
                --base_dir=/tmp/ydb-azu-2 \
                --cloud_location=azu.us-east-1.us-east-1a \
                --join=127.0.0.1
</code></pre></div>
<p>在所有节点上启动bm-ctl进程后，配置universe的数据放置约束，如下所示： </p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl configure data_placement --base_dir=/tmp/ydb-azu-1 --fault_tolerance=zone --rf 5
</code></pre></div>
<p>这个命令可以在任何已经启动AiSQL的节点上执行。</p>
<p>要检查正在运行的多节点universe的状态，请运行以下命令：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl status --base_dir=/tmp/ydb-azu-1
</code></pre></div>
<p>您应该有一个6节点集群，每个云提供商中有2个节点，如下所示： </p>
<p><img alt="" src="./media/chapter3/4.png" /></p>
<h4 id="_49"><strong>多云应用</strong></h4>
<p>场景：假设您有执行交易的零售应用程序，并希望将其部署在离east和west地区的用户更近的地方。这两个应用程序都需要欺诈检测，需要速度快。
部署：您可以从全局应用程序的设计模式列表中进行选择，以便使用以下设置设计您的多云应用程序。
当您希望您的零售应用程序更接近用户时，您可以将它们部署在AWS（us-west）和AZU（us-east）的数据中心。由于这两个系统都需要快速的欺诈检测，而且各地区相距甚远，您可以选择在GCP上部署欺诈检测基础设施，如下所示：</p>
<p><img alt="" src="./media/chapter3/5.png" /></p>
<h4 id="_50"><strong>混合云</strong></h4>
<p>您还可以使用私有数据中心和公共云的组合来部署应用程序。例如，您可以在传统提供商上处理数据中心部署零售应用程序，在公共云中部署欺诈检测系统。有关更多信息，请参阅<a href="#_混合云_2">混合云</a>。 </p>
<h4 id="_51"><strong>故障转移</strong></h4>
<p>在区域故障时，根据您为设置选择的应用程序设计模式，多云AiSQL universe 将自动故障转移到其余任何一个云区域。在上面的示例中，如果您将首选区域的顺序设置为aws:1 azu:2，那么当aws失败时，应用程序将移动到azu，并且应用程序将使用us-east的数据为用户提供服务，而不会丢失任何数据。 </p>
<p><img alt="" src="./media/chapter3/6.png" />
您可以选择距离较近的区域，以避免故障切换延迟的增加。</p>
<h3 id="_52"><strong>多云迁移</strong></h3>
<p>在不同的云之间迁移数据。</p>
<p>将应用程序从传统的数据中心移动到公共云，或从一个公共云移动到另一个，是一项不简单的任务。AiSQL 为您提供了一个简单的模式，可以相对轻松地完成这项任务</p>
<h4 id="_53"><strong>两个云间迁移</strong></h4>
<p>为了进行说明，请考虑一个场景，其中您在AWS（us-west）部署了一个3节点集群，并希望迁移到GCP（us-central）。
<img alt="" src="./media/chapter3/7.png" />要完成迁移，请使用xDCR功能，该功能提供从一个universe 到另一个universe 的单向异步复制。在这种情况下，AWS将是来源，GCP宇宙将是目标。</p>
<ol>
<li>
<p>设置universe 
使用以下设置程序在AWS中设置源universe，在GCP中设置目标universe 
完成后，记下源宇宙和目标universes的universe-uuids</p>
</li>
<li>
<p>引导新universe 
GCP universe设置完成后，您需要从AWS universe填充数据。这个过程通常被称为引导。</p>
</li>
</ol>
<p>基本引导流程如下：
A. 为AWS领域中的所有表创建一个检查点。例如：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-admin -master_addresses &lt;AWS_universe_master_addresses&gt; \
        bootstrap_cdc_producer &lt;comma_separated_source_universe_table_ids&gt;
</code></pre></div>
<p>B. 对AWS universe 上的表进行备份，并将它们恢复到GCP universe 中。</p>
<p>这确保了AWS universe 中的当前数据被正确复制到GCP universe </p>
<ol>
<li>建立复制
在您的数据从AWS universe 预填充到GCP universe 后，您需要设置从AWS到GCP universe 的复制流。
设置复制的简单方法如下：</li>
</ol>
<p><div class="highlight"><pre><span></span><code>./bin/bm-admin -master_addresses &lt;GCP_universe_master_addresses&gt; setup_universe_replication \
  &lt;AWS_universe_uuid&gt;_&lt;replication_stream_name&gt; &lt;AWS_universe_master_addresses&gt; \
  &lt;comma_separated_source_universe_table_ids&gt; &lt;comma_separated_bootstrap_ids&gt;
</code></pre></div>
<img alt="" src="./media/chapter3/8.png" />对AWS universe 的任何数据更改都会自动应用于GCP universe 。注意：对于此示例，DDL更改必须手动应用。</p>
<ol>
<li>切换到新的universe 
在新universe赶上旧universe的数据后，你可以切换到新的universe。
切换的基本流程如下：</li>
<li>使用基本技术验证数据是否已成功迁移，例如验证两个Universe中对应表的行数是否相同（例如SELECT count（*））。</li>
<li>停止到旧universe的应用程序访问，以确保不再尝试更改数据。</li>
<li>暂停在新universe上的复制。</li>
<li>将GCP universe 提升为ACTIVE。例如：</li>
</ol>
<div class="highlight"><pre><span></span><code>./bin/bm-admin \
    -master_addresses &lt;GCP_master_addresses&gt; \
    -certs_dir_name &lt;cert_dir&gt; \
    change_xDCR_role ACTIVE
</code></pre></div>
<p>您可以将应用程序指向GCP中的新universe ，然后停止复制。
<img alt="" src="./media/chapter3/9.png" />在这一点上，您可以拆除您的AWS universe，也可以将其转换为备用集群进行灾难恢复，方法是设置从新的GCP universe 到AWS universe 的xDCR复制</p>
<h4 id="_54"><strong>从传统数据中心迁移</strong></h4>
<p>您可以使用相同的过程将数据从传统的数据中心迁移到公共云。在完全迁移到公共云之前，您可能需要考虑混合云。有关更多详细信息，请参阅<a href="#_混合云_2">混合云</a></p>
<h3 id="_55"><strong>混合云</strong></h3>
<p>许多在数字化现代化之旅中的第一步是将一些应用程序转移到公共云，同时仍在私人数据中心运行许多应用程序。公共云和私有数据中心的混合云环境的这种设置通常被称为混合云。
在云迁移过程中，经常采用混合云实现，以逐步、有条理地转换其应用程序和数据。混合云环境能够继续使用传统服务，同时利用公共云提供商提供的灵活数据存储和应用程序访问选项的优点。
下图显示了一个基本的混合云，包括两个传统数据中心和一个公共云。
<img alt="" src="./media/chapter3/10.png" /></p>
<h4 id="_56"><strong>混合云的优点</strong></h4>
<p>混合云方法非常适合利用公共云提供的可扩展性和存在性，同时将数据保留在本地以遵守数据监管法律。以下是采用混合云的几个关键好处：
* 逐步现代化：使用混合云，您可以灵活地以自己喜欢的速度将应用程序迁移到云，使您能够随着时间的推移逐步实现技术基础设施的现代化。
* 法规遵从性：许多行业都有关于应用程序和数据的操作位置的特定法规。混合云环境使您能够在遵守法规要求的同时使用私有云和公共云。
* 遗留应用程序支持：您可能有难以迁移到云的遗留系统。混合云允许您通过将应用程序保留在本地来适应这些系统。
* 边缘计算能力：零售或电信等行业通常需要低延迟的边缘计算，例如在信息亭或网络边缘位置运行应用程序。使用混合方法，您可以在边缘运行选定的应用程序，以满足这些特定需求。
* 最新技术：混合云模型提供了利用人工智能和机器学习等尖端技术的机会，而无需扩展或更换当前的基础设施。
通过采用混合云方法，您可以利用公共云和私有云的优势，定制您的基础设施以满足法规遵从性、操作限制和对延迟敏感的要求。</p>
<h4 id="_57"><strong>混合云部署模式</strong></h4>
<p>每一种混合云策略都必须适应您组织的特定需求，同时考虑到工作负载、法规遵从性和可用性。使用以下模式来绘制将应用程序移动到公共云的路径。</p>
<p>对于这个示例，假设您在us-west和us-east有两个数据中心，并且您在GCP的us-central添加了一个区域。
1. 将琐碎的工作负载转移到公共云上
混合云策略的一个关键好处是，您可以将应用程序从本地数据中心缓慢迁移到公共云。这个过程的第一阶段可能是将一些应用程序转移到公共云。例如，假设您有两个本地数据中心，AiSQL部署用于您的生产和测试应用程序，如下所示：
<img alt="" src="./media/chapter3/11.png" />
作为数据中心现代化和扩展的一部分，您可以在您没有业务的地区（例如，us-central）选择一家公共云提供商，并将您的测试应用程序转移到该公共云，如下所示：
<img alt="" src="./media/chapter3/12.png" /></p>
<p>此举具有多重优势：
* 您可以在不影响生产系统的情况下测试新的公共数据中心。
* 您不需要花费时间和金钱在us-central建立数据中心，而是利用现有的云基础设施来增加您在us-central的影响力。
* 将一个新的公共云添加到您的环境中，并将不太重要的工作负载转移到其中，这为在本地数据中心中运行其他重要工作负载开辟了可能性。 </p>
<ol>
<li>
<p>将资源密集型工作负载转移到公共云上
在测试了添加到基础设施中的新公共云之后，您可以开始将更重要和资源密集型的应用程序（如机器学习逻辑/流处理等）转移到新采用的公共云。 
<img alt="" src="./media/chapter3/13.png" />将资源密集型应用程序转移到公共云的原因，是更容易切换到公共云提供的强大节点实例。例如，AWS实例类型和GCP实例类型。 </p>
</li>
<li>
<p>在混合云上传播应用程序
在您对管理新添加的公共云感到满意并对其性能感到满意后，将主数据库分布在本地数据中心和公共云上是一个不错的选择，如下图所示：
<img alt="" src="./media/chapter3/14.png" /></p>
</li>
</ol>
<p>通过此设置，您可以获得一个全局数据库，使您的数据在两个本地数据中心和公共云之间保持一致，并允许所有数据中心中运行的所有应用程序访问您的数据。在这种情况下，您可以将本地数据中心设置为首选zone-1，将公共云设置为第二首选区域。</p>
<h4 id="_58"><strong>故障转移</strong></h4>
<p>由于您已将公共云设置为第二个首选区域，如果us-west的主要本地数据中心失败，位于us-central的GCP地区的分片follower将被提升为leader，您的应用程序可以继续为您的用户服务，而不会有任何数据丢失。 
<img alt="" src="./media/chapter3/15.png" /></p>
<h2 id="_59"><strong>常见模式</strong></h2>
<p>BMDB是一个分布式数据库，通过BSQL和BCQL API提供数据访问。尽管它支持这些复杂的API，但它下面是一个NoSQL存储。这使得BMDB自然适合于时间序列、键值和宽列等多种数据模型。
以下部分介绍了如何利用通用数据模型来设计健壮高效的应用程序。</p>
<h3 id="_60"><strong>概述</strong></h3>
<h4 id="_61">时间序列数据</h4>
<p>时间序列数据模型满足了大型事件数据场景对保留事件排序和海量存储的特殊需求。时间序列实际上是按时间排序的一系列事件或消息。事件数据可以是可变大小的，BMDB可以出色地处理大量数据。在BMDB中，数据被排序并按顺序写入磁盘。当按行键然后按范围检索数据时，由于磁盘寻道次数最少，因此可以获得快速高效的访问模式。时间序列数据非常适合这种类型的模式。
一个很好的示例是汽车中的速度传感器，它可以跟踪汽车的速度并将数据发送到远程系统进行跟踪。</p>
<div class="highlight"><pre><span></span><code>&quot;car1&quot; , &quot;2023-05-01 01:00:00&quot;, 35
&quot;car1&quot; , &quot;2023-05-01 01:01:00&quot;, 40
&quot;car1&quot; , &quot;2023-05-01 01:02:00&quot;, 42
&quot;car2&quot; , &quot;2023-05-06 01:00:00&quot;, 60
&quot;car2&quot; , &quot;2023-05-06 01:01:00&quot;, 65
&quot;car2&quot; , &quot;2023-05-06 01:01:00&quot;, 70
</code></pre></div>
<p>保险公司可以使用这些数据来调查事故，或者汽车公司可以跟踪各种传感器并提高汽车的性能。这可能相当于数十亿个数据点。</p>
<p>有关在BMDB中存储和检索如此大量有序数据的更多信息，请参阅<a href="#_时间序列">时间序列数据模型</a> </p>
<h4 id="_62"><strong>键值</strong></h4>
<p>在键值数据模型中，每个键都与一个且仅与一个值相关联。BMDB内部将数据存储为键值对的集合，因此自动成为键值存储。
因为在键值存储中，每个键只有一个值，所以键通常被定义为多个参数的组合。例如，为了存储用户的详细信息，可以采用以下模式：</p>
<div class="highlight"><pre><span></span><code>user1.name = &quot;John Wick&quot;
user1.country = &quot;CN&quot;
user2.name = &quot;Harry Potter&quot;
user2.country = &quot;UK&quot;
</code></pre></div>
<p>关键值存储有望成为一些速度最快的存储数据模型。有关将BMDB用于键值存储的更多信息，请参阅<a href="#_键值_1">键值数据模型</a>。</p>
<h4 id="_63"><strong>宽列</strong></h4>
<p>在宽列数据模型中，数据被组织为行和列。每一行由行id或名称标识，每一列由列id或名称识别。每一行可以附加任意数量的列。您可以将其可视化为一个类似表格的结构，其中一些单元格为空。例如：</p>
<div class="highlight"><pre><span></span><code>|       | col-1 | col-2 | col-3 |
| ----- | ----- | ----- | ----- |
| row-1 | a     |       | c     |
| row-2 | e     | f     | g     |
| row-3 | z     |       |       |
</code></pre></div>
<p>要检索特定单元格，可以发出类似于以下命令的命令：</p>
<div class="highlight"><pre><span></span><code>get(row-1, col-3) ==&gt; c
get(row-3, col-2) ==&gt; NULL
</code></pre></div>
<h3 id="_64"><strong>时间序列</strong></h3>
<p>时间序列数据是随着时间的推移而被跟踪和监控的测量值或事件。这可能是服务器指标、应用程序性能监控、网络数据、传感器数据、事件、点击、市场交易以及许多其他类型的分析数据。时间序列数据模型是专门为处理按时间排序的大量数据而设计的。
尽管BMDB默认情况下是哈希分片的，但它也支持范围分片，即在特定边界对数据进行排序和分割。
时间序列模式最适用于需要查找给定时间范围内的范围查询。
您可以使用以下常见模式以分布式和有序的方式，在BMDB中存储和检索时间序列数据： </p>
<ul>
<li>按时间排序的订单
  在这种模式中，您的所有数据都是按时间在不同的分片上排序的。
  要了解如何以这种模式高效地存储和检索数据，请参阅按时间全局排序。</li>
<li>按每个实体的时间排序
  在这种模式中，数据在特定实体中按时间排序。
  要了解如何有效地分发实体并避免热分片，请参阅按每个实体的时间排序。 </li>
<li>自动数据过期
  在某些情况下，您不希望数据长期存在，因为这些数据可能不需要，或者您的组织中有规则规定，您不能存储超过特定持续时间的特定数据。对于这种情况，可以对行、列和表本身设置生存时间值。
  有关更多详细信息，请参阅自动数据过期。</li>
<li>分区
  当你有很多数据需要定期删除时，你可以选择对数据进行分区。在某些情况下，这也具有速度优势。
  有关更多详细信息，请参阅按时间分区。</li>
</ul>
<h4 id="_65"><strong>按时间排序的订单</strong></h4>
<p>了解如何通过分片来分布整个时间排序数据集，并高效检索数据。</p>
<ol>
<li>基于时间戳的分布
   考虑一个速度指标跟踪系统，它跟踪来自许多汽车的速度传感器的数据。</li>
</ol>
<p>创建一个具有示例架构的表，如下所示：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE global_order1 (
    ts timestamp, /* time at which the event was generated */
    car varchar, /* name of the car */
    speed int, /* speed of your car */
    PRIMARY KEY(ts ASC)
);
</code></pre></div>
<p>global_order1表存储不同车辆到达时的速度数据点。</p>
<p>在表中插入一些样本数据，如下所示：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO global_order1 (ts, car, speed)
        (SELECT &#39;2023-07-01 00:00:00&#39;::timestamp + make_interval(secs=&gt;id),
            &#39;car-&#39; || ceil(random()*2), ceil(random()*60)
            FROM generate_series(1,100) AS id);
</code></pre></div>
<p>从表中检索一些数据，如下所示： </p>
<div class="highlight"><pre><span></span><code>SELECT * FROM global_order1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>         ts          |  car  | speed
---------------------+-------+-------
 2023-07-01 00:00:01 | car-1 |    50
 2023-07-01 00:00:02 | car-2 |    25
 2023-07-01 00:00:03 | car-1 |    39
 2023-07-01 00:00:04 | car-1 |    49
 2023-07-01 00:00:05 | car-2 |     3
 2023-07-01 00:00:06 | car-2 |    22
 2023-07-01 00:00:07 | car-2 |    25
 2023-07-01 00:00:08 | car-1 |    58
 2023-07-01 00:00:09 | car-2 |    55
</code></pre></div>
<p>请注意数据是如何按时间自动排序的。这是因为表被设置为按PRIMARY KEY（ts ASC）在ts上排序。这样可以确保数据经过排序，并且附近的所有数据都位于同一分片中。此顺序使范围查询能够高效地检索特定时间范围内的所有数据。例如：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM global_order1 WHERE ts &gt; &#39;2023-07-01 00:01:00&#39; AND ts &lt; &#39;2023-07-01 00:01:05&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>         ts          |  car  | speed
---------------------+-------+-------
 2023-07-01 00:01:01 | car-1 |    21
 2023-07-01 00:01:02 | car-2 |    58
 2023-07-01 00:01:03 | car-1 |    57
 2023-07-01 00:01:04 | car-2 |    60
</code></pre></div>
<p>随着数据量的增长，分片会进行拆分，并将一半数据移动到不同的分片，从而确保可扩展性。这也意味着数据在移动到下一个分片之前会在一个分片中增长。然而，由于特定范围可能在单个分片中，这可能导致一个分片成为热分片。</p>
<ol>
<li>基于bucket的分配
   要在不同的分片上分发有序的数据，可以使用基于存储bucket的分发，将数据拆分为存储bucket，然后进行分发。
   要做到这一点，请修改表以包括一个值范围很小的bucketid字段，然后分发bucket。例如：</li>
</ol>
<div class="highlight"><pre><span></span><code>CREATE TABLE global_order2 (
    ts timestamp,/* time at which the event was generated */
    car varchar, /* name of the car */
    speed int,   /* speed of your car */
    bucketid smallint DEFAULT random()*8, /* bucket id*/
    PRIMARY KEY(bucketid HASH, ts ASC)
) SPLIT INTO 3 TILES;
</code></pre></div>
<p>这将向数据中添加一个bucketid，该bucketid由0到7之间的随机数组成，用于在整体和bucketid上分发数据。</p>
<p>将上面相同的数据添加到新表中，如下所示：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO global_order2 (ts, car, speed)
        (SELECT &#39;2023-07-01 00:00:00&#39;::timestamp + make_interval(secs=&gt;id),
            &#39;car-&#39; || ceil(random()*2), ceil(random()*60)
            FROM generate_series(1,100) AS id);
</code></pre></div>
<p>因为bucketid的默认值设置为random()*8，所以不必显式插入该值。</p>
<p>从表中检索数据，如下所示： </p>
<div class="highlight"><pre><span></span><code>SELECT *, bm_hash_code(bucketid) % 3 as tile FROM global_order2;
</code></pre></div>
<div class="highlight"><pre><span></span><code>         ts          |  car  | speed | bucketid | tile
---------------------+-------+-------+----------+--------
 2023-07-01 00:00:24 | car-2 |    19 |        4 |      2
 2023-07-01 00:00:25 | car-1 |    21 |        4 |      2
 2023-07-01 00:00:26 | car-1 |    40 |        4 |      2
...
 2023-07-01 00:00:35 | car-1 |    46 |        0 |      1
 2023-07-01 00:00:40 | car-1 |    16 |        0 |      1
 2023-07-01 00:00:41 | car-2 |    34 |        0 |      1
...
 2023-07-01 00:00:22 | car-2 |    57 |        0 |      0
 2023-07-01 00:00:35 | car-1 |    46 |        0 |      0
 2023-07-01 00:00:40 | car-1 |    16 |        0 |      0
</code></pre></div>
<p>请注意，数据被划分为存储bucket，存储bucket分布在不同的分片上。数据按每个存储bucket中的ts排序，但您的结果没有排序。
因为查询计划不知道bucketid的不同值，所以它必须对前面的查询执行顺序扫描。为了有效地检索特定汽车（比如car-1）的所有数据，请修改查询以显式调用bucket，如下所示：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM global_order2 WHERE bucketid IN (0,1,2,3,4,5,6,7) ORDER BY ts ASC;
</code></pre></div>
<div class="highlight"><pre><span></span><code>         ts          |  car  | speed | bucketid
---------------------+-------+-------+----------
 2023-07-01 00:00:01 | car-2 |     7 |        1
 2023-07-01 00:00:02 | car-1 |    27 |        6
 2023-07-01 00:00:03 | car-1 |    32 |        1
 2023-07-01 00:00:04 | car-2 |    28 |        6
 2023-07-01 00:00:05 | car-2 |    45 |        2
 2023-07-01 00:00:06 | car-1 |    14 |        3
 2023-07-01 00:00:07 | car-1 |    14 |        1
 2023-07-01 00:00:08 | car-1 |    35 |        5
 2023-07-01 00:00:09 | car-1 |    58 |        3
</code></pre></div>
<p>您可以执行示例查询计划来验证前面的查询是否使用主键索引，如下所示： </p>
<div class="highlight"><pre><span></span><code>EXPLAIN ANALYZE SELECT * FROM global_order2 WHERE bucketid IN (0,1,2,3,4,5,6,7) ORDER BY ts ASC;
</code></pre></div>
<div class="highlight"><pre><span></span><code>                                               QUERY PLAN
--------------------------------------------------------------------------------------------------------
 Sort (actual time=2.279..2.289 rows=95 loops=1)
   Output: ts, car, speed, bucketid
   Sort Key: global_order2.ts
   Sort Method: quicksort  Memory: 32kB
   -&gt;  Index Scan using global_order2_pkey on public.global_order2 (actual time=2.139..2.207 rows=95 loops=1)
         Output: ts, car, speed, bucketid
         Index Cond: (global_order2.bucketid = ANY (&#39;{0,1,2,3,4,5,6,7}&#39;::integer[]))
 Planning Time: 0.180 ms
 Execution Time: 2.388 ms
 Peak Memory Usage: 34 kB
</code></pre></div>
<h4 id="_66"><strong>按每个实体的时间排序</strong></h4>
<p>在时间序列数据模型中，为了强制一个实体的所有数据保持在一起，同时保持基于时间戳的排序，您必须按实体分发数据并按时间排序。</p>
<p>以下部分介绍了如何通过几个示例按实体进行排序 </p>
<ol>
<li>排序每一实体</li>
</ol>
<p>考虑一个速度指标跟踪系统，它跟踪来自许多汽车的速度传感器的数据。</p>
<p>创建一个具有示例架构的表，如下所示：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE entity_order1 (
    ts timestamp,/* time at which the event was generated */
    car varchar, /* name of the car */
    speed int,   /* speed of your car */
    PRIMARY KEY(car HASH, ts ASC)
) SPLIT INTO 3 TILES;
</code></pre></div>
<p>当您插入数据时，它是按bm_hash_code(car)的值分布的，但在car中，数据是按时间戳排序的。</p>
<p>将数据插入表中，如下所示：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO entity_order1 (ts, car, speed)
        (SELECT &#39;2023-07-01 00:00:00&#39;::timestamp + make_interval(secs=&gt;id),
            &#39;car-&#39; || ceil(random()*2), ceil(random()*60)
            FROM generate_series(1,100) AS id);
</code></pre></div>
<p>从表中检索数据，如下所示：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM entity_order1 WHERE car = &#39;car-1&#39; ;
</code></pre></div>
<div class="highlight"><pre><span></span><code>         ts          |  car  | speed
---------------------+-------+-------
 2023-07-01 00:00:01 | car-1 |    22
 2023-07-01 00:00:03 | car-1 |    43
 2023-07-01 00:00:04 | car-1 |    11
 2023-07-01 00:00:07 | car-1 |    39
 2023-07-01 00:00:08 | car-1 |    21
 2023-07-01 00:00:14 | car-1 |     5
 2023-07-01 00:00:15 | car-1 |    31
 2023-07-01 00:00:16 | car-1 |    21
 2023-07-01 00:00:18 | car-1 |    14
 2023-07-01 00:00:19 | car-1 |    46
 2023-07-01 00:00:20 | car-1 |     4
</code></pre></div>
<p>car-1的数据自动排序，无需明确要求排序。此外，特定汽车（本例中为car-1）的所有数据都将位于同一分片中，因为您已经定义了要分布在car列哈希的数据（PRIMARY KEY(car hash，ts ASC))。</p>
<p>按实体（car）分发数据，并按每个实体的时间戳排序数据解决了将实体的数据保持在一起的问题，同时在不同的分片上保持不同实体之间的全局分布。但如果同一辆车上有太多操作，这可能会导致热分片问题。</p>
<ol>
<li>基于bucket的分配
   解决热分片问题的一种方法是使用基于bucket的分发。</li>
</ol>
<p>Bucketing允许您在特定实体上分发数据，同时保持数据在实体中的有序性。其思想是将实体的数据拆分为bucket，并分发bucket。要理解这一点，请修改上表以添加一个bucketid，如下所示：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE entity_order2 (
    ts timestamp,/* time at which the event was generated */
    car varchar, /* name of the car */
    speed int,   /* speed of your car */
    bucketid smallint DEFAULT random()*8, /* bucket id*/
    PRIMARY KEY((car, bucketid) HASH, ts ASC)
) SPLIT INTO 3 TILES;
</code></pre></div>
<p>这将向数据中添加一个bucketid，该bucketid由0到7之间的随机数组成，用于在实体和bucketid上分发数据。</p>
<p>将相同的数据添加到新表中，如下所示：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO entity_order2 (ts, car, speed)
        (SELECT &#39;2023-07-01 00:00:00&#39;::timestamp + make_interval(secs=&gt;id),
            &#39;car-&#39; || ceil(random()*2), ceil(random()*60)
            FROM generate_series(1,100) AS id);
</code></pre></div>
<p>因为bucketid的默认值设置为random()*8，所以不必显式插入该值。</p>
<p>从表中检索数据，如下所示： </p>
<div class="highlight"><pre><span></span><code>SELECT * FROM entity_order2;
</code></pre></div>
<div class="highlight"><pre><span></span><code>         ts          |  car  | speed | bucketid
---------------------+-------+-------+----------
 2023-07-01 00:00:06 | car-1 |     4 |        7
 2023-07-01 00:00:09 | car-1 |    55 |        7
...
 2023-07-01 00:00:53 | car-1 |     5 |        7
 2023-07-01 00:01:05 | car-1 |     9 |        7
 2023-07-01 00:00:14 | car-2 |    29 |        1
...
 2023-07-01 00:01:00 | car-1 |    24 |        2
 2023-07-01 00:01:37 | car-1 |    13 |        2
 2023-07-01 00:00:11 | car-2 |    30 |        6
 2023-07-01 00:00:30 | car-2 |    30 |        6
...
 2023-07-01 00:01:35 | car-2 |    14 |        6
 2023-07-01 00:00:31 | car-2 |    55 |        0
 2023-07-01 00:00:44 | car-2 |    45 |        0
</code></pre></div>
<p>现在，每辆车的数据被划分为多个bucket，每个bucket中的数据按ts排序，buckets分布在不同的分片上。</p>
<p>因为查询计划不知道bucketid的不同值，所以它必须对前面的查询执行顺序扫描。为了有效地检索特定汽车（比如car-1）的所有数据，请修改查询以显式调用bucket，如下所示： </p>
<div class="highlight"><pre><span></span><code>SELECT * FROM entity_order2
    WHERE car=&#39;car-1&#39; AND bucketid IN (0,1,2,3,4,5,6,7); 
</code></pre></div>
<div class="highlight"><pre><span></span><code>         ts          |  car  | speed | bucketid
---------------------+-------+-------+----------
 2023-07-01 00:00:21 | car-1 |    45 |        7
 2023-07-01 00:00:22 | car-1 |     9 |        7
 2023-07-01 00:00:37 | car-1 |    32 |        7
 2023-07-01 00:00:41 | car-1 |    51 |        7
 2023-07-01 00:00:57 | car-1 |    50 |        7
 2023-07-01 00:01:09 | car-1 |    59 |        7
 2023-07-01 00:01:23 | car-1 |    54 |        7 
</code></pre></div>
<p>这使查询计划器能够使用car的主索引bucketid，因为现在它知道了要查找的car和bucketid的值。</p>
<div class="highlight"><pre><span></span><code>EXPLAIN ANALYZE SELECT * FROM entity_order2 WHERE car=&#39;car-1&#39; AND bucketid IN (0,1,2,3,4,5,6,7);
</code></pre></div>
<div class="highlight"><pre><span></span><code>                                                              QUERY PLAN
------------------------------------------------------------------------------------------------------------------------------
 Index Scan using entity_order2_pkey on entity_order2  (cost=0.00..16.25 rows=100 width=46) (actual time=1.534..1.562 rows=49 loops=1)
   Index Cond: (((car)::text = &#39;car-1&#39;::text) AND (bucketid = ANY (&#39;{0,1,2,3,4,5,6,7}&#39;::integer[])))
 Planning Time: 0.129 ms
 Execution Time: 1.624 ms
 Peak Memory Usage: 8 kB
</code></pre></div>
<p>您可以看到数据在结果集中并没有真正排序。这是因为数据只在每个bucket中排序。将order by子句添加到原始查询中，如下所示： </p>
<div class="highlight"><pre><span></span><code>SELECT * FROM entity_order2 WHERE car=&#39;car-1&#39; AND bucketid IN (0,1,2,3,4,5,6,7) ORDER BY ts ASC;
</code></pre></div>
<div class="highlight"><pre><span></span><code>  ts          |  car  | speed | bucketid
---------------------+-------+-------+----------
 2023-07-01 00:00:01 | car-1 |    57 |        4
 2023-07-01 00:00:03 | car-1 |     7 |        5
 2023-07-01 00:00:04 | car-1 |    58 |        6
 2023-07-01 00:00:07 | car-1 |    48 |        3
 2023-07-01 00:00:08 | car-1 |    43 |        2
 2023-07-01 00:00:12 | car-1 |    60 |        1
 2023-07-01 00:00:13 | car-1 |    20 |        2
</code></pre></div>
<p>现在您可以看到数据在ts上的顺序是正确的。</p>
<h4 id="_67"><strong>自动数据过期</strong></h4>
<p>考虑这样一种情况：您只需要最后几个值，而旧数据没有任何价值，可以清除。通常，这需要设置一个单独的后台作业。但是，使用BMDB，您可以使用Using TTL运算符为列设置过期值。
注意：
基于TTL的过期仅在BCQL中可用。</p>
<ol>
<li>行级TTL</li>
</ol>
<p>考虑一个速度指标跟踪系统，它跟踪来自许多汽车的速度传感器的数据。</p>
<p>创建一个表并插入带有示例架构的数据，如下所示： </p>
<div class="highlight"><pre><span></span><code>CREATE KEYSPACE IF NOT EXISTS bigmath;
USE bigmath;
CREATE TABLE exp_demo (
    ts timestamp,/* time at which the event was generated */
    car text, /* name of the car */
    speed int,   /* speed of your car */
    PRIMARY KEY(car, ts)
) WITH CLUSTERING ORDER BY (ts DESC);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO exp_demo(ts,car,speed) VALUES(&#39;2023-07-01 10:00:01&#39;,&#39;car-1&#39;,50) USING TTL 10;
INSERT INTO exp_demo(ts,car,speed) VALUES(&#39;2023-07-01 10:00:02&#39;,&#39;car-2&#39;,25) USING TTL 15;
INSERT INTO exp_demo(ts,car,speed) VALUES(&#39;2023-07-01 10:00:03&#39;,&#39;car-1&#39;,39) USING TTL 15;
INSERT INTO exp_demo(ts,car,speed) VALUES(&#39;2023-07-01 10:00:04&#39;,&#39;car-1&#39;,49) USING TTL 20;
INSERT INTO exp_demo(ts,car,speed) VALUES(&#39;2023-07-01 10:00:05&#39;,&#39;car-2&#39;, 3) USING TTL 25;
</code></pre></div>
<p>插入数据后，立即开始反复选择所有行。最终，您将看到所有数据消失。 </p>
<div class="highlight"><pre><span></span><code>SELECT * from exp_demo;
</code></pre></div>
<ol>
<li>列级TTL
   对于更细粒度的过期，您可以设置每列的TTL，而不是对整行设置TTL。例如，请执行以下操作： 
   1）增加一行</li>
</ol>
<div class="highlight"><pre><span></span><code>INSERT INTO exp_demo(ts,car,speed) VALUES(&#39;2023-08-01 10:00:01&#39;, &#39;car-5&#39;, 50);
</code></pre></div>
<p>2）获取行</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM exp_demo WHERE car=&#39;car-5&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> car   | ts                              | speed
-------+---------------------------------+-------
 car-5 | 2023-08-01 17:00:01.000000+0000 |    50
</code></pre></div>
<p>3）按如下方式在该行的speed列上设置过期时间：</p>
<div class="highlight"><pre><span></span><code>UPDATE exp_demo USING TTL 5 SET speed=10 WHERE car=&#39;car-5&#39; AND ts =&#39;2023-08-01 10:00:01&#39;;
</code></pre></div>
<p>4）等待五秒钟，然后取下car-5的那一行</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM exp_demo WHERE car=&#39;car-5&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> car   | ts                              | speed
-------+---------------------------------+-------
 car-5 | 2023-08-01 17:00:01.000000+0000 |   null
</code></pre></div>
<p>请注意，行存在，但speed列的值为空。</p>
<ol>
<li>表级TTL
   您可以在表上设置TTL，而不是在行或列级别显式设置TTL。这也有节省空间的好处，因为TTL值只存储在一个位置，而不是每行或每列。</li>
</ol>
<p>使用default_time_to_live 属性定义表级TTL。 </p>
<h4 id="_68"><strong>分区</strong></h4>
<p>分区是指将逻辑上的一个大表拆分为更小的物理部分。BMDB中分区的关键优势在于，因为每个分区都是一个单独的表，所以将最重要的（例如，最新的）数据保留在一个分区中是有效的，而将不那么重要的数据保留在其他分区中是高效的，这样就可以很容易地删除它们。</p>
<p>以下示例更详细地描述了分区的优点。</p>
<p>注意：分区仅仅在BSQL中可用。</p>
<ol>
<li>配置
   考虑一个场景，在这个场景中，你有很多来自汽车的数据点，而你只关心上个月的数据。尽管您可以执行一条语句来删除超过30天的数据，但由于数据不会立即从底层存储（基于LSM的CoreDB）中删除，这可能会影响扫描性能。</li>
</ol>
<p>创建一个具有示例架构的表，如下所示： </p>
<div class="highlight"><pre><span></span><code>CREATE TABLE part_demo (
    ts timestamp,/* time at which the event was generated */
    car varchar, /* name of the car */
    speed int,   /* speed of your car */
    PRIMARY KEY(car HASH, ts ASC)
) PARTITION BY RANGE (ts);
</code></pre></div>
<p>为每个月创建分区。此外，为不属于任何其他分区的数据创建一个DEFAULT分区。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE part_7_23 PARTITION OF part_demo
    FOR VALUES FROM (&#39;2023-07-01&#39;) TO (&#39;2023-08-01&#39;);

CREATE TABLE part_8_23 PARTITION OF part_demo
    FOR VALUES FROM (&#39;2023-08-01&#39;) TO (&#39;2023-09-01&#39;);

CREATE TABLE part_9_23 PARTITION OF part_demo
    FOR VALUES FROM (&#39;2023-09-01&#39;) TO (&#39;2023-10-01&#39;);

CREATE TABLE def_part_demo PARTITION OF part_demo DEFAULT;
</code></pre></div>
<p>在主表part_demo中插入一些数据： </p>
<div class="highlight"><pre><span></span><code>INSERT INTO part_demo (ts, car, speed)
    (SELECT &#39;2023-07-01 00:00:00&#39;::timestamp +
        make_interval(secs=&gt;id, months=&gt;((random()*2)::int)),
        &#39;car-&#39; || ceil(random()*2), ceil(random()*60)
        FROM generate_series(1,100) AS id);
</code></pre></div>
<p>如果从相应的分区中检索行，请注意，它们具有相应日期范围的行。例如：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM part_9_23 LIMIT 4;
</code></pre></div>
<div class="highlight"><pre><span></span><code>         ts          |  car  | speed
---------------------+-------+-------
 2023-09-01 00:00:04 | car-2 |    45
 2023-09-01 00:00:05 | car-2 |    38
 2023-09-01 00:00:08 | car-2 |    49
 2023-09-01 00:00:23 | car-2 |    33
</code></pre></div>
<ol>
<li>获取数据</li>
</ol>
<p>尽管数据作为分区存储在不同的表中，但要访问所有数据，只需要查询父表。如下所示，查看所选查询的查询计划： </p>
<div class="highlight"><pre><span></span><code>EXPLAIN ANALYZE SELECT * FROM part_demo;
</code></pre></div>
<div class="highlight"><pre><span></span><code>                                  QUERY PLAN
-------------------------------------------------------------------------------
 Append (actual time=1.085..5.351 rows=100 loops=1)
   -&gt;  Seq Scan on public.part_7_23 (actual time=1.079..2.431 rows=25 loops=1)
         Output: part_7_23.ts, part_7_23.car, part_7_23.speed
   -&gt;  Seq Scan on public.part_8_23 (actual time=0.665..1.555 rows=47 loops=1)
         Output: part_8_23.ts, part_8_23.car, part_8_23.speed
   -&gt;  Seq Scan on public.part_9_23 (actual time=0.648..1.342 rows=28 loops=1)
         Output: part_9_23.ts, part_9_23.car, part_9_23.speed
 Planning Time: 0.105 ms
 Execution Time: 5.434 ms
 Peak Memory Usage: 19 kB
</code></pre></div>
<p>查询父表时，会自动查询子分区</p>
<ol>
<li>获取时间范围内的数据
   由于数据是根据时间划分的，因此在查询特定时间范围时，查询执行器仅从数据预期所在的分区中获取数据。例如，请参阅获取特定月份数据的查询计划</li>
</ol>
<div class="highlight"><pre><span></span><code>EXPLAIN ANALYZE SELECT * FROM part_demo WHERE ts &gt; &#39;2023-07-01&#39; AND ts &lt; &#39;2023-08-01&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>                                   QUERY PLAN
-----------------------------------------------------------------------------------------------------------
 Append (actual time=2.288..2.310 rows=25 loops=1)
   -&gt;  Seq Scan on public.part_7_23 (actual time=2.285..2.301 rows=25 loops=1)
         Output: part_7_23.ts, part_7_23.car, part_7_23.speed
         Remote Filter: ((part_7_23.ts &gt; &#39;2023-07-01 00:00:00&#39;::timestamp without time zone)
                AND (part_7_23.ts &lt; &#39;2023-08-01 00:00:00&#39;::timestamp without time zone))
 Planning Time: 0.309 ms
 Execution Time: 2.411 ms
 Peak Memory Usage: 14 kB
</code></pre></div>
<p>您可以看到查询计划只选择了一个分区来从中获取数据 </p>
<ol>
<li>删除旧数据
   数据分区的主要优点是可以轻松地丢弃较旧的数据。要删除旧数据，您所需要做的就是删除特定的分区表。例如，当不需要第7个月的数据时，请执行以下操作：</li>
</ol>
<div class="highlight"><pre><span></span><code>DROP TABLE part_7_23;
</code></pre></div>
<div class="highlight"><pre><span></span><code>DROP TABLE
Time: 103.214 ms
</code></pre></div>
<h3 id="_69"><strong>键值</strong></h3>
<p>在键值数据模型中，每个键都与一个且仅与一个值相关联。键值存储公开了三个基本API：</p>
<ul>
<li>GET获取键的值（例如，GET('name')）</li>
<li>SET存储键的值（例如，SET('name'，'bigmath')）</li>
<li>DEL删除键及其值（例如，DEL('name')） </li>
</ul>
<p>有了这三个简单的功能，键值存储凭借其速度和简单性在现代基础设施中占据了一席之地。
BMDB在用键值存储时提供了几个优势：
BMDB内部将数据存储为键值对的集合，因此自动成为键值存储。
BMDB在设计上是分布式的，自然也可以作为分布式键值存储。
由于RAFT复制，BMDB固有地提供了数据的一致性，而其他键值存储通常无法保证这一点。 </p>
<h4 id="_70"><strong>存储用户数据</strong></h4>
<p>例如，为了存储用户的详细信息，可以采用一个模式，其中每个属性都是一个单独的键，例如以下内容：</p>
<div class="highlight"><pre><span></span><code>user1.name = &quot;John Wick&quot;
user1.country = &quot;USA&quot;
user2.name = &quot;Harry Potter&quot;
user2.country = &quot;UK&quot;
</code></pre></div>
<p>为此，您可以创建一个表，如下所示： </p>
<div class="highlight"><pre><span></span><code>CREATE TABLE kvstore (
    key VARCHAR,
    value VARCHAR,
    PRIMARY KEY(key)
);
</code></pre></div>
<p>要添加一些数据，请输入以下内容：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO kvstore VALUES (&#39;user1.name&#39;, &#39;John Wick&#39;), (&#39;user1.country&#39;, &#39;USA&#39;),
                           (&#39;user2.name&#39;, &#39;Harry Potter&#39;), (&#39;user2.country&#39;, &#39;UK&#39;);
</code></pre></div>
<ol>
<li>GET
   要获取user1的名称，您可以执行以下操作： </li>
</ol>
<div class="highlight"><pre><span></span><code>SELECT value FROM kvstore WHERE key = &#39;user1.name&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>   value
-----------
 John Wick
</code></pre></div>
<ol>
<li>SET
   要存储键的值，可以执行插入操作。因为key 可能已经存在，所以应该提供一个ON CONFLICT UPDATE子句。 </li>
</ol>
<div class="highlight"><pre><span></span><code>INSERT INTO kvstore(key, value) VALUES(&#39;user1.name&#39;, &#39;Jack Ryan&#39;) 
        ON CONFLICT (key) DO
        UPDATE SET value = EXCLUDED.value;
</code></pre></div>
<ol>
<li>DEL
   要删除键及其值，可以执行如下简单的delete命令 </li>
</ol>
<div class="highlight"><pre><span></span><code>DELETE FROM kvstore WHERE key = &#39;user1.name&#39;;
</code></pre></div>
<h4 id="_71"><strong>适用举例</strong></h4>
<ol>
<li>
<p>缓存服务器
   键值数据模型最适合设计缓存服务器，其中缓存的数据由键表示。缓存的对象可以用JSON字符串表示（具有多个属性），并由应用程序进行解析。</p>
</li>
<li>
<p>电话簿
   电话簿键值模型，其中键是电话号码，值是电话号码所属人员的姓名和地址。</p>
</li>
<li>
<p>会话存储
   面向会话的应用程序，如web应用程序，在用户登录时启动会话，并一直处于活动状态，直到用户注销或会话超时。在此期间，应用程序将所有与会话相关的数据，如配置文件信息、主题、邮政编码、地理位置等进行键值存储。</p>
</li>
<li>
<p>购物车
   用户的购物车可以表示为JSON字符串，并存储在一个键下，例如user1.cart。由于BMDB提供了强大的一致性和弹性，即使发生灾难，购物车信息也不会丢失。</p>
</li>
</ol>
<h2 id="_72"><strong>学习应用程序开发</strong></h2>
<h3 id="_73"><strong>数据建模</strong></h3>
<p>数据建模是一个涉及识别实体（要存储的项）和实体之间关系的过程。要创建数据模型，请确定用于访问数据的模式以及要执行的查询类型。这两个想法为数据的组织和结构以及数据库表的设计和创建提供了信息。</p>
<p>本主题介绍了使用BMDB云查询语言（BCQL）、BMDB的Cassandra兼容API进行数据建模。</p>
<h4 id="_74"><strong>键空间、表、行和列</strong></h4>
<h5 id="_75"><strong>键空间</strong></h5>
<p>Cassandra键空间是表的集合。它们类似于SQL命名空间。通常，每个应用程序在一个键空间中创建其所有表。</p>
<h5 id="_76"><strong>表</strong></h5>
<p>表是数据的集合。键空间通常包含一个或多个表。每个表都由一个名称标识。表有一组列，并包含数据的记录（行）。可以在运行时创建、删除和更改表，而不会阻止更新和查询。</p>
<h5 id="_77"><strong>行</strong></h5>
<p>每个表包含多行数据。行是在所有其他行中唯一可识别的一组列的集合。</p>
<h5 id="_78"><strong>列</strong></h5>
<p>每一行都由一列或多列组成。列是一个基本的数据元素，不需要进一步细分。</p>
<p>作为users 表的示例，该表保存关于服务的用户的信息。</p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>firstname</th>
<th>lastname</th>
<th>address</th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>Sherlock</td>
<td>Holmes</td>
<td>221b Baker St, London, CN</td>
</tr>
<tr>
<td>1003</td>
<td>Clark</td>
<td>Kent</td>
<td>344 Clinton Street, Metropolis</td>
</tr>
<tr>
<td>1007</td>
<td>James</td>
<td>Bond</td>
<td></td>
</tr>
</tbody>
</table>
<p>请注意以下关于users 表的信息：</p>
<ul>
<li>表中的每一行都有一个主键列（user_id）的唯一值。</li>
<li>除了主键之外，users表还有另外三列-firstname、lastname和address，每一列都是一个字符串。</li>
<li>某些列可能没有数据（例如，James Bond的address 未知），这些在数据库中具有null值。 </li>
</ul>
<p>现在考虑books 表的另一个示例，它记录作者和他们写的书。 </p>
<table>
<thead>
<tr>
<th>author</th>
<th>book_title</th>
<th>price</th>
<th>year</th>
<th>genre</th>
</tr>
</thead>
<tbody>
<tr>
<td>William hakespeare</td>
<td>Hamlet</td>
<td>6.75</td>
<td>1602</td>
<td>tragedy</td>
</tr>
<tr>
<td>William Shakespeare</td>
<td>Macbeth</td>
<td>7.50</td>
<td>1606</td>
<td>tragedy</td>
</tr>
<tr>
<td>Charles Dickens</td>
<td>Oliver Twist</td>
<td>9.25</td>
<td>1837</td>
<td>serial novel</td>
</tr>
<tr>
<td>Charles Dickens</td>
<td>A Tale of Two Cities</td>
<td>11.40</td>
<td>1859</td>
<td>historical novel</td>
</tr>
</tbody>
</table>
<p>请注意以下关于books 表的内容：</p>
<ul>
<li>该表的主键由两列组成——author和book_title。表中的每一行都必须具有这两个属性的值，并且这些值的组合必须是唯一的。</li>
<li>除了主键之外，该表还有其他列，如price，year，genre。</li>
<li>列author、book_title和genre是字符串，price是浮点值，year是整数。</li>
</ul>
<h4 id="_79"><strong>主键</strong></h4>
<p>创建表时，除了表名之外，还必须指定表的主键。主键唯一地标识表中的每一行，因此没有两行可以具有相同的键。
主键有两个组成部分，如下所述</p>
<h5 id="_80"><strong>分区键列（必需）</strong></h5>
<p>表中的一个或多个列成为分区键列。分区键列的值用于计算内部哈希值。此哈希值确定将在其中存储该行的tile（或分区）。这有两个含义：</p>
<ul>
<li>每个唯一的分区键值的集合都经过hash处理，并随机分布在节点之间，以确保集群的统一利用率。</li>
<li>分区键值的唯一集合的所有数据总是存储在同一个节点上。只有当存在集群键列时，这才重要，这将在下一节中进行描述。 
  在users表的情况下，可以将user_id列作为唯一的主键列。对于分区键来说，这是一个很好的选择，因为我们的查询不关心user_id的顺序。如果将表拆分为多个分片（分区），则可以按如下方式分配数据。 </li>
</ul>
<table>
<thead>
<tr>
<th>tile</th>
<th>user_id</th>
<th>firstname</th>
<th>lastname</th>
<th>address</th>
</tr>
</thead>
<tbody>
<tr>
<td>tile-22</td>
<td>1001</td>
<td>Sherlock</td>
<td>Holmes</td>
<td>221b Baker St, London, CN</td>
</tr>
<tr>
<td>tile-4</td>
<td>1003</td>
<td>Clark</td>
<td>Kent</td>
<td>344 Clinton Street, Metropolis</td>
</tr>
<tr>
<td>tile-17</td>
<td>1007</td>
<td>James</td>
<td>Bond</td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="_81"><strong>集群键列（可选）</strong></h5>
<p>集群列指定列数据排序的顺序，并且对于一个给定的唯一分区键值指定存储在磁盘上的顺序。
集群列指定为给定的唯一分区键值对列数据进行排序并将其存储在磁盘上的顺序。可以指定多个集群列，并且这些列按照在集群列中声明的顺序进行排序。还可以控制这些列的排序顺序（升序或降序）。 
在同时具有分区键和集群键的表中，两行可能具有相同的分区键值，因此它们最终位于同一节点上。但是，为了满足主键要求，这些行必须具有不同的集群键值。没有集群键列的表被认为具有简单的主键。
在books表示例，author是一个好的分区键，book_title是一个很好的集群键。这样的数据模型可以很容易地列出给定作者的所有书籍，以及查找特定书籍的详细信息。这将导致数据存储如下。 </p>
<table>
<thead>
<tr>
<th>tile</th>
<th>author</th>
<th>book_title</th>
<th>price</th>
<th>year</th>
<th>genre</th>
</tr>
</thead>
<tbody>
<tr>
<td>tile-15</td>
<td>William Shakespeare</td>
<td>Hamlet</td>
<td>6.75</td>
<td>1602</td>
<td>tragedy</td>
</tr>
<tr>
<td>tile-15</td>
<td>William Shakespeare</td>
<td>Macbeth</td>
<td>7.50</td>
<td>1606</td>
<td>tragedy</td>
</tr>
<tr>
<td>tile-21</td>
<td>Charles Dickens</td>
<td>A Tale of Two Cities</td>
<td>11.40</td>
<td>1859</td>
<td>historical novel</td>
</tr>
<tr>
<td>tile-21</td>
<td>Charles Dickens</td>
<td>Oliver Twist</td>
<td>9.25</td>
<td>1837</td>
<td>serial novel</td>
</tr>
</tbody>
</table>
<p>请注意，如果您同时设置了author和book_title分区键列，则无法有效地列出给定作者的所有书籍。</p>
<p>注意</p>
<ul>
<li>分区键列通常也称为其哈希列。这是因为内部哈希函数用于根据数据项的分区键值在分片之间分配数据项。</li>
<li>集群键列也称为其范围列。这是因为具有相同分区键的行按照集群键值的排序顺序存储在磁盘上。 </li>
</ul>
<h4 id="_82"><strong>二级索引</strong></h4>
<p>数据库索引是一种提高数据库表上数据检索操作速度的数据结构。通常，数据库在按主键查找数据方面非常高效。二级索引可以使用数据库表的一个或多个列创建，并在按这些列查询时为快速随机查找和高效访问有序记录提供了基础。为了实现这一点，辅助索引需要额外的写入和存储空间来维护索引数据结构。在这里，详细记录了BMDB的二级索引的支持。</p>
<h5 id="_83"><strong>二级索引的优势</strong></h5>
<p>二级索引可用于加快查询速度，并强制列中值的唯一性。</p>
<p>加快查询速度：二级索引的主要用途是使某些列值的查找更加高效。让我们举一个users表的示例，其中user_id是主键。假设我们想通过用户的电子邮件高效地查找user_id。您可以通过以下方式实现这一点。 </p>
<div class="highlight"><pre><span></span><code>CREATE KEYSPACE example;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE TABLE example.users(
         user_id    bigint PRIMARY KEY,
         firstname  text,
         lastname   text,
         email      text
       ) WITH transactions = { &#39;enabled&#39; : true };
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE INDEX user_by_email ON example.users (email)
         INCLUDE (firstname, lastname);
</code></pre></div>
<p>接下来，插入一些测试数据：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO example.users (user_id, firstname, lastname, email)
       VALUES (1, &#39;James&#39;, &#39;Bond&#39;, &#39;bond@example.com&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO example.users (user_id, firstname, lastname, email)
       VALUES (2, &#39;Sherlock&#39;, &#39;Holmes&#39;, &#39;sholmes@example.com&#39;);
</code></pre></div>
<p>现在，您可以通过用户的电子邮件高效地查询表，如下所示。</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM example.users WHERE email=&#39;bond@example.com&#39;;
</code></pre></div>
<h5 id="_84"><strong>强制列值的唯一性</strong></h5>
<p>在某些情况下，您需要确保不能在表的列中插入重复的值。您可以在BMDB中通过创建一个唯一的二级索引来实现这一点，应用程序不希望在列中插入重复的值。</p>
<div class="highlight"><pre><span></span><code>CREATE KEYSPACE example;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE TABLE example.users(
         user_id    bigint PRIMARY KEY,
         firstname  text,
         lastname   text,
         email      text
       ) WITH transactions = { &#39;enabled&#39; : true };
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE UNIQUE INDEX unique_emails ON example.users (email);
</code></pre></div>
<p>只要电子邮件是唯一的，插入就会成功。 </p>
<div class="highlight"><pre><span></span><code>INSERT INTO example.users (user_id, firstname, lastname, email)
       VALUES (1, &#39;James&#39;, &#39;Bond&#39;, &#39;bond@example.com&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO example.users (user_id, firstname, lastname, email)
       VALUES (2, &#39;Sherlock&#39;, &#39;Holmes&#39;, &#39;sholmes@example.com&#39;);
</code></pre></div>
<p>但是在插入重复的电子邮件时，会出现错误。 </p>
<div class="highlight"><pre><span></span><code>INSERT INTO example.users (user_id, firstname, lastname, email)
       VALUES (3, &#39;Fake&#39;, &#39;Bond&#39;, &#39;bond@example.com&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>InvalidRequest: Error from server: code=2200 [Invalid query] message=&quot;SQL error: Execution Error. Duplicate value disallowed by unique index unique_emails
</code></pre></div>
<h4 id="_85"><strong>文档</strong></h4>
<p>文档是存储、检索和管理半结构化数据的最常见方式。与传统的关系数据模型不同，文档数据模型不局限于行和列的模式。模式可以很容易地更改，从而帮助应用程序开发人员比以往更快地编写业务逻辑。文档包含数据类型的描述和该描述的值，而不是关系模型中使用的具有名称和数据类型的列。每个文档可以具有相同或不同的结构。甚至嵌套文档结构也是可能的，其中一个或多个子文档嵌入到更大的文档中。</p>
<p>数据库通常通过使用JSON数据类型来支持文档数据管理。JSON.org将JSON（JavaScript Object Notation）定义为一种轻量级的数据交换格式。人类进行相应的读与写都很容易，机器也很容易解析和生成。JSON有四种简单的数据类型： </p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null (or empty)
  此外，它还有两种核心复杂数据类型。 </li>
<li>名称-值对的集合，根据语言的不同，可以实现为对象、哈希表、字典或类似的东西。</li>
<li>值的有序列表，根据语言实现为数组、向量、列表或序列。
  文档数据模型最适合需要灵活模式和快速数据访问的应用程序。例如，嵌套文档使应用程序能够以非规范化的方式将相关信息存储在同一数据库记录中。因此，应用程序可以发出更少的查询和更新来完成常见操作。</li>
</ul>
<h5 id="apache-cassandrajson"><strong>与Apache Cassandra的JSON支持的比较</strong></h5>
<p>Apache Cassandra的JSON支持可能会误导许多开发人员。BCQL允许SELECT和INSERT语句包含JSON关键字。SELECT输出现在将以JSON格式提供，INSERT输入现在可以以JSON格式指定。然而，这种“JSON”支持只是CQL层中的一种易于使用的抽象，底层数据库引擎对此一无所知。由于CQL中没有本地JSON数据类型，因此模式对用户提供的JSON没有任何了解。这意味着模式定义不会更改，模式强制也不会更改。之前，需要原生JSON支持的Cassandra开发人员别无选择，只能在数据层中添加一个新的文档数据库，如MongoDB或Couchbase。
有了BMDB使用JSONB数据类型的原生JSON支持，应用程序开发人员现在可以在单个数据库中受益于Cassandra的结构化查询语言和MongoDB的文档数据建模。 </p>
<h3 id="_86"><strong>数据类型</strong></h3>
<p>本主题列出了BMDB的Cassandra兼容BCQL API中可用的各种数据类型。</p>
<h4 id="jsonb"><strong>JSONB</strong></h4>
<p>JSON数据有许多不同的序列化格式，其中一种流行的格式是JSONB（JSON Better），用于有效地对文档数据进行建模。 
BCQL API支持JSONB数据类型来解析、存储和查询JSON文档。这种数据类型在查询语言语法和功能上与PostgreSQL支持的数据类型相似。JSONB序列化允许轻松搜索和检索文档中的属性。这是通过按排序顺序存储所有JSON属性来实现的，这允许对键进行有效的二进制搜索。类似地，数组的存储使得可以对序列化JSON文档中的特定数组索引进行随机访问。此外，BMDB的底层存储引擎CoreDB是面向文档的，这使得存储JSON数据比其他情况下更简单。 
以在线书店的电子商务应用程序为例。这样一个书店的数据库需要存储各种书籍的详细信息，其中一些可能具有自定义属性。以下示例显示了一个JSON文档，该文档捕获了William Shakespeare的《Macbeth》一书的详细信息。 </p>
<div class="highlight"><pre><span></span><code>{
   &quot;name&quot;:&quot;Macbeth&quot;,
   &quot;author&quot;:{
      &quot;first_name&quot;:&quot;William&quot;,
      &quot;last_name&quot;:&quot;Shakespeare&quot;
   },
   &quot;year&quot;:1623,
   &quot;editors&quot;:[
      &quot;John&quot;,
      &quot;Elizabeth&quot;,
      &quot;Jeff&quot;
   ]
}
</code></pre></div>
<h5 id="_87"><strong>建表</strong></h5>
<p>这家书店的图书表可以按如下方式制作。假设每本书的ID都是int，但它可以是字符串或UUID。</p>
<div class="highlight"><pre><span></span><code>CREATE KEYSPACE store;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE TABLE store.books ( id int PRIMARY KEY, details jsonb );
</code></pre></div>
<h5 id="_88"><strong>插入数据</strong></h5>
<p>接下来，将几本书的一些示例数据插入到该存储中，如下所示： </p>
<div class="highlight"><pre><span></span><code>INSERT INTO store.books (id, details) VALUES (1,
  &#39;{ &quot;name&quot;   : &quot;Macbeth&quot;,
     &quot;author&quot; : {&quot;first_name&quot;: &quot;William&quot;, &quot;last_name&quot;: &quot;Shakespeare&quot;},
     &quot;year&quot;   : 1623,
     &quot;editors&quot;: [&quot;John&quot;, &quot;Elizabeth&quot;, &quot;Jeff&quot;] }&#39;
);
INSERT INTO store.books (id, details) VALUES (2,
  &#39;{ &quot;name&quot;   : &quot;Hamlet&quot;,
     &quot;author&quot; : {&quot;first_name&quot;: &quot;William&quot;, &quot;last_name&quot;: &quot;Shakespeare&quot;},
     &quot;year&quot;   : 1603,
     &quot;editors&quot;: [&quot;Lysa&quot;, &quot;Mark&quot;, &quot;Robert&quot;] }&#39;
);
INSERT INTO store.books (id, details) VALUES (3,
  &#39;{ &quot;name&quot;   : &quot;Oliver Twist&quot;,
     &quot;author&quot; : {&quot;first_name&quot;: &quot;Charles&quot;, &quot;last_name&quot;: &quot;Dickens&quot;},
     &quot;year&quot;   : 1838,
     &quot;genre&quot;  : &quot;novel&quot;,
     &quot;editors&quot;: [&quot;Mark&quot;, &quot;Tony&quot;, &quot;Britney&quot;] }&#39;
);
INSERT INTO store.books (id, details) VALUES (4,
  &#39;{ &quot;name&quot;   : &quot;Great Expectations&quot;,
     &quot;author&quot; : {&quot;first_name&quot;: &quot;Charles&quot;, &quot;last_name&quot;: &quot;Dickens&quot;},
     &quot;year&quot;   : 1950,
     &quot;genre&quot;  : &quot;novel&quot;,
     &quot;editors&quot;: [&quot;Robert&quot;, &quot;John&quot;, &quot;Melisa&quot;] }&#39;
);
INSERT INTO store.books (id, details) VALUES (5,
  &#39;{ &quot;name&quot;   : &quot;A Brief History of Time&quot;,
     &quot;author&quot; : {&quot;first_name&quot;: &quot;Stephen&quot;, &quot;last_name&quot;: &quot;Hawking&quot;},
     &quot;year&quot;   : 1988,
     &quot;genre&quot;  : &quot;science&quot;,
     &quot;editors&quot;: [&quot;Melisa&quot;, &quot;Mark&quot;, &quot;John&quot;] }&#39;
);
</code></pre></div>
<p>请注意以下关于前一本书的详细信息：</p>
<ul>
<li>每本书的year属性都被解释为一个整数。</li>
<li>前两本书没有genre属性，其他的都有。</li>
<li>author属性是一个映射。</li>
<li>editors 属性是一个数组。</li>
</ul>
<h5 id="_89"><strong>检索属性的子集</strong></h5>
<p>运行以下SELECT查询将返回每本书的所有属性：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM store.books;
</code></pre></div>
<p>以下查询仅检索所有书籍的ID和名称： </p>
<div class="highlight"><pre><span></span><code>SELECT id, details-&gt;&gt;&#39;name&#39; as book_title FROM store.books;
</code></pre></div>
<div class="highlight"><pre><span></span><code> id | book_title
----+-------------------------
  5 | A Brief History of Time
  1 |                 Macbeth
  4 |      Great Expectations
  2 |                  Hamlet
  3 |            Oliver Twist
</code></pre></div>
<h5 id="_90"><strong>按属性值（字符串）查询</strong></h5>
<p>name属性是书籍详细信息JSON文档中的一个字符串。运行以下命令以查询名为《Hamlet》的书的详细信息。 </p>
<div class="highlight"><pre><span></span><code>SELECT * FROM store.books WHERE details-&gt;&gt;&#39;name&#39;=&#39;Hamlet&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> id | details
----+---------------------------------------------------------------
  2 | {&quot;author&quot;:{&quot;first_name&quot;:&quot;William&quot;,&quot;last_name&quot;:&quot;Shakespeare&quot;},
       &quot;editors&quot;:[&quot;Lysa&quot;,&quot;Mark&quot;,&quot;Robert&quot;],
       &quot;name&quot;:&quot;Hamlet&quot;,&quot;year&quot;:1603}
</code></pre></div>
<p>请注意，您可以按仅存在于某些文档中的属性进行查询。例如，您可以查询所有具有小说类型的书籍。回想一下，并不是所有的书都定义了类型属性。</p>
<div class="highlight"><pre><span></span><code>SELECT id, details-&gt;&gt;&#39;name&#39; as title,
              details-&gt;&gt;&#39;genre&#39; as genre
         FROM store.books
         WHERE details-&gt;&gt;&#39;genre&#39;=&#39;novel&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> id | title              | genre
----+--------------------+-------
  4 | Great Expectations | novel
  3 |       Oliver Twist | novel
</code></pre></div>
<h5 id="_91"><strong>按属性值（映射）查询</strong></h5>
<p>author属性是一个映射，依次由属性first_name和last_name组成。获取William Shakespeare所有书籍的ID和标题，如下所示：</p>
<div class="highlight"><pre><span></span><code>SELECT id, details-&gt;&gt;&#39;name&#39; as title,
              details-&gt;&gt;&#39;author&#39; as author
         FROM store.books
         WHERE details-&gt;&#39;author&#39;-&gt;&gt;&#39;first_name&#39; = &#39;William&#39; AND
               details-&gt;&#39;author&#39;-&gt;&gt;&#39;last_name&#39; = &#39;Shakespeare&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> id | title   | author
----+---------+----------------------------------------------------
  1 | Macbeth | {&quot;first_name&quot;:&quot;William&quot;,&quot;last_name&quot;:&quot;Shakespeare&quot;}
  2 |  Hamlet | {&quot;first_name&quot;:&quot;William&quot;,&quot;last_name&quot;:&quot;Shakespeare&quot;}
</code></pre></div>
<h5 id="_92"><strong>按属性值（数组）查询</strong></h5>
<p>editors属性是一个数组，由每本书的editors 的first name组成。您可以查询图书标题，其中Mark是editors 列表中的第一个条目，如下所示：</p>
<div class="highlight"><pre><span></span><code>SELECT id, details-&gt;&gt;&#39;name&#39; as title,
              details-&gt;&gt;&#39;editors&#39; as editors FROM store.books
         WHERE details-&gt;&#39;editors&#39;-&gt;&gt;0 = &#39;Mark&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> id | title        | editors
----+--------------+---------------------------
  3 | Oliver Twist | [&quot;Mark&quot;,&quot;Tony&quot;,&quot;Britney&quot;]
</code></pre></div>
<h3 id="sql-vs-nosql"><strong>SQL vs NoSQL</strong></h3>
<p>大多数应用程序开发人员都使用SQL，可能还有一些NoSQL数据库来构建应用程序。BMDB将这两个数据库中最好的数据库整合到一个统一的平台中，以简化可扩展云服务的开发。
通常情况下，今天的云服务和应用程序一开始只需要少量请求和数据。这些可以由几个节点提供服务。但是，如果该应用程序变得流行，他们将不得不迅速扩展，以处理数百万个请求和数TB的数据，BMDB非常适合这类工作负载。</p>
<h4 id="sqlnosql"><strong>统一SQL和NoSQL</strong></h4>
<p>以下是一些不同的标准，BMDB将SQL和NoSQL的最佳功能整合到一个数据库平台中。</p>
<h5 id="_93"><strong>数据库特征</strong></h5>
<p>这些可以被松散地定义为选择数据库来构建应用程序或云服务时的高级关注点，例如其数据模型、支持的API、一致性语义等。下表对比了BMDB与SQL和NoSQL数据库提供的一般功能。请注意，有许多不同的NoSQL数据库，每个数据库都有自己的细微行为，并且该表并不适用于所有NoSQL数据库——它只是为了给出一个想法。</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>SQL</th>
<th>NoSQL</th>
<th>BMDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据模型</td>
<td>定义良好的架构（表、行、列）</td>
<td>无架构</td>
<td>都有</td>
</tr>
<tr>
<td>API</td>
<td>SQL</td>
<td>各式各样</td>
<td>关系型SQL +半关系型SQL</td>
</tr>
<tr>
<td>一致性</td>
<td>强</td>
<td>结果一致</td>
<td>强</td>
</tr>
<tr>
<td>事务</td>
<td>ACID</td>
<td>无</td>
<td>ACID</td>
</tr>
<tr>
<td>高写入吞吐量</td>
<td>否</td>
<td>有时</td>
<td>是</td>
</tr>
<tr>
<td>可调整读取延迟</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<h5 id="_94"><strong>操作特性</strong></h5>
<p>操作特性可以定义为在生产中部署、运行和管理数据库时出现的运行时问题。当在类似云的体系结构中的生产中运行数据库时，许多操作特性变得至关重要。下表比较了BMDB的SQL和NoSQL数据库的功能。与前一节一样，有许多NoSQL数据库在各自方面都有所不同，下表旨在提供一个大致的概念。
下表列出了BMDB支持的一些重要功能，以及用于利用该功能的API。请注意，通常部署多个数据库以实现相同的功能。</p>
<table>
<thead>
<tr>
<th>操作特性</th>
<th>SQL</th>
<th>NoSQL</th>
<th>BMDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动分片</td>
<td>否</td>
<td>有时</td>
<td>是</td>
</tr>
<tr>
<td>线性扩展</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>容错</td>
<td>否-手动设置</td>
<td>是-智能客户端检测到故障节点</td>
<td>是-智能客户端检测到故障节点</td>
</tr>
<tr>
<td>数据恢复</td>
<td>否</td>
<td>是-但重建会导致高延迟</td>
<td>是-自动、高效的数据重建</td>
</tr>
<tr>
<td>地理分布</td>
<td>否-手动设置</td>
<td>有时</td>
<td>是</td>
</tr>
<tr>
<td>低延迟读取</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可预测的p99读取延迟</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>高数据密度</td>
<td>否</td>
<td>有时-当密度增加时会出现延迟</td>
<td>是-高数据密度时会出现可预测的延迟</td>
</tr>
<tr>
<td>读取复制副本支持</td>
<td>否-手动设置</td>
<td>否-没有异步复制</td>
<td>是—同步和异步复制选项</td>
</tr>
</tbody>
</table>
<h4 id="_95"><strong>核心功能</strong></h4>
<p>应用程序和云服务依赖于数据库来实现各种内置功能。这些功能可以包括执行多行事务、JSON或文档支持、辅助索引、使用TTL的自动数据过期等等。
下面是一个表，列出了BMDB支持的一些重要功能，以及为了实现这些功能，要使用哪些BMDB的API。请注意，为了实现这些功能，通常会部署多个数据库。 </p>
<table>
<thead>
<tr>
<th>数据库功能</th>
<th>BMDB SQL API</th>
<th>BMDB 云QL API</th>
</tr>
</thead>
<tbody>
<tr>
<td>多行事务</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>一致的辅助索引</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>JSON/文档支持</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>二级索引</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>外键</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>JOINs</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>TTL自动数据到期</td>
<td>否</td>
<td>是-表和列级别TTL</td>
</tr>
<tr>
<td>为AI/ML运行Apache Spark</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<h4 id="_96"><strong>线性扩展</strong></h4>
<p>为了测试BMDB 的线性可扩展性，我们运行了一些大型集群基准测试（最多50个节点），并能够将BMDB 扩展到每秒数百万次读写，同时保持低延迟。</p>
<h4 id="_97"><strong>高性能</strong></h4>
<p>BMDB 的构建是为了在不牺牲一致性的情况下在公共云环境中提供性能。BMDB 是用C++编写的，正是因为这个原因。下图显示了BMDB 在运行YCSB基准测试时与ApacheCassandra的比较情况。
下图显示了运行YCSB基准测试时的总操作数/秒：</p>
<p><img alt="" src="./media/chapter3/16.png" />下图显示了YCSB运行的延迟： 
<img alt="" src="./media/chapter3/17.png" /></p>
<h3 id="_98"><strong>事务</strong></h3>
<h4 id="_99"><strong>概述</strong></h4>
<h5 id="bsql"><strong>BSQL</strong></h5>
<p>在BMDB 中，事务是作为单个逻辑工作单元执行的一系列操作。事务的要点是，它将多个步骤捆绑到一个单一的、要么全有要么全无的操作中。这些步骤之间的中间状态对其他并发事务是不可见的，如果发生了一些阻止事务完成的故障，那么这些步骤都不会影响数据库。</p>
<h6 id="_100">概述</h6>
<p>在BMDB 中，事务是BEGIN-COMMIT 块中的一组命令。例如： </p>
<div class="highlight"><pre><span></span><code>BEGIN;
  UPDATE accounts SET balance = balance + 1000.00 WHERE name = &#39;John Smith&#39;;
  -- other statements
COMMIT;
</code></pre></div>
<p>当您有多个语句要作为事务的一部分执行时，需要BEGIN和COMMIT块。BMDB 将每个特定的SQL语句视为在事务中执行。 </p>
<p>如果您决定取消事务而不提交它，您可以发出ROLLBACK 而不是COMMIT。还可以使用SAVEPOINT控制语句子集的回滚。回滚到savepoint后，将继续定义该保存点，因此可以多次回滚到该savepoint。</p>
<p>由于BMDB 中的所有事务都保证符合ACID，因此可以在事务处理过程中抛出错误，以确保不违反正确性保证。BMDB 为每种情况返回不同的错误代码，并提供详细信息。应用程序需要被设计为正确地进行重试以获得高可用性。 </p>
<h6 id="_101">典型命令</h6>
<p>事务中通常涉及以下命令： </p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>BEGIN</td>
<td>启动事务。这是事务中的第一条语句。</td>
<td>BEGIN TRANSACTION</td>
</tr>
<tr>
<td>SET</td>
<td>设置会话级事务设置</td>
<td>SET idle_in_transaction_session_timeout = 10000</td>
</tr>
<tr>
<td>SHOW</td>
<td>显示会话级事务设置</td>
<td>SHOW idle_in_transaction_session_timeout</td>
</tr>
<tr>
<td>SET TRANSACTION</td>
<td>设置隔离级别。</td>
<td>SET TRANSACTION SERIALIZABLE</td>
</tr>
<tr>
<td>SAVEPOINT</td>
<td>创建一个检查点。</td>
<td>SAVEPOINT bm_save</td>
</tr>
<tr>
<td>ROLLBACK TO SAVEPOINT</td>
<td>Rollback到一个指定的保存点</td>
<td>ROLLBACK TO SAVEPOINT bm_save</td>
</tr>
<tr>
<td>RELEASE SAVEPOINT</td>
<td>销毁一个保存点</td>
<td>RELEASE bm_save</td>
</tr>
<tr>
<td>ROLLBACK</td>
<td>取消事务</td>
<td>ROLLBACK</td>
</tr>
<tr>
<td>COMMIT</td>
<td>应用事务到表中</td>
<td>COMMIT</td>
</tr>
</tbody>
</table>
<h6 id="_102">并发控制</h6>
<ol>
<li>隔离级别 
   隔离级别定义了事务的数据可见性级别。BMDB 支持多版本并发控制（MVCC），无需锁定即可隔离并发事务。
   BMDB 支持三种隔离级别，以支持不同的应用需求。 </li>
</ol>
<table>
<thead>
<tr>
<th>级别</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Repeatable Read (Snapshot)</td>
<td>只有在事务开始之前提交的数据对事务可见。实际上，事务会在事务开始时看到数据库的快照。</td>
</tr>
<tr>
<td>Read Committed (beta)</td>
<td>事务的每条语句都会看到任何并发事务在执行该语句之前提交的最新数据。如果另一个事务修改了与当前事务相关的行，则当前事务将等待另一事务提交或回滚其更改。</td>
</tr>
<tr>
<td>Serializable</td>
<td>这是最严格的隔离级别，其效果是所有事务都以串行方式执行，一个接一个而不是并行执行。</td>
</tr>
</tbody>
</table>
<ol>
<li>显式锁定 
   通常，SELECT语句不会自动锁定事务期间提取的行。根据您的应用程序需要，您可能必须锁定SELECT期间检索到的行。BMDB 支持这种情况下的显式行级锁定，并确保没有两个事务可以在同一行上持有锁。根据并发控制策略解决锁获取冲突。</li>
</ol>
<p>锁定具有以下格式：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM txndemo WHERE k=1 FOR UPDATE;
</code></pre></div>
<p>BMDB 支持以下类型的显式行锁： </p>
<table>
<thead>
<tr>
<th>锁</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>FOR UPDATE</td>
<td>最强独占锁。阻止这些行上的所有其他锁，直到事务结束。</td>
</tr>
<tr>
<td>FOR NO KEY UPDATE</td>
<td>弱于FOR UPDATE和独占。不会阻止FOR KEY SHARE命令。</td>
</tr>
<tr>
<td>FOR SHARE</td>
<td>不阻止其他FOR SHARE和FOR KEY SHARE命令的共享锁。</td>
</tr>
<tr>
<td>FOR KEY SHARE</td>
<td>不阻止其他FOR SHARE、FOR KEY SHARE和FOR NO KEY UPDATE命令的共享锁。</td>
</tr>
</tbody>
</table>
<h6 id="_103">失败时重试</h6>
<p>在事务处理过程中，由于BMDB 保证强ACID属性，可能会发生故障。每个场景都会返回适当的错误代码，应用程序应采用特定于其使用的隔离级别的正确重试机制，以实现高可用性。通常，错误代码可分为以下三种类型： </p>
<ol>
<li>警告：解释语句失败原因的信息性消息。例如：</li>
</ol>
<div class="highlight"><pre><span></span><code>-- When a BEGIN statement is issued inside a transaction
WARNING:  25001: there is already a transaction in progress
</code></pre></div>
<p>大多数客户端库都隐藏警告，但当您直接从终端执行语句时，可能会注意到这些消息。语句执行可以继续而不中断，但需要进行修改以避免消息再次出现。</p>
<ol>
<li>错误：当事务无法继续，并且客户端必须重新启动时，会返回错误。例如：</li>
</ol>
<div class="highlight"><pre><span></span><code>-- When multiple transactions are modifying the same key.
ERROR:  40001: Operation expired: Transaction XXXX expired or aborted by a conflict
</code></pre></div>
<p>应用程序需要采取适当的操作处理这些错误。</p>
<ol>
<li>致命：将返回致命消息，通知与服务器的连接已断开。例如：</li>
</ol>
<div class="highlight"><pre><span></span><code>-- When the application takes a long time to issue a statement in the middle of a transaction.
FATAL:  25P03: terminating connection due to idle-in-transaction timeout
</code></pre></div>
<p>此时，应用程序应该重新连接到服务器。 </p>
<h6 id="_104">高性能调优</h6>
<p>所有应用程序都需要进行调优以获得最佳性能。BMDB 支持各种结构和多种设置，可以根据您的需求进行调整。在正确的场景中采用正确的构造可以极大地提高应用程序的性能。例如：</p>
<ul>
<li>将影响单行的多语句事务转换为快速路径事务。</li>
<li>避免长时间等待和适当的超时。</li>
<li>使用ON CONFLICT 子句最大限度地减少冲突错误。</li>
<li>不间断的长扫描</li>
<li>使用存储过程最大限度地减少往返行程。</li>
</ul>
<h6 id="_105">可观测性</h6>
<p>BMDB 导出了许多可观测的指标，这样您就可以看到集群中发生了什么。这些度量可以导出到Prometheus ，并在Grafana中可视化。以下是与事务相关的关键指标：</p>
<ol>
<li>
<p>transactions_running
   显示当前活动的事务数，它提供了集群当前事务密集程度的概述。 </p>
</li>
<li>
<p>transaction_conflicts
   描述事务与其它事务发生冲突的次数，冲突数量的增加可能会直接导致应用程序的延迟增加。</p>
</li>
<li>
<p>expired_transactions
   显示由于状态分片未从客户端连接的节点接收到足够的检测信号而未完成的事务数。如果管理事务的节点或进程崩溃，通常会发生这种情况。 </p>
</li>
</ol>
<h6 id="_106">会话级设置</h6>
<p>以下BSQL参数会影响事务，可以根据应用程序的需要进行配置。可以使用SET 命令设置这些设置，并且可以使用SHOW命令获取当前值。 </p>
<ol>
<li>default_transaction_read_only
   设置为ON/TRUE/1可使当前会话中的所有事务都为只读。当您想要运行报告或设置follower 读取时，这很有帮助。</li>
</ol>
<div class="highlight"><pre><span></span><code>SET default_transaction_read_only = TRUE;
</code></pre></div>
<ol>
<li>default_transaction_isolation
   将其设置为serializable、repeatable read或read committed之一。这为当前会话中的所有事务设置默认隔离级别。</li>
</ol>
<div class="highlight"><pre><span></span><code>SET default_transaction_isolation = &#39;serializable&#39;;
</code></pre></div>
<ol>
<li>default_transaction_deferrable 
   设置为ON/TRUE/1可使当前会话中的所有事务都可延迟。这样可以确保事务不会因序列化失败而取消。 </li>
</ol>
<div class="highlight"><pre><span></span><code>SET default_transaction_deferrable = TRUE;
</code></pre></div>
<p>注意：
DEFERRABLE 事务属性无效，除非该事务是SERIALIZABLE 且READ ONLY。 </p>
<ol>
<li>
<p>idle_in_transaction_session_timeout
   将其设置为持续时间（例如，“10s或1000”），以限制事务语句中的延迟。默认时间单位为毫秒。</p>
</li>
<li>
<p>bm_transaction_priority_lower_bound
   将其设置为[0.0 - 1.0]范围内的值，以设置动态优先级分配的下限</p>
</li>
<li>
<p>bm_transaction_priority_upper_bound
   将其设置为[0.0 - 1.0]范围内的值，以设置动态优先级分配的上限。</p>
</li>
</ol>
<h5 id="bcql"><strong>BCQL</strong></h5>
<p>事务是作为单个逻辑工作单元执行的一系列操作。事务具有以下四个关键属性，通常缩写为ACID：
原子性：事务中的所有工作都被视为一个原子单元——要么全部执行，要么不执行。
一致性：完成的事务使数据库处于一致的内部状态。这可以是事务中的所有操作都成功，也可以是没有一个成功。
隔离性：此属性确定一个事务所做的更改对另一个事务可见的方式和时间。例如，可序列化隔离级别保证两个并发事务看起来好像一个在另一个之后执行（也就是说，好像它们以完全隔离的方式发生）。BMDB支持BCQL API中的快照隔离级别。
持久性：事务处理的结果永久存储在系统中。即使在断电或系统故障的情况下，修改也必须持久。 </p>
<h6 id="_107">事务属性</h6>
<p>要在BCQL中的表上启用分布式事务，请创建启用了transactions属性的表，如下所示： </p>
<div class="highlight"><pre><span></span><code>CREATE TABLE IF NOT EXISTS &lt;TABLE_NAME&gt; (...) WITH transactions = { &#39;enabled&#39; : true };
</code></pre></div>
<h6 id="cqlsh">cqlsh使用示例</h6>
<p>创建键值空间：</p>
<div class="highlight"><pre><span></span><code>CREATE KEYSPACE banking;
</code></pre></div>
<p>创建一个启用transactions 属性集的表，如下所示：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE banking.accounts (
  account_name varchar,
  account_type varchar,
  balance float,
  PRIMARY KEY ((account_name), account_type)
) with transactions = { &#39;enabled&#39; : true };
</code></pre></div>
<p>您可以通过运行以下查询来验证此表上是否启用了事务： </p>
<div class="highlight"><pre><span></span><code>select keyspace_name, table_name, transactions from system_schema.tables
where keyspace_name=&#39;banking&#39; AND table_name = &#39;accounts&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> keyspace_name | table_name | transactions
---------------+------------+---------------------
       banking |   accounts | {&#39;enabled&#39;: &#39;true&#39;}

(1 rows)
</code></pre></div>
<p>插入以下一些示例数据： </p>
<div class="highlight"><pre><span></span><code>INSERT INTO banking.accounts (account_name, account_type, balance) VALUES (&#39;John&#39;, &#39;savings&#39;, 1000);
INSERT INTO banking.accounts (account_name, account_type, balance) VALUES (&#39;John&#39;, &#39;checking&#39;, 100);
INSERT INTO banking.accounts (account_name, account_type, balance) VALUES (&#39;Smith&#39;, &#39;savings&#39;, 2000);
INSERT INTO banking.accounts (account_name, account_type, balance) VALUES (&#39;Smith&#39;, &#39;checking&#39;, 50);
</code></pre></div>
<p>显示John和Smith的余额： </p>
<div class="highlight"><pre><span></span><code>select * from banking.accounts;
</code></pre></div>
<div class="highlight"><pre><span></span><code> account_name | account_type | balance
--------------+--------------+---------
         John |     checking |     100
         John |      savings |    1000
        Smith |     checking |      50
        Smith |      savings |    2000
</code></pre></div>
<p>检查John的余额如下：</p>
<div class="highlight"><pre><span></span><code>SELECT SUM(balance) as Johns_balance FROM banking.accounts WHERE account_name=&#39;John&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> johns_balance
---------------
          1100
</code></pre></div>
<p>检查Smith的余额如下：</p>
<div class="highlight"><pre><span></span><code>SELECT SUM(balance) as smiths_balance FROM banking.accounts WHERE account_name=&#39;Smith&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> smiths_balance
----------------
           2050
</code></pre></div>
<p>执行事务：</p>
<p>假设John 把$200 从他的储蓄帐户转到他的支票帐户。这必须是一个事务性操作。这可以通过以下方式实现： </p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION
  UPDATE banking.accounts SET balance = balance - 200 WHERE account_name=&#39;John&#39; AND account_type=&#39;savings&#39;;
  UPDATE banking.accounts SET balance = balance + 200 WHERE account_name=&#39;John&#39; AND account_type=&#39;checking&#39;;
END TRANSACTION;
</code></pre></div>
<p>如果您现在选择了John帐户的值，您应该会看到反映的金额。总余额应与以前一样为$1100。 </p>
<div class="highlight"><pre><span></span><code>select * from banking.accounts where account_name=&#39;John&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> account_name | account_type | balance
--------------+--------------+---------
         John |     checking |     300
         John |      savings |     800
</code></pre></div>
<p>检查John的余额如下：</p>
<div class="highlight"><pre><span></span><code>SELECT SUM(balance) as Johns_balance FROM banking.accounts WHERE account_name=&#39;John&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> johns_balance
---------------
          1100
</code></pre></div>
<p>此外，John的支票和储蓄账户余额应该在同一写入时间戳写入。 </p>
<div class="highlight"><pre><span></span><code>select account_name, account_type, balance, writetime(balance)
from banking.accounts where account_name=&#39;John&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> account_name | account_type | balance | writetime(balance)
--------------+--------------+---------+--------------------
         John |     checking |     300 |   1517898028890171
         John |      savings |     800 |   1517898028890171
</code></pre></div>
<p>现在假设John 把$200从他的支票帐户转到Smith的支票帐户。您可以通过以下事务来完成此操作： </p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION
  UPDATE banking.accounts SET balance = balance - 200 WHERE account_name=&#39;John&#39; AND account_type=&#39;checking&#39;;
  UPDATE banking.accounts SET balance = balance + 200 WHERE account_name=&#39;Smith&#39; AND account_type=&#39;checking&#39;;
END TRANSACTION;
</code></pre></div>
<p>要验证转账是否按预期进行，并验证更新两个帐户的时间是否相同，请执行以下查询：</p>
<div class="highlight"><pre><span></span><code>select account_name, account_type, balance, writetime(balance) from banking.accounts;
</code></pre></div>
<div class="highlight"><pre><span></span><code> account_name | account_type | balance | writetime(balance)
--------------+--------------+---------+--------------------
         John |     checking |     100 |   1517898167629366
         John |      savings |     800 |   1517898028890171
        Smith |     checking |     250 |   1517898167629366
        Smith |      savings |    2000 |   1517894361290020
</code></pre></div>
<p>John 的净余额本应减少$200，Smith 的净余额应增加$200。 </p>
<p>检查John的余额如下： </p>
<div class="highlight"><pre><span></span><code>SELECT SUM(balance) as Johns_balance FROM banking.accounts WHERE account_name=&#39;John&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> johns_balance
---------------
           900
</code></pre></div>
<p>检查Smith的余额如下： </p>
<div class="highlight"><pre><span></span><code>SELECT SUM(balance) as smiths_balance FROM banking.accounts WHERE account_name=&#39;Smith&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> smiths_balance
----------------
           2250
</code></pre></div>
<h6 id="java_1">JAVA使用示例</h6>
<p>以下示例显示了如何创建一个基本键值表，该表有两列且启用了事务： </p>
<div class="highlight"><pre><span></span><code>String create_stmt =
  String.format(&quot;CREATE TABLE IF NOT EXISTS %s (k varchar, v varchar, primary key (k)) &quot; +
                &quot;WITH transactions = { &#39;enabled&#39; : true };&quot;,
                tablename);
</code></pre></div>
<p>可以通过在BEGIN TRANSACTION 和END TRANSACTION 块内执行命令序列来插入数据。 </p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION
  statement 1
  statement 2
END TRANSACTION;
</code></pre></div>
<p>以下代码片段显示了如何将数据插入此表： </p>
<div class="highlight"><pre><span></span><code>// Insert two key values, (key1, value1) and (key2, value2) as a transaction.
String create_stmt =
  String.format(&quot;BEGIN TRANSACTION&quot; +
                &quot;  INSERT INTO %s (k, v) VALUES (%s, %s);&quot; +
                &quot;  INSERT INTO %s (k, v) VALUES (%s, %s);&quot; +
                &quot;END TRANSACTION;&quot;,
                tablename, key1, value1,
                tablename, key2, value2;
</code></pre></div>
<p>您可以准备带有事务的语句，并在执行查询时将变量绑定到准备好的语句。 </p>
<div class="highlight"><pre><span></span><code>String create_stmt =
  String.format(&quot;BEGIN TRANSACTION&quot; +
                &quot;  INSERT INTO %s (k, v) VALUES (:k1, :v1);&quot; +
                &quot;  INSERT INTO %s (k, v) VALUES (:k1, :v2);&quot; +
                &quot;END TRANSACTION;&quot;,
                tablename, key1, value1,
                tablename, key2, value2;
PreparedStatement pstmt = client.prepare(create_stmt);

...

BoundStatement txn1 = pstmt.bind().setString(&quot;k1&quot;, key1)
                                  .setString(&quot;v1&quot;, value1)
                                  .setString(&quot;k2&quot;, key2)
                                  .setString(&quot;v2&quot;, value2);

ResultSet resultSet = client.execute(txn1);
</code></pre></div>
<h6 id="_108">关于线性化的注意事项</h6>
<p>从客户端的角度来看，自动重试可能会破坏操作的线性化。
默认情况下，原始Cassandra Java驱动程序和BMDB Cassandra Java驱动程序使用com.datastax.driver.core.policies.DefaultRetryPolicy，它可以在客户端超时时重试请求。在网络分区下，这可能导致客户端成功响应重试请求并将操作视为已完成，但由于重试，该值可能会被旧操作覆盖。 
为了避免这些线性化问题，请添加com.bigmath.driver.core.policies.NoRetryOnClientTimeoutPolicy，它从DefaultRetryPolicy 继承行为，但有一个例外-在操作超时的情况下会导致错误（带有OperationTimedOutException）。然后，您可以在应用程序层中处理客户端超时。</p>
<h4 id="bsql_1"><strong>BSQL中的事务重试</strong></h4>
<p>BMDB 为事务处理过程中出现问题的各种场景返回不同的错误代码。应用程序需要被设计为正确处理这些场景，以便具有高可用性，这样用户就不会受到影响。尽管大多数错误在多个隔离级别中很常见，但有些错误是特定于某些事务隔离级别的。</p>
<p>以下部分中的示例说明了可用于在应用程序中处理这些故障的故障场景和技术 </p>
<h5 id="_109"><strong>先决条件</strong></h5>
<ol>
<li>创建表</li>
</ol>
<div class="highlight"><pre><span></span><code>CREATE TABLE txndemo (
  k int,
  V int,
  PRIMARY KEY(k)
);
</code></pre></div>
<ol>
<li>插入一些数据</li>
</ol>
<div class="highlight"><pre><span></span><code>INSERT INTO txndemo VALUES (1,10),(2,10),(3,10),(4,10),(5,10);
</code></pre></div>
<h5 id="_110"><strong>自动重试</strong></h5>
<p>BMDB 根据并发控制策略，在没有客户端干预的情况下，尽可能在服务器端自动重试失败的事务。即使对于被隐含地视为事务的单个语句也是如此。在“Read Committed”隔离模式下，服务器将无限期重试。</p>
<p>在某些情况下，服务器端重试是不合适的。例如，已达到重试限制或事务未处于有效状态。在这些情况下，客户端有责任在应用程序层重试事务。</p>
<h5 id="_111"><strong>客户端重试</strong></h5>
<p>由于冲突和死锁而发生的大多数事务错误都可以由客户端重新启动。以下场景描述了失败的原因以及应用程序需要处理的方法。</p>
<p>执行在try..catch块中的事务，当发生可重试的失败时，发出ROLLBACK，然后重试事务。为了避免服务器过载并导致无限循环，请在两次重试之间等待一段时间，并限制重试次数。下面演示了一个典型的客户端重试实现。</p>
<div class="highlight"><pre><span></span><code>max_attempts = 10   # max no.of retries
sleep_time = 0.002  # 2 ms - base sleep time
backoff = 2         # exponential multiplier

attempt = 0
while attempt &lt; max_attempts:
    attempt += 1
    try :
        cursor = cxn.cursor()
        cursor.execute(&quot;BEGIN&quot;);

        # Execute Transaction Statments here

        cursor.execute(&quot;COMMIT&quot;);
        break
    except psycopg2.errors.SerializationFailure as e:
        cursor.execute(&quot;ROLLBACK&quot;)
        if attempt &lt; max_attempts:
            time.sleep(sleep_time)
            sleep_time *= backoff
</code></pre></div>
<p>如果COMMIT成功，程序将退出循环。attempt &lt; max_attempts将重试次数限制为max_attempts，并且代码在下一次重试之前等待的时间也会随着sleep_time*＝backoff而增加。选择适合您的应用程序的值</p>
<h6 id="40001-serializationfailure">40001 - SerializationFailure</h6>
<p>当多个事务更新同一组键（冲突）或事务相互等待（死锁）时，会发生SerializationFailure 错误。错误消息可能是以下类型之一： </p>
<p>在冲突期间，会重试某些事务。但是，在达到重试限制后，会出现以下错误： </p>
<div class="highlight"><pre><span></span><code>ERROR:  40001: All transparent retries exhausted.
</code></pre></div>
<p>所有事务都具有动态优先级。当检测到死锁时，优先级较低的事务会自动终止。对于这种情况，客户端可能会收到类似于以下内容的消息：</p>
<div class="highlight"><pre><span></span><code>ERROR:  40001: Operation expired: Heartbeat: Transaction XXXX expired or aborted by a conflict
</code></pre></div>
<p>处理此错误的正确方法是使用具有后退的重试循环，如客户端重试中所述。当UPDATE或COMMIT由于SerializationFailure而失败时，代码会在等待sleep_time秒后重试，最多可达max_attempts。
处理这些失败的另一种方法是回滚到失败语句之前的检查点，然后如Savepoints中所述继续操作。</p>
<h5 id="savepoints"><strong>Savepoints</strong></h5>
<p>Savepoints 是命名的检查点，可用于回滚少数语句，然后继续处理事务，而不是在出现错误时中止整个事务。</p>
<p>考虑以下插入一行的示例[k=1，v=30]：</p>
<div class="highlight"><pre><span></span><code>connstr = &#39;postgresql://bigmath@localhost:2521/bigmath&#39;
cxn = psycopg2.connect(connstr)
cursor = cxn.cursor()
try:
    cursor.execute(&quot;BEGIN&quot;)

    # ... Execute other statements

    cursor.execute(&quot;SAVEPOINT before_insert&quot;)
    try:
        # insert a row
        cursor.execute(&quot;INSERT INTO txndemo VALUES (1,30)&quot;)
    except psycopg2.errors.UniqueViolation as e:
        print(e)
        # k=1 already exists in our table
        cursor.execute(&quot;ROLLBACK TO SAVEPOINT before_insert&quot;)
        cursor.execute(&quot;UPDATE txndemo SET v=30 WHERE k=1;&quot;)

    # ... Execute other statements
    cursor.execute(&quot;COMMIT&quot;)
except Exception as e:
  print(e)
  cursor.execute(&quot;ROLLBACK&quot;)
</code></pre></div>
<p>如果表中已存在行[k=1]，则INSERT操作将导致Unique Violation异常。从技术上讲，事务将处于错误状态，进一步的语句将导致25P02:in失败的SQL事务错误。您必须捕获异常并回滚。但是，您可以回滚到先前声明的保存点before_insert，并使用k=1更新行的值，而不是回滚整个事务。然后您可以继续处理事务中的其他语句 。</p>
<h5 id="_112"><strong>不可重试的错误</strong></h5>
<p>尽管在大多数错误情况下可以重试大多数事务，但在某些情况下，重试事务不会解决问题。例如，当语句发布不正确时，可能会出现错误。这些语句必须在代码中修复才能继续 。</p>
<h6 id="25001-specify-transaction-isolation-level">25001 - Specify transaction isolation level</h6>
<p>应在执行事务的第一条语句之前指定事务级隔离。如果没有，则会发生以下错误：</p>
<div class="highlight"><pre><span></span><code>BEGIN;
</code></pre></div>
<div class="highlight"><pre><span></span><code>BEGIN
Time: 0.797 ms
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE txndemo SET v=20 WHERE k=1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE 1
Time: 10.416 ms
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
</code></pre></div>
<div class="highlight"><pre><span></span><code>ERROR:  25001: SET TRANSACTION ISOLATION LEVEL must be called before any query
Time: 3.808 ms
</code></pre></div>
<h6 id="25006-modify-a-row-in-a-read-only-transaction">25006 - Modify a row in a read-only transaction</h6>
<p>将事务指定为只读（READ ONLY）后修改行时会出现此错误，如下所示： </p>
<div class="highlight"><pre><span></span><code>BEGIN READ ONLY;
</code></pre></div>
<div class="highlight"><pre><span></span><code>BEGIN
Time: 1.095 ms
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE txndemo SET v=20 WHERE k=1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>ERROR:  25006: cannot execute UPDATE in a read-only transaction
Time: 4.417 ms
</code></pre></div>
<h6 id="25p02-infailedsqltransaction">25P02 - InFailedSqlTransaction</h6>
<p>当在事务中已经存在错误之后发出语句时，就会发生此错误。错误消息将类似于以下内容：</p>
<div class="highlight"><pre><span></span><code>ERROR:  25P02: current transaction is aborted, commands ignored until end of transaction block
</code></pre></div>
<p>考虑以下场景：</p>
<div class="highlight"><pre><span></span><code>BEGIN;
</code></pre></div>
<div class="highlight"><pre><span></span><code>BEGIN
Time: 0.393 ms
</code></pre></div>
<div class="highlight"><pre><span></span><code>INVALID TXN STATEMENT;
</code></pre></div>
<div class="highlight"><pre><span></span><code>ERROR:  42601: syntax error at or near &quot;INVALID&quot;
Time: 2.523 ms
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * from txndemo where k=1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>ERROR:  25P02: current transaction is aborted, commands ignored until end of transaction block
Time: 17.074 ms
</code></pre></div>
<p>此时唯一有效的语句是ROLLBACK或COMMIT</p>
<h4 id="bsql_2"><strong>BSQL中的性能调优</strong></h4>
<p>作为一个通用的分布式数据库，BMDB可以部署在各种配置中，用于各种用例。以下最佳实践和提示可以极大地提高BMDB集群的性能。 </p>
<h5 id="_113"><strong>快速单行事务</strong></h5>
<p>BMDB具有特定的优化功能，可以在事务在单行上操作的某些场景中提高事务的性能。这些事务被称为单行或快速路径事务。这些比分布在分片上的一组行的分布式事务快得多，这些行本身分布在分布在数据中心、区域或全局的多个节点上。
例如，考虑事务中的一个常见场景，其中更新一行并获取新值。这通常分以下多个步骤进行： </p>
<div class="highlight"><pre><span></span><code>BEGIN;
SELECT v FROM txndemo WHERE k=1 FOR UPDATE;
UPDATE txndemo SET v = v + 3 WHERE k=1;
SELECT v FROM txndemo WHERE k=1;
COMMIT;
</code></pre></div>
<p>如上脚本中，当行在第一个SELECT语句中被锁定时，BMDB不知道哪些行将在后续命令中被修改。因此，它认为事务是分布式的。
然而，如果你把它写成一个单独的语句，BMDB可以自信地把它当作一个单行事务。要使用单个语句更新行并返回其新值，请按如下方式使用RETURNING子句：</p>
<div class="highlight"><pre><span></span><code>UPDATE txndemo SET v = v + 3 WHERE k=1 RETURNING v;
</code></pre></div>
<p>BMDB将其视为单行事务，执行速度要快得多。这也节省了一次往返行程，并立即获取更新后的值。</p>
<h5 id="_114"><strong>最大限度地减少冲突错误</strong></h5>
<p>INSERT语句有一个可选的ON CONFLICT子句，它有助于避免某些错误并避免多个语句。
例如，如果并发事务正在插入同一行，这可能会导致UniqueViolation。您不需要让服务器抛出错误并在代码中进行处理，只需要求服务器忽略它，如下所示： </p>
<div class="highlight"><pre><span></span><code>INSERT INTO txndemo VALUES (1,10) ON CONFLICT DO NOTHING;
</code></pre></div>
<p>使用DO NOTHING，服务器不会抛出错误，从而减少应用程序和服务器之间的往返行程。</p>
<p>您还可以通过使用DO UPDATE SET 而不是执行INSERT、fail和UPDATE来模拟upsert ，如下所示：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO txndemo VALUES (1,10)
        ON CONFLICT (k)
        DO UPDATE SET v=10;
</code></pre></div>
<p>现在，当插入失败时，服务器会自动更新行。同样，这会减少应用程序和服务器之间的往返行程。</p>
<h5 id="_115"><strong>处理空闲应用程序</strong></h5>
<p>当应用程序在事务中的两个语句之间花费很长时间或只是挂起时，它可能在这段时间内持有临时记录的锁。如果相应地设置idle_in_transaction_session_timeout，它将达到超时。达到超时后，连接将断开，客户端将不得不重新连接。典型的错误消息是： </p>
<div class="highlight"><pre><span></span><code>FATAL:  25P03: terminating connection due to idle-in-transaction timeout
</code></pre></div>
<p>默认情况下，idle_in_transaction_session_timeout设置为0。您可以使用以下命令在sqlsh中将超时设置为特定值：</p>
<div class="highlight"><pre><span></span><code>SET idle_in_transaction_session_timeout = &#39;10s&#39;;
</code></pre></div>
<p>要查看当前值，请使用以下命令：</p>
<div class="highlight"><pre><span></span><code>SHOW idle_in_transaction_session_timeout;
</code></pre></div>
<div class="highlight"><pre><span></span><code> idle_in_transaction_session_timeout
-------------------------------------
 10s
</code></pre></div>
<p>设置此超时可以避免出现死锁情况，即应用程序获取锁，然后意外挂起。</p>
<h5 id="_116"><strong>大型扫描和批处理作业</strong></h5>
<p>当事务处于SERIALIZABLE 隔离级别和READ ONLY模式时，如果设置了事务属性DEFERRABLE ，则该事务的执行开销要低得多，并且永远不会因为序列化失败而取消。这可以用于批处理或长时间运行的作业，这些作业需要数据库的一致快照，而不会干扰或受到其他事务的干扰。例如： </p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE READ ONLY DEFERRABLE;
SELECT * FROM very_large_table;
COMMIT;
</code></pre></div>
<h5 id="_117"><strong>乐观并发控制</strong></h5>
<p>如前所述，所有事务都会动态地分配优先级。这是一个在[0.0，1.0]范围内的值。可以使用bm_get_current_transaction_prority设置获取当前优先级，如下所示：</p>
<div class="highlight"><pre><span></span><code>SELECT bm_get_current_transaction_priority();
</code></pre></div>
<div class="highlight"><pre><span></span><code>    bm_get_current_transaction_priority
-------------------------------------------
 0.000000000 (Normal priority transaction)
(1 row)
</code></pre></div>
<p>优先级值由两个设置绑定，即bm_transaction_priority_lower_bound和bm_transaction_priority_upper_bound。如果应用程序希望特定事务具有更高的优先级，则可以发出以下语句： </p>
<div class="highlight"><pre><span></span><code>SET bm_transaction_priority_lower_bound=0.9;
SET bm_transaction_priority_upper_bound=1.0;
</code></pre></div>
<p>这确保了分配给您的事务的优先级在[0.9-1.0]范围内，从而使其成为高优先级事务。</p>
<h5 id="_118"><strong>存储过程：最大限度地减少往返</strong></h5>
<p>具有多条语句的客户端执行的事务块，需要在客户端和服务器之间进行多次往返。考虑以下事务：</p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION;
    UPDATE txndemo SET v = 11 WHERE k = 1;
    UPDATE txndemo SET v = 22 WHERE k = 2;
    UPDATE txndemo SET v = 33 WHERE k = 3;
COMMIT;
</code></pre></div>
<p>这个方法需要在应用程序和服务器之间进行五次往返，这意味着应用程序与服务器之间的延迟是前者的五倍。即使延迟很低，这也是非常有害的。如果这些事务被封装在存储过程中，则可以避免这些往返。存储过程在服务器中执行，可以包含循环和错误处理。只需一次调用即可从客户端调用存储过程，如下所示： </p>
<div class="highlight"><pre><span></span><code>CALL stored_procedure_name(argument_list);
</code></pre></div>
<p>根据事务块的复杂性，这可以极大地提高性能。</p>
<h4 id="_119"><strong>全局应用程序的性能调优</strong></h4>
<p>以下最佳实践和提示可以极大地提高多区域部署中事务的性能。</p>
<h5 id="leader"><strong>将Leader放在一个区域</strong></h5>
<p>在多地区的设置中，事务必须接触到分布在多个地区的分片Leader。在这种情况下，事务可能会导致高的区域间延迟。</p>
<p>通过使用bm-admin中的set_preferred_zones命令将所有分片Leader放置在一个区域中，可以避免跨区域访问。</p>
<h5 id="follower"><strong>follower读</strong></h5>
<p>BMDB中的所有读取都由leader处理，以确保应用程序获取最新的数据，即使数据被复制到follower。虽然复制很快，但它不是即时的，并且follower在读取时可能没有最新的数据。但在某些情况下，没有必要从leader那里了解情况。例如：</p>
<ul>
<li>数据不会经常更改（例如，电影数据库）。</li>
<li>应用程序不需要最新数据（例如，阅读昨天的报告）。 </li>
</ul>
<p>在这种情况下，您可以启用follower 读取，以从follower 读取内容，而不是转到可能位于不同地区的leader。
要启用follower读取，请将事务设置为READ ONLY，并打开BSQL参数bm_read_from_followers。例如：</p>
<div class="highlight"><pre><span></span><code>SET bm_read_from_followers = true;
BEGIN TRANSACTION READ ONLY;
...
COMMIT;
</code></pre></div>
<p>这将从最近的follower 或leader那里读取数据。由于复制副本可能不是所有更新都是最新的，因此按设计，这将只返回过时的数据（默认值：30秒）。即使读给了leader，情况也是如此。可以使用其他设置更改旧值，如：</p>
<div class="highlight"><pre><span></span><code>SET bm_follower_read_staleness_ms = 10000; -- 10s
</code></pre></div>
<h5 id="_120"><strong>使用重复索引</strong></h5>
<p>添加索引是加快查询速度的常用技术。通过添加查询中创建覆盖索引所需的所有列，可以执行仅索引扫描，而不需要扫描表，只需要扫描索引。如果覆盖索引的模式与表相同，则称为重复索引。</p>
<p>如果从多个区域运行应用程序，可以将重复索引与多区域集群中的表空间结合使用，以大大提高读取延迟，如下所示： </p>
<ul>
<li>创建不同的表空间，并为每个区域设置首选leader。</li>
<li>创建重复索引，并将它们附加到每个表空间。</li>
</ul>
<p>这导致多个重复索引与本地leader立即一致，每个区域一个。现在，在一个区域中运行的应用程序不必跨区域转到另一个区域的表leader。尽管这会影响写入延迟，因为每次更新都必须到达多个索引，但读取延迟要低得多，因为读取会到达表的本地重复索引。</p>
<h4 id="_121"><strong>错误码</strong></h4>
<p>由于BMDB保证了强大的ACID属性，事务过程中的失败是不可避免的。您需要设计应用程序，以便对失败的语句采取适当的操作，以确保它们具有高可用性。BMDB为事务处理过程中发生的错误返回各种错误代码。</p>
<p>以下错误代码通常发生在事务处理过程中:</p>
<h5 id="25001-active-sql-transaction"><strong>25001: Active SQL transaction</strong></h5>
<p>应该在事务块外部运行的某些语句会发生此错误，因为它们具有不可回滚的副作用或执行内部提交。例如，在事务内部发出BEGIN语句。</p>
<div class="highlight"><pre><span></span><code>WARNING:  25001: there is already a transaction in progress
</code></pre></div>
<p>注：25001个错误只是警告。但该代码需要修复，以避免将来出现警告。 </p>
<h5 id="25006-read-only-sql-transaction"><strong>25006: Read only SQL transaction</strong></h5>
<p>当在违反只读约束的只读事务中执行某些语句时，会发生此错误。例如，修改只读事务中的记录。</p>
<div class="highlight"><pre><span></span><code>ERROR:  25006: cannot execute UPDATE in a read-only transaction
</code></pre></div>
<p>注：25006错误不可重试。应从只读事务代码中删除写入操作。 </p>
<h5 id="25p01-no-active-sql-transaction"><strong>25P01: No active SQL transaction</strong></h5>
<p>当应该在事务中执行的某些语句在事务之外执行时，就会发生此错误。例如，在事务外部发出ROLLBACK。</p>
<div class="highlight"><pre><span></span><code>WARNING:  25P01: there is no transaction in progress
</code></pre></div>
<p>注：25P01错误只是警告。但该代码需要修复，以避免将来出现警告。</p>
<h5 id="25p02-in-failed-sql-transaction"><strong>25P02: In failed SQL transaction</strong></h5>
<p>当语句在事务内部失败，并且执行COMMIT或ROLLBACK以外的另一条语句时，就会发生此错误。</p>
<div class="highlight"><pre><span></span><code>ERROR:  25P02: current transaction is aborted, commands ignored until end of transaction block
</code></pre></div>
<p>注：25P02错误不可重试。通过尝试正确处理try..catch块，并且COMMIT或ROLLBACK应该被适当地执行。</p>
<h5 id="25p03-idle-in-transaction-session-timeout"><strong>25P03: Idle in transaction session timeout</strong></h5>
<p>当应用程序在事务中间的空闲时间超过idle_in_transaction_session_timeout时，就会发生这种情况。</p>
<div class="highlight"><pre><span></span><code>FATAL:  25P03: terminating connection due to idle-in-transaction timeout
</code></pre></div>
<p>注：客户端可以重新连接到服务器，然后重试事务。 </p>
<h5 id="40001-serialization-failure"><strong>40001: Serialization failure</strong></h5>
<p>当事务由于其他冲突事务而无法应用或无法继续进行时，就会发生此错误。例如，当多个事务正在修改同一个Key时。 </p>
<div class="highlight"><pre><span></span><code>ERROR:  40001: Operation expired: Transaction XXXX expired or aborted by a conflict
</code></pre></div>
<p>注：客户端可以重试序列化失败错误。</p>
<h5 id="2d000-invalid-transaction-termination"><strong>2D000: Invalid transaction termination</strong></h5>
<p>当事务被COMMIT或ROLLBACK终止在无效位置时，就会发生此错误。例如，当COMMIT在从事务内部调用的存储过程中发出时。 </p>
<div class="highlight"><pre><span></span><code>ERROR:  2D000: invalid transaction termination
</code></pre></div>
<p>注：2D000错误是不可重试的。需要修复事务代码才能避免此错误。 </p>
<h5 id="3b001-invalid-savepoint-specification"><strong>3B001: Invalid savepoint specification</strong></h5>
<p>当您尝试ROLLBACK到或RELEASE 未定义的存储点时，会发生此错误。</p>
<div class="highlight"><pre><span></span><code>ERROR:  3B001: savepoint &quot;FIRST_SAVE&quot; does not exist
</code></pre></div>
<p>注：3B001错误不可重试。需要修复事务代码以指定正确的保存点名称来修复此错误。 </p>
<h3 id="_122"><strong>文本搜索</strong></h3>
<h4 id="_123"><strong>概述</strong></h4>
<p>基本文本搜索使用模式匹配，使用=、LIKE和ILIKE运算符来检查文档中是否存在给定的模式。虽然这对于许多情况来说是足够的，但它有以下缺点：</p>
<ul>
<li>结果未排序。</li>
<li>不支持索引，因此必须扫描所有行，从而降低性能。</li>
<li>搜索多个模式很麻烦，并且需要对搜索项进行严格排序。 </li>
</ul>
<p>全文搜索带来了一种全新的数据预处理模式，能够将数据解析为令牌，将令牌转换为词法（c.f.词干），并以最适合搜索的方式存储处理后的数据（例如，反向索引）。它还添加了新类型的模式匹配，如前缀匹配、后缀匹配、模糊匹配等等。</p>
<p>BMDB提供以下搜索文本的方法和功能 </p>
<h5 id="_124"><strong>模式匹配</strong></h5>
<p>模式匹配是通过使用%，_，*，.字符指定一个模式来完成的，并使用LIKE、ILIKE和~运算符。模式的范围可以从基本的前缀/后缀表达式到复杂的正则表达式。例如：</p>
<div class="highlight"><pre><span></span><code>&#39;abc&#39; LIKE &#39;a%&#39;             --&gt; true
&#39;abc&#39; LIKE &#39;_bc&#39;            --&gt; true
&#39;abc&#39; LIKE &#39;c&#39;              --&gt; false
&#39;abc&#39; SIMILAR TO &#39;%(b|d)%&#39;  --&gt; true
&#39;abc&#39; ~ &#39;a.*c&#39;              --&gt; true
</code></pre></div>
<h5 id="_125"><strong>相似性搜索</strong></h5>
<p>相似性匹配的工作原理是通过考虑有多少字母不同以及有多少字母出现在一起来确定两个字符串的相似程度。当您不知道查询词的确切拼写时，请使用相似性搜索。相似性搜索可以用于设计拼写检查器。</p>
<p>例如，warehoused和warehouse 为1，因为它仅仅比warehouse 多了一个字符（d）。</p>
<h5 id="_126"><strong>全文搜索</strong></h5>
<p>今天几乎所有的搜索引擎都广泛使用反向索引。反向索引解析文档并存储单个单词，及其在文档中的相应位置。例如： </p>
<div class="highlight"><pre><span></span><code>&#39;The quick brown fox jumps jumps over the lazy dog&#39;
</code></pre></div>
<p>将被解析如下： </p>
<div class="highlight"><pre><span></span><code> &#39;brown&#39;:3 &#39;dog&#39;:10 &#39;fox&#39;:4 &#39;jump&#39;:5,6 &#39;lazi&#39;:9 &#39;quick&#39;:2
</code></pre></div>
<p>这使您能够搜索具有fox 和quick 或jumping dog的文档。 </p>
<h5 id="_127"><strong>拼音搜索</strong></h5>
<p>如果你不知道确切的搜索词，并且想找到听起来与特定词相似的类似项目或文档，模糊或语音搜索会派上用场。BMDB通过PostgreSQL扩展支持Soundex、Metaphone 等模糊搜索。例如，要找到听起来像anapistagafi的单词，您可以执行， </p>
<div class="highlight"><pre><span></span><code>select word from words where dmetaphone(word) = dmetaphone(&#39;anapistagafi&#39;) limit 5;
</code></pre></div>
<h4 id="_128"><strong>模式匹配</strong></h4>
<p>LIKE操作符是一个基本的模式匹配操作符，它模拟类似于许多*nix shell的通配符匹配。模式匹配可以使用%（百分比）匹配任何字符序列，也可以使用_（下划线）匹配任何单个字符。 </p>
<h5 id="_129"><strong>部署</strong></h5>
<p>创建表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE IF NOT EXISTS words (
    id SERIAL,
    word TEXT NOT NULL,
    PRIMARY KEY(id)
);
</code></pre></div>
<p>加载如下数据：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO words(word) VALUES
  (&#39;camp&#39;),(&#39;carousel&#39;),(&#39;cartel&#39;),(&#39;carpet&#39;),(&#39;carnivore&#39;),(&#39;cartoon&#39;),(&#39;carry&#39;),(&#39;capsule&#39;),
  (&#39;corsica&#39;),(&#39;medica&#39;),(&#39;azteca&#39;),(&#39;republica&#39;),(&#39;chronica&#39;),(&#39;orca&#39;),(&#39;cathodically&#39;),(&#39;capably&#39;),
  (&#39;cot&#39;),(&#39;cat&#39;),(&#39;cut&#39;),(&#39;cwt&#39;),(&#39;cit&#39;),(&#39;cit&#39;),(&#39;captainly&#39;),(&#39;callously&#39;),(&#39;career&#39;),(&#39;calculate&#39;),
  (&#39;lychees&#39;),(&#39;deer&#39;),(&#39;peer&#39;),(&#39;seer&#39;),(&#39;breeze&#39;),(&#39;green&#39;),(&#39;teen&#39;),(&#39;casually&#39;);
</code></pre></div>
<h5 id="_130"><strong>后缀匹配</strong></h5>
<p>将%添加到模式的末尾，以匹配完成给定模式的任何字符串。例如，要获取所有以ca开头的单词，请执行以下操作： </p>
<div class="highlight"><pre><span></span><code>SELECT word FROM words WHERE word LIKE &#39;ca%&#39; limit 5;
</code></pre></div>
<div class="highlight"><pre><span></span><code>      word
--------------
 carnivore
 camp
 capably
 cathodically
 cartoon
</code></pre></div>
<h5 id="_131"><strong>前缀匹配</strong></h5>
<p>将%添加到模式的开头，以匹配以给定模式结束的任何字符串。例如，要获取以ca结尾的单词，请执行以下操作：</p>
<div class="highlight"><pre><span></span><code>SELECT word FROM words WHERE word LIKE &#39;%ca&#39; limit 5;
</code></pre></div>
<div class="highlight"><pre><span></span><code>   word
-----------
 azteca
 chronica
 republica
 corsica
 medica
</code></pre></div>
<h5 id="infix"><strong>Infix匹配</strong></h5>
<p>您也可以使用%来匹配给定模式之间的任何文本序列。例如，要获取所有以ca开头、以ly结尾的单词，请执行以下操作： </p>
<div class="highlight"><pre><span></span><code>SELECT word FROM words WHERE word LIKE &#39;ca%ly&#39; limit 5;
</code></pre></div>
<div class="highlight"><pre><span></span><code>     word
--------------
 capably
 cathodically
 casually
 captainly
 callously
</code></pre></div>
<h5 id="_132"><strong>不区分大小写的匹配</strong></h5>
<p>LIKE运算符执行区分大小写的匹配。例如，如果将模式更改为大写，则可能不会得到相同的结果。 </p>
<div class="highlight"><pre><span></span><code>SELECT word FROM words WHERE word LIKE &#39;C_T&#39; limit 5;
</code></pre></div>
<div class="highlight"><pre><span></span><code> word
------
(0 rows)
</code></pre></div>
<p>要支持不区分大小写的匹配，请使用ILIKE运算符。 </p>
<div class="highlight"><pre><span></span><code>SELECT word FROM words WHERE word ILIKE &#39;C_T&#39; limit 5;
</code></pre></div>
<div class="highlight"><pre><span></span><code> word
------
 cit
 cot
 cut
 cat
 cit
</code></pre></div>
<h5 id="regex"><strong>Regex匹配</strong></h5>
<p>使用SIMILAR TO运算符可以使用SQL标准的正则表达式定义来匹配模式。SQL正则表达式是LIKE表示法和公共（POSIX）正则表达式表示法。</p>
<p>例如，要查找e连续出现三次或三次以上的所有单词，请执行以下操作： </p>
<div class="highlight"><pre><span></span><code>SELECT word FROM words WHERE word SIMILAR TO &#39;%e{2,}%&#39; ;
</code></pre></div>
<div class="highlight"><pre><span></span><code>  word
---------
 peer
 green
 seer
 lychees
 deer
 teen
 breeze
 career
</code></pre></div>
<p>SIMILAR TO支持以下模式匹配元字符： </p>
<ul>
<li>| 表示交替（两个备选方案中的任意一个）。</li>
<li>
<ul>
<li>表示前一项重复零次或多次。</li>
</ul>
</li>
<li>
<ul>
<li>表示前一项的重复一次或多次。</li>
</ul>
</li>
<li>? 表示前一项的重复零次或一次。</li>
<li>{m} 表示前一项的重复恰好为m次。</li>
<li>{m，}表示前一项的重复m次或更多次。</li>
<li>{m，n}表示前一项的重复至少m次且不超过n次。</li>
</ul>
<p>使用圆括号 () 将项分组为单个逻辑项。括号表达式[…]指定一个字符类，就像在POSIX正则表达式中一样。</p>
<h5 id="_133"><strong>单个字符匹配</strong></h5>
<p>使用 _（下划线）匹配任何单个字符。要获取所有以c开头、以t结尾的3个字母的单词，请执行以下操作：</p>
<div class="highlight"><pre><span></span><code>SELECT word FROM words WHERE word LIKE &#39;c_t&#39; limit 5;
</code></pre></div>
<div class="highlight"><pre><span></span><code> word
------
 cit
 cot
 cut
 cat
 cit
</code></pre></div>
<h4 id="_134"><strong>相似性搜索</strong></h4>
<p>相似性匹配的工作原理是确定两个不同字符串的相似程度。当你不知道查询词的确切拼写时，这会很有帮助，可以用来设计拼写检查器。</p>
<h5 id="_135"><strong>部署</strong></h5>
<p>创建表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE words (
    id SERIAL,
    word TEXT NOT NULL,
    PRIMARY KEY(id)
);
</code></pre></div>
<p>加载如下数据：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO words(word) VALUES 
  (&#39;warehouse&#39;),(&#39;warmhouse&#39;),(&#39;warehoused&#39;),(&#39;warehouser&#39;),(&#39;warhorse&#39;),
  (&#39;tirehouse&#39;),(&#39;washhouse&#39;),(&#39;carhouse&#39;),(&#39;firehouse&#39;),(&#39;gatehouse&#39;);
  (&#39;amphigoric&#39;),(&#39;amebic&#39;),(&#39;amebous&#39;),(&#39;ambassage&#39;),(&#39;unpacified&#39;),(&#39;unposing&#39;);
</code></pre></div>
<h5 id="levenshtein"><strong>Levenshtein</strong></h5>
<p>Levenshtein 距离是两个字符串之间差值的度量。它通过考虑将一个字符串转换为另一个字符串所需的编辑次数（插入、删除和替换）来计算差异。这对于拼写检查特别有用。此函数由PostgreSQL扩展fuzzystrmatch提供。
要启用Levenshtein 功能，请按如下方式激活fuzzystrmatch扩展： </p>
<div class="highlight"><pre><span></span><code>CREATE extension IF NOT EXISTS fuzzystrmatch;
</code></pre></div>
<p>例如，要确定warehouse的不同拼写错误，请执行以下操作： </p>
<div class="highlight"><pre><span></span><code>SELECT word, levenshtein(&#39;warehouse&#39;, word) FROM words WHERE levenshtein(&#39;warehouse&#39;, word) &lt; 3  ORDER BY levenshtein(&#39;warehouse&#39;, word) ASC LIMIT 10;
</code></pre></div>
<div class="highlight"><pre><span></span><code>    word    | levenshtein
------------+-------------
 warehouse  |           0
 warmhouse  |           1
 warehoused |           1
 warehouser |           1
 warhorse   |           2
 tirehouse  |           2
 washhouse  |           2
 carhouse   |           2
 firehouse  |           2
 gatehouse  |           2
</code></pre></div>
<p>warehoused 的Levenstein得分为1，因为它比仓库多了一个字符（d）。wayhouse 的得分是2，因为它需要两次编辑（r-&gt;y和删除e）。</p>
<h5 id="trigrams"><strong>Trigrams</strong></h5>
<p>trigram 是从一个字符串中提取的一组连续三个字符。你可以通过计算两个字符串共享的trigrams 数来衡量它们的相似性。pg_trgm扩展提供了show_trgm和similarity等多个函数，这些函数提供了两个字符串相似程度的分数。
例如，warehouse 的trigrams 如下：</p>
<div class="highlight"><pre><span></span><code>{&quot;  w&quot;,&quot; wa&quot;,are,eho,hou,ous,reh,&quot;se &quot;,use,war}
</code></pre></div>
<p>要启用trigrams 功能，请激活pg_trgm扩展：</p>
<div class="highlight"><pre><span></span><code>CREATE extension IF NOT EXISTS pg_trgm;
</code></pre></div>
<p>例如，假设您正在寻找拼写接近geodymamist的单词。要获得实际单词，您可以执行以下操作：</p>
<div class="highlight"><pre><span></span><code>SELECT word, similarity(word, &#39;geodymamist&#39;) as score FROM words ORDER BY score DESC LIMIT 5;
</code></pre></div>
<div class="highlight"><pre><span></span><code>     word      |  score
---------------+----------
 geodynamicist | 0.444444
 geodesist     |    0.375
 geochemist    | 0.352941
 geodynamics   | 0.333333
 geologist     | 0.294118
</code></pre></div>
<p>要通过避免使用跨单词trigrams来匹配单词边界，可以使用strict_word_similarity函数。例如： </p>
<div class="highlight"><pre><span></span><code>SELECT strict_word_similarity(&#39;word&#39;, &#39;two words&#39;), similarity(&#39;word&#39;, &#39;two words&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code> strict_word_similarity | similarity
------------------------+------------
               0.571429 |   0.363636
</code></pre></div>
<p>strict_word_similarity比相似性更高，因为它对两个字符串中确切单词的存在给予了更高的重要性。</p>
<h4 id="_136"><strong>全文搜索</strong></h4>
<p>虽然LIKE和ILIKE运算符匹配模式，在许多情况下都很有帮助，但它们不能用于查找一组可能以任何顺序或略有不同的形式出现的单词。例如，对于检索具有特定条件的文本（如“quick”和“brown”，而不是“fox”或搜索等待时匹配等待），这不是最佳选择。为此，BMDB支持通过tsvector、tsquery和反向索引的高级搜索机制。这些都是搜索引擎用来构建大规模网络搜索系统的基本概念。</p>
<p>让我们通过一些示例来了解如何使用全文搜索 </p>
<h5 id="_137"><strong>部署</strong></h5>
<p>创建表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE movies (
    name TEXT NOT NULL,
    summary TEXT NOT NULL,
    PRIMARY KEY(name)
);
</code></pre></div>
<p>加载如下数据：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO movies(name, summary) VALUES(&#39;The Shawshank Redemption&#39;, &#39;Two convicts become friends and one convict escapes.&#39;);
INSERT INTO movies(name, summary) VALUES(&#39;The Godfather&#39;,&#39;A don hands over his empire to one of his sons.&#39;);
INSERT INTO movies(name, summary) VALUES(&#39;Inception&#39;,&#39;A thief is given the task of planting an idea onto a mind&#39;);
</code></pre></div>
<h5 id="_138"><strong>分析文档</strong></h5>
<p>文本可以表示为单词向量，它实际上是单词列表和单词在文本中的位置。表示这一点的数据类型是tsvector。例如，考虑一下短语“Two convicts become friends and one convict escapes.”。当您使用to_tsvector 辅助函数将其转换为tsvector 时，您会得到以下内容： </p>
<div class="highlight"><pre><span></span><code>SELECT to_tsvector(&#39;Two convicts become friends and one convict escapes.&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>                         to_tsvector
--------------------------------------------------------------
 &#39;becom&#39;:3 &#39;convict&#39;:2,7 &#39;escap&#39;:8 &#39;friend&#39;:4 &#39;one&#39;:6 &#39;two&#39;:1
(1 row)
</code></pre></div>
<p>单词one出现在文本中的位置6，单词friend 出现在位置4。同样，由于“convict ”一词出现两次，所以位置2和7都列出了。</p>
<p>Stemming 
请注意，单词“become ”和“escape ”存储为“becom ”和“escap”。这是一个名为Stemming的过程的结果，该过程将单词的不同形式转换为其词根形式。例如，单词escape escaper escaping escaped词干为escap。这使得在搜索escaping 或escaped时能够快速检索所有不同形式的escap 。</p>
<p>停词
注意单词and是如何从矢量中丢失的。这是因为常见的单词如a, an, and, the ...称为“停词”，通常在文档和查询处理过程中删除。</p>
<h5 id="_139"><strong>分析搜索查询</strong></h5>
<p>正如为了更快地搜索而必须处理文本一样，查询也必须经过相同的词干和停词删除过程。表示查询的数据类型是tsquery。您可以使用许多辅助函数之一将简单文本转换为tsquery，如to_tsquery、plainto_tsquery、phraseto_tsquery和websearch_to_tsquery等。如果您想搜索escaping 或empire，请执行以下操作：</p>
<div class="highlight"><pre><span></span><code>SELECT to_tsquery(&#39;escaping | empire&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>   to_tsquery
-----------------
 &#39;escap&#39; | &#39;empir&#39;
(1 row)
</code></pre></div>
<p>这将以类似于文本转换为tsvector的方式转换查询 </p>
<h5 id="_140"><strong>搜索</strong></h5>
<p>在处理完文本和查询之后，您可以使用查询来匹配文本。要执行此操作，请使用@@运算符，该运算符将矢量连接到查询 </p>
<p>OR</p>
<div class="highlight"><pre><span></span><code>-- either `one` or `son`
SELECT * FROM movies WHERE to_tsvector(summary) @@ to_tsquery(&#39;one | son&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>           name           |                       summary
--------------------------+------------------------------------------------------
 The Godfather            | A don hands over his empire to one of his sons.
 The Shawshank Redemption | Two convicts become friends and one convict escapes.
</code></pre></div>
<p>AND</p>
<div class="highlight"><pre><span></span><code>-- both `one` and `son`
SELECT * FROM movies WHERE to_tsvector(summary) @@ to_tsquery(&#39;one &amp; son&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>     name      |                     summary
---------------+-------------------------------------------------
 The Godfather | A don hands over his empire to one of his sons.
</code></pre></div>
<p>NOT</p>
<div class="highlight"><pre><span></span><code>-- both `one` but NOT `son`
SELECT * FROM movies WHERE to_tsvector(summary) @@ to_tsquery(&#39;one &amp; !son&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>           name           |                       summary
--------------------------+------------------------------------------------------
 The Shawshank Redemption | Two convicts become friends and one convict escapes.
</code></pre></div>
<p>Stemming
在电影表中搜索conviction，如下所示： </p>
<div class="highlight"><pre><span></span><code>SELECT * FROM movies WHERE to_tsvector(summary) @@ to_tsquery(&#39;conviction&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>           name           |                       summary
--------------------------+------------------------------------------------------
 The Shawshank Redemption | Two convicts become friends and one convict escapes.
</code></pre></div>
<p>尽管表中没有“conviction ”一词，返回The Shawshank Redemption。这是因为“conviction ”一词源于convict ，与正确的电影相匹配。这就是全文搜索的功能</p>
<h5 id="_141"><strong>排名结果</strong></h5>
<p>可以使用ts_rank函数生成的匹配分数对检索到的结果进行排名，该函数测量文本与查询的相关性。这可以用于识别与查询更相关的文本。例如，当您按如下方式搜索one或son时：</p>
<div class="highlight"><pre><span></span><code>SELECT ts_rank(to_tsvector(summary), to_tsquery(&#39;one | son&#39;)) as score,* FROM movies;
</code></pre></div>
<p>您将得到以下输出：</p>
<div class="highlight"><pre><span></span><code>   score   |           name           |                          summary
-----------+--------------------------+-----------------------------------------------------------
 0.0607927 | The Godfather            | A don hands over his empire to one of his sons.
         0 | Inception                | A thief is given the task of planting an idea onto a mind
 0.0303964 | The Shawshank Redemption | Two convicts become friends and one convict escapes.
</code></pre></div>
<p>请注意，The Godfather 的评分是The Shawshank Redemption的两倍。这是因为one 和son 都出现在前者中，但只有one 出现在后者中。此分数可用于按相关性对结果进行排序。</p>
<h5 id="_142"><strong>突出显示匹配项</strong></h5>
<p>您可以使用ts_headline函数来突出显示文本中的查询匹配项。 </p>
<div class="highlight"><pre><span></span><code>SELECT name, ts_headline(summary,to_tsquery(&#39;one | son&#39;))  FROM movies WHERE to_tsvector(summary) @@ to_tsquery(&#39;one | son&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>           name           |                          ts_headline
--------------------------+---------------------------------------------------------------
 The Godfather            | A don hands over his empire to &lt;b&gt;one&lt;/b&gt; of his &lt;b&gt;sons&lt;/b&gt;.
 The Shawshank Redemption | Two convicts become friends and &lt;b&gt;one&lt;/b&gt; convict escapes.
</code></pre></div>
<p>匹配项被 <b>..</b>包围，这对显示搜索结果时非常有帮助。 </p>
<h5 id="_143"><strong>搜索多个列</strong></h5>
<p>前面的所有搜索都已在summary列上进行。如果要同时搜索name 和summary，可以按如下方式连接这两列：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM movies WHERE to_tsvector(name || &#39; &#39; || summary) @@ to_tsquery(&#39;godfather | thief&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>     name      |                          summary
---------------+-----------------------------------------------------------
 The Godfather | A don hands over his empire to one of his sons.
 Inception     | A thief is given the task of planting an idea onto a mind
</code></pre></div>
<p>查询词godfather 与一部电影的标题相匹配，而thief 与另一部电影摘要相匹配。</p>
<h5 id="_144"><strong>存储已处理的文档</strong></h5>
<p>对于之前的每一次搜索，都会一次又一次地分析所有行中的摘要。可以通过将tsvector存储在单独的列中并在每次插入时存储计算出的tsvector来避免这种情况。通过添加一个新列并添加一个触发器以在行更新时更新该列来执行此操作，如下所示：</p>
<div class="highlight"><pre><span></span><code>ALTER TABLE movies ADD COLUMN tsv tsvector;
</code></pre></div>
<p>按如下方式更新tsv列： </p>
<div class="highlight"><pre><span></span><code>UPDATE movies SET tsv = to_tsvector(name || &#39; &#39; || summary);
</code></pre></div>
<p>现在，您可以在tsv列上查询该表，如下所示： </p>
<div class="highlight"><pre><span></span><code>SELECT * FROM movies WHERE tsv @@ to_tsquery(&#39;godfather | thief&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>     name      |                          summary                          |                                       tsv
---------------+-----------------------------------------------------------+---------------------------------------------------------------------------------
 The Godfather | A don hands over his empire to one of his sons.           | &#39;empir&#39;:8 &#39;godfath&#39;:2 &#39;hand&#39;:5 &#39;one&#39;:10 &#39;son&#39;:13
 Inception     | A thief is given the task of planting an idea onto a mind | &#39;given&#39;:5 &#39;idea&#39;:11 &#39;incept&#39;:1 &#39;mind&#39;:14 &#39;onto&#39;:12 &#39;plant&#39;:9 &#39;task&#39;:7 &#39;thief&#39;:3
</code></pre></div>
<p>您可以使用tsvector_update_trigger函数将列设置为在未来插入时自动更新，并使用触发器进行更新。</p>
<div class="highlight"><pre><span></span><code>CREATE TRIGGER tsvectorupdate BEFORE INSERT OR UPDATE
    ON movies FOR EACH ROW EXECUTE FUNCTION
    tsvector_update_trigger (tsv, &#39;pg_catalog.english&#39;, name, summary);
</code></pre></div>
<h5 id="gin"><strong>使用GIN索引优化查询</strong></h5>
<p>即使处理后的tsvector现在存储在一个单独的列中，每次搜索都必须扫描所有行。</p>
<p>显示查询计划如下：</p>
<div class="highlight"><pre><span></span><code>EXPLAIN ANALYZE SELECT name FROM movies WHERE tsv @@ to_tsquery(&#39;godfather&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>                             QUERY PLAN
---------------------------------------------------------------------
 Seq Scan on public.movies (actual time=2.987..6.378 rows=1 loops=1)
   Output: name
   Filter: (movies.tsv @@ to_tsquery(&#39;godfather&#39;::text))
   Rows Removed by Filter: 2
 Planning Time: 0.248 ms
 Execution Time: 7.067 ms
 Peak Memory Usage: 14 kB
(7 rows)
</code></pre></div>
<p>这是一次顺序扫描。要避免这种情况，请在tsv列上创建一个GIN索引，如下所示：</p>
<div class="highlight"><pre><span></span><code>CREATE INDEX idx_movie ON movies USING bmgin(tsv);
</code></pre></div>
<p>再次获取查询计划： </p>
<div class="highlight"><pre><span></span><code>EXPLAIN ANALYZE SELECT name FROM movies WHERE tsv @@ to_tsquery(&#39;godfather&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>                                      QUERY PLAN
---------------------------------------------------------------------------------------
 Index Scan using idx_movie on public.movies (actual time=2.580..2.584 rows=1 loops=1)
   Output: name
   Index Cond: (movies.tsv @@ to_tsquery(&#39;godfather&#39;::text))
 Planning Time: 0.207 ms
 Execution Time: 2.684 ms
 Peak Memory Usage: 18 kB
</code></pre></div>
<p>请注意，它现在进行索引扫描，所花费的时间要少得多</p>
<h4 id="_145"><strong>拼音搜索</strong></h4>
<p>虽然在大多数情况下查找精确匹配就足够了，但在不知道搜索的确切术语，但可能记得该术语或该术语部分的语音的情况下，您需要近似匹配。</p>
<p>对于语音匹配，BMDB原生支持PostgreSQL扩展fuzzystrmatch，它提供了多种功能-Soundex、Metaphone和Double Metaphone-您可以使用这些功能来确定文本之间的语音相似性。</p>
<h5 id="_146"><strong>部署</strong></h5>
<p>创建表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE IF NOT EXISTS words (
    id SERIAL,
    word TEXT NOT NULL,
    PRIMARY KEY(id)
);
</code></pre></div>
<p>加载如下数据：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO words(word) VALUES 
  (&#39;anopisthographic&#39;),(&#39;ambassadorship&#39;),(&#39;ambuscader&#39;),(&#39;ambiguity&#39;),(&#39;ampycides&#39;),
  (&#39;anapaestically&#39;),(&#39;anapests&#39;),(&#39;anapsidan&#39;),(&#39;unpsychic&#39;),(&#39;anapsid&#39;),
  (&#39;unpessimistic&#39;),(&#39;unepistolary&#39;),(&#39;inabstracted&#39;),(&#39;anapaest&#39;),(&#39;unobstinate&#39;),
  (&#39;amphigoric&#39;),(&#39;amebic&#39;),(&#39;amebous&#39;),(&#39;ambassage&#39;),(&#39;unpacified&#39;),(&#39;unposing&#39;);
</code></pre></div>
<p>要启用模糊匹配，请按如下方式激活fuzzystrmatch 扩展 </p>
<div class="highlight"><pre><span></span><code>CREATE extension IF NOT EXISTS fuzzystrmatch;
</code></pre></div>
<h5 id="soundex"><strong>Soundex</strong></h5>
<p>Soundex系统是一种通过将发音相似的名称转换为相同的四个字母的代码来匹配这些名称的方法，然后可以使用这些代码来确定文本之间的相似性。</p>
<p>例如，假设你听到了一个听起来像anapistagafi的单词。要找到听起来相似的实际单词，您可以使用soundex 方法找到发音最接近的单词，如下所示：</p>
<div class="highlight"><pre><span></span><code>SELECT word, soundex(word), difference(word,&#39;anapistagafi&#39;) FROM words WHERE soundex(word) = soundex(&#39;anapistagafi&#39;) limit 5;
</code></pre></div>
<div class="highlight"><pre><span></span><code>      word      | soundex | difference
----------------+---------+------------
 anapaestically | A512    |          4
 ampycides      | A512    |          4
 anapsid        | A512    |          4
 amebous        | A512    |          4
 anapaest       | A512    |          4
</code></pre></div>
<p>difference 法计算一个Soundex代码与另一个代码的不同程度。该值的范围为0-4，可用于对结果进行排名。在这种情况下，差异是相同的。</p>
<h5 id="metaphone"><strong>Metaphone</strong></h5>
<p>metaphone 算法通过考虑英语拼写和发音的不一致性来改进Soundex，以产生更准确的编码。例如： </p>
<div class="highlight"><pre><span></span><code>SELECT word, metaphone(word,4) FROM words WHERE metaphone(word,4) = metaphone(&#39;anapistagafi&#39;,4) limit 5;
</code></pre></div>
<div class="highlight"><pre><span></span><code>       word       | metaphone
------------------+-----------
 anapaestically   | ANPS
 anapsid          | ANPS
 anapaest         | ANPS
 anapsidan        | ANPS
 anopisthographic | ANPS
</code></pre></div>
<p>metaphone 函数接受一个额外的代码输出长度参数，该参数可用于稍微修改匹配错误。</p>
<h5 id="double-metaphone"><strong>Double Metaphone</strong></h5>
<p>Double Metaphone 在最初的Metaphone算法基础上进行了一些基本的设计改进。它计算两种不同的代码，使其能够比较更广泛的发音。</p>
<div class="highlight"><pre><span></span><code>SELECT word, dmetaphone(word) FROM words WHERE dmetaphone(word) = dmetaphone(&#39;anapistagafi&#39;) limit 5;
</code></pre></div>
<div class="highlight"><pre><span></span><code>      word      | dmetaphone
----------------+------------
 unpsychic      | ANPS
 anapaestically | ANPS
 inabstracted   | ANPS
 unobstinate    | ANPS
 unposing       | ANPS
</code></pre></div>
<h3 id="_147"><strong>聚集</strong></h3>
<h4 id="bcql_1"><strong>BCQL</strong></h4>
<p>BMDB支持许多标准聚合函数。例如，考虑以下产品表：</p>
<table>
<thead>
<tr>
<th>ProductID</th>
<th>ProductName</th>
<th>SupplierID</th>
<th>CategoryID</th>
<th>Unit</th>
<th>Price</th>
<th>Quantity</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Chais</td>
<td>1</td>
<td>1</td>
<td>10 boxes x 20 bags</td>
<td>18</td>
<td>25</td>
</tr>
<tr>
<td>2</td>
<td>Chang</td>
<td>1</td>
<td>1</td>
<td>24 - 12 oz bottles</td>
<td>19</td>
<td>12</td>
</tr>
<tr>
<td>3</td>
<td>Aniseed Syrup</td>
<td>1</td>
<td>2</td>
<td>12 - 550 ml bottles</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>4</td>
<td>Chef Anton's Cajun Seasoning</td>
<td>2</td>
<td>2</td>
<td>48 - 6 oz jars</td>
<td>22</td>
<td>9</td>
</tr>
<tr>
<td>5</td>
<td>Chef Anton's Gumbo Mix</td>
<td>2</td>
<td>2</td>
<td>36 boxes</td>
<td>21.35</td>
<td>40</td>
</tr>
</tbody>
</table>
<p>让我们用ProductID作为主Hash键来创建这个表。</p>
<div class="highlight"><pre><span></span><code>CREATE KEYSPACE store;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE TABLE store.products (ProductID BIGINT PRIMARY KEY, ProductName VARCHAR, SupplierID INT, CategoryID INT, Unit TEXT, Price FLOAT, Quantity INT);
</code></pre></div>
<p>现在填充示例数据。 </p>
<div class="highlight"><pre><span></span><code>INSERT INTO store.products (ProductID, ProductName, SupplierID, CategoryID, Unit, Price, Quantity) VALUES (1, &#39;Chais&#39;, 1, 1, &#39;10 boxes x 20 bags&#39;, 18, 25);
INSERT INTO store.products (ProductID, ProductName, SupplierID, CategoryID, Unit, Price, Quantity) VALUES (2, &#39;Chang&#39;, 1, 1, &#39;24 - 12 oz bottles&#39;, 19, 12);
INSERT INTO store.products (ProductID, ProductName, SupplierID, CategoryID, Unit, Price, Quantity) VALUES (3, &#39;Aniseed Syrup&#39;, 1, 2, &#39;12 - 550 ml bottles&#39;, 10, 10);
INSERT INTO store.products (ProductID, ProductName, SupplierID, CategoryID, Unit, Price, Quantity) VALUES (4, &#39;Chef Anton&#39;&#39;s Cajun Seasoning&#39;, 2, 2, &#39;48 - 6 oz jars&#39;, 22, 9);
INSERT INTO store.products (ProductID, ProductName, SupplierID, CategoryID, Unit, Price, Quantity) VALUES (5, &#39;Chef Anton&#39;&#39;s Gumbo Mix&#39;, 2, 2, &#39;36 boxes&#39;, 21.35, 40);
</code></pre></div>
<h5 id="_148"><strong>统计</strong></h5>
<p>按如下方式查找商店中的商品类型数量：</p>
<div class="highlight"><pre><span></span><code>SELECT COUNT(ProductID) FROM store.products;
</code></pre></div>
<div class="highlight"><pre><span></span><code>count(productid)
------------------
            5

(1 rows)
</code></pre></div>
<p>指定一个别名，如下所示：</p>
<div class="highlight"><pre><span></span><code>SELECT COUNT(ProductID) as num_products FROM store.products;
</code></pre></div>
<div class="highlight"><pre><span></span><code>num_products
--------------
         5

(1 rows)
</code></pre></div>
<p>查找供应商1的物料类型数量，如下所示： </p>
<div class="highlight"><pre><span></span><code>SELECT COUNT(ProductID) as supplier1_num_products FROM store.products WHERE SupplierID=1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>supplier1_num_products
------------------------
                3

(1 rows)
</code></pre></div>
<h5 id="_149"><strong>数字聚合函数</strong></h5>
<p>min、max、sum、avg和count的标准聚合函数是内置函数。 </p>
<p>要查找存储中的项目总数，请运行以下查询： </p>
<div class="highlight"><pre><span></span><code>SELECT SUM(Quantity) FROM store.products;
</code></pre></div>
<div class="highlight"><pre><span></span><code>sum(quantity)
---------------
        96

(1 rows)
</code></pre></div>
<p>要查找最便宜和最贵商品的价格，请运行以下操作：</p>
<div class="highlight"><pre><span></span><code>SELECT MIN(Price), MAX(Price) FROM store.products;
</code></pre></div>
<div class="highlight"><pre><span></span><code>min(price) | max(price)
------------+------------
      10 |       22

(1 rows)
</code></pre></div>
<p>要查找商店中所有商品的平均价格，请运行以下操作： </p>
<div class="highlight"><pre><span></span><code>SELECT AVG(price) FROM store.products;
</code></pre></div>
<div class="highlight"><pre><span></span><code>system.avg(price)
-------------------
         18.07

(1 rows)
</code></pre></div>
<h3 id="_150"><strong>批处理操作</strong></h3>
<h4 id="bcql_2"><strong>BCQL</strong></h4>
<p>批处理操作允许您在一个RPC调用中将多个操作发送到数据库。批处理大小越大，整个批处理的延迟就越高。尽管整个操作批的延迟高于任何单个操作的延迟，但操作批的吞吐量要高得多。 </p>
<h5 id="_151"><strong>插入数据</strong></h5>
<p>要在批处理中插入数据，会将具有绑定值的已准备语句添加到写入批处理中。这样做是为了减少重复语句解析开销。</p>
<p>Java 示例</p>
<p>要在Java中执行批插入操作，请首先创建一个BatchStatement 对象。接下来，向其中添加所需数量的已准备和绑定的插入语句。最后，执行批处理对象。如下所示：</p>
<div class="highlight"><pre><span></span><code>// Create a batch statement object.
BatchStatement batch = new BatchStatement();

// Create a prepared statement object to add to the batch.
PreparedStatement insert = client.prepare(&quot;INSERT INTO table (k, v) VALUES (?, ?);&quot;);

// Bind values to the prepared statement and add them to the batch.
for (...) {
  batch.add(insert.bind( ... &lt;values for bind variables&gt; ... ));
}

// Execute the batch operation.
ResultSet resultSet = client.execute(batch);
</code></pre></div>
<h5 id="_152"><strong>查询数据</strong></h5>
<p>读取多行可以通过几种不同的方式实现。</p>
<h6 id="_153">范围查询</h6>
<p>范围查询非常高效，因为数据库将数据保存在磁盘上。范围查询仅在主键的集群列上执行，为了执行范围查询，应该使用集群列创建表。这些用例通常需要对某些主键列具有排序顺序。</p>
<p>考虑一个表，它有一个hash 列h和两个聚集列r1和r2。以下范围查询是有效的。 </p>
<p>查询给定h的r1的值范围</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM table WHERE h = &#39;...&#39; AND r1 &lt; &#39;&lt;upper-bound&gt;&#39; AND r1 &gt; &#39;&lt;lower-bound&gt;&#39;;
</code></pre></div>
<p>查询给定h和r1的r2值范围</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM table WHERE h = &#39;...&#39; AND r1 = &#39;...&#39; AND r2 &lt; &#39;&lt;upper-bound&gt;&#39; AND r2 &gt; &#39;&lt;lower-bound&gt;&#39;;
</code></pre></div>
<p>在给定h的情况下查询r2的值范围可能效率不高。这个查询需要遍历r1的所有唯一值才能获取结果，如果一个键有很多r1列的值，那么效率会更低。</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM table WHERE h = &#39;...&#39; AND r2 &lt; &#39;&lt;upper-bound&gt;&#39; AND r2 &gt; &#39;&lt;lower-bound&gt;&#39;;
</code></pre></div>
<p>在没有指定h的情况下查询r1的值范围可能效率不高。此查询将对表执行完全扫描，如果表很大，则效率会降低。</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM table WHERE r1 &lt; &#39;&lt;upper-bound&gt;&#39; AND r1 &gt; &#39;&lt;lower-bound&gt;&#39;;
</code></pre></div>
<h6 id="in">IN</h6>
<p>IN运算符允许为WHERE子句指定多个键，并对SELECT语句进行简单的批处理。</p>
<p>考虑一个表，它有一个hash 列h和一个聚类列r。</p>
<p>查询一组h值此操作将执行各种哈希键的查找并返回响应。读取的查询在tile级别进行批处理，并并行执行。此查询将比从应用程序执行每次查找更高效。 </p>
<div class="highlight"><pre><span></span><code>SELECT * FROM table WHERE h IN (&#39;&lt;value1&gt;&#39;, &#39;&lt;value2&gt;&#39;, ...);
</code></pre></div>
<p>在给定h的一个值的情况下，查询r的一组值-此查询是有效的，并将寻求给定h的各种值的r。 </p>
<div class="highlight"><pre><span></span><code>SELECT * FROM table WHERE h = &#39;...&#39; AND r IN (&#39;&lt;value1&gt;&#39;, &#39;&lt;value2&gt;&#39;, ...);
</code></pre></div>
<p>查询一组h值和一组r值。此查询将对提供的h值和r值的每个组合进行点查找。例如，如果查询为h指定3个值，为r指定2个值，则将在内部执行6个查找，结果集最多可以有6行</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM table WHERE h IN (&#39;&lt;value1&gt;&#39;, &#39;&lt;value2&gt;&#39;, ...) AND r IN (&#39;&lt;value1&gt;&#39;, &#39;&lt;value2&gt;&#39;, ...);
</code></pre></div>
<h5 id="java_2"><strong>Java应用示例</strong></h5>
<p>您可以在bm-sample-apps存储库中找到使用BMDB的事务的工作示例。此应用程序写入批处理键值对，每个批具有可配置数量的键。有多个读写器并行运行，执行这些批处理写入操作。</p>
<p>以下是如何试用此示例应用程序。</p>
<div class="highlight"><pre><span></span><code>Usage:
  java -jar bm-sample-apps.jar \
    --workload CassandraBatchKeyValue \
    --nodes 127.0.0.1:9542

  Other flags (with default values):
    [ --num_unique_keys 1000000 ]
    [ --num_reads -1 ]
    [ --num_writes -1 ]
    [ --value_size 0 ]
    [ --num_threads_read 24 ]
    [ --num_threads_write 2 ]
    [ --batch_size 10 ]
    [ --table_ttl_seconds -1 ]
</code></pre></div>
<h3 id="date-and-time"><strong>Date and time</strong></h3>
<h4 id="bsql_3"><strong>BSQL</strong></h4>
<h5 id="_154"><strong>介绍</strong></h5>
<p>BMDB具有广泛的日期和时间功能。一旦理解，丰富的功能允许您执行非常复杂的计算和精细的时间捕获。</p>
<h5 id="_155"><strong>特殊值</strong></h5>
<p>你可以参考一些特殊的值-BMDB只满足一些，PostgreSQL中的其他特殊值没有在BMDB中实现，但如果你需要，可以重新创建一些。以下示例演示了BSQL选择特殊日期和时间值的方法。首先从命令行启动sqlsh。</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh 
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT current_date, current_time, current_timestamp, now();
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_date |    current_time    |       current_timestamp       |              now
--------------+--------------------+-------------------------------+-------------------------------
 2019-07-09   | 00:53:13.924407+00 | 2019-07-09 00:53:13.924407+00 | 2019-07-09 00:53:13.924407+00
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT make_timestamptz(1970, 01, 01, 00, 00, 00, &#39;UTC&#39;) as epoch;
</code></pre></div>
<div class="highlight"><pre><span></span><code>         epoch
------------------------
 1970-01-01 00:00:00+00
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT (current_date-1)::timestamp as yesterday,
                  current_date::timestamp as today,
                  (current_date+1)::timestamp as tomorrow;
</code></pre></div>
<div class="highlight"><pre><span></span><code>      yesterday      |        today        |      tomorrow
---------------------+---------------------+---------------------
 2019-07-08 00:00:00 | 2019-07-09 00:00:00 | 2019-07-10 00:00:00
</code></pre></div>
<h5 id="_156"><strong>格式化</strong></h5>
<p>前面的示例显示了日期和时间戳的默认ISO格式。以下示例显示了如何设置日期格式：</p>
<div class="highlight"><pre><span></span><code>SELECT to_char(current_timestamp, &#39;DD-MON-YYYY&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>   to_char
-------------
 09-JUL-2019
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT to_date(to_char(current_timestamp, &#39;DD-MON-YYYY&#39;), &#39;DD-MON-YYYY&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>  to_date
------------
 2019-07-09
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT to_char(current_timestamp, &#39;DD-MON-YYYY HH:MI:SS PM&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>         to_char
-------------------------
 09-JUL-2019 01:50:13 AM
</code></pre></div>
<p>示例使用to_char()函数以友好可读的格式显示日期。当表示为日期或时间数据类型时，将使用系统设置进行显示，这就是为什么文本09-JUL-2019的日期表示形式显示为2019-07-09 </p>
<h5 id="_157"><strong>时区</strong></h5>
<p>BMDB安装的默认时区是UTC（+0）。要列出其他可用时区，请输入以下内容：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM pg_timezone_names;
</code></pre></div>
<div class="highlight"><pre><span></span><code>               name               | abbrev | utc_offset | is_dst
----------------------------------+--------+------------+--------
 W-SU                             | MSK    | 03:00:00   | f
 GMT+0                            | GMT    | 00:00:00   | f
 ROK                              | KST    | 09:00:00   | f
 UTC                              | UTC    | 00:00:00   | f
 US/Eastern                       | EDT    | -04:00:00  | t
 US/Pacific                       | PDT    | -07:00:00  | t
 US/Central                       | CDT    | -05:00:00  | t
 MST                              | MST    | -07:00:00  | f
 Zulu                             | UTC    | 00:00:00   | f
 posixrules                       | EDT    | -04:00:00  | t
 GMT                              | GMT    | 00:00:00   | f
 Etc/UTC                          | UTC    | 00:00:00   | f
 Etc/Zulu                         | UTC    | 00:00:00   | f
 Etc/Universal                    | UTC    | 00:00:00   | f
 Etc/GMT+2                        | -02    | -02:00:00  | f
 Etc/Greenwich                    | GMT    | 00:00:00   | f
 Etc/GMT+12                       | -12    | -12:00:00  | f
 Etc/GMT+8                        | -08    | -08:00:00  | f
 Etc/GMT-12                       | +12    | 12:00:00   | f
 WET                              | WEST   | 01:00:00   | t
 EST                              | EST    | -05:00:00  | f
 Australia/West                   | AWST   | 08:00:00   | f
 Australia/Sydney                 | AEST   | 10:00:00   | f
 GMT-0                            | GMT    | 00:00:00   | f
 PST8PDT                          | PDT    | -07:00:00  | t
 Hongkong                         | HKT    | 08:00:00   | f
 Singapore                        | +08    | 08:00:00   | f
 Universal                        | UTC    | 00:00:00   | f
 Arctic/Longyearbyen              | CEST   | 02:00:00   | t
 UCT                              | UCT    | 00:00:00   | f
 GMT0                             | GMT    | 00:00:00   | f
 Europe/London                    | BST    | 01:00:00   | t
 GB                               | BST    | 01:00:00   | t
 ...
(593 rows)
</code></pre></div>
<p>注：并不是所有可用的时区都显示出来；检查您的BSQL输出以找到您感兴趣的时区。 </p>
<p>您可以使用set命令设置会话使用的时区。您可以使用pg_timezone_names中列出的时区名称设置时区，但不能使用缩写。您也可以将时区设置为时间偏移的数字/十进制表示形式。例如，-3.5是UTC之前的3小时30分钟。 </p>
<p>提示：
能够使用上面的UTC_OFFSET格式设置时区似乎是合乎逻辑的。BMDB允许这样做，但是，如果您选择此方法，请注意以下行为：
当使用POSIX时区名称时，正偏移量用于格林尼治以西的位置。在其他地方，BMDB遵循ISO-8601惯例，即正时区偏移位于格林尼治以东。因此，输入“+10:00:0”会导致时区偏移量为-10小时，因为这被视为格林尼治以东。 </p>
<p>要显示基础服务器的当前日期和时间，请输入以下内容：</p>
<div class="highlight"><pre><span></span><code>\echo `date`
</code></pre></div>
<div class="highlight"><pre><span></span><code>Tue 09 Jul 12:27:08 AEST 2019
</code></pre></div>
<p>服务器时间不是数据库的日期和时间。然而，在BMDB的单节点实现中，您的计算机的日期和数据库日期之间存在关系，因为BMDB在启动时从服务器获得日期。</p>
<p>以下示例探讨数据库中的日期和时间（时间戳）。 </p>
<div class="highlight"><pre><span></span><code>SHOW timezone;
</code></pre></div>
<div class="highlight"><pre><span></span><code> TimeZone
----------
 UTC
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT current_timestamp;
</code></pre></div>
<div class="highlight"><pre><span></span><code>      current_timestamp
------------------------------
 2019-07-09 02:27:46.65152+00
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET timezone = +1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET
</code></pre></div>
<div class="highlight"><pre><span></span><code>SHOW timezone;
</code></pre></div>
<div class="highlight"><pre><span></span><code> TimeZone
----------
 &lt;+01&gt;-01
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT current_timestamp;
</code></pre></div>
<div class="highlight"><pre><span></span><code>      current_timestamp
------------------------------
 2019-07-09 03:28:11.52311+01
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET timezone = -1.5;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT current_timestamp;
</code></pre></div>
<div class="highlight"><pre><span></span><code>        current_timestamp
----------------------------------
 2019-07-09 00:58:27.906963-01:30
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET timezone = &#39;Australia/Sydney&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET
</code></pre></div>
<div class="highlight"><pre><span></span><code>SHOW timezone;
</code></pre></div>
<div class="highlight"><pre><span></span><code>     TimeZone
------------------
 Australia/Sydney
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT current_timestamp;
</code></pre></div>
<div class="highlight"><pre><span></span><code>       current_timestamp
-------------------------------
 2019-07-09 12:28:46.610746+10
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET timezone = &#39;UTC&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT current_timestamp;
</code></pre></div>
<div class="highlight"><pre><span></span><code>       current_timestamp
-------------------------------
 2019-07-09 02:28:57.610746+00
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT current_timestamp AT TIME ZONE &#39;Australia/Sydney&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>          timezone
----------------------------
 2019-07-09 12:29:03.416867
</code></pre></div>
<p>（请注意，上面的AT TIME ZONE语句不适用于WITH TIME ZONE 和WITHOUT TIME ZONE的变体。） </p>
<div class="highlight"><pre><span></span><code>SELECT current_timestamp(0);
</code></pre></div>
<div class="highlight"><pre><span></span><code>   current_timestamp
------------------------
 2019-07-09 03:15:38+00
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT current_timestamp(2);
</code></pre></div>
<div class="highlight"><pre><span></span><code>     current_timestamp
---------------------------
 2019-07-09 03:15:53.07+00
</code></pre></div>
<p>使用时间戳时，可以通过指定0-&gt;6之间的值来控制秒精度。时间戳不能超过毫秒精度，即1000000分之一秒。</p>
<p>如果您的应用程序采用本地时间，请确保它发出SET命令以设置为正确的时间偏移。（夏令时是一个高级主题，因此建议暂时使用偏移量表示法，例如，在UTC之前的3小时30分钟为-3.5。） </p>
<h5 id="timestamps"><strong>Timestamps</strong></h5>
<p>数据库通常从底层服务器获取其日期和时间。然而，分布式数据库是一个同步的数据库，分布在许多不太可能具有同步时间的服务器上。
一个更简单的解释是，时间由表的分片leader决定，这是leader所有followers 使用的时间。因此，底层服务器的UTC时间戳可能与用于特定表上事务的当前时间戳不同。 </p>
<p>以下示例假设您已使用Retail Analytics 示例数据集创建并连接到bm_demo数据库： </p>
<div class="highlight"><pre><span></span><code>SELECT to_char(max(orders.created_at), &#39;DD-MON-YYYY HH24:MI&#39;) AS &quot;Last Order Date&quot; from orders;
</code></pre></div>
<div class="highlight"><pre><span></span><code>  Last Order Date
-------------------
 19-APR-2020 14:07
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT extract(MONTH from o.created_at) AS &quot;Mth Num&quot;, to_char(o.created_at, &#39;MON&#39;) AS &quot;Month&quot;,
        extract(YEAR from o.created_at) AS &quot;Year&quot;, count(*) AS &quot;Orders&quot;
   from orders o
  where o.created_at &gt; current_timestamp(0)
  group by 1,2,3
  order by 3 DESC, 1 DESC limit 10;
</code></pre></div>
<div class="highlight"><pre><span></span><code> Mth Num | Month | Year | Orders
---------+-------+------+--------
       4 | APR   | 2020 |    344
       3 | MAR   | 2020 |    527
       2 | FEB   | 2020 |    543
       1 | JAN   | 2020 |    580
      12 | DEC   | 2019 |    550
      11 | NOV   | 2019 |    542
      10 | OCT   | 2019 |    540
       9 | SEP   | 2019 |    519
       8 | AUG   | 2019 |    566
       7 | JUL   | 2019 |    421
(10 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT to_char(o.created_at, &#39;HH AM&#39;) AS &quot;Popular Hours&quot;, count(*) AS &quot;Orders&quot;
   from orders o
  group by 1
  order by 2 DESC
  limit 4;
</code></pre></div>
<div class="highlight"><pre><span></span><code>Popular Hours | Orders
---------------+--------
 12 PM         |    827
 11 AM         |    820
 03 PM         |    812
 08 PM         |    812
(4 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>update orders
   set created_at = created_at + ((floor(random() * (25-2+2) + 2))::int * interval &#39;1 day 14 hours&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE 18760
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT to_char(o.created_at, &#39;Day&#39;) AS &quot;Top Day&quot;,
        count(o.*) AS &quot;SALES&quot;
   from orders o
  group by 1
  order by 2 desc;
</code></pre></div>
<div class="highlight"><pre><span></span><code>Top Day  | SALES
-----------+---------
 Monday    |    2786
 Tuesday   |    2737
 Saturday  |    2710
 Wednesday |    2642
 Friday    |    2634
 Sunday    |    2630
 Thursday  |    2621
(7 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>create table order_deliveries (
          order_id bigint,
          creation_date date DEFAULT current_date,
          delivery_date timestamptz);
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE TABLE
</code></pre></div>
<div class="highlight"><pre><span></span><code>insert into order_deliveries
          (order_id, delivery_date)
SELECT o.id, o.created_at + ((floor(random() * (25-2+2) + 2))::int * interval &#39;1 day 3 hours&#39;)
   from orders o
  where o.created_at &lt; current_timestamp - (20 * interval &#39;1 day&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT 0 12268
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * from order_deliveries limit 5;
</code></pre></div>
<div class="highlight"><pre><span></span><code> order_id | creation_date |       delivery_date
----------+---------------+----------------------------
     5636 | 2019-07-09    | 2017-01-06 03:06:01.071+00
    10990 | 2019-07-09    | 2018-12-16 12:02:56.169+00
    13417 | 2019-07-09    | 2018-06-26 09:28:02.153+00
     9367 | 2019-07-09    | 2017-05-21 06:49:42.298+00
    13954 | 2019-07-09    | 2019-02-08 04:07:01.457+00
(5 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT d.order_id, to_char(o.created_at, &#39;DD-MON-YYYY HH AM&#39;) AS &quot;Ordered&quot;,
        to_char(d.delivery_date, &#39;DD-MON-YYYY HH AM&#39;) AS &quot;Delivered&quot;,
        d.delivery_date - o.created_at AS &quot;Delivery Days&quot;
   from orders o, order_deliveries d
  where o.id = d.order_id
        and d.delivery_date - o.created_at &gt; interval &#39;15 days&#39;
   order by d.delivery_date - o.created_at DESC, d.delivery_date DESC limit 10;
</code></pre></div>
<div class="highlight"><pre><span></span><code> order_id |      Ordered      |     Delivered     |  Delivery Days
----------+-------------------+-------------------+------------------
    10984 | 12-JUN-2019 08 PM | 07-JUL-2019 02 AM | 24 days 06:00:00
     6263 | 01-JUN-2019 03 AM | 25-JUN-2019 09 AM | 24 days 06:00:00
    10498 | 18-MAY-2019 01 AM | 11-JUN-2019 07 AM | 24 days 06:00:00
    14996 | 14-MAR-2019 05 PM | 08-APR-2019 12 AM | 24 days 06:00:00
     6841 | 06-FEB-2019 01 AM | 02-MAR-2019 07 AM | 24 days 06:00:00
    10977 | 11-MAY-2019 01 PM | 03-JUN-2019 07 PM | 23 days 06:00:00
    14154 | 09-APR-2019 01 PM | 02-MAY-2019 07 PM | 23 days 06:00:00
     6933 | 31-MAY-2019 05 PM | 23-JUN-2019 12 AM | 22 days 06:00:00
     5289 | 04-MAY-2019 04 PM | 26-MAY-2019 10 PM | 22 days 06:00:00
    10226 | 01-MAY-2019 06 AM | 23-MAY-2019 12 PM | 22 days 06:00:00
(10 rows)
</code></pre></div>
<p>您的输出可能略有不同，因为RANDOM()函数用于在新的order_deliveries 表中设置delivery_date。
您可以使用BMDB数据目录的视图来创建已经为应用程序代码准备和格式化的数据，这样您的SQL就更简单了。以下示例显示了如何指定已格式化并可用于显示目的的时区： </p>
<div class="highlight"><pre><span></span><code>CREATE OR REPLACE VIEW TZ AS
SELECT &#39;* Current time&#39; AS &quot;tzone&quot;, &#39;&#39; AS &quot;offset&quot;, to_char(current_timestamp AT TIME ZONE &#39;Australia/Sydney&#39;, &#39;Dy dd-Mon-yy hh:mi PM&#39;) AS &quot;Local Time&quot;
UNION
SELECT x.name AS &quot;tzone&quot;,
left(x.utc_offset::text, 5) AS &quot;offset&quot;,
to_char(current_timestamp AT TIME ZONE x.name, &#39;Dy dd-Mon-yy hh:mi PM&#39;) AS &quot;Local Time&quot;
from pg_catalog.pg_timezone_names x
where x.name like &#39;Australi%&#39; or name in(&#39;Singapore&#39;, &#39;NZ&#39;, &#39;UTC&#39;)
order by 1 asc;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE VIEW
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * from tz;
</code></pre></div>
<div class="highlight"><pre><span></span><code>         tzone         | offset |       Local Time
-----------------------+--------+------------------------
 * Current time        |        | Wed 10-Jul-19 11:49 AM
 Australia/ACT         | 10:00  | Wed 10-Jul-19 11:49 AM
 Australia/Adelaide    | 09:30  | Wed 10-Jul-19 11:19 AM
 Australia/Brisbane    | 10:00  | Wed 10-Jul-19 11:49 AM
 Australia/Broken_Hill | 09:30  | Wed 10-Jul-19 11:19 AM
 Australia/Canberra    | 10:00  | Wed 10-Jul-19 11:49 AM
 Australia/Currie      | 10:00  | Wed 10-Jul-19 11:49 AM
 Australia/Darwin      | 09:30  | Wed 10-Jul-19 11:19 AM
 Australia/Eucla       | 08:45  | Wed 10-Jul-19 10:34 AM
 Australia/Hobart      | 10:00  | Wed 10-Jul-19 11:49 AM
 Australia/LHI         | 10:30  | Wed 10-Jul-19 12:19 PM
 Australia/Lindeman    | 10:00  | Wed 10-Jul-19 11:49 AM
 Australia/Lord_Howe   | 10:30  | Wed 10-Jul-19 12:19 PM
 Australia/Melbourne   | 10:00  | Wed 10-Jul-19 11:49 AM
 Australia/NSW         | 10:00  | Wed 10-Jul-19 11:49 AM
 Australia/North       | 09:30  | Wed 10-Jul-19 11:19 AM
 Australia/Perth       | 08:00  | Wed 10-Jul-19 09:49 AM
 Australia/Queensland  | 10:00  | Wed 10-Jul-19 11:49 AM
 Australia/South       | 09:30  | Wed 10-Jul-19 11:19 AM
 Australia/Sydney      | 10:00  | Wed 10-Jul-19 11:49 AM
 Australia/Tasmania    | 10:00  | Wed 10-Jul-19 11:49 AM
 Australia/Victoria    | 10:00  | Wed 10-Jul-19 11:49 AM
 Australia/West        | 08:00  | Wed 10-Jul-19 09:49 AM
 Australia/Yancowinna  | 09:30  | Wed 10-Jul-19 11:19 AM
 NZ                    | 12:00  | Wed 10-Jul-19 01:49 PM
 Singapore             | 08:00  | Wed 10-Jul-19 09:49 AM
 UTC                   | 00:00  | Wed 10-Jul-19 01:49 AM
(27 rows)
</code></pre></div>
<p>假设你选择了你感兴趣的时区，你的结果应该与上面显示的不同 </p>
<h5 id="_158"><strong>日期和时间间隔</strong></h5>
<p>间隔是一种描述时间增量的数据类型。间隔允许您显示两个时间戳之间的差异，或者通过添加或减去特定的度量单位来创建新的时间戳。考虑以下示例： </p>
<div class="highlight"><pre><span></span><code>SELECT current_timestamp AS &quot;Current Timestamp&quot;,
           current_timestamp + (10 * interval &#39;1 min&#39;) AS &quot;Plus 10 Mins&quot;,
           current_timestamp + (10 * interval &#39;3 min&#39;) AS &quot;Plus 30 Mins&quot;,
           current_timestamp + (10 * interval &#39;2 hour&#39;) AS &quot;Plus 20 hours&quot;,
           current_timestamp + (10 * interval &#39;1 month&#39;) AS &quot;Plus 10 Months&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>       Current Timestamp       |         Plus 10 Mins          |         Plus 30 Mins          |         Plus 20 hours         |        Plus 10 Months
-------------------------------+-------------------------------+-------------------------------+-------------------------------+-------------------------------
 2019-07-09 05:08:58.859123+00 | 2019-07-09 05:18:58.859123+00 | 2019-07-09 05:38:58.859123+00 | 2019-07-10 01:08:58.859123+00 | 2020-05-09 05:08:58.859123+00
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT current_time::time(0), time &#39;05:00&#39; + interval &#39;5 hours 7 mins&#39; AS &quot;New time&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_time | New Time
--------------+----------
 05:09:24     | 10:16:24
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT current_date - date &#39;01-01-2019&#39; AS &quot;Day of Year(A)&quot;, current_date - date_trunc(&#39;year&#39;, current_date) AS &quot;Day of Year(B)&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> Day of Year(A) | Day of Year(B)
----------------+----------------
            189 | 189 days
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT timestamp &#39;2019-07-09 10:00:00.000000+00&#39; - timestamp &#39;2019-07-09 09:00:00.000000+00&#39; AS &quot;Time Difference&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> Time Difference
-----------------
 01:00:00
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT timestamp &#39;2019-07-09 10:00:00.000000+00&#39; - timestamptz &#39;2019-07-09 10:00:00.000000+00&#39; AS &quot;Time Offset&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>  Time Offset
-------------
 00:00:00 
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT timestamp &#39;2019-07-09 10:00:00.000000+00&#39; - timestamptz &#39;2019-07-09 10:00:00.000000EST&#39; AS &quot;Time Offset&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> Time Offset
-------------
 -05:00:00
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT timestamp &#39;2019-07-09 10:00:00.000000+00&#39; - timestamptz &#39;2019-07-08 10:00:00.000000EST&#39; AS &quot;Time Offset&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> Time Offset
-------------
 19:00:00
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT timestamp &#39;2019-07-09 10:00:00.000000+00&#39; - timestamptz &#39;2019-07-07 10:00:00.000000EST&#39; AS &quot;Time Offset&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>  Time Offset
----------------
 1 day 19:00:00
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT age(timestamp &#39;2019-07-09 10:00:00.000000+00&#39;, timestamptz &#39;2019-07-07 10:00:00.000000EST&#39;) AS &quot;Age Diff&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>    Age Diff
----------------
 1 day 19:00:00
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT (extract(&#39;days&#39; from age(timestamp &#39;2019-07-09 10:00:00.000000+00&#39;, timestamptz &#39;2019-07-07 10:00:00.000000EST&#39;))*24)+
           (extract(&#39;hours&#39; from age(timestamp &#39;2019-07-09 10:00:00.000000+00&#39;, timestamptz &#39;2019-07-07 10:00:00.000000EST&#39;))) AS &quot;Hours Diff&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> Hours Diff
------------
         43
</code></pre></div>
<p>以上内容表明，日期和时间操作可以通过多种方式实现。需要注意的是，有些输出类型为INTEGER ，而另一些输出类型为INTERVAL（并非显示的文本）。上面“Hours Diff”的最后一个BSQL使用EXTRACT 的输出，该输出产生一个INTEGER ，以便它可以乘以每天的小时数，而EXTRACT 函数本身需要INTERVAL 或TIMESTAMP（TZ）数据类型作为其输入。</p>
<p>可以对时间（tz）、日期和时间戳（tz）进行转换，如MY_VALUE::timestamptz。 </p>
<h5 id="_159"><strong>截断操作</strong></h5>
<p>DATE_TRUNC命令用于将时间戳“floor”到特定单元。本示例假设您已创建并连接到带有Retail Analytics示例数据集的bm_demo数据库。 </p>
<div class="highlight"><pre><span></span><code>SELECT date_trunc(&#39;hour&#39;, current_timestamp);
</code></pre></div>
<div class="highlight"><pre><span></span><code>       date_trunc
------------------------
 2019-07-09 06:00:00+00
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT to_char((date_trunc(&#39;month&#39;, generate_series)::date)-1, &#39;DD-MON-YYYY&#39;) AS &quot;Last Day of Month&quot;
          from generate_series(current_date-(365-1), current_date, &#39;1 month&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code> Last Day of Month
-------------------
 30-JUN-2018
 31-JUL-2018
 31-AUG-2018
 30-SEP-2018
 31-OCT-2018
 30-NOV-2018
 31-DEC-2018
 31-JAN-2019
 28-FEB-2019
 31-MAR-2019
 30-APR-2019
 31-MAY-2019
(12 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT date_trunc(&#39;days&#39;, age(created_at)) AS &quot;Product Age&quot; from products order by 1 desc limit 10;
</code></pre></div>
<div class="highlight"><pre><span></span><code>      Product Age
------------------------
 3 years 2 mons 12 days
 3 years 2 mons 10 days
 3 years 2 mons 6 days
 3 years 2 mons 4 days
 3 years 1 mon 28 days
 3 years 1 mon 27 days
 3 years 1 mon 15 days
 3 years 1 mon 9 days
 3 years 1 mon 9 days
 3 years 1 mon
(10 rows)
</code></pre></div>
<h5 id="_160"><strong>整合</strong></h5>
<p>一个常见的要求是找出下周一的日期；例如，出于日程安排的目的，这可能是新一周的第一天。这可以通过多种方式实现。以下说明了将不同的日期和时间运算符和函数链接在一起以获得所需结果： </p>
<div class="highlight"><pre><span></span><code>SELECT to_char(current_date, &#39;Day, DD-MON-YYYY&#39;) AS &quot;Today&quot;,
           to_char((current_timestamp AT TIME ZONE &#39;Australia/Sydney&#39;)::date +
           (7-(extract(&#39;isodow&#39; from current_timestamp AT TIME ZONE &#39;Australia/Sydney&#39;))::int + 1),
           &#39;Day, DD-MON-YYYY&#39;) AS &quot;Start of Next Week&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>         Today          |   Start of Next Week
------------------------+------------------------
 Tuesday  , 09-JUL-2019 | Monday   , 15-JUL-2019
</code></pre></div>
<p>上述方法是将一周中的当前日期提取为整数。由于今天是星期二，所以结果是2。正如您所知，每周有7天，您需要针对结果为8的计算，即比第7天多1天。我们使用它来计算在当前日期（7天-2+1天）上加多少天才能到达下周一，也就是一周中的第几天。添加AT TIME ZONE纯粹是为了说明问题，不会影响结果，因为您处理的是天，而时区差仅为+10小时，因此不会影响日期。然而，如果你的工作时间不超过几个小时，那么时区可能会对你的结果产生影响。 </p>
<h5 id="-datestyle"><strong>歧义-使用DateStyle</strong></h5>
<p>世界各地的人们都熟悉当地的日期表示。时间相当相似，但日期可能不同。美国使用3/5/19，而在澳大利亚使用5/3/19，在欧洲使用5.3.19或5/3/19。日期是什么？2019年3月5日。</p>
<p>BMDB具有应用于会话的DateStyle 设置，因此可以确定不明确的日期，并且可以将BSQL中的日期显示默认为特定格式。 </p>
<p>默认情况下，BMDB使用YYYY-MM-DD HH24:MI:SS的ISO标准。您可以使用的其他设置有“SQL”、“'German'”和“Postgres”。这些都用于以下示例中。</p>
<p>除了ISO之外的所有设置都允许您指定一天是出现在月之前还是之后。因此，设置“DMY”会导致3/5是5月3日，而“MDY”会在3月5日。</p>
<p>如果您从文件或任何非BMDB日期或时间戳数据类型的源读取日期作为文本字段，则正确设置DateStyle 非常重要，除非您非常具体地了解如何将文本字段转换为日期-下面包括一个示例。 </p>
<p>请注意，BMDB总是将“6/6”解释为6月6日，将“13/12”解释为12月13日（因为月份不能是13），但“6/12”呢？让我们来看看BSQL中的一些示例。</p>
<div class="highlight"><pre><span></span><code>SHOW DateStyle;
</code></pre></div>
<div class="highlight"><pre><span></span><code> DateStyle
-----------
 ISO, DMY
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT current_date, current_time(0), current_timestamp(0);
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_date | current_time |   current_timestamp
--------------+--------------+------------------------
 2019-07-09   | 20:26:28+00  | 2019-07-09 20:26:28+00
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET DateStyle = &#39;SQL, DMY&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT current_date, current_time(0), current_timestamp(0);
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_date | current_time |    current_timestamp
--------------+--------------+-------------------------
 09/07/2019   | 20:26:48+00  | 09/07/2019 20:26:48 UTC
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET DateStyle = &#39;SQL, MDY&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET 
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT current_date, current_time(0), current_timestamp(0);
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_date | current_time |    current_timestamp
--------------+--------------+-------------------------
 07/09/2019   | 20:27:04+00  | 07/09/2019 20:27:04 UTC
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET DateStyle = &#39;German, DMY&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET 
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT current_date, current_time(0), current_timestamp(0);
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_date | current_time |    current_timestamp
--------------+--------------+-------------------------
 09.07.2019   | 20:27:30+00  | 09.07.2019 20:27:30 UTC
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET DateStyle = &#39;Postgres, DMY&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET 
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT current_date, current_time(0), current_timestamp(0);
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_date | current_time |      current_timestamp
--------------+--------------+------------------------------
 09-07-2019   | 20:28:07+00  | Tue 09 Jul 20:28:07 2019 UTC
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET DateStyle = &#39;Postgres, MDY&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET 
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT current_date, current_time(0), current_timestamp(0);
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_date | current_time |      current_timestamp
--------------+--------------+------------------------------
 07-09-2019   | 20:28:38+00  | Tue Jul 09 20:28:38 2019 UTC
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT &#39;01-01-2019&#39;::date;
</code></pre></div>
<div class="highlight"><pre><span></span><code>    date
------------
 01-01-2019
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT to_char(&#39;01-01-2019&#39;::date, &#39;DD-MON-YYYY&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>   to_char
-------------
 01-JAN-2019
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT to_char(&#39;05-03-2019&#39;::date, &#39;DD-MON-YYYY&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>   to_char
-------------
 03-MAY-2019
</code></pre></div>
<p>以下示例说明了日期可能出现的困难：</p>
<div class="highlight"><pre><span></span><code>SET DateStyle = &#39;Postgres, DMY&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SET 
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT to_char(&#39;05-03-2019&#39;::date, &#39;DD-MON-YYYY&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>   to_char
-------------
 05-MAR-2019
</code></pre></div>
<p>系统需要一个“DMY”值，但源的格式为“MDY”。BMDB不知道如何转换不明确的情况，所以要明确如下： </p>
<div class="highlight"><pre><span></span><code>SELECT to_char(to_date(&#39;05-03-2019&#39;, &#39;MM-DD-YYYY&#39;), &#39;DD-MON-YYYY&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>   to_char
-------------
 03-MAY-2019
</code></pre></div>
<p>建议通过TO_DATE 或TO_TIMESTAMP函数传递日期和时间数据类型的所有文本表示。没有“to_time”函数，因为它的格式始终固定为“HH24:MI:SS.ms”，因此要小心AM/PM时间，您的毫秒也可能是千分之一秒，因此应提供3或6位数字 </p>
<h5 id="_161"><strong>日志</strong></h5>
<p>BMDB继承了许多类似于PostgreSQL API的功能，这就解释了为什么当你开始寻找引擎盖时，它看起来非常像PostgreSQL。
BMDB在其目录中跟踪其设置。以下示例查询一些相关设置，并使用“扩展显示”设置转换查询结果的布局。这可以在任何数据库中完成。 </p>
<div class="highlight"><pre><span></span><code>\x on
</code></pre></div>
<div class="highlight"><pre><span></span><code>Expanded display is on.
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT name, short_desc, coalesce(setting, reset_val) AS &quot;setting_value&quot;, sourcefile
          from pg_catalog.pg_settings
          where name in(&#39;log_timezone&#39;, &#39;log_directory&#39;, &#39;log_filename&#39;, &#39;lc_time&#39;)
          order by name asc;
</code></pre></div>
<div class="highlight"><pre><span></span><code>-[ RECORD 1 ]-+----------------------------------------------------------------
name          | lc_time
short_desc    | Sets the locale for formatting date and time values.
setting_value | en_US.UTF-8
sourcefile    | /home/xxxxx/bigmath-data/node-1/disk-1/pg_data/postgresql.conf
-[ RECORD 2 ]-+----------------------------------------------------------------
name          | log_directory
short_desc    | Sets the destination directory for log files.
setting_value | /home/xxxxx/bigmath-data/node-1/disk-1/bm-data/dbserver/logs
sourcefile    |
-[ RECORD 3 ]-+----------------------------------------------------------------
name          | log_filename
short_desc    | Sets the file name pattern for log files.
setting_value | postgresql-%Y-%m-%d_%H%M%S.log
sourcefile    |
-[ RECORD 4 ]-+----------------------------------------------------------------
name          | log_timezone
short_desc    | Sets the time zone to use in log messages.
setting_value | UTC
sourcefile    | /home/xxxxx/bigmath-data/node-1/disk-1/pg_data/postgresql.conf
</code></pre></div>
<div class="highlight"><pre><span></span><code>\x off
</code></pre></div>
<p>使用log_directory和log_filename引用，您可以找到BMDB日志来检查插入到日志中的时间戳。这些都是UTC时间戳，应该保持不变。</p>
<p>您可以看到lc_time设置当前为UTF，并且列出了从中获取该设置的文件。以sudo/superuser的身份打开该文件，您会看到如下内容（搜索“datestyle”）： </p>
<div class="highlight"><pre><span></span><code># - Locale and Formatting -

datestyle = &#39;iso, mdy&#39;
#intervalstyle = &#39;postgres&#39;
timezone = &#39;UTC&#39;
#timezone_abbreviations = &#39;Default&#39;     # Select the set of available time zone
                                        # abbreviations.  Currently, there are
                                        #   Default
                                        #   Australia (historical usage)
                                        #   India
                                        # You can create your own file in
                                        # share/timezonesets/.
#extra_float_digits = 0                 # min -15, max 3
#client_encoding = sql_ascii            # actually, defaults to database
                                        # encoding

# These settings are initialized by initdb, but they can be changed.
lc_messages = &#39;en_US.UTF-8&#39;                     # locale for system error message
                                        # strings
lc_monetary = &#39;en_US.UTF-8&#39;                     # locale for monetary formatting
lc_numeric = &#39;en_US.UTF-8&#39;                      # locale for number formatting
lc_time = &#39;en_US.UTF-8&#39;                         # locale for time formatting

# default configuration for text search
default_text_search_config = &#39;pg_catalog.english&#39;
</code></pre></div>
<p>备份原始文件，然后更改datestyle='SQL，DMY'，timezone='GB'（或您喜欢的任何其他时区名称）并保存文件。您需要重新启动BMDB集群才能使更改生效。</p>
<p>群集按预期运行后，请执行以下操作：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh
</code></pre></div>
<div class="highlight"><pre><span></span><code>sqlsh (11.2)
Type &quot;help&quot; for help.
</code></pre></div>
<div class="highlight"><pre><span></span><code>SHOW timezone;
</code></pre></div>
<div class="highlight"><pre><span></span><code> TimeZone
----------
 GB
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT current_date;
</code></pre></div>
<div class="highlight"><pre><span></span><code> current_date
--------------
 09/07/2019
</code></pre></div>
<p>不需要每次输入BSQL时都进行这些设置。但是，应用程序不应该依赖于这些设置，它们应该在提交SQL之前始终设置其需求。这些设置只能由“临时查询”使用，如您现在所做的操作。</p>
<h5 id="_162"><strong>结论</strong></h5>
<p>日期和时间是一个全面的领域，PostgreSQL和BMDB中的BSQL都很好地解决了这一问题。实现了所有的日期-时间数据类型，并且提供了绝大多数方法、运算符和特殊值。该功能非常复杂，您可以对其SQL API的BSQL实现中发现的任何不足进行编码。 </p>
<h3 id="_163"><strong>字符串和文本</strong></h3>
<h4 id="bsql_4"><strong>BSQL</strong></h4>
<h5 id="_164"><strong>介绍</strong></h5>
<p>字符串、字符数据类型或文本是每个可想象系统的一部分。操作和输出文本是一个非常重要的主题，对于您使用的许多不同类型的系统来说都是必需的。本节概述了BMDB SQL API广泛的文本功能。</p>
<p>示例使用Retail Analytics 示例数据集。</p>
<h5 id="_165"><strong>字符数据类型</strong></h5>
<p>对于PostgreSQL，不同字符数据类型的使用具有历史意义。BMDB—作为一个较新的实现——没有这样的历史。请考虑保持字符数据类型的使用简单，理想情况下仅使用“text”或“varchar（n）”（如果需要限制长度）。使用文本，然后验证字符串的长度，可以开发自己的方法来管理这种情况，而不是遇到超过任意长度的错误。
如果使用char(n), character(n)或varchar(n)。如果长度不受限制，请使用不带长度说明的字符数据类型，例如“text”。但是，如果您有忽略尾随空格的特定要求，那么您可能希望考虑使用char(n)。 
有关字符数据类型的详细信息，请参阅数据类型。请注意，BMDB实现了数据类型别名，这就是这里所使用的。</p>
<p>以下示例显示了使用不同数据类型的几种方法：</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh
</code></pre></div>
<div class="highlight"><pre><span></span><code>sqlsh (11.2)
Type &quot;help&quot; for help.
</code></pre></div>
<div class="highlight"><pre><span></span><code>create table text_columns(a_text text, a_varchar varchar, a_char char, b_varchar varchar(10), b_char char(10));
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE TABLE
</code></pre></div>
<div class="highlight"><pre><span></span><code>insert into text_columns values(&#39;abc &#39;, &#39;abc &#39;, &#39;abc &#39;, &#39;abc &#39;, &#39;abc &#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>ERROR:  value too long for type character(1)
</code></pre></div>
<div class="highlight"><pre><span></span><code>insert into text_columns values(&#39;abc &#39;, &#39;abc &#39;, &#39;a&#39;, &#39;abc &#39;, &#39;abc &#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT 0 1
</code></pre></div>
<div class="highlight"><pre><span></span><code>select * from text_columns
           where a_text like &#39;ab__&#39; and a_varchar like &#39;ab__&#39;
           and b_varchar like &#39;ab__&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> a_text | a_varchar | a_char | b_varchar |   b_char
--------+-----------+--------+-----------+------------
 abc    | abc       | a      | abc       | abc
</code></pre></div>
<div class="highlight"><pre><span></span><code>select * from text_columns
           where a_text like &#39;ab__&#39; and a_varchar like &#39;ab__&#39;
           and b_varchar like &#39;ab__&#39; and b_char like &#39;ab__&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> a_text | a_varchar | a_char | b_varchar | b_char
--------+-----------+--------+-----------+--------
(0 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>select length(a_text) as a_text, length(a_varchar) as a_varchar, length(a_char) as a_char,
           length(b_varchar) as b_varchar, length(b_char) as b_char
           from text_columns;
</code></pre></div>
<div class="highlight"><pre><span></span><code> a_text | a_varchar | a_char | b_varchar | b_char
--------+-----------+--------+-----------+--------
      4 |         4 |      1 |         4 |      3
</code></pre></div>
<p>请注意，b_char列不包含尾部空格，这可能会影响SQL。此外，如果在列定义上指定最大长度，SQL也可能会生成错误，因此您必须手动截断输入值或引入错误处理</p>
<h6 id="_166">转换</h6>
<p>当您使用用户通过应用程序输入的文本时，请确保BMDB了解它使用的是文本输入。所有值都应强制转换，除非它们由于已经发生的其他验证措施而可信。</p>
<p>以下示例显示了转换的影响：</p>
<div class="highlight"><pre><span></span><code>select cast(123 AS TEXT), cast(&#39;123&#39; AS TEXT), 123::text, &#39;123&#39;::text;
</code></pre></div>
<div class="highlight"><pre><span></span><code> text | text | text | text
------+------+------+------
 123  | 123  | 123  | 123
</code></pre></div>
<div class="highlight"><pre><span></span><code>select tablename, hasindexes AS nocast, hasindexes::text AS casted
  from pg_catalog.pg_tables
  where tablename in(&#39;pg_default_acl&#39;, &#39;sql_features&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>   tablename    | nocast | casted
----------------+--------+--------
 pg_default_acl | t      | true
 sql_features   | f      | false
</code></pre></div>
<p>列“hasindexes”是布尔数据类型，通过将其强制转换为文本，您将收到true或false的文本结果 </p>
<h5 id="_167"><strong>文本使用</strong></h5>
<p>许多函数可以应用于文本。在下面的示例中，函数被分类为逻辑分组——在许多情况下，函数的重载和个人的选择决定了如何解决问题。
这里的重点是快速展示如何使用每个函数，以及一些示例。
本示例假设您已创建并连接到带有Retail Analytics 示例数据集的bm_demo数据库。</p>
<h6 id="_168">更改文本的显示</h6>
<div class="highlight"><pre><span></span><code>select lower(&#39;hELLO world&#39;) AS LOWER,
  upper(&#39;hELLO world&#39;) AS UPPER,
  initcap(&#39;hELLO world&#39;) AS INITCAP;
</code></pre></div>
<div class="highlight"><pre><span></span><code>    lower    |    upper    |   initcap
-------------+-------------+-------------
 hello world | HELLO WORLD | Hello World
</code></pre></div>
<div class="highlight"><pre><span></span><code>select quote_ident(&#39;ok&#39;) AS EASY, quote_ident(&#39;I am OK&#39;) AS QUOTED, quote_ident(&#39;I&#39;&#39;m not OK&#39;) AS DOUBLE_QUOTED, quote_ident(&#39;&#39;) AS EMPTY_STR, quote_ident(null) AS NULL_QUOTED;
</code></pre></div>
<div class="highlight"><pre><span></span><code> easy |  quoted   | double_quoted | empty_str | null_quoted
------+-----------+---------------+-----------+-------------
 ok   | &quot;I am OK&quot; | &quot;I&#39;m not OK&quot;  | &quot;&quot;        |
</code></pre></div>
<div class="highlight"><pre><span></span><code>select quote_literal(&#39;ok&#39;) AS EASY, quote_literal(&#39;I am OK&#39;) AS QUOTED, quote_literal(&#39;I&#39;&#39;m not OK&#39;) AS DOUBLE_QUOTED, quote_literal(&#39;&#39;) AS EMPTY_STR, quote_literal(null) AS NULL_QUOTED;
</code></pre></div>
<div class="highlight"><pre><span></span><code> easy |  quoted   | double_quoted | empty_str | null_quoted
------+-----------+---------------+-----------+-------------
 &#39;ok&#39; | &#39;I am OK&#39; | &#39;I&#39;&#39;m not OK&#39; | &#39;&#39;        |
</code></pre></div>
<div class="highlight"><pre><span></span><code>select quote_nullable(&#39;ok&#39;) AS EASY, quote_nullable(&#39;I am OK&#39;) AS QUOTED, quote_nullable(&#39;I&#39;&#39;m not OK&#39;) AS DOUBLE_QUOTED, quote_nullable(&#39;&#39;) AS EMPTY_STR, quote_nullable(null) AS NULL_QUOTED;
</code></pre></div>
<div class="highlight"><pre><span></span><code>easy |  quoted   | double_quoted | empty_str | null_quoted
------+-----------+---------------+-----------+-------------
 &#39;ok&#39; | &#39;I am OK&#39; | &#39;I&#39;&#39;m not OK&#39; | &#39;&#39;        | NULL
</code></pre></div>
<p>使用quote_ident来解析SQL中类似列名的标识符，并将quote_nullable作为可能也是null的字符串文字。</p>
<h6 id="_169">解析原始文本</h6>
<p>您可以使用“美元符号引用”来解析原始文本——任何包含在美元符号（$）引用中的文本都被视为原始文本。起始标记和结束标记不必相同，但必须以美元符号开头和结尾。请考虑以下示例：</p>
<div class="highlight"><pre><span></span><code>select $$%&amp;*$&amp;$%7&#39;\67458\&#39;&#39;&quot;&quot;&quot;&quot;&#39;;;&#39;\//\/\/\&quot;&quot;&#39;/&#39;&#39;&#39;&#39;&#39;&quot;&quot;&quot;&quot;&quot;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;$$;
</code></pre></div>
<div class="highlight"><pre><span></span><code>                         ?column?
-----------------------------------------------------------
 %&amp;*$&amp;$%7&#39;\67458\&#39;&#39;&quot;&quot;&quot;&quot;&#39;;;&#39;\//\/\/\&quot;&quot;&#39;/&#39;&#39;&#39;&#39;&#39;&quot;&quot;&quot;&quot;&quot;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;
</code></pre></div>
<div class="highlight"><pre><span></span><code>select $__unique_$           Lots of space
                   and multi-line too       $__unique_$;
</code></pre></div>
<div class="highlight"><pre><span></span><code>                   ?column?
----------------------------------------------
            Lots of space                    +
                    and multi-line too
</code></pre></div>
<div class="highlight"><pre><span></span><code>select $$first$$ AS &quot;F1&quot;, $$second$$ AS &quot;F2&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>  F1   |   F2
-------+--------
 first | second
</code></pre></div>
<h6 id="_170">填充与截断</h6>
<p>出于格式化目的，需要填充一些值，而lpad()和rpad()（分别为“左填充”和“右填充”）就是用于此目的的。它们通常与空格一起使用，但您可以使用任何东西进行填充，包括多个字符。例如，您可以使用下划线（_）或间隔点填充。您没有指定要填充的长度，而是指定要添加的最大长度。因此，如果你的值已经和你的最大长度一样长，那么就不需要填充了。请注意，如果字段的长度超过指定的最大长度，这可能会导致截断。</p>
<p>填充的反面是截断，如果找到空格，则会截断空格。以下示例使用填充和截断来获得所需的结果： </p>
<div class="highlight"><pre><span></span><code>select name, lpad(name, 10), rpad(name, 15) from users order by name limit 5;
</code></pre></div>
<div class="highlight"><pre><span></span><code>       name        |    lpad    |      rpad
-------------------+------------+-----------------
 Aaron Hand        | Aaron Hand | Aaron Hand
 Abbey Satterfield | Abbey Satt | Abbey Satterfie
 Abbie Parisian    | Abbie Pari | Abbie Parisian
 Abbie Ryan        | Abbie Ryan | Abbie Ryan
 Abby Larkin       | Abby Larki | Abby Larkin
</code></pre></div>
<div class="highlight"><pre><span></span><code>select name, lpad(name, 20), rpad(name, 20) from users order by name limit 5;
</code></pre></div>
<div class="highlight"><pre><span></span><code>       name        |         lpad         |         rpad
-------------------+----------------------+----------------------
 Aaron Hand        |           Aaron Hand | Aaron Hand
 Abbey Satterfield |    Abbey Satterfield | Abbey Satterfield
 Abbie Parisian    |       Abbie Parisian | Abbie Parisian
 Abbie Ryan        |           Abbie Ryan | Abbie Ryan
 Abby Larkin       |          Abby Larkin | Abby Larkin
</code></pre></div>
<div class="highlight"><pre><span></span><code>select name, lpad(name, 20, &#39;. &#39;), rpad(name, 20, &#39;.&#39;) from users order by name limit 5;
</code></pre></div>
<div class="highlight"><pre><span></span><code>       name        |         lpad         |         rpad
-------------------+----------------------+----------------------
 Aaron Hand        | . . . . . Aaron Hand | Aaron Hand..........
 Abbey Satterfield | . .Abbey Satterfield | Abbey Satterfield...
 Abbie Parisian    | . . . Abbie Parisian | Abbie Parisian......
 Abbie Ryan        | . . . . . Abbie Ryan | Abbie Ryan..........
 Abby Larkin       | . . . . .Abby Larkin | Abby Larkin.........
</code></pre></div>
<div class="highlight"><pre><span></span><code>select repeat(&#39; &#39;, ((x.maxlen-length(u.name))/2)::int) || rpad(u.name, x.maxlen) AS &quot;cname&quot;
          from users u,
          (select max(length(a.name))::int AS maxlen from users a) AS x;
</code></pre></div>
<div class="highlight"><pre><span></span><code>            cname
------------------------------
      Stewart Marks
      Regan Corkery
    Domenic Daugherty
    Winfield Donnelly
    Theresa Kertzmann
    Terrence Emmerich
      Hudson Jacobi
      Aidan Hagenes
    Virgil Schowalter
      Rahul Kreiger
    Wilhelmine Erdman
      Elwin Okuneva
  Maximillian Dickinson
      Lucie Cormier
  Alexandrine Rosenbaum
    Jayne Breitenberg
  Alexandria Schowalter
 Augustine Runolfsdottir
    Mathilde Weissnat
      Theresa Grant
 ...
</code></pre></div>
<div class="highlight"><pre><span></span><code>select x.RawDay, length(x.RawDay) AS RawLen, x.TrimDay, length(x.TrimDay) AS TrimLen,
          x.LTrimDay, length(x.LTrimDay) AS LTrimLen, x.RTrimDay, length(x.RTrimDay) AS RTrimLen
          from (select to_char(generate_series, &#39;Day&#39;) AS RawDay,
                trim(to_char(generate_series, &#39;Day&#39;)) AS TrimDay,
                ltrim(to_char(generate_series, &#39;Day&#39;)) AS LTrimDay,
                rtrim(to_char(generate_series, &#39;Day&#39;)) AS RTrimDay
                from generate_series(current_date, current_date+6, &#39;1 day&#39;)) AS x;
</code></pre></div>
<div class="highlight"><pre><span></span><code>  rawday   | rawlen |  trimday  | trimlen | ltrimday  | ltrimlen | rtrimday  | rtrimlen
-----------+--------+-----------+---------+-----------+----------+-----------+----------
 Wednesday |      9 | Wednesday |       9 | Wednesday |        9 | Wednesday |        9
 Thursday  |      9 | Thursday  |       8 | Thursday  |        9 | Thursday  |        8
 Friday    |      9 | Friday    |       6 | Friday    |        9 | Friday    |        6
 Saturday  |      9 | Saturday  |       8 | Saturday  |        9 | Saturday  |        8
 Sunday    |      9 | Sunday    |       6 | Sunday    |        9 | Sunday    |        6
 Monday    |      9 | Monday    |       6 | Monday    |        9 | Monday    |        6
 Tuesday   |      9 | Tuesday   |       7 | Tuesday   |        9 | Tuesday   |        7
</code></pre></div>
<p>前面的示例显示了如何将文本居中，截断示例显示了不同截断对填充值的影响。请注意，“Day”值被右填充为9个字符，这就是为什么左截断对字段长度没有任何影响的原因；只有右侧截断或“完全”截断才能去除空格。</p>
<h6 id="_171">转义</h6>
<p>您还可以通过前缀为“e”或“E”来声明文本值是“转义”的。例如： </p>
<div class="highlight"><pre><span></span><code>select E&#39;I&#39;&#39;ve told BMDB that this is an escaped string\n\tso I can specify escapes safely&#39; as escaped_text;
</code></pre></div>
<div class="highlight"><pre><span></span><code>                   escaped_text
---------------------------------------------------
 I&#39;ve told BMDB that this is an escaped string+
         so I can specify escapes safely
</code></pre></div>
<div class="highlight"><pre><span></span><code>select E&#39;a\\b/c\u00B6&#39; as escaped_txt, &#39;a\\b/c\u00B6&#39; as raw_txt;
</code></pre></div>
<div class="highlight"><pre><span></span><code> escaped_txt |   raw_txt
-------------+--------------
 a\b/c¶     | a\\b/c\u00B6
</code></pre></div>
<p>注：\n表示一个新行，\t是一个制表符，因此是格式化的结果。 </p>
<h6 id="_172">编码和转换文本</h6>
<p>BMDB还具有DECODE和ENCODE，用于对二进制数据进行解码和编码。它适用于“base64”、“hex”和“escape”表示。Decode以BYTEA数据类型给出输出。此外，还可以使用TO_HEX命令将ASCII数字转换为其数字表示形式。</p>
<h6 id="_173">连接字符串</h6>
<p>您可以用几种不同的方式连接文本字符串。为了健壮性，您应该确保传递的所有内容都被解释为文本（通过强制转换），这样在边缘情况下就不会出现意外结果。以下示例表明，BMDB在传递变量时很宽容，但您应该实现更健壮的强制转换，以正确处理字符串：</p>
<div class="highlight"><pre><span></span><code>select &#39;one&#39; || &#39;-&#39; || 2 || &#39;-one&#39; AS &quot;121&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>    121
-----------
 one-2-one
</code></pre></div>
<div class="highlight"><pre><span></span><code>select 2 || &#39;-one-one&#39; AS &quot;211&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>    211
-----------
 2-one-one
</code></pre></div>
<div class="highlight"><pre><span></span><code>select 1 || &#39;-one&#39; || repeat(&#39;-two&#39;, 2) AS &quot;1122&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>     1122
---------------
 1-one-two-two
</code></pre></div>
<div class="highlight"><pre><span></span><code>select 1::text || 2::text || 3::text AS &quot;123&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> 123
-----
 123
</code></pre></div>
<div class="highlight"><pre><span></span><code>select 1 || 2 || 3 AS &quot;123&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>ERROR:  operator does not exist: integer || integer
LINE 1: select 1 || 2 || 3 AS &quot;123&quot;;
                 ^
HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
</code></pre></div>
<div class="highlight"><pre><span></span><code>select concat(1,2,3) AS &quot;123&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> 123
-----
 123
</code></pre></div>
<div class="highlight"><pre><span></span><code>select concat_ws(&#39;:&#39;, 1,2,3) AS &quot;123 WS&quot;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> 123 WS
--------
 1:2:3
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>select left(vendor,1) AS V, string_agg(distinct(category), &#39;, &#39; ORDER BY category) AS CATEGORIES
  from products group by left(vendor,1) order by 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code> v |            categories
---+----------------------------------
 A | Doohickey, Gadget, Gizmo
 B | Doohickey, Gadget, Gizmo, Widget
 C | Doohickey, Gadget, Gizmo, Widget
 D | Gadget, Gizmo, Widget
 E | Gadget, Gizmo, Widget
 F | Doohickey, Gadget, Gizmo, Widget
 G | Doohickey, Gadget, Widget
 H | Doohickey, Gadget, Gizmo, Widget
 I | Gizmo, Widget
 J | Doohickey, Gadget, Gizmo, Widget
 K | Doohickey, Gadget, Gizmo, Widget
 L | Doohickey, Gadget, Gizmo, Widget
 M | Doohickey, Gadget, Gizmo, Widget
 N | Doohickey, Gadget, Widget
 O | Doohickey, Gadget, Gizmo, Widget
 P | Doohickey, Gadget, Gizmo, Widget
 Q | Doohickey
 R | Doohickey, Gadget, Gizmo, Widget
 S | Doohickey, Gadget, Gizmo, Widget
 T | Gizmo, Widget
 U | Gadget
 V | Doohickey, Widget
 W | Doohickey, Gadget, Gizmo, Widget
 Z | Gizmo
</code></pre></div>
<p>前面的示例使用了LEFT函数，但string_agg函数最好由一系列或一组数据输入使用，就像在SQL行中所做的那样。该示例显示了聚合字符串与外部SQL（分类为A-Z）相比如何具有自己的顺序。</p>
<p>REVERSE函数反转文本内容，如以下示例所示：</p>
<div class="highlight"><pre><span></span><code>select reverse(to_char(current_date, &#39;DD-MON-YYYY&#39;));
</code></pre></div>
<div class="highlight"><pre><span></span><code>   reverse
-------------
 9102-LUJ-92
</code></pre></div>
<h6 id="_174">分析用户输入</h6>
<p>为了最大限度地减少SQL注入攻击中常见的意外数据的影响，可以使用FORMAT函数将用户输入解析为SQL语句的参数。最常用的方法是在过程中使用EXECUTE 命令，因为它在BSQL命令提示符下不可用，只能在BSQL PL/pgSQL环境中使用。FORMAT命令用于完成传递给EXECUTE以运行的完整SQL语句。由于您在这里不是在模拟BSQL PL/pgSQL，以下示例说明了如何使用FORMAT函数：</p>
<div class="highlight"><pre><span></span><code>select format(&#39;Hello %s, today&#39;&#39;s date is %s&#39;, &#39;Jono&#39;, to_char(current_date, &#39;DD-MON-YYYY&#39;), &#39;discarded&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>                 format
-----------------------------------------
 Hello Jono, today&#39;s date is 29-JUL-2019
</code></pre></div>
<div class="highlight"><pre><span></span><code>select format(&#39;On this day, %2$s, %1$s was here&#39;, &#39;Jono&#39;, to_char(current_date, &#39;DD-MON-YYYY&#39;));
</code></pre></div>
<div class="highlight"><pre><span></span><code>                 format
-----------------------------------------
 On this day, 29-JUL-2019, Jono was here
</code></pre></div>
<div class="highlight"><pre><span></span><code>select format(&#39;SELECT %2$I, %3$I from %1$I where name = %4$L&#39;, &#39;users&#39;, &#39;birth_date&#39;, &#39;email&#39;, &#39;Brody O&#39;&#39;Reilly&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>                               format
--------------------------------------------------------------------
 SELECT birth_date, email from users where name = &#39;Brody O&#39;&#39;Reilly&#39;
</code></pre></div>
<h6 id="_175">替换文本</h6>
<p>用其他文本替换文本可能是一项复杂的任务，因为您需要完全了解函数可能的数据范围。常见的情况是由于传递了意外值（如NULL、空字符串“”）或BMDB将其解释为不同数据类型（如true或3）而导致的失败。</p>
<p>数学运算中对null的处理通常是有问题的，字符串连接也是如此，因为将null连接到值会导致null。如以下示例所示，合并输入可以避免这些问题：</p>
<div class="highlight"><pre><span></span><code>select trunc(avg(coalesce(discount,0))::numeric,3) AS &quot;COALESCED&quot;, trunc(avg(discount)::numeric,3) AS &quot;RAW&quot; from orders;
</code></pre></div>
<div class="highlight"><pre><span></span><code> COALESCED |  RAW
-----------+-------
     0.530 | 5.195
</code></pre></div>
<div class="highlight"><pre><span></span><code>select &#39;Hello &#39; || null AS GREETING, &#39;Goodbye &#39; || coalesce(null, &#39;Valued Customer&#39;) AS GOODBYE;
</code></pre></div>
<div class="highlight"><pre><span></span><code> greeting |         goodbye
----------+-------------------------
          | Goodbye Valued Customer
</code></pre></div>
<p>前面的示例显示了当为null时进行替换如何对您获得的结果，甚至应用程序的行为产生重大影响。</p>
<p>以下示例演示了使用其他文本更改现有文本的方法。 </p>
<div class="highlight"><pre><span></span><code>select overlay(password placing &#39;XXXXXXXXXXXXXXX&#39; from 1 for length(password)) AS SCRAMBLED from users limit 5;
</code></pre></div>
<div class="highlight"><pre><span></span><code>    scrambled
-----------------
 XXXXXXXXXXXXXXX
 XXXXXXXXXXXXXXX
 XXXXXXXXXXXXXXX
 XXXXXXXXXXXXXXX
 XXXXXXXXXXXXXXX
</code></pre></div>
<div class="highlight"><pre><span></span><code>select regexp_replace(&#39;Hi my number is +999 9996-1234&#39;,&#39;[[:alpha:]]&#39;,&#39;&#39;,&#39;g&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>   regexp_replace
--------------------
     +999 9996-1234
</code></pre></div>
<div class="highlight"><pre><span></span><code>select &#39;I think I can hear an &#39; || repeat(&#39;echo.. &#39;, 3) AS CLICHE;
</code></pre></div>
<div class="highlight"><pre><span></span><code>                   cliche
---------------------------------------------
 I think I can hear an echo.. echo.. echo..
</code></pre></div>
<div class="highlight"><pre><span></span><code>select replace(&#39;Gees I love Windows&#39;, &#39;Windows&#39;, &#39;Linux&#39;) AS OBVIOUS;
</code></pre></div>
<div class="highlight"><pre><span></span><code>      obvious
-------------------
 Gees I love Linux
</code></pre></div>
<p>前面的示例去掉了字母表中的所有字符，并用一个空字符串替换它们。“g”标志是“global”，导致替换发生在整个字符串中；如果没有“g”标志，替换将在第一次替换后停止。请注意，结果包含空格，这就是它看起来奇怪的原因。您可能认为此示例显示了非字母字符的提取，但它只是用空字符串替换它们。</p>
<h6 id="_176">提取文本</h6>
<p>有几种方法可以从文本中提取文本；在某些情况下，这可能是“清理”文本的一部分。（删除前导或尾部空格由上一节中显示的截断功能所涵盖。）此处的其余功能显示了如何操作文本的各个部分。</p>
<div class="highlight"><pre><span></span><code>select left(&#39;123456&#39;, 3);
</code></pre></div>
<div class="highlight"><pre><span></span><code> left
------
 123
</code></pre></div>
<div class="highlight"><pre><span></span><code>select right(&#39;123456&#39;, 3);
</code></pre></div>
<div class="highlight"><pre><span></span><code> right
-------
 456
</code></pre></div>
<div class="highlight"><pre><span></span><code>select substr(&#39;123456&#39;, 3);
</code></pre></div>
<div class="highlight"><pre><span></span><code> substr
--------
 3456
</code></pre></div>
<div class="highlight"><pre><span></span><code>select substr(&#39;123456&#39;, 3, 2);
</code></pre></div>
<div class="highlight"><pre><span></span><code> substr
--------
 34
</code></pre></div>
<div class="highlight"><pre><span></span><code>select substr(&#39;123456&#39;, position(&#39;4&#39; in &#39;123456&#39;)+1, 2);
 substring
-----------
 56
</code></pre></div>
<div class="highlight"><pre><span></span><code>select replace(substr(email, position(&#39;@&#39; in email)+1, (length(email)
     -position(&#39;.&#39; in substr(email, position(&#39;@&#39; in email)+1)))), &#39;.com&#39;, &#39;&#39;) AS &quot;Domain&quot;, count(*)
 from users
group by 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code> Domain  | count
---------+-------
 hotmail |   813
 yahoo   |   838
 gmail   |   849
</code></pre></div>
<p>命令SUBSTRING重载了接受POSIX表达式的等效项。前面的示例显示了SUBSTRING（也可以用作SUBSTR）的基本用法。建议在使用POSIX时仅使用完整的SUBSTRING命令。</p>
<h6 id="_177">正则表达式</h6>
<p>正则表达式的完整描述需要它自己的全面文档，这里不涉及这些文档。以下示例说明了它们的用途： </p>
<div class="highlight"><pre><span></span><code>select name as Fullname, regexp_match(name, &#39;(.*)(\s+)(.*)&#39;) AS &quot;REGEXED Name&quot;,
          (regexp_match(name, &#39;(.*)(\s+)(.*)&#39;))[1] AS &quot;First Name&quot;,
          (regexp_match(name, &#39;(.*)(\s+)(.*)&#39;))[3] AS &quot;Last Name&quot;
from users limit 5;
</code></pre></div>
<div class="highlight"><pre><span></span><code>    fullname    |     REGEXED Name     | First Name | Last Name
----------------+----------------------+------------+-----------
 Jacinthe Rowe  | {Jacinthe,&quot; &quot;,Rowe}  | Jacinthe   | Rowe
 Walter Mueller | {Walter,&quot; &quot;,Mueller} | Walter     | Mueller
 Fatima Murphy  | {Fatima,&quot; &quot;,Murphy}  | Fatima     | Murphy
 Paxton Mayer   | {Paxton,&quot; &quot;,Mayer}   | Paxton     | Mayer
 Mellie Wolf    | {Mellie,&quot; &quot;,Wolf}    | Mellie     | Wolf
</code></pre></div>
<p>在前面的示例中，您要求“name”列由空格的存在来分隔，然后报告匹配项报告的第一组和第三组文本。正则表达式返回的是文本数组，而不是文本值，因此必须引用数组索引才能以文本形式访问该值。请注意，此SQL很容易受到数据输入引起的错误的影响，包括中间名，或者缺少名字或姓氏都会导致错误。</p>
<p>现在，让我们来看看文本的一些操作和拆分，以便您可以将其分块处理。以下示例使用了用于处理付款的银行文件的示例摘录。如果整个文件作为单个文本条目上传到表中，然后选择它并进行处理，则此示例可能适用。 </p>
<div class="highlight"><pre><span></span><code>create table bank_payments(bank_file text);
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE TABLE
</code></pre></div>
<div class="highlight"><pre><span></span><code>insert into bank_payments values($$&quot;CMGB&quot;,&quot;1.0&quot;,&quot;95012141352105&quot;,&quot;999999&quot;,&quot;30128193018492&quot;,&quot;20&quot;,&quot;&quot;,&quot;GBP&quot;,&quot;B&quot;,&quot;Beneficiary name18&quot;,&quot;Txt on senders acc&quot;,&quot;Txt for credit acc&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;909170/1&quot;,&quot;AB&quot;
&quot;CMGB&quot;,&quot;1.0&quot;,&quot;95012141352105&quot;,&quot;999999&quot;,&quot;95012113864863&quot;,&quot;10.00&quot;,&quot;&quot;,&quot;GBP&quot;,&quot;B&quot;,&quot;Beneficiary name18&quot;,&quot;Txt on senders acc&quot;,&quot;Txt for credit acc&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;Remitters name  18&quot;,&quot;Tech ref for automatic processing5&quot;,&quot;AT&quot;,&quot;/t.x&quot;,
&quot;CMGB&quot;,&quot;1.0&quot;,&quot;95012141352105&quot;,&quot;&quot;,&quot;30128193018492&quot;,&quot;21&quot;,&quot;&quot;,&quot;GBP&quot;,&quot;C&quot;,&quot;Beneficiary name18&quot;,&quot;Txt on senders acc&quot;,&quot;&quot;,&quot;Txt for credit acc&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;909175/0&quot;,&quot;AB&quot;
&quot;CMGB&quot;,&quot;1.0&quot;,&quot;95012141352105&quot;,&quot;&quot;,&quot;30128193018492&quot;,&quot;22&quot;,&quot;&quot;,&quot;GBP&quot;,&quot;I&quot;,&quot;Beneficiary name18&quot;,&quot;Txt on senders acc&quot;,&quot;text&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;909175/1&quot;,&quot;AB&quot;
&quot;CMGB&quot;,&quot;1.0&quot;,&quot;95012141352105&quot;,&quot;&quot;,&quot;30128193018492&quot;,&quot;23&quot;,&quot;&quot;,&quot;GBP&quot;,&quot;F&quot;,&quot;Beneficiary name18&quot;,&quot;Txt on senders acc&quot;,&quot;Txt for credit acc&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;909171/0&quot;,&quot;AB&quot;$$);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT 0 1
</code></pre></div>
<div class="highlight"><pre><span></span><code>select regexp_split_to_table(bank_file, chr(10)) from bank_payments;
</code></pre></div>
<div class="highlight"><pre><span></span><code>regexp_split_to_table
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 &quot;CMGB&quot;,&quot;1.0&quot;,&quot;95012141352105&quot;,&quot;999999&quot;,&quot;30128193018492&quot;,&quot;20&quot;,&quot;&quot;,&quot;GBP&quot;,&quot;B&quot;,&quot;Beneficiary name18&quot;,&quot;Txt on senders acc&quot;,&quot;Txt for credit acc&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;909170/1&quot;,&quot;AB&quot;
 &quot;CMGB&quot;,&quot;1.0&quot;,&quot;95012141352105&quot;,&quot;999999&quot;,&quot;95012113864863&quot;,&quot;10.00&quot;,&quot;&quot;,&quot;GBP&quot;,&quot;B&quot;,&quot;Beneficiary name18&quot;,&quot;Txt on senders acc&quot;,&quot;Txt for credit acc&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;Remitters name  18&quot;,&quot;Tech ref for automatic processing5&quot;,&quot;AT&quot;,&quot;/t.x&quot;,
 &quot;CMGB&quot;,&quot;1.0&quot;,&quot;95012141352105&quot;,&quot;&quot;,&quot;30128193018492&quot;,&quot;21&quot;,&quot;&quot;,&quot;GBP&quot;,&quot;C&quot;,&quot;Beneficiary name18&quot;,&quot;Txt on senders acc&quot;,&quot;&quot;,&quot;Txt for credit acc&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;909175/0&quot;,&quot;AB&quot;
 &quot;CMGB&quot;,&quot;1.0&quot;,&quot;95012141352105&quot;,&quot;&quot;,&quot;30128193018492&quot;,&quot;22&quot;,&quot;&quot;,&quot;GBP&quot;,&quot;I&quot;,&quot;Beneficiary name18&quot;,&quot;Txt on senders acc&quot;,&quot;text&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;909175/1&quot;,&quot;AB&quot;
 &quot;CMGB&quot;,&quot;1.0&quot;,&quot;95012141352105&quot;,&quot;&quot;,&quot;30128193018492&quot;,&quot;23&quot;,&quot;&quot;,&quot;GBP&quot;,&quot;F&quot;,&quot;Beneficiary name18&quot;,&quot;Txt on senders acc&quot;,&quot;Txt for credit acc&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;909171/0&quot;,&quot;AB&quot;
</code></pre></div>
<div class="highlight"><pre><span></span><code>select split_part(f.line, &#39;,&#39; , 8) AS &quot;currency&quot;,
                 split_part(f.line, &#39;,&#39; , 5) AS &quot;Account&quot;
from (select regexp_split_to_table(bank_file, chr(10)) AS &quot;line&quot; from bank_payments) AS f;
</code></pre></div>
<div class="highlight"><pre><span></span><code> currency |     Account
----------+------------------
 &quot;GBP&quot;    | &quot;30128193018492&quot;
 &quot;GBP&quot;    | &quot;95012113864863&quot;
 &quot;GBP&quot;    | &quot;30128193018492&quot;
 &quot;GBP&quot;    | &quot;30128193018492&quot;
 &quot;GBP&quot;    | &quot;30128193018492&quot;
</code></pre></div>
<p>如果不再需要表“bank_payments”，请记住将其删除。 </p>
<div class="highlight"><pre><span></span><code>select reverse(translate(replace(lower(i.input), &#39; &#39;, &#39;&#39;),
                         &#39;abcdefghijklmnopqrstuvwxyz&#39;,
                         &#39;A8Cd349h172!mN0pQr$TuVw*yZ&#39;)) AS &quot;simplePWD&quot;
 from (select &#39;type a word here&#39; AS &quot;input&quot;) AS i;
</code></pre></div>
<div class="highlight"><pre><span></span><code>   simplePWD
---------------
 3r3hdr0wA3pyT
</code></pre></div>
<p>前面的TRANSLATE 命令将替换单个命令中的多个不同字符，这可能很有用。在本例中，“a”替换为“A”，“b”替换为数字“8”，依此类推。 </p>
<h5 id="_178"><strong>获取有关文本的信息</strong></h5>
<p>您通常可能想要了解文本的特定属性，而不是格式化或更改文本的内容。以下示例使用命令返回有关文本的信息： </p>
<div class="highlight"><pre><span></span><code>select x.c AS CHAR, ascii(x.c) AS ASCII
          from (select regexp_split_to_table(i.input, &#39;&#39;) AS &quot;c&quot;
from (select &#39;hello&#39; AS input) AS i) AS x;
</code></pre></div>
<div class="highlight"><pre><span></span><code> char | ascii
------+-------
 h    |   104
 e    |   101
 l    |   108
 l    |   108
 o    |   111
</code></pre></div>
<div class="highlight"><pre><span></span><code>select bit_length(&#39;hello&#39;), char_length(&#39;hello&#39;), octet_length(&#39;hello&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code> bit_length | char_length | octet_length
------------+-------------+--------------
       40 |         5 |         5
</code></pre></div>
<div class="highlight"><pre><span></span><code>select array_agg(chr(ascii(x.c))) AS &quot;CHAR&quot;
          from (select regexp_split_to_table(i.input, &#39;&#39;) AS &quot;c&quot;
 from (select &#39;hello&#39; AS input) AS i) AS x;
</code></pre></div>
<div class="highlight"><pre><span></span><code>    CHAR
-------------
 {h,e,l,l,o}
</code></pre></div>
<div class="highlight"><pre><span></span><code>select avg(length(name))::int AS AVG_LENGTH from users;
</code></pre></div>
<div class="highlight"><pre><span></span><code> avg_length
------------
         14
</code></pre></div>
<div class="highlight"><pre><span></span><code>select name from users
          where position(&#39;T&#39; in name) &gt; 2
          and position(&#39;p&#39; in name) = length(name)
order by name;
</code></pre></div>
<div class="highlight"><pre><span></span><code>      name
-----------------
 Cory Tromp
 Demario Tromp
 Demetris Tromp
 Deon Tromp
 Emelia Tromp
 Ivah Tromp
 Jany Torp
 Jared Tromp
 Judd Tromp
 Larue Torp
 Magdalen Torp
 Margarita Tromp
 Marjolaine Torp
 Patrick Torp
 Porter Tromp
 Rebeka Tromp
</code></pre></div>
<div class="highlight"><pre><span></span><code>select name, position(&#39;ar&#39; in name) AS posn, strpos(name, &#39;ar&#39;) as strpos
          from users
          where strpos(name, &#39;ark&#39;) &gt; 0
          order by name desc limit 10;
</code></pre></div>
<div class="highlight"><pre><span></span><code>      name      | posn | strpos
----------------+------+--------
 Yasmin Stark   |   10 |     10
 Veronica Stark |   12 |     12
 Tamia Larkin   |    8 |      8
 Stewart Marks  |    5 |      5
 Ryann Parker   |    8 |      8
 Rudy Larkin    |    7 |      7
 Rodolfo Larkin |   10 |     10
 Novella Marks  |   10 |     10
 Markus Hirthe  |    2 |      2
 Mark Klein     |    2 |      2
</code></pre></div>
<div class="highlight"><pre><span></span><code>select m.name
          from (select to_char(generate_series, &#39;Month&#39;) AS name
                from generate_series(current_date-364, current_date, &#39;1 month&#39;)) AS m
          where starts_with(m.name, &#39;J&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>   name
-----------
 January
 June
 July
</code></pre></div>
<h5 id="_179"><strong>高级应用</strong></h5>
<p>如果您喜欢挑战，下面的示例URL会转义一个字符串。目前的形式还有更多的调整空间，这是留给你做的。 </p>
<div class="highlight"><pre><span></span><code>select string_agg(case
                              when to_hex(ascii(x.arr::text))::text
                                   in(&#39;20&#39;,&#39;23&#39;,&#39;24&#39;,&#39;25&#39;,&#39;26&#39;,&#39;40&#39;,&#39;60&#39;,&#39;2b&#39;,&#39;2c&#39;,&#39;2f&#39;,&#39;3a&#39;,&#39;3b&#39;,&#39;3c&#39;,&#39;3d&#39;,&#39;3e&#39;,&#39;3f&#39;,
                                   &#39;5b&#39;,&#39;5c&#39;,&#39;5d&#39;,&#39;5e&#39;,&#39;7b&#39;,&#39;7c&#39;,&#39;7d&#39;) then &#39;%&#39; || to_hex(ascii(x.arr::text))::text
                              else x.arr
                              end, &#39;&#39;) AS &quot;url_escaped&quot;
           from (select regexp_split_to_table(&#39;www.url.com/form?name=&quot;My name&quot;&amp;dob=&quot;1/1/2000&quot;&amp;email=&quot;hello@example.com&quot;&#39;, &#39;&#39;)) AS x (arr);
</code></pre></div>
<div class="highlight"><pre><span></span><code>                             url_escaped
------------------------------------------------------------------------------------------------
 www.url.com%2fform%3fname%3d&quot;My%20name&quot;%26dob%3d&quot;1%2f1%2f2000&quot;%26email%3d&quot;hello%40example.com&quot;
</code></pre></div>
<h3 id="ttl"><strong>数据过期的TTL</strong></h3>
<h4 id="bcql_3"><strong>BCQL</strong></h4>
<h5 id="_180"><strong>介绍</strong></h5>
<p>BCQL中有两种类型的生存时间（TTL）：</p>
<ul>
<li>未存储在CoreDB中的表级TTL。相反，它作为表模式的一部分存储在mserver系统目录中。</li>
<li>非表级TTL，包括与列的值和行级TTL一起存储的列级TTL。</li>
</ul>
<p>如果列的值处不存在TTL，则表级别的TTL将用作默认值。 </p>
<p>此外，BCQL还区分了使用INSERT和UPDATE语句创建的行。这种差异以及行级TTL是使用所谓的liveness 列来跟踪的，这是一种对您不可见的特殊系统列。它是为插入而添加的，而不是更新，确保即使只有在插入的情况下才删除所有非主键列，也能显示行。 </p>
<h5 id="ttl_1"><strong>表级TTL</strong></h5>
<p>BCQL允许在表级别指定TTL属性，在这种情况下，您不会在CoreDB中按键值存储TTL。相反，TTL在读取和压缩期间被隐式地强制执行，以回收空间。</p>
<p>可以使用default_time_to_live属性定义表级TTL。</p>
<h5 id="ttl_2"><strong>行级TTL</strong></h5>
<p>BCQL允许在每个INSERT和UPDATE操作的级别指定TTL属性。
行级TTL将使整行过期。该值是在使用USING TTL子句执行INSERT或UPDATE操作期间指定的。在这种情况下，TTL被存储为CoreDB值的一部分。</p>
<p>请考虑以下查询： </p>
<div class="highlight"><pre><span></span><code>INSERT INTO pageviews(path) VALUES (&#39;/index&#39;) USING TTL 10;
SELECT * FROM pageviews;
</code></pre></div>
<div class="highlight"><pre><span></span><code> path   | views
--------+-------
 /index |  null

(1 rows)
</code></pre></div>
<p>10秒钟后，该行过期，如下所示： </p>
<div class="highlight"><pre><span></span><code>SELECT * FROM pageviews;
</code></pre></div>
<div class="highlight"><pre><span></span><code> path | views
------+-------

(0 rows)
</code></pre></div>
<h5 id="ttl_3"><strong>列级TTL</strong></h5>
<p>BCQL还允许您设置列级TTL，在这种情况下，TTL存储为CoreDB列值的一部分，您只能在更新列时设置该值，如以下示例所示：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO pageviews(path,views) VALUES (&#39;/index&#39;, 10);

SELECT * FROM pageviews;
</code></pre></div>
<div class="highlight"><pre><span></span><code> path   | views
--------+-------
 /index |  10

(1 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE pageviews USING TTL 10 SET views=10 WHERE path=&#39;/index&#39;;
</code></pre></div>
<p>10秒钟后，查询行将导致视图列返回NULL，但该行仍将存在，如以下示例所示： </p>
<div class="highlight"><pre><span></span><code>SELECT * FROM pageviews;
</code></pre></div>
<div class="highlight"><pre><span></span><code> path   | views
--------+-------
 /index |  null

(1 rows)
</code></pre></div>
<h5 id="ttl_4"><strong>TTL的有效数据过期</strong></h5>
<p>BCQL包括一个文件过期功能，该功能针对主要依赖表级TTL设置（或具有一致的行或列级TTL值）的工作负载进行了优化。此功能减少了CPU使用量和空间放大，特别是对于经常使用表级TTL将数据集保存到特定大小的时间序列工作负载。这是通过按时间将数据组织成文件来实现的，类似于Cassandra的时间窗口压缩策略。</p>
<h6 id="bcql_4">新BCQL数据集配置</h6>
<p>如果为时间序列数据集配置新的BCQL数据库并使用默认生存时间，建议使用以下BM - dbserver标志配置： 
--tile_enable_ttl_file_filter = true
允许直接删除过期文件，而不是在压缩过程中依赖垃圾收集。</p>
<p>--rocksdb_max_file_size_for_compaction = [the amount of data to be deleted at once, in bytes]</p>
<p>此标志的值取决于预期一次删除的数据量。例如，如果表的TTL为90天，则可能需要同时删除三天的数据。在这种情况下，rocksdb_max_file_size_for_compaction应设置为预计在3天内生成的数据量。超过此大小的文件将被排除在正常压缩之外，从而增加CPU。</p>
<p>请注意，在创建的文件数量和读取性能之间存在一些折衷。一个合理的经验法则是配置标志，使30到50个文件存储完整的数据集（例如，90天除以3天就是30个文件）。使用此功能的CPU优势应该足以弥补任何读取性能损失。</p>
<p>--sst_files_soft_limit = [number of expected files at steady state + 20]
--sst_files_hard_limit = [number of expected files at steady state + 40]</p>
<p>这些标志的值取决于预期在稳定状态下保存完整数据集的文件数。如果每个分片的文件数超过其值，这些标志将限制对BCQL的写入。因此，它们的设置方式需要能够适应数据集稳定状态下预期的文件数量。在上面的示例中，30个文件应该包含90天的数据。在这种情况下，sst_files_soft_limit将被设置为50，sst_files_hard_limit将设置为70。</p>
<p>在某些新数据集的情况下，在打开应用程序之前，新数据将被回填到数据库中。此回填的数据可能具有与之相关联的值级别TTL，该值级别明显低于表上的default_time_to_live属性，所需效果是该数据将在表TTL允许的时间之前被删除。默认情况下，此类数据不会提前过期。但是，file_expiration_value_ttl_overrides_table_ttl标志可用于忽略表TTL 并仅根据值TTL 过期。 </p>
<p>警告：
使用file_expiration_value_ttl_overrides_table_ttl标志时，请确保在值级别为TTL 的所有数据（例如，回填的数据）完全过期之前将该标志设置回false。否则可能会导致数据意外丢失。例如，如果default_time_to_live为90天，并且数据已用值级别TTL从1天回填到89天，则重要的是在数据分析后89天内将file_expiration_value_ttl_overrides_table_ttl 标志设置回false，以避免数据丢失。 </p>
<h6 id="bcql_5">现有BCQL数据集配置</h6>
<p>要将现有的BCQL表转换为针对文件过期配置的表，可以使用与上面相同的dbserver标志值。然而，在这种情况下，应预期数据的临时2倍空间放大。这种放大是因为现有的文件结构将把大部分数据保存在一个大文件中，而该文件现在将被排除在压缩之外。因此，该文件将保持不变，直到其内容完全过期，大约是配置文件过期功能后的TTL时间量。
file_expiration_ignore_value_ttl标志可以设置为true以忽略丢失的元数据。这将忽略行和列级别的TTL元数据，使文件完全基于表的default_time_to_live过期。 </p>
<p>警告
为了防止早期数据删除，非常重要的是，在这些情况下，任何具有TTL的表的default_time_to_live 都应设置为大于或等于这些表中包含的最大值级别TTL。建议删除缺少元数据的文件后，将file_expiration_ignore_value_ttl标志设置回false（无需重新启动）。 </p>
<h6 id="_181">最佳做法和故障排除</h6>
<ul>
<li>文件过期功能仅对具有默认生存时间的表启用。即使是在插入时明确设置TTL的应用程序也应该配置默认生存时间。</li>
<li>文件过期功能假设数据是按照其预期过期时间的大致时间顺序到达的。如果不满足这一假设，该功能可以安全使用，但效果会显著降低。</li>
<li>文件以保守的方式过期，只有在其保存的每个数据项完全过期后才会被删除。如果一个文件同时具有表级TTL和列级TTL，则在确定过期时使用两者中较晚的一个。 </li>
<li>如果插入的数据项具有不合理的高TTL（或无TTL），则文件过期功能将停止垃圾收集数据。在这些情况下，可能需要将file_expiration_ignore_value_ttl标志设置为true，这可能会导致不必要的数据丢失。</li>
</ul>
<h5 id="ttl_5"><strong>TTL相关命令和功能</strong></h5>
<p>使用TTL有几种方法： </p>
<ol>
<li>具有default_time_to_live属性的表级TTL。</li>
<li>具有TTL的过期的行。 </li>
<li>TTL函数返回到过期的秒数。</li>
<li>WriteTime函数在插入行或列时返回时间戳</li>
<li>可更新行或列的TTL</li>
<li>bm-dbserver的<a href="#_基于TTL的文件过期标志">基于TTL的文件过期标志</a>配置</li>
</ol>
<h2 id="_182"><strong>最佳实践</strong></h2>
<h3 id="bsql_5"><strong>BSQL</strong></h3>
<h4 id="_183"><strong>使用应用程序模式</strong></h4>
<p>在多个数据中心中运行应用程序并在这些数据中心之间拆分数据，这不是一项微不足道的任务。在设计全局应用程序时，请从一套经过实战测试的设计模式中为您的应用程序选择合适的设计模式，包括全局数据库、多主、备用集群、重复索引等。您也可以根据需要组合这些模式。</p>
<h4 id="_184"><strong>共址</strong></h4>
<p>共址表通过减少小型表在网络上的额外访问来优化数据访问的延迟和性能。此外，它还减少了为每个关系（表、索引等）及其每个节点的存储创建分片的开销。 </p>
<h4 id="_185"><strong>使用覆盖索引加快读取速度</strong></h4>
<p>当查询使用索引更快地查找行时，索引中不存在的列将从原始表中提取。这导致到主表的额外往返行程，导致延迟增加。
使用覆盖索引将查询所需的所有列存储在索引中，索引将标准索引扫描转换为仅索引扫描。</p>
<h4 id="_186"><strong>使用部分索引加快写入速度</strong></h4>
<p>部分索引是建立在表的子集上的索引，只包括满足WHERE子句中指定条件的行。这加快了对表的任何写入并减小了索引的大小，从而提高了使用索引的读取查询的速度。</p>
<h4 id="_187"><strong>具有唯一索引的不同键</strong></h4>
<p>如果需要某些列中的值是唯一的，可以将索引指定为unique。</p>
<p>将唯一索引应用于两列或多列时，这些列中的组合值不能在多行中重复。请注意，因为NULL值被视为不同的值，所以在具有唯一索引的列中可以有多个NULL值。 </p>
<h4 id="_188"><strong>具有服务器级缓存的快序列</strong></h4>
<p>数据库中的序列会自动生成递增的数字，非常适合生成唯一的值，如订单号、用户ID、支票号等。它们可以防止多个应用程序实例同时生成重复的值。但是，在跨区域的数据库上生成序列可能会对应用程序产生延迟影响。
启用服务器级缓存以提高序列的速度，同时避免在应用程序断开连接时丢弃许多序列值。</p>
<h4 id="_189"><strong>快速单行事务</strong></h4>
<p>更新行和在多个语句中获取结果的常见场景可能会导致应用程序和服务器之间的多次往返。在许多情况下，使用RETURNING子句将这些语句重写为单个语句将降低延迟，因为BMDB进行了优化，使单个语句更快。例如，以下语句： </p>
<div class="highlight"><pre><span></span><code>SELECT v FROM txndemo WHERE k=1 FOR UPDATE;
UPDATE txndemo SET v = v + 3 WHERE k=1;
SELECT v FROM txndemo WHERE k=1;
</code></pre></div>
<p>可以如下重写：</p>
<div class="highlight"><pre><span></span><code>UPDATE txndemo SET v = v + 3 WHERE k=1 RETURNING v;
</code></pre></div>
<h4 id="_190"><strong>使用分区快速删除旧数据</strong></h4>
<p>使用表分区可以根据日期将数据拆分为多个分区，这样您就可以通过删除分区来快速删除较旧的数据。</p>
<h4 id="_191"><strong>为分区键使用正确的数据类型</strong></h4>
<p>通常，整数、任意精度的数字、字符串（不是很长的字符串）和时间戳类型是比较的安全选择。
避免以下情况：</p>
<p>浮点数字数据类型-因为它们以二进制浮点格式存储，无法精确表示大多数十进制值，所以可能存在多个内部表示，因此假定相同的值可能不会被视为匹配。</p>
<p>日期、时间和类似的时间戳组件类型，如果它们可以与来自不同时区或一年中不同日期的值进行比较，或者其中一个值来自观测或曾经观测到夏令时的国家或地区</p>
<h4 id="_192"><strong>尽可能使用多行插入</strong></h4>
<p>如果要插入多行，则尽可能将它们批处理在一起会更快。您可以从每个批次128行开始，测试不同的批次大小以找到最佳点。</p>
<p>不要使用多个语句：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO users(name,surname) VALUES (&#39;bill&#39;, &#39;jane&#39;);
INSERT INTO users(name,surname) VALUES (&#39;billy&#39;, &#39;bob&#39;);
INSERT INTO users(name,surname) VALUES (&#39;joey&#39;, &#39;does&#39;);
</code></pre></div>
<p>相反，将值分组为一条语句，如下所示：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO users(name,surname) VALUES (&#39;bill&#39;, &#39;jane&#39;), (&#39;billy&#39;, &#39;bob&#39;), (&#39;joe&#39;, &#39;does&#39;);
</code></pre></div>
<h4 id="upsert"><strong>UPSERT 尽可能的多行</strong></h4>
<p>PostgreSQL和BSQL使您能够使用INSERT ON CONFLICT子句进行upserts 。与多行插入类似，您也可以在单个INSERT ON CONFLICT语句中批处理多个追加，以获得更好的性能。</p>
<p>如果该行已经存在，则可以使用EXCLUDED访问现有值<column_name>。</p>
<p>以下示例创建一个表来跟踪产品数量，并批量增加行数：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE products
  (
     name     TEXT PRIMARY KEY,
     quantity BIGINT DEFAULT 0
  );
---
INSERT INTO products(name, quantity)
VALUES
  (&#39;apples&#39;, 1),
  (&#39;oranges&#39;, 5) ON CONFLICT(name) DO UPDATE
SET
  quantity = products.quantity + excluded.quantity;
---
INSERT INTO products(name, quantity)
VALUES
  (&#39;apples&#39;, 1),
  (&#39;oranges&#39;, 5) ON CONFLICT(name) DO UPDATE
SET
  quantity = products.quantity + excluded.quantity;
---
SELECT * FROM products;
  name   | quantity
---------+----------
 apples  |        2
 oranges |       10
(2 rows)
</code></pre></div>
<p>Load balance and failover using smart drivers</p>
<h4 id="_193"><strong>使用智能驱动程序实现负载平衡和故障切换</strong></h4>
<p>BMDB智能驱动程序提供高级的集群感知负载平衡功能，使您的应用程序只需连接到一个节点即可向集群中的多个节点发送请求。您还可以通过为特定区域分配优先级并确保连接到具有最高优先级的区域来设置回退层次结构，然后在高优先级区域出现故障时回退到具有下一优先级的区域。</p>
<h4 id="_194"><strong>使用连接池扩展应用程序</strong></h4>
<p>使用HikariCP 和Tomcat等流行的池化解决方案以及BMDB智能驱动程序，根据应用程序的扩展需要，使用不同的负载平衡策略设置不同的池。</p>
<h4 id="bsql_6"><strong>使用BSQL连接管理器</strong></h4>
<p>BMDB包括一个内置的连接池程序BSQL connection Manager TP，它提供了与其他外部池解决方案相同的连接池优势，但没有许多限制。由于管理器与产品捆绑在一起，因此可以方便地管理、监视和配置服务器连接。 </p>
<h4 id="_195"><strong>重复使用预编译语句的查询计划</strong></h4>
<p>只要可能，使用预编译语句来确保BMDB可以重复使用相同的查询计划，并消除服务器在每次操作中解析查询的需要。 </p>
<h4 id="_196"><strong>大型扫描和批处理作业</strong></h4>
<p>对于批处理或长时间运行的作业，请使用BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE READ ONLY DEFERRABLE，这些作业需要数据库的一致快照，而不会受到其他事务的干扰。 </p>
<h4 id="jsonb_1"><strong>JSONB数据类型</strong></h4>
<p>使用JSONB数据类型对JSON数据进行建模；也就是说，没有设置模式但具有真正动态模式的数据。
BSQL中的JSONB与PostgreSQL中的JSONB数据类型相同。
您可以使用JSONB对表中不太感兴趣或访问频率较低的列进行分组。
BSQL还支持JSONB表达式索引，该索引可用于加快数据检索，否则将需要扫描JSON条目。</p>
<p>注：
仅在必要时使用JSONB列
一个好的模式设计是只将JSONB用于真正的动态模式。也就是说，不要在放置所有内容的地方创建“data JSONB”列；相反，为动态数据创建一个JSONB列，并为其他数据使用常规列。
与普通列相比，JSONB列的读/写速度较慢。
JSONB值占用更多的空间，因为它们需要将键存储在字符串中，而且维护数据一致性更困难，需要更复杂的查询来获取/设置JSONB的值。
当写入是作为具有每行层次结构的整个文档来完成时，JSONB非常适合。如果有数组，那么选择不是JSONB与列，而是与其他关系表。
对于读取，如果您读取整个文档，并且搜索到的表达式已编入索引，那么JSONB非常适合。
当频繁读取一个属性时，最好将其移动到列中，因为它可以包含在仅索引扫描的索引中。 </p>
<h4 id="_197"><strong>跨分片并行</strong></h4>
<p>对于必须扫描所有分片的大型或批量SELECT或DELETE，您可以通过使用bm_hash_code函数创建仅影响分片特定部分的查询来并行化操作。 </p>
<h4 id="az"><strong>单一可用性区域（AZ）部署</strong></h4>
<p>在单个AZ部署中，需要将bm-dbserver标志--durable_wal_write=true设置为在整个数据中心出现故障（例如电源故障）时不会丢失数据。</p>
<h4 id="_198"><strong>行大小限制</strong></h4>
<p>当您选择整行或多行时，大列会相加。为了保持一致的延迟或性能，建议将大小保持在10MB或以下，最大32MB。</p>
<h4 id="_199"><strong>列大小限制</strong></h4>
<p>为了保持一致的延迟或性能，建议将列的大小设置在2MB或更小的范围内，即使支持单个列或行限制到32MB。</p>
<h4 id="truncatedelete"><strong>TRUNCATE表而不是DELETE</strong></h4>
<p>TRUNCATE 删除存储表的数据库文件，速度比DELETE快得多，DELETE为事务中的每一行插入一个删除标记，这些事务稍后在压缩运行期间从存储中删除。 </p>
<h4 id="_200"><strong>表和索引的数量</strong></h4>
<p>每个表和索引都被拆分为多个分片，每个分片都有开销。</p>
<h4 id="_201"><strong>每台服务器的分片</strong></h4>
<p>每个表和索引都由几个基于--bsql_num_shards_per_dbserver标志的分片组成。
对于带有RF3的集群，1000个分片的raft心跳开销为0.4vCPU（假设心跳间隔为0.5秒），300MB内存，128GB磁盘空间用于WAL（预写日志）。</p>
<p>您需要记住这个数字，这取决于您打算创建的每台服务器的表数和分片数。请注意，每个分片可以包含100GB+的数据。 </p>
<p>您可以尝试以下方法之一来减少分片的数量：</p>
<ul>
<li>使用共址将小表分组为一个分片。</li>
<li>使用--bsql_num_shards_per_dbserver标志减少每个表的分片数量。</li>
<li>创建表时使用SPLIT INTO子句。</li>
<li>从少量分片开始，使用自动拆分分片 </li>
</ul>
<h4 id="cicd"><strong>CI和CD集成测试的设置</strong></h4>
<p>您可以在CI和CD自动测试场景中使用BMDB设置某些标志以提高性能，如下所示： </p>
<ul>
<li>
<p>将标志--fs_data_dirs和--fs_wal_dirs指向RAMDisk目录，以加快DML、DDL、集群创建和集群删除的速度，确保数据不会写入磁盘。 </p>
</li>
<li>
<p>设置标志--bm_num_shards_per_dbserver=1。减少分片数量可以降低创建或删除BSQL表以及写入或读取少量数据时的开销。 </p>
</li>
<li>
<p>在BSQL中使用共址数据库。在创建或删除BSQL表以及写入或读取少量数据时，共址降低了开销。</p>
</li>
<li>
<p>为测试场景设置标志--replication_factor=1，因为不需要保持数据的三向复制（默认）。将其减少到1可减少空间使用并提高性能。 </p>
</li>
<li>
<p>使用TRUNCATE table1,table2,table3..tablen;而不是CREATE TABLE和DROP TABLE。 </p>
</li>
</ul>
<h3 id="bcql_6"><strong>BCQL</strong></h3>
<h4 id="_202"><strong>全局二级索引</strong></h4>
<p>索引使用BMDB的多分片事务功能，具有全局性和强一致性（ACID）。要添加辅助索引，您需要创建启用了事务的表。通过使用INCLUDE 子句，它们也可以用作物化视图。</p>
<h4 id="_203"><strong>唯一索引</strong></h4>
<p>BCQL支持唯一索引。唯一索引不允许在索引列中插入重复值 </p>
<h4 id="_204"><strong>覆盖索引</strong></h4>
<p>当通过辅助索引进行查询时，会查阅原始表以获取索引中未指定的列。这可能导致在主表上进行多次随机读取。</p>
<p>有时，更好的方法是使用include子句包括您正在查询的不属于索引的其他列。当索引中包含其他列时，它们可以用于直接响应索引中的查询，而不必查询表。</p>
<p>这将从主表中（可能的）随机读取变成索引上的过滤。 </p>
<h4 id="update-if-exists-"><strong>使用UPDATE IF EXISTS的原子读-修改-写操作</strong></h4>
<p>对于UPDATE ... IF EXISTS 和INSERT ... IF NOT EXISTS操作，需要原子读-修改-写的情况，Apache Cassandra使用LWT，它需要在对等端之间进行4次往返。由于BMDB的CP（在CAP定理中）设计基于强一致性，这些操作在BMDB中得到了更有效的支持，并且只需要在对等点之间进行一次Raft往返。数字和计数器类型工作相同，不需要单独的“计数器”表。</p>
<h4 id="jsonb_2"><strong>JSONB</strong></h4>
<p>BMDB支持jsonb数据类型来对JSON数据进行建模，JSON数据没有设置模式，可能会经常更改。您可以使用JSONB对表中访问较少的列进行分组。BCQL还支持JSONB表达式索引，这些索引可用于加快数据检索，否则将需要扫描JSON条目。</p>
<p>注：
仅在必要时使用JSONB列
与普通列相比，jsonb列的读写速度较慢。它们还占用了更多的空间，因为它们需要将Key存储在字符串中，并使保持数据一致性变得更加困难。一个好的模式设计是将大多数列保留为常规列或集合，并且只对真正的动态值使用jsonb。不要在存储所有内容的地方创建数据jsonb列；相反，使用dynamic_data jsonb列，其他列为基元列。 </p>
<h4 id="_205"><strong>递增和递减数字类型</strong></h4>
<p>在BMDB中，BCQL扩展了Apache Cassandra，为整数数据类型添加了递增和递减运算符。整数可以设置、插入、递增和递减，而COUNTER只能递增或递减。BMDB在一次往返中实现CAS（比较和设置）操作，而Apache Cassandra需要四次往返。</p>
<h4 id="ttl_6"><strong>使用TTL自动使旧记录过期</strong></h4>
<p>BCQL支持使用TTL功能的数据自动过期。您可以为表/行/列级别的数据设置保留策略，旧数据将自动从数据库中清除。
如果为时间序列数据集或任何具有表级TTL的数据集配置TTL，建议使用TTL特定的配置选项直接使旧文件过期，以提高CPU和空间效率。</p>
<h4 id="bmdb"><strong>使用BMDB驱动程序</strong></h4>
<p>使用BMDB特定的客户端驱动程序，因为它们支持集群和分区，并支持jsonb列。</p>
<h4 id="bcql_7"><strong>利用BCQL客户端中的连接池</strong></h4>
<p>理想情况下，单个客户端（例如，多线程应用程序）应该使用单个集群对象。单个集群对象通常在底层包含可配置数量的到BM - dbserver的连接。通常，每个BM - dbserver 1或2个连接足以服务64-128个应用程序线程。同一连接可以用于多个未完成的请求，也称为多路复用。</p>
<h4 id="_206"><strong>使用预编译语句</strong></h4>
<p>只要可能，使用预编译语句来确保BMDB分区感知驱动程序可以将查询路由到分片leader，以提高吞吐量，并消除服务器在每次操作中解析查询的需要。</p>
<h4 id="_207"><strong>使用批处理提高吞吐量</strong></h4>
<p>使用批处理来编写一组操作，以便在单个RPC调用中发送所有操作，而不是使用多个RPC调用，每个操作一个。与单行操作相比，每个批处理操作具有更高的延迟，但总体吞吐量更高。</p>
<h4 id="_208"><strong>列和行大小</strong></h4>
<p>为了获得一致的延迟/性能，请将列保持在2 MB或更小的范围内。
选择多列或整行时，大列相加。为了获得一致的延迟和性能，请将单个行的大小保持在32 MB或更小的范围内。</p>
<h4 id="_209"><strong>不要使用大型集合</strong></h4>
<p>集合用于存储不希望增长到任意大小的小集合（例如用户的电话号码或地址，而不是帖子或消息）。虽然允许较大的集合，但它们可能会对涉及它们的查询的性能产生重大影响。特别是，某些列表操作（在索引处插入并移除元素）需要先读后写 </p>
<h4 id="_210"><strong>具有许多元素的集合</strong></h4>
<p>集合中的每个元素最终在CoreDB中作为一个单独的键值，增加了每个元素的开销。</p>
<p>如果您的集合是不可变的，或者您完全更新了整个集合，请考虑使用JSONB数据类型。另一种选择是使用ProtoBuf 或FlatBuffers ，并将序列化的数据存储在BLOB列中。 </p>
<h4 id="partition_hash"><strong>将partition_hash用于大型表扫描</strong></h4>
<p>partition_hash函数可用于查询数据的子集，以获得近似的行计数，或将全表操作分解为可以并行运行的较小子任务。</p>
<h4 id="truncatedelete_1"><strong>TRUNCATE表而不是DELETE</strong></h4>
<p>TRUNCATE删除存储表的数据库文件，速度比DELETE快得多，DELETE为事务中的每一行插入一个删除标记，并在压缩运行时将其从存储中删除。 </p>
<h2 id="_211"><strong>驱动与对象关系映射</strong></h2>
<h3 id="_212"><strong>概述</strong></h3>
<p>应用程序使用API客户端库（也称为客户端驱动程序）连接到BMDB并与之交互。由于BMDB BSQL API与PostgreSQL兼容，并且BCQL API植根于Apache Cassandra CQL，因此BMDB支持许多第三方驱动程序。</p>
<p>除了兼容的上游PostgreSQL驱动程序外，BMDB还支持智能驱动程序，它扩展了PostgreSQL的驱动程序，使客户端应用程序能够连接到BMDB集群，而不需要外部负载均衡器。</p>
<p>选择语言：</p>
<ul>
<li>Java</li>
<li>Go</li>
<li>Python</li>
<li>Node.js</li>
<li>C</li>
<li>C++</li>
<li>C#</li>
<li>Ruby</li>
<li>Rust</li>
<li>PHP</li>
<li>Scala</li>
</ul>
<h4 id="_213"><strong>支持的库</strong></h4>
<p>BMDB正式支持以下库。</p>
<h5 id="java_3"><strong>Java</strong></h5>
<table>
<thead>
<tr>
<th></th>
<th>版本</th>
<th>支持等级</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>驱动</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>BMDB JDBC Smart Driver[推荐]</td>
<td>42.3.5-bm-3</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>BMDB JDBC Driver</td>
<td>42.3.4</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>Vert.x Pg Client</td>
<td>4.3.2</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>BMDB Java Driver for BSQL</td>
<td>3.10.3-bm-2</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>BMDB Java Driver for BCQL</td>
<td>4.15.0-bm-1</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>ORMs</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Ebean</td>
<td>13.23.0</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>Hibernate</td>
<td>5.4.19</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>Spring Data BMDB</td>
<td>2.3.0</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>Spring Data JPA</td>
<td>2.6.3</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>MyBatis</td>
<td>3.5.9</td>
<td>全部</td>
<td>CRUD</td>
</tr>
</tbody>
</table>
<h5 id="go_1"><strong>Go</strong></h5>
<table>
<thead>
<tr>
<th></th>
<th>版本</th>
<th>支持等级</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>驱动</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>BMDB PGX Smart Driver[推荐]</td>
<td>v4</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>PGX Driver</td>
<td>v4</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>PQ Driver</td>
<td>v1.10.2</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>BMDB Go Driver for BCQL</td>
<td>3.16.3</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>ORMs</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GORM</td>
<td>1.9.16</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>PG</td>
<td>10</td>
<td>全部</td>
<td>CRUD</td>
</tr>
</tbody>
</table>
<h5 id="python_1"><strong>Python</strong></h5>
<table>
<thead>
<tr>
<th></th>
<th>版本</th>
<th>支持等级</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>驱动</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>BMDB Psycopg2 Smart Driver[推荐]</td>
<td>2.9.3</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>PostgreSQL Psycopg2 Driver</td>
<td>2.9.3</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>aiopg</td>
<td>1.4</td>
<td>全部</td>
<td>Hello World</td>
</tr>
<tr>
<td>BMDB Python Driver for BCQL</td>
<td>3.25.0</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>ORMs</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Django</td>
<td>2.2 or later</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>SQLAlchemy</td>
<td>2.0</td>
<td>全部</td>
<td>CRUD</td>
</tr>
</tbody>
</table>
<h5 id="nodejs_1"><strong>Node.js</strong></h5>
<table>
<thead>
<tr>
<th></th>
<th>版本</th>
<th>支持等级</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>驱动</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>BMDB node-postgres Smart Driver[推荐]</td>
<td>8.7.3-bm-1</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>PostgreSQL node-postgres Driver</td>
<td>8.7.3</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>BMDB Node.js Driver for BCQL</td>
<td>4.0.0</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>ORMs</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Sequelize</td>
<td>6.6.5</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>Prisma</td>
<td>3.14</td>
<td>全部</td>
<td>CRUD</td>
</tr>
</tbody>
</table>
<h5 id="c_3"><strong>C</strong></h5>
<table>
<thead>
<tr>
<th>驱动</th>
<th>版本</th>
<th>支持等级</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>libpq C Driver</td>
<td>5.11</td>
<td>全部</td>
<td>CRUD</td>
</tr>
</tbody>
</table>
<h5 id="c_4"><strong>C++</strong></h5>
<table>
<thead>
<tr>
<th>驱动</th>
<th>版本</th>
<th>支持等级</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>libpqxx C++ Driver</td>
<td></td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>BMDB C++ Driver for BCQL</td>
<td>2.9.0-bm-10</td>
<td>全部</td>
<td>CRUD</td>
</tr>
</tbody>
</table>
<h5 id="c_5"><strong>C#</strong></h5>
<table>
<thead>
<tr>
<th></th>
<th>版本</th>
<th>支持等级</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>驱动</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>BMDB C# Smart Driver for BCQL</td>
<td>8.0.0-bm-1-beta</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>PostgreSQL Npgsql Driver</td>
<td>6.0.3</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>BMDB C# Driver for BCQL</td>
<td>3.6.0</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>ORMs</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Entity Framework</td>
<td>6.0.2</td>
<td>全部</td>
<td>CRUD</td>
</tr>
</tbody>
</table>
<h5 id="ruby_1"><strong>Ruby</strong></h5>
<table>
<thead>
<tr>
<th></th>
<th>版本</th>
<th>支持等级</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>驱动</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pg Gem Driver</td>
<td>1.5.4</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>BMDB Ruby Driver for BCQL</td>
<td>3.2.3.2</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>ORMs</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Active Record</td>
<td>7.0.4</td>
<td>全部</td>
<td>CRUD</td>
</tr>
</tbody>
</table>
<h5 id="rust_1"><strong>Rust</strong></h5>
<table>
<thead>
<tr>
<th></th>
<th>版本</th>
<th>支持等级</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>驱动</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Rust-postgres Driver</td>
<td>v0.19.7-bm-1-betav0.7.10-bm-1-beta</td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>ORMs</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Diesel</td>
<td>1.42</td>
<td>全部</td>
<td>CRUD</td>
</tr>
</tbody>
</table>
<h5 id="php_1"><strong>PHP</strong></h5>
<table>
<thead>
<tr>
<th></th>
<th>版本</th>
<th>支持等级</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>驱动</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>php-pgsql Driver</td>
<td></td>
<td>全部</td>
<td>CRUD</td>
</tr>
<tr>
<td>ORMs</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Laravel</td>
<td>8.40</td>
<td>全部</td>
<td>CRUD</td>
</tr>
</tbody>
</table>
<h5 id="scala"><strong>Scala</strong></h5>
<table>
<thead>
<tr>
<th>驱动</th>
<th>版本</th>
<th>支持等级</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>BMDB Java Driver for BCQL</td>
<td>3.10.3-bm-2</td>
<td>全部</td>
<td>CRUD</td>
</tr>
</tbody>
</table>
<h3 id="bsql_7"><strong>BSQL智能驱动程序</strong></h3>
<p>除了兼容的上游PostgreSQL驱动程序外，BMDB还支持智能驱动程序，它扩展了PostgreSQL的驱动程序，使客户端应用程序能够连接到BMDB集群，而不需要外部负载均衡器。</p>
<p>BMDB为BSQL开发了以下智能驱动程序，可作为Apache 2.0许可证下的开源软件使用。</p>
<table>
<thead>
<tr>
<th>GitLab 项目</th>
<th>基于</th>
<th>文档</th>
</tr>
</thead>
<tbody>
<tr>
<td>BMDB JDBC Driver for Java</td>
<td>PostgreSQL JDBC Driver</td>
<td>Documentation</td>
</tr>
<tr>
<td>BMDB PGX Driver for Go</td>
<td>jackc/pgx</td>
<td>Documentation</td>
</tr>
<tr>
<td>BMDB Psycopg2 Driver for Python</td>
<td>PostgreSQL psycopg2</td>
<td>Documentation</td>
</tr>
<tr>
<td>BMDB node-postgres Driver for Node.js</td>
<td>node-postgres</td>
<td>Documentation</td>
</tr>
<tr>
<td>BMDB Npgsql Driver for C#</td>
<td>PostgreSQL Npgsql Driver</td>
<td>Documentation</td>
</tr>
<tr>
<td>BMDB Rust-postgres Driver</td>
<td>Rust-Postgres Driver</td>
<td>Documentation</td>
</tr>
</tbody>
</table>
<p>所有BMDB 智能驱动程序库都得到了维护，并接受了错误修复、性能增强和安全补丁 。</p>
<h4 id="_214"><strong>主要功能</strong></h4>
<p>BMDB 智能驱动程序具有以下关键功能：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>多个主机</td>
<td>与上游驱动程序（node.js除外）一样，您可以为初始连接指定多个主机，以避免在主不可用的情况下断开连接。</td>
</tr>
<tr>
<td>集群感知</td>
<td>智能驱动程序执行自动统一连接负载平衡在驱动程序建立初始连接后，它从集群中获取可用服务器的列表，并在这些服务器之间均匀分布连接。</td>
</tr>
<tr>
<td>拓扑感知</td>
<td>如果您想限制到特定地理位置的连接以实现更低的延迟，可以针对特定区域、区域和回退区域来平衡连接。</td>
</tr>
<tr>
<td>可配置的刷新间隔</td>
<td>默认情况下，驱动程序每五分钟刷新一次可用服务器的列表。间隔是可配置的（Python除外）。</td>
</tr>
<tr>
<td>连接池</td>
<td>与上游驱动程序一样，智能驱动程序支持流行的连接池解决方案。</td>
</tr>
</tbody>
</table>
<h4 id="_215"><strong>概述</strong></h4>
<p>BMDB 是一个分布式、容错、高可用的数据库，具有较低的读写延迟。BMDB 中的数据在多个节点之间自动进行分片、复制和平衡，这些节点可能位于不同的可用性区域和地区。为了获得更好的性能和容错性，您还可以平衡宇宙中各节点之间的应用程序流量（数据库连接），以避免任何单个节点上的CPU和内存负载过大。 </p>
<p>您可以通过以下方式对应用程序与数据库的连接进行负载平衡：</p>
<ul>
<li>外部负载平衡器</li>
<li>集群感知智能驱动程序</li>
</ul>
<h5 id="_216"><strong>使用外部负载平衡器</strong></h5>
<p>由于BMDB 与PostgreSQL功能兼容，应用程序可以使用许多广泛可用的PostgreSQL客户端驱动程序连接到BMDB 集群。然而，这些驱动程序被设计用于具有单个网络地址的单片数据库。当他们连接到分布式数据库时，他们不明白数据库由多个可以连接的节点组成。绕过这一限制的一种方法是将节点放在一个或多个外部负载均衡器后面。 </p>
<p>然而，这种方法会导致复杂的配置并增加管理开销。例如，数据库集群端点抽象数据库集群中发生的角色更改（主发生选举）和拓扑更改（实例的添加和删除），并且DNS更新不是即时的。此外，它们可能导致数据库事件发生的时间与应用程序注意到和处理该事件的时间之间的延迟稍长。 </p>
<p><img alt="" src="./media/chapter3/18.png" /></p>
<h5 id="_217"><strong>智能驱动的优势</strong></h5>
<p>智能客户端驱动程序允许应用程序通过连接到分布式SQL数据库集群中的任何节点来获得更好的性能和容错性，而不需要外部负载均衡器。</p>
<p>智能驱动程序经过优化，可与分布式SQL数据库一起使用，并且具有集群意识和拓扑意识；驱动跟踪集群的成员及其位置。在集群中添加或删除节点时，驱动程序会更新其成员身份和拓扑信息。驱动程序从元数据表中读取数据库集群拓扑，并在不依赖高级集群端点的情况下将新连接路由到各个实例端点。智能驱动程序还能够在可用的BM -dbservers上实现只读连接的负载平衡。 </p>
<p>与PostgreSQL驱动程序相比，智能驱动程序具有以下优势：</p>
<ul>
<li>通过消除负载平衡器简化操作。因为PostgreSQL驱动程序是为单节点数据库设计的，所以它们不会跟踪分布式数据库集群的节点或它们的位置。客户依赖外部负载均衡器将请求路由到数据库集群中的不同节点，这增加了操作开销。智能驱动程序消除了对外部负载平衡器的需求。 </li>
<li>通过连接到附近的节点来提高性能。客户端应用程序可以识别并连接到离它们最近的数据库集群节点，以实现更低的延迟。 </li>
<li>通过更好的故障处理提高可用性。如果数据库节点由于网络问题或服务器故障而无法访问，则客户端可以连接到群集中的其他节点。客户端上的重试逻辑可以使故障对最终用户透明。</li>
</ul>
<h4 id="bmdb_1"><strong>使用BMDB智能驱动程序</strong></h4>
<p>开发人员可以在两种配置中使用智能驱动程序连接负载平衡：</p>
<ul>
<li>集群感知，使用负载平衡连接参数</li>
<li>拓扑感知，使用拓扑密钥连接参数</li>
</ul>
<p>在这两种情况下，驱动程序都会尝试连接到可用服务器组中负载最小的服务器。对于拓扑感知负载平衡，此组由使用拓扑密钥连接参数指定的地理位置确定。 </p>
<h5 id="_218"><strong>支持集群的连接负载平衡</strong></h5>
<p>使用集群感知（也称为统一）连接负载平衡，无论连接的位置如何，都可以在集群中的所有BM dbserver上均匀分布连接。</p>
<p>例如，如果一个客户端应用程序创建了一百个到由十个节点组成的BMDB的连接，那么驱动程序会创建到每个节点的十个连接。如果连接的数量不能完全被服务器的数量整除，那么一些服务器可能比其他服务器少一个或多一个连接。这是负载的客户端视图，因此如果其他客户端应用程序未使用智能驱动程序，则服务器可能无法很好地平衡。</p>
<p>连接的工作原理如下：</p>
<ul>
<li>驱动程序与URL或连接字符串中指定的主机进行初始连接。如果与主的连接失败，可以指定多个主机作为备份。</li>
<li>驱动程序使用bm_servers（）函数获取有关节点的信息。默认情况下，此列表每5分钟刷新一次，当收到新的连接请求时会检查此时间。</li>
<li>然后，驱动程序在将连接返回到应用程序之前连接到负载最少的节点。</li>
</ul>
<h6 id="_219">启用负载平衡</h6>
<p>若要启用集群感知负载平衡，请在连接URL或连接字符串（DSN样式）中将负载平衡连接参数设置为true。</p>
<p>例如，使用Go智能驱动程序，可以按如下方式启用负载平衡：</p>
<div class="highlight"><pre><span></span><code>&quot;postgres://username:password@host:2521/database_name?load_balance=true&quot;
</code></pre></div>
<p>通过在URL中指定此参数，驱动程序从BMDB中可用的给定端点获取并维护节点列表，并在这些节点之间平均分配连接。</p>
<p>在与节点建立连接后，如果该节点失败，则不重试请求。</p>
<p>为了使连接均匀分布，应用程序必须使用相同的连接URL来创建所需的每个连接。</p>
<p>请注意，为了实现负载平衡，节点必须是可访问的。例如，如果集群有多个区域部署在不同的VPC中，您的应用程序将需要访问所有区域，通常是通过对等 </p>
<h6 id="_220">服务器刷新间隔</h6>
<p>要更改驱动程序获取更新的服务器列表的频率，请指定服务器刷新间隔参数。</p>
<p>例如，使用Go智能驱动程序，可以将间隔更改为四分钟（以秒为单位），如下所示： </p>
<div class="highlight"><pre><span></span><code>&quot;postgres://username:password@host:2521/database_name?load_balance=true&amp;bm_servers_refresh_interval=240&quot;
</code></pre></div>
<p>（请注意，目前BMDB Python智能驱动程序中不提供此功能。）</p>
<h5 id="_221"><strong>拓扑感知连接负载平衡</strong></h5>
<p>对于跨多个区域的数据库部署，在所有数据库节点上均匀分布请求可能不是最佳的。使用拓扑感知的连接负载平衡，您可以针对指定地理位置的节点。然后，驱动程序将连接均匀地分布在指定位置的节点之间。这在以下情况下是有益的： </p>
<ul>
<li>用于连接到地理位置最近的区域和区域，以获得更低的延迟和更少的网络跳数。通常，您会将应用程序放在区域中。拓扑平衡允许您仅针对承载应用程序的区域。</li>
<li>已指定了首选位置，所有分片Leader都位于该位置。在这种情况下，为了获得最佳性能，您希望应用程序以首选位置为目标。 </li>
</ul>
<p>您还可以指定回退位置以及尝试回退的顺序。当主位置中没有可用的节点时，驱动程序会尝试按指定的顺序连接到回退位置中的节点。例如，通过这种方式，您可以将目标锁定在地理位置最近的下一个位置，以防第一个位置不可用。
如果不提供回退位置，当主位置中没有可用的节点时，驱动程序将回退到整个集群中的节点 </p>
<h6 id="_222">拓扑键</h6>
<p>您可以将位置指定为拓扑键，其值格式为cloud.region.zone。可以将多个区域指定为逗号分隔的值。您可以在连接URL或连接字符串（DSN样式）中指定拓扑键。您仍然需要将负载平衡指定为true，以启用拓扑感知连接负载平衡。 </p>
<p>例如，使用Go驱动程序，可以按如下方式设置参数： </p>
<div class="highlight"><pre><span></span><code>&quot;postgres://username:password@localhost:2521/database_name?load_balance=true&amp;topology_keys=cloud1.region1.zone1,cloud1.region1.zone2&quot;
</code></pre></div>
<p>使用星号（*）指定区域中的所有分区。（不能对区域或云执行此操作。）例如： </p>
<div class="highlight"><pre><span></span><code>&quot;postgres://username:password@localhost:2521/database_name?load_balance=true&amp;topology_keys=cloud1.region1.*&quot;
</code></pre></div>
<h6 id="_223">回退拓扑密钥</h6>
<p>若要在某个位置不可用时指定回退位置，请在拓扑键中添加：n，其中n是表示优先级的整数。以下示例将zone1设置为拓扑关键字，如果无法到达zone1，则将zon2和zon3设置为回退（按顺序）：</p>
<div class="highlight"><pre><span></span><code>&quot;postgres://username:password@localhost:2521/database_name?load_balance=true&amp;topology_keys=cloud1.region1.zone1:1,cloud1.region1.zone2:2,cloud1.region1.zone3:3&quot;
</code></pre></div>
<p>不指定优先级等同于将优先级设置为1。
如果没有可用的服务器，则请求可能会失败返回 </p>
<h5 id="_224"><strong>连接池</strong></h5>
<p>智能驱动程序可以使用Hikari和Tomcat等流行的池化解决方案进行配置。如果需要，可以使用不同的负载平衡策略配置不同的池。例如，应用程序可以为一个区域及其可用性区域配置一个具有拓扑意识的池，并将另一个池配置为与完全不同的区域通信。</p>
<p>适当的连接超时取决于应用程序的特定要求。除了通常的注意事项外，由于BMDB 是分布式的，您还希望连接尽快移动到已恢复或新添加的节点。</p>
<p>当连接达到超时时，池会重新建立到连接数量最少的节点的新连接，该节点很可能是新节点。将超时设置得太长，可能无法最大限度地利用新节点。例如，10分钟的超时意味着新节点可能在长达10分钟的时间内无法接收连接。（该节点仍将用于BM dbserver操作，但不用于新的客户端连接。）但是，将超时设置得太短会由于第一次连接延迟过高而降低总体延迟性能。使用不同的超时值进行实验，并监视应用程序和数据库的性能以确定最佳值。 </p>
<h3 id="java_4"><strong>Java</strong></h3>
<h4 id="_225"><strong>概述</strong></h4>
<h5 id="_226"><strong>支持的项目</strong></h5>
<p>以下项目可用于使用BMDB  BSQL和BCQL API实现Java应用程序。</p>
<table>
<thead>
<tr>
<th>驱动</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>BMDB JDBC Driver [推荐]</td>
<td>42.3.5-bm-1</td>
</tr>
<tr>
<td>PostgreSQL JDBC Driver</td>
<td>42.3.4</td>
</tr>
<tr>
<td>Vert.x Pg Client</td>
<td>4.3.2</td>
</tr>
<tr>
<td>BMDB BSQL(3.10) Driver</td>
<td>3.10.3-bm-2</td>
</tr>
<tr>
<td>BMDB BCQL (4.15) Driver</td>
<td>4.15.0-bm-1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>项目</th>
<th>APP 示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hibernate ORM</td>
<td>Hibernate ORM APP</td>
</tr>
<tr>
<td>Spring Data JPA</td>
<td>Spring Data JPA APP</td>
</tr>
<tr>
<td>Ebean ORM</td>
<td>Ebean ORM APP</td>
</tr>
<tr>
<td>MyBatis ORM</td>
<td>MyBatis ORM APP</td>
</tr>
<tr>
<td>Spring Data BMDB</td>
<td>Spring Data BMDB Sample App</td>
</tr>
</tbody>
</table>
<h5 id="_227"><strong>先决条件</strong></h5>
<p>要为BMDB 开发Java驱动程序应用程序，您需要以下内容： </p>
<ul>
<li>
<p>Java开发工具包（JDK）
  安装JDK 8或更高版本。Linux和macOS的JDK安装程序可以从Oracle、Adoptium（OpenJDK）或Azul Systems（OpenJDK）下载。macOS上的Homebrew用户可以使用brew install openjdk进行安装。 </p>
</li>
<li>
<p>创建Java项目
  您可以使用Maven或Gradle软件项目管理工具创建Java项目。为了便于使用，可以使用集成开发环境（IDE），如IntelliJ IDEA或Eclipse IDE来配置Maven或Gradle来构建和运行您的项目。</p>
</li>
<li>
<p>创建一个名为“DriverDemo”的项目。 </p>
</li>
</ul>
<div class="highlight"><pre><span></span><code>mvn archetype:generate \
     -DgroupId=com.bigmath\
     -DartifactId=DriverDemo \
     -DarchetypeArtifactId=maven-archetype-quickstart \
     -DinteractiveMode=false

cd DriverDemo
</code></pre></div>
<p>2.在文本编辑器中打开pom.xml文件，并在<url>元素下方添加以下内容。</p>
<div class="highlight"><pre><span></span><code>&lt;properties&gt;
  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
</code></pre></div>
<p>如果您使用的是Java 11，它应该是：</p>
<div class="highlight"><pre><span></span><code> &lt;properties&gt;
   &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
   &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
 &lt;/properties&gt;
</code></pre></div>
<ul>
<li>BMDB集群
  按照Install BMDB中的步骤设置一个独立的BMDB集群。 </li>
</ul>
<h4 id="_228"><strong>应用连接</strong></h4>
<h5 id="bsql_8"><strong>BSQL</strong></h5>
<h6 id="bmdb-jdbc">BMDB JDBC智能驱动程序</h6>
<p>BMDB JDBC智能驱动程序是一个基于PostgreSQL JDBC驱动程序的BSQL JDBC驱动程序，具有额外的连接负载平衡功能。 
对于Java应用程序，JDBC驱动程序通过Java平台上可用的标准JDBC应用程序接口（API）提供数据库连接。 
3.7.3.2.1.1.1. <em>CRUD操作</em>
以下部分演示如何执行Java应用程序开发所需的常见任务。
若要开始构建应用程序，请确保满足先决条件。
<strong>步骤1</strong>：设置客户端依赖关系
Maven依赖:
如果您正在使用Maven，请将以下内容添加到项目的pom.xml中。 </p>
<div class="highlight"><pre><span></span><code>&lt;dependency&gt;
  &lt;groupId&gt;com.bigmath&lt;/groupId&gt;
  &lt;artifactId&gt;jdbc-bigmathdb&lt;/artifactId&gt;
  &lt;version&gt;42.3.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- https://mvnrepository.com/artifact/com.zaxxer/HikariCP --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;
  &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;
  &lt;version&gt;4.0.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></div>
<p>使用mvn install安装添加的依赖项</p>
<p>Gradle依赖:
如果您正在使用Gradle，请将以下依赖项添加到您的build.gradle 文件中： </p>
<div class="highlight"><pre><span></span><code>implementation &#39;com.bigmath:jdbc-bigmathdb:42.3.0&#39;
implementation &#39;com.zaxxer:HikariCP:4.0.3&#39;
</code></pre></div>
<p><strong>步骤2</strong>：设置数据库连接
设置完依赖关系后，使用BMDB JDBC驱动程序实现Java客户端应用程序，以连接到BMDB 数据库集群并对样本数据运行查询。 </p>
<p>设置驱动程序属性以配置用于连接到集群的凭据和SSL证书。Java应用程序可以使用Java.sql.DriverManager类连接到BMDB 数据库并查询该数据库。使用BMDB 数据库所需的所有JDBC接口都是java.sql.*包的一部分。</p>
<p>使用DriverManager.getConnection方法获取BMDB 数据库的连接对象，然后可以使用该连接对象对数据库执行DDL和DML操作。 </p>
<p>下表描述了连接所需的连接参数，包括用于统一和拓扑负载平衡的智能驱动程序参数。 </p>
<table>
<thead>
<tr>
<th>JDBC 参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>hostname</td>
<td>BMDB实例的主机名，也可输入多个地址。</td>
<td>localhost</td>
</tr>
<tr>
<td>port</td>
<td>BSQL监听端口</td>
<td>2521</td>
</tr>
<tr>
<td>database</td>
<td>数据库名</td>
<td>bigmath</td>
</tr>
<tr>
<td>user</td>
<td>连接到数据库的用户</td>
<td>bigmath</td>
</tr>
<tr>
<td>password</td>
<td>用户密码</td>
<td>bigmath</td>
</tr>
<tr>
<td>load-balance</td>
<td>负载平衡</td>
<td>默认为上游驱动程序行为，除非设置为“true”</td>
</tr>
<tr>
<td>bm-servers-refresh-interval</td>
<td>如果load_balance为true，则刷新服务器列表的间隔（以秒为单位）</td>
<td>300</td>
</tr>
<tr>
<td>topology-keys</td>
<td>拓扑感知负载平衡</td>
<td>如果load-balance为true，则使用统一负载平衡，除非设置为cloud.region.zone形式的逗号分隔地理位置。</td>
</tr>
</tbody>
</table>
<p>以下是用于连接到BMDB的JDBC URL示例：</p>
<div class="highlight"><pre><span></span><code>jdbc:bigmathdb://hostname:port/database?user=bigmath&amp;password=bigmath&amp;load-balance=true&amp; \
    bm-servers-refresh-interval=240&amp; \
    topology-keys=cloud.region.zone1,cloud.region.zone2
</code></pre></div>
<p>在驱动程序建立初始连接后，它会从集群中获取可用服务器的列表，并在这些服务器之间负载平衡后续的连接请求。</p>
<p>使用多个地址：
您可以在连接字符串中指定多个主机，以便在初始连接期间提供备用选项，以防主地址出现故障。 
使用逗号分隔地址，如下所示：</p>
<div class="highlight"><pre><span></span><code>jdbc:bigmathdb://hostname1:port,hostname2:port,hostname3:port/database?user=bigmath&amp;password=bigmath&amp;load-balance=true&amp; \
    topology-keys=cloud.region.zone1,cloud.region.zone2
</code></pre></div>
<p>主机仅在初始连接尝试期间使用。如果驱动程序连接时第一台主机关闭，则驱动程序会尝试连接到字符串中的下一台主机，依此类推。 </p>
<p>使用SSL：
下表介绍了使用SSL进行连接所需的连接参数。</p>
<table>
<thead>
<tr>
<th>JDBC 参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>ssl</td>
<td>启用SSL客户端连接</td>
<td>false</td>
</tr>
<tr>
<td>sslmode</td>
<td>SSL 模式</td>
<td>require</td>
</tr>
<tr>
<td>sslrootcert</td>
<td>计算机上根证书的路径</td>
<td>~/.postgresql/</td>
</tr>
</tbody>
</table>
<p>以下是用于连接到启用SSL加密的BMDB集群的JDBC URL示例。</p>
<div class="highlight"><pre><span></span><code>jdbc:bigmathdb://hostname:port/database?user=bigmath&amp;password=bigmath&amp;load-balance=true&amp; \
    ssl=true&amp;sslmode=verify-full&amp;sslrootcert=~/.postgresql/root.crt
</code></pre></div>
<p>第3步：应用写入 
在项目的基本包目录中创建一个名为QuickStartApp.Java的新Java类，如下所示： </p>
<div class="highlight"><pre><span></span><code>touch ./src/main/java/com/bigmath/QuickStartApp.java
</code></pre></div>
<p>复制以下代码以设置BMDB 表，并从Java客户端查询表内容。如果需要，请确保将连接字符串bmurl替换为集群的凭据和SSL证书。</p>
<div class="highlight"><pre><span></span><code>package com.bigmath;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.ResultSet;

public class QuickStartApp {
  public static void main(String[] args) throws ClassNotFoundException, SQLException {
    Class.forName(&quot;com.bigmath.Driver&quot;);
    String bmurl = &quot;jdbc:bigmathdb://127.0.0.1:2521/bigmath?user=bigmath&amp;password=bigmath&amp;load-balance=true&quot;;
    Connection conn = DriverManager.getConnection(bmurl);
    Statement stmt = conn.createStatement();
    try {
        System.out.println(&quot;Connected to the BMDB Cluster successfully.&quot;);
        stmt.execute(&quot;DROP TABLE IF EXISTS employee&quot;);
        stmt.execute(&quot;CREATE TABLE IF NOT EXISTS employee&quot; +
                    &quot;  (id int primary key, name varchar, age int, language text)&quot;);
        System.out.println(&quot;Created table employee&quot;);

        String insertStr = &quot;INSERT INTO employee VALUES (1, &#39;John&#39;, 35, &#39;Java&#39;)&quot;;
        stmt.execute(insertStr);
        System.out.println(&quot;EXEC: &quot; + insertStr);

        ResultSet rs = stmt.executeQuery(&quot;select * from employee&quot;);
        while (rs.next()) {
          System.out.println(String.format(&quot;Query returned: name = %s, age = %s, language = %s&quot;,
                                          rs.getString(2), rs.getString(3), rs.getString(4)));
        }
    } catch (SQLException e) {
      System.err.println(e.getMessage());
    }
  }
}
</code></pre></div>
<p>3.7.3.2.1.1.2. <strong><em>运行应用</em></strong>
使用以下命令运行项目QuickStartApp.java： </p>
<div class="highlight"><pre><span></span><code>mvn -q package exec:java -DskipTests -Dexec.mainClass=com.bigmath.QuickStartApp
</code></pre></div>
<p>您应该看到类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>Connected to the BMDB Cluster successfully.
Created table employee
Inserted data: INSERT INTO employee (id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;Java&#39;);
Query returned: name=John, age=35, language: Java
</code></pre></div>
<p>如果没有收到输出或出现错误，请检查连接字符串中的参数</p>
<h6 id="postgresql-jdbc">PostgreSQL JDBC驱动</h6>
<p>PostgreSQL JDBC驱动程序是PostgreSQL的官方JDBC驱动程序，可用于连接BMDB BSQL。BSQL与PostgreSQL JDBC驱动程序完全兼容，并允许Java程序员连接到BMDB 数据库，使用标准JDBC API执行DML和DDL。</p>
<p>对于Java应用程序，JDBC驱动程序通过Java平台上可用的标准JDBC应用程序接口（API）提供数据库连接。</p>
<p>3.7.3.2.1.2.1. <em>CRUD操作</em>
以下部分演示如何执行Java应用程序开发所需的常见任务。</p>
<p>若要开始构建应用程序，请确保满足先决条件。</p>
<p>如果使用SSL构建应用程序，请执行以下附加步骤：</p>
<p>根据您选择的创建本地群集的平台设置SSL/TLS。要使用SSL/TLS在Minikube中设置集群，请参阅Kubernetes中集群的SSL证书。要为本地集群设置SSL证书，请参阅为Java应用程序设置SSL证书。</p>
<p>安装OpenSSL 1.1.1或更高版本。 </p>
<p><strong>步骤1</strong>：设置客户端依赖关系</p>
<p>PostgreSQL JDBC驱动程序作为maven 依赖项提供，您可以通过将以下依赖项添加到Java项目来下载驱动程序。</p>
<p>Maven依赖
如果您正在使用Maven，请将以下内容添加到项目的pom.xml中。 </p>
<div class="highlight"><pre><span></span><code>&lt;!-- https://mvnrepository.com/artifact/org.postgresql/postgresql --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
  &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
  &lt;version&gt;42.2.14&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></div>
<p>Gradle依赖
如果您正在使用Gradle，请将以下依赖项添加到您的build.Gradle文件中： </p>
<div class="highlight"><pre><span></span><code>// https://mvnrepository.com/artifact/org.postgresql/postgresql
implementation &#39;org.postgresql:postgresql:42.2.14&#39;
</code></pre></div>
<p>使用mvn-Install安装添加的依赖项。</p>
<p><strong>步骤2</strong>：设置数据库连接 </p>
<p>设置完依赖关系后，实现一个Java客户端应用程序，该应用程序使用PostgreSQL JDBC驱动程序连接到BMDB集群，并对样本数据运行查询。</p>
<p>Java应用程序可以使用Java.sql连接并查询BMDB数据库。DriverManager类。java.sql.*包包括使用BMDB所需的所有JDBC接口。</p>
<p>使用DriverManager.getConnection方法为BMDB数据库创建一个连接对象。这可以用于对数据库执行DDL和DML。 </p>
<table>
<thead>
<tr>
<th>JDBC 参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>hostname</td>
<td>BMDB 实例的主机名</td>
<td>localhost</td>
</tr>
<tr>
<td>port</td>
<td>BSQL 监听的端口</td>
<td>2521</td>
</tr>
<tr>
<td>database</td>
<td>数据库名</td>
<td>bigmath</td>
</tr>
<tr>
<td>user</td>
<td>连接数据库的用户名</td>
<td>bigmath</td>
</tr>
<tr>
<td>password</td>
<td>连接数据库的用户密码</td>
<td>bigmath</td>
</tr>
</tbody>
</table>
<p>以下是用于连接到BMDB的PostgreSQL JDBC URL格式： </p>
<div class="highlight"><pre><span></span><code>jdbc:postgresql://hostname:port/database
</code></pre></div>
<p>以下是用于连接到BMDB的JDBC URL示例： </p>
<div class="highlight"><pre><span></span><code>String bmurl = &quot;jdbc:postgresql://localhost:2521/bigmath&quot;;
Connection conn = DriverManager.getConnection(bmurl , &quot;bigmath&quot;, &quot;bigmath&quot;);
</code></pre></div>
<p><strong>使用SSL</strong></p>
<p>下表介绍了使用SSL进行连接所需的连接参数。 </p>
<table>
<thead>
<tr>
<th>JDBC 参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>ssl</td>
<td>启用SSL客户端连接</td>
<td>false</td>
</tr>
<tr>
<td>sslmode</td>
<td>SSL 模式</td>
<td>require</td>
</tr>
<tr>
<td>sslrootcert</td>
<td>计算机上根证书的路径</td>
<td>~/.postgresql/</td>
</tr>
</tbody>
</table>
<p>以下是用于连接到启用SSL加密的BMDB集群的JDBC URL示例。 </p>
<div class="highlight"><pre><span></span><code>String bmurl = &quot;jdbc:postgresql://hostname:port/database?user=bigmath&amp;password=bigmath&amp;ssl=true&amp;sslmode=verify-full&amp;sslrootcert=~/.postgresql/root.crt&quot;;
Connection conn = DriverManager.getConnection(bmurl );
</code></pre></div>
<p><strong>步骤3</strong>：写应用 
在项目的基本包目录中创建一个名为QuickStartApp.Java的新Java类，如下所示： </p>
<div class="highlight"><pre><span></span><code>touch ./src/main/java/com/bigmath/QuickStartApp.java
</code></pre></div>
<p>复制以下代码以设置BMDB表，并从Java客户端查询表内容。如果需要，请确保将连接字符串bmurl替换为集群的凭据和SSL证书。 </p>
<div class="highlight"><pre><span></span><code>package com.bigmath;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.ResultSet;

public class QuickStartApp {
  public static void main(String[] args) throws ClassNotFoundException, SQLException {
    Class.forName(&quot;org.postgresql.Driver&quot;);
    String bmurl= &quot;jdbc:postgresql://localhost:2521/bigmath&quot;;
    Connection conn = DriverManager.getConnection(bmurl, &quot;bigmath&quot;, &quot;bigmath&quot;);
    Statement stmt = conn.createStatement();
    try {
        System.out.println(&quot;Connected to the PostgreSQL server successfully.&quot;);
        stmt.execute(&quot;DROP TABLE IF EXISTS employee&quot;);
        stmt.execute(&quot;CREATE TABLE IF NOT EXISTS employee&quot; +
                    &quot;  (id int primary key, name varchar, age int, language text)&quot;);
        System.out.println(&quot;Created table employee&quot;);

        String insertStr = &quot;INSERT INTO employee VALUES (1, &#39;John&#39;, 35, &#39;Java&#39;)&quot;;
        stmt.execute(insertStr);
        System.out.println(&quot;EXEC: &quot; + insertStr);

        ResultSet rs = stmt.executeQuery(&quot;select * from employee&quot;);
        while (rs.next()) {
          System.out.println(String.format(&quot;Query returned: name = %s, age = %s, language = %s&quot;,
                                          rs.getString(2), rs.getString(3), rs.getString(4)));
        }
    } catch (SQLException e) {
      System.err.println(e.getMessage());
    }
  }
}
</code></pre></div>
<p>如果使用SSL，请使用以下代码替换连接字符串bmurl： </p>
<div class="highlight"><pre><span></span><code>String bmurl= &quot;jdbc:postgresql://localhost:2521/bigmath?ssl=true&amp;sslmode=require&amp;sslcert=src/main/resources/ssl/bigmathdb.crt.der&amp;sslkey=src/main/resources/ssl/bigmathdb.key.pk8&quot;;
Connection conn = DriverManager.getConnection(bmurl, &quot;bigmath&quot;, &quot;bigmath&quot;);
</code></pre></div>
<p>使用以下命令运行项目QuickStartApp.java：</p>
<div class="highlight"><pre><span></span><code>mvn -q package exec:java -DskipTests -Dexec.mainClass=com.bigmath.QuickStartApp
</code></pre></div>
<p>您应该看到类似于以下内容的输出： </p>
<div class="highlight"><pre><span></span><code>Connected to the BMDB Cluster successfully.
Created table employee
Inserted data: INSERT INTO employee (id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;Java&#39;);
Query returned: name=John, age=35, language: Java
</code></pre></div>
<p>如果没有输出或出现错误，请验证Java类中的连接字符串是否具有正确的参数。</p>
<h6 id="vertx-pg-client">Vert.x Pg Client</h6>
<p>PostgreSQL的Vert.xPg 客户端驱动程序是一个响应式和非阻塞式客户端，用于通过单线程API处理数据库连接。因为BMDB与PostgreSQL兼容，所以Vert.x PG 客户端与BMDB数据库完全兼容。
3.7.3.2.1.3.1. <em>CRUD操作</em></p>
<p>以下部分演示如何使用Vert.x PG 客户端执行Java应用程序开发所需的常见任务。
若要开始构建应用程序，请确保满足先决条件。 </p>
<p><strong>步骤1</strong>：设置客户端依赖关系 </p>
<p>Maven依赖</p>
<p>如果您正在使用Maven，请将以下内容添加到项目的pom.xml中。 </p>
<div class="highlight"><pre><span></span><code> &lt;dependency&gt;
     &lt;groupId&gt;io.vertx&lt;/groupId&gt;
     &lt;artifactId&gt;vertx-pg-client&lt;/artifactId&gt;
     &lt;version&gt;4.3.2&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre></div>
<p>使用mvn install安装依赖项。</p>
<p><strong>步骤2</strong>：设置数据库连接 </p>
<p>设置依赖关系后，实现一个Java客户端应用程序，该应用程序使用Vert.x Pg客户端连接到BMDB集群，并对样本数据运行查询。
Java应用程序可以使用PgPool类连接到BMDB数据库并查询该数据库。io.vertx.*包包括使用BMDB所需的所有接口。
使用PgPool.getConnection方法为BMDB数据库创建连接对象。这可以用于对数据库执行DDL和DML。
下表介绍了连接所需的连接参数。 </p>
<table>
<thead>
<tr>
<th>PG客户端参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>setHost</td>
<td>BMDB 实例的主机名</td>
<td>localhost</td>
</tr>
<tr>
<td>setPort</td>
<td>BSQL 监听的端口</td>
<td>2521</td>
</tr>
<tr>
<td>setDatabase</td>
<td>数据库名</td>
<td>bigmath</td>
</tr>
<tr>
<td>setUser</td>
<td>连接数据库的用户名</td>
<td>bigmath</td>
</tr>
<tr>
<td>setPassword</td>
<td>连接数据库的用户密码</td>
<td>bigmath</td>
</tr>
</tbody>
</table>
<p><strong>步骤3</strong>：写应用</p>
<p>在项目的基本包目录中创建一个名为QuickStartApp.Java的新Java类，如下所示： </p>
<div class="highlight"><pre><span></span><code>touch ./src/main/java/com/bigmath/QuickStartApp.java
</code></pre></div>
<p>复制以下代码以设置BMDB表，并从Java客户端查询表内容 </p>
<div class="highlight"><pre><span></span><code>package com.bigmath;

import io.vertx.core.Promise;
import io.vertx.core.Vertx;
import io.vertx.pgclient.PgConnectOptions;
import io.vertx.pgclient.PgPool;
import io.vertx.sqlclient.PoolOptions;
import io.vertx.sqlclient.Tuple;
import io.vertx.sqlclient.Row;
import io.vertx.sqlclient.RowStream;

public class vertxPgExample {
    public static void main(String[] args) {

        PgConnectOptions options = new PgConnectOptions()
            .setPort(2521)
            .setHost(&quot;127.0.0.1&quot;)
            .setDatabase(&quot;bigmath&quot;)
            .setUser(&quot;bigmath&quot;)
            .setPassword(&quot;bigmath&quot;);

        Vertx vertx = Vertx.vertx();
        // creating the PgPool with configuration as option and maxsize 10.
        PgPool pool = PgPool.pool(vertx, options, new PoolOptions().setMaxSize(10));

        //getting a connection from the pool and running the example on that
        pool.getConnection().compose(connection -&gt; {
            Promise&lt;Void&gt; promise = Promise.promise();
            // create a test table
            connection.query(&quot;create table test(id int primary key, name text)&quot;).execute()
                    .compose(v -&gt; {
                        // insert some test data
                        return connection.query(&quot;insert into test values (1, &#39;Hello&#39;), (2, &#39;World&#39;), (3,&#39;Example&#39;), (4, &#39;Vertx&#39;), (5, &#39;bigmath&#39;)&quot;).execute();
                    })
                    .compose(v -&gt; {
                        // prepare the query
                        return connection.prepare(&quot;select * from test order by id&quot;);
                    })
                    .map(preparedStatement -&gt; {
                        // create a stream for the prepared statement
                        return preparedStatement.createStream(50, Tuple.tuple());
                    })
                    .onComplete(ar -&gt; {
                        if (ar.succeeded()) {
                            RowStream&lt;Row&gt; stream = ar.result();
                            stream
                                    .exceptionHandler(promise::fail)
                                    .endHandler(promise::complete)
                                    .handler(row -&gt; System.out.println(row.toJson())); // Printing each row as JSON
                        } else {
                            promise.fail(ar.cause());
                        }
                    });
            return promise.future().onComplete(v -&gt; {
                // close the connection
                connection.close();
            });
        }).onComplete(ar -&gt; {
            if (ar.succeeded()) {
                System.out.println(&quot;Example ran successfully!&quot;);
            } else {
                ar.cause().printStackTrace();
            }
        });

    }
}
</code></pre></div>
<p>使用以下命令运行项目QuickStartApp.java： </p>
<div class="highlight"><pre><span></span><code>mvn -q package exec:java -DskipTests -Dexec.mainClass=com.bigmath.QuickStartApp
</code></pre></div>
<p>您应该看到类似于以下内容的输出： </p>
<div class="highlight"><pre><span></span><code>{&quot;id&quot;:1,&quot;name&quot;:&quot;Hello&quot;}
{&quot;id&quot;:2,&quot;name&quot;:&quot;World&quot;}
{&quot;id&quot;:3,&quot;name&quot;:&quot;Example&quot;}
{&quot;id&quot;:4,&quot;name&quot;:&quot;Vertx&quot;}
{&quot;id&quot;:5,&quot;name&quot;:&quot;bigmath&quot;}
Example ran successfully!
</code></pre></div>
<p>3.7.3.2.1.3.2. <em>限制</em>
BMDB目前不支持Vert.x PG客户端的Pub/sub。当向BMDB添加LISTEN/NOTIFY支持时，此限制将消失。 </p>
<h5 id="bcql_8"><strong>BCQL</strong></h5>
<h6 id="bmdb-java-310">BMDB Java驱动 (3.10)</h6>
<p>3.7.3.2.2.1.1. <em>Maven</em></p>
<p>要使用bigmath Java 驱动构建示例Java应用程序，请将以下Maven依赖项添加到应用程序中： </p>
<div class="highlight"><pre><span></span><code>   &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.bigmath &lt;/groupId&gt;
      &lt;artifactId&gt;cassandra-driver-core&lt;/artifactId&gt;
      &lt;version&gt;3.10.3-bm-2&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</code></pre></div>
<p>3.7.3.2.2.1.2. <em>创建示例Java应用程序</em></p>
<p>3.7.3.2.2.1.2.1. 先决条件
本教程假设您具备：</p>
<ul>
<li>安装了BMDB，创建了一个universe，并能够使用BCQL shell与之交互。如果没有，请按照“快速入门”中的步骤进行操作。</li>
<li>已安装JDK 1.8或更高版本。</li>
<li>已安装Maven 3.3或更高版本 </li>
</ul>
<p>3.7.3.2.2.1.2.2. 创建项目的POM
创建一个名为pom.xml的文件，然后将以下内容复制到其中。项目对象模型（POM）包括构建项目所需的配置信息 </p>
<div class="highlight"><pre><span></span><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;project
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;
  xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;com.bigmath.sample.apps&lt;/groupId&gt;
  &lt;artifactId&gt;hello-world&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.bigmath&lt;/groupId&gt;
      &lt;artifactId&gt;cassandra-driver-core&lt;/artifactId&gt;
      &lt;version&gt;3.8.0-bm-5&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.1&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;copy-dependencies&lt;/id&gt;
            &lt;phase&gt;prepare-package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;copy-dependencies&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;outputDirectory&gt;${project.build.directory}/lib&lt;/outputDirectory&gt;
              &lt;overWriteReleases&gt;true&lt;/overWriteReleases&gt;
              &lt;overWriteSnapshots&gt;true&lt;/overWriteSnapshots&gt;
              &lt;overWriteIfNewer&gt;true&lt;/overWriteIfNewer&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</code></pre></div>
<p>3.7.3.2.2.1.2.3. 编写一个示例Java应用程序</p>
<p>按照Maven的预期创建适当的目录结构。</p>
<div class="highlight"><pre><span></span><code>mkdir -p src/main/java/com/bigmath/sample/apps
</code></pre></div>
<p>将以下内容复制到src/main/java.com/bigmath/sample/apps/cqlshHelloWorld.java文件中。</p>
<div class="highlight"><pre><span></span><code>package com.bigmath.sample.apps;

import java.util.List;
import com.datastax.driver.core.Cluster;
import com.datastax.driver.core.ResultSet;
import com.datastax.driver.core.Row;
import com.datastax.driver.core.Session;

public class cqlshHelloWorld {
  public static void main(String[] args) {
    try {
      // Create a Cassandra client.
      Cluster cluster = Cluster.builder()
                               .addContactPoint(&quot;127.0.0.1&quot;)
                               .build();
      Session session = cluster.connect();

      // Create keyspace &#39;bmdemo&#39; if it does not exist.
      String createKeyspace = &quot;CREATE KEYSPACE IF NOT EXISTS bmdemo;&quot;;
      ResultSet createKeyspaceResult = session.execute(createKeyspace);
      System.out.println(&quot;Created keyspace bmdemo&quot;);

      // Create table &#39;employee&#39; if it does not exist.
      String createTable = &quot;CREATE TABLE IF NOT EXISTS bmdemo.employee (id int PRIMARY KEY, &quot; +
                                                                       &quot;name varchar, &quot; +
                                                                       &quot;age int, &quot; +
                                                                       &quot;language varchar);&quot;;
      ResultSet createResult = session.execute(createTable);
      System.out.println(&quot;Created table employee&quot;);

      // Insert a row.
      String insert = &quot;INSERT INTO bmdemo.employee (id, name, age, language)&quot; +
                                          &quot; VALUES (1, &#39;John&#39;, 35, &#39;Java&#39;);&quot;;
      ResultSet insertResult = session.execute(insert);
      System.out.println(&quot;Inserted data: &quot; + insert);

      // Query the row and print out the result.
      String select = &quot;SELECT name, age, language FROM bmdemo.employee WHERE id = 1;&quot;;
      ResultSet selectResult = session.execute(select);
      List&lt;Row&gt; rows = selectResult.all();
      String name = rows.get(0).getString(0);
      int age = rows.get(0).getInt(1);
      String language = rows.get(0).getString(2);
      System.out.println(&quot;Query returned &quot; + rows.size() + &quot; row: &quot; +
                         &quot;name=&quot; + name + &quot;, age=&quot; + age + &quot;, language: &quot; + language);

      // Close the client.
      session.close();
      cluster.close();
    } catch (Exception e) {
        System.err.println(&quot;Error: &quot; + e.getMessage());
    }
  }
}
</code></pre></div>
<p>3.7.3.2.2.1.2.4. 构建项目</p>
<p>要构建项目，请运行以下mvn package命令。 </p>
<div class="highlight"><pre><span></span><code>mvn package
</code></pre></div>
<p>您应该会看到一条BUILD SUCCESS消息。
3.7.3.2.2.1.2.5. 运行应用程序
要使用该应用程序，请运行以下命令。 </p>
<div class="highlight"><pre><span></span><code>java -cp &quot;target/hello-world-1.0.jar:target/lib/*&quot; com.bigmath.sample.apps.cqlshHelloWorld
</code></pre></div>
<p>您应该看到以下内容作为输出。 </p>
<div class="highlight"><pre><span></span><code>Created keyspace bmdemo
Created table employee
Inserted data: INSERT INTO bmdemo.employee (id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;Java&#39;);
Query returned 1 row: name=John, age=35, language: Java
</code></pre></div>
<h6 id="bmdb-java-415">BMDB Java驱动 (4.15)</h6>
<p>3.7.3.2.2.2.1. <em>Maven</em>
要使用Bigmath Java驱动构建示例Java应用程序，请将以下Maven依赖项添加到应用程序中：</p>
<div class="highlight"><pre><span></span><code> &lt;dependency&gt;
   &lt;groupId&gt;com.bigmath&lt;/groupId&gt;
   &lt;artifactId&gt;java-driver-core&lt;/artifactId&gt;
   &lt;version&gt;4.15.0-bm-1&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre></div>
<p>3.7.3.2.2.2.2. <em>创建示例Java应用程序</em></p>
<p>3.7.3.2.2.2.2.1. 先决条件</p>
<p>本教程假设您具备：</p>
<ul>
<li>安装了BMDB，创建了一个universe，并能够使用BCQL shell与之交互。如果没有，请按照“快速入门”中的步骤进行操作。</li>
<li>已安装JDK 1.8或更高版本。</li>
<li>已安装Maven 3.3或更高版本。 </li>
</ul>
<p>3.7.3.2.2.2.2.2. 创建项目的POM
创建一个名为pom.xml的文件，然后将以下内容复制到其中。项目对象模型（POM）包括构建项目所需的配置信息 </p>
<div class="highlight"><pre><span></span><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;project
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;
  xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;com.bigmath.sample.apps&lt;/groupId&gt;
  &lt;artifactId&gt;hello-world&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;properties&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.bigmath&lt;/groupId&gt;
      &lt;artifactId&gt;java-driver-core&lt;/artifactId&gt;
      &lt;version&gt;4.15.0-bm-1&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.1&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;copy-dependencies&lt;/id&gt;
            &lt;phase&gt;prepare-package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;copy-dependencies&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;outputDirectory&gt;${project.build.directory}/lib&lt;/outputDirectory&gt;
              &lt;overWriteReleases&gt;true&lt;/overWriteReleases&gt;
              &lt;overWriteSnapshots&gt;true&lt;/overWriteSnapshots&gt;
              &lt;overWriteIfNewer&gt;true&lt;/overWriteIfNewer&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</code></pre></div>
<p>3.7.3.2.2.2.2.3. 编写一个示例Java应用程序</p>
<p>按照Maven的预期创建适当的目录结构。 </p>
<div class="highlight"><pre><span></span><code>mkdir -p src/main/java/com/bigmath/sample/apps
</code></pre></div>
<p>将以下内容复制到src/main/java.com/bigmath/sample/apps/cqlshHelloWorld.java文件中。 </p>
<div class="highlight"><pre><span></span><code>package com.bigmath.sample.apps;
import java.net.InetSocketAddress;
import java.util.List;
import com.datastax.oss.driver.api.core.CqlSession;
import com.datastax.oss.driver.api.core.cql.ResultSet;
import com.datastax.oss.driver.api.core.cql.Row;
public class cqlshHelloWorld {
    public static void main(String[] args) {
        try {
            // Create a BCQL client.
            CqlSession session = CqlSession
                .builder()
                .addContactPoint(new InetSocketAddress(&quot;127.0.0.1&quot;, 9542))
                .withLocalDatacenter(&quot;datacenter1&quot;)
                .build();
            // Create keyspace &#39;bmdemo&#39; if it does not exist.
            String createKeyspace = &quot;CREATE KEYSPACE IF NOT EXISTS bmdemo;&quot;;
            session.execute(createKeyspace);
            System.out.println(&quot;Created keyspace bmdemo&quot;);
            // Create table &#39;employee&#39;, if it does not exist.
            String createTable = &quot;CREATE TABLE IF NOT EXISTS bmdemo.employee (id int PRIMARY KEY, &quot; + &quot;name varchar, &quot; +
                &quot;age int, &quot; + &quot;language varchar);&quot;;
            session.execute(createTable);
            System.out.println(&quot;Created table employee&quot;);
            // Insert a row.
            String insert = &quot;INSERT INTO bmdemo.employee (id, name, age, language)&quot; +
                &quot; VALUES (1, &#39;John&#39;, 35, &#39;Java&#39;);&quot;;
            session.execute(insert);
            System.out.println(&quot;Inserted data: &quot; + insert);
            // Query the row and print out the result.
            String select = &quot;SELECT name, age, language FROM bmdemo.employee WHERE id = 1;&quot;;
            ResultSet selectResult = session.execute(select);
            List &lt; Row &gt; rows = selectResult.all();
            String name = rows.get(0).getString(0);
            int age = rows.get(0).getInt(1);
            String language = rows.get(0).getString(2);
            System.out.println(&quot;Query returned &quot; + rows.size() + &quot; row: &quot; + &quot;name=&quot; + name + &quot;, age=&quot; + age +
                &quot;, language: &quot; + language);
            // Close the client.
            session.close();
        } catch (Exception e) {
            System.err.println(&quot;Error: &quot; + e.getMessage());
        }
    }
}
</code></pre></div>
<p>3.7.3.2.2.2.2.4. 构建项目</p>
<p>要构建项目，请运行以下mvn package命令。 </p>
<div class="highlight"><pre><span></span><code>mvn package
</code></pre></div>
<p>您应该会看到一条BUILD SUCCESS消息。</p>
<p>3.7.3.2.2.2.2.5. 运行应用程序
要使用该应用程序，请运行以下命令。 </p>
<div class="highlight"><pre><span></span><code>java -cp &quot;target/hello-world-1.0.jar:target/lib/*&quot; com.bigmath.sample.apps.cqlshHelloWorld
</code></pre></div>
<p>您应该看到以下内容作为输出。 </p>
<div class="highlight"><pre><span></span><code>Created keyspace bmdemo
Created table employee
Inserted data: INSERT INTO bmdemo.employee (id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;Java&#39;);
Query returned 1 row: name=John, age=35, language: Java
</code></pre></div>
<h4 id="orm"><strong>使用ORM</strong></h4>
<h5 id="hibernate-orm"><strong>Hibernate ORM</strong></h5>
<p>Hibernate ORM是一个用于Java应用程序的对象/关系映射（ORM）框架。Hibernate ORM关注关系数据库的数据持久性，并使开发人员能够编写的应用数据超过应用程序的生命周期。</p>
<p>BMDB BSQL API与Hibernate ORM完全兼容，用于Java应用程序中的数据持久性。此页面提供了开始使用Hibernate ORM连接BMDB 的详细信息</p>
<h6 id="crud">CRUD操作</h6>
<p>了解如何使用Java ORM示例应用程序页面中的步骤建立与BMDB 数据库的连接，并开始基本的CRUD操作。</p>
<p>以下部分演示如何使用Hibernate ORM执行Java应用程序开发所需的常见任务。</p>
<p><strong>步骤1</strong>：添加Hibernate ORM依赖项</p>
<p>如果您正在使用Maven，请将以下内容添加到项目的pom.xml文件中。</p>
<div class="highlight"><pre><span></span><code>&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
    &lt;version&gt;5.4.19.Final&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
    &lt;version&gt;3.5.6-Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></div>
<p>如果您使用的是Gradle，请将以下依赖项添加到您的build.gradle文件中： </p>
<div class="highlight"><pre><span></span><code>implementation &#39;org.hibernate:hibernate-core:5.4.19.Final&#39;
implementation &#39;org.hibernate:hibernate-annotations:3.5.6-Final&#39;
</code></pre></div>
<p>注意：Hibernate ORM可以与BMDB JDBC驱动程序和PostgreSQL JDBC驱动程序一起使用。</p>
<p><strong>步骤2</strong>：为BMDB 实现ORM映射</p>
<p>在项目的基本包目录中创建一个名为Employee.java的文件，并为包含以下字段、setters和getters的类添加以下代码。</p>
<div class="highlight"><pre><span></span><code>@Entity
@Table(name = &quot;employee&quot;)
public class Employee {

  @Id
  Integer id;
  String name;
  Integer age;
  String language;

  // Setters and Getters

}
</code></pre></div>
<p><strong>步骤3</strong>：为Employee对象创建一个DAO对象</p>
<p>在基本包目录中创建一个数据访问对象（DAO）EmployeeDAO.java。DAO用于实现域对象Employee.java的基本CRUD操作。将以下示例代码复制到您的项目中。 </p>
<div class="highlight"><pre><span></span><code>import org.hibernate.Session;

public class EmployeeDAO {

  Session hibernateSession;

  public EmployeeDAO (Session session) {
    hibernateSession = session;
  }

  public void save(final Employee employeeEntity) {
    Transaction transaction = session.beginTransaction();
        try {
            session.save(entity);
            transaction.commit();
        } catch(RuntimeException rte) {
            transaction.rollback();
        }
        session.close();
  }

  public Optional&lt;Employee&gt; findById(final Integer id) {
    return Optional.ofNullable(session.get(Emplyee.class, id));
  }
}
</code></pre></div>
<p><strong>步骤4</strong>：配置Hibernate属性</p>
<p>将hibernate配置文件hibernate.cfg.xml添加到resources目录中，并将以下内容复制到该文件中。 </p>
<div class="highlight"><pre><span></span><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE hibernate-configuration SYSTEM
        &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;

&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.PostgreSQLDialect&lt;/property&gt;
        &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.bigmathdb.Driver&lt;/property&gt;
        &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:bigmathdb://localhost:2521/bigmath&lt;/property&gt;
        &lt;property name=&quot;hibernate.connection.username&quot;&gt;bigmath&lt;/property&gt;
        &lt;property name=&quot;hibernate.connection.password&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt;
        &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;
        &lt;property name=&quot;generate-ddl&quot;&gt;true&lt;/property&gt;
        &lt;property name=&quot;hibernate.ddl-auto&quot;&gt;generate&lt;/property&gt;
        &lt;property name=&quot;hibernate.connection.isolation&quot;&gt;8&lt;/property&gt;
        &lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt;
        &lt;property name=&quot;javax.persistence.create-database-schemas&quot;&gt;true&lt;/property&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;
</code></pre></div>
<p>Hibernate配置文件提供了为BMDB配置Hibernate ORM所需的一组通用属性。 </p>
<table>
<thead>
<tr>
<th>Hibernate参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>hibernate.dialect</td>
<td>Dialect 用于生成针对特定数据库优化的SQL</td>
<td>org.hibernate.dialect.PostgreSQLDialect</td>
</tr>
<tr>
<td>hibernate.connection.driver_class</td>
<td>JDBC驱动名</td>
<td>com.bigmathdb.Driver</td>
</tr>
<tr>
<td>hibernate.connection.url</td>
<td>JDBC连接URL</td>
<td>jdbc:bigmathdb://localhost:2521/bigmath</td>
</tr>
<tr>
<td>hibernate.connection.username</td>
<td>用户名</td>
<td>bigmath</td>
</tr>
<tr>
<td>hibernate.connection.password</td>
<td>密码</td>
<td>bigmath</td>
</tr>
<tr>
<td>hibernate.hbm2ddl.auto</td>
<td>自动模式生成的行为</td>
<td>none</td>
</tr>
</tbody>
</table>
<p>Hibernate提供了一个详尽的属性列表，用于配置ORM支持的不同功能。更多的细节请参考相关的Hibernate文档。</p>
<p><strong>步骤5</strong>：添加对象关系映射</p>
<p>除了用于配置Hibernate ORM的属性外，Hibernate.cfg.xml还用于使用＜mapping＞标记指定域对象映射。</p>
<p>在hibernate.cfg.xml中添加Employee对象的映射</p>
<div class="highlight"><pre><span></span><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE hibernate-configuration SYSTEM
        &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;

&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        ...
        &lt;mapping class=&quot;com.bigmath.hibernatedemo.model.Employee&quot;/&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;
</code></pre></div>
<p>步骤6：使用Hibernate ORM查询BMDB集群</p>
<p>在项目的基本包目录中创建一个名为QuickStartOrmApp.Java的新Java类。复制以下示例代码，使用Hibernate ORM从Java客户端查询表内容。如果需要，请确保将连接字符串bmurl中的参数替换为集群凭据和SSL证书。</p>
<div class="highlight"><pre><span></span><code>import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.Scanner;
import org.hibernate.Session;
import org.hibernate.SessionFactory;

public class QuickStartOrmApp {


  public static void main(String[] args) throws ClassNotFoundException, SQLException {

    SessionFactory sessionFactory = HibernateUtil.getSessionFactory();
    Session session = sessionFactory.openSession();

    try {
          System.out.println(&quot;Connected to the BMDB Cluster successfully.&quot;);
          EmplyeeDAO employeeDAO = new EmployeeDAO(session);
          // Save an employee
          employeeDAO.save(new Employee());

          // Find the emplyee
          Employee employee = employeeDAO.findByID(1);
          System.out.println(&quot;Query Returned:&quot; + employee.toString());
        }
    } catch (SQLException e) {
      System.err.println(e.getMessage());
    }
  }
}
</code></pre></div>
<p>当您运行项目时，QuickStartApp.java应该输出如下内容：</p>
<div class="highlight"><pre><span></span><code>Connected to the BMDB Cluster successfully.
Created table employee
Inserted data: INSERT INTO employee (id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;Java&#39;);
Query returned: name=John, age=35, language: Java
</code></pre></div>
<h5 id="ebean-orm"><strong>Ebean ORM</strong></h5>
<p>Ebean ORM是一个用于Java应用程序的对象关系映射（ORM）工具。Ebean API使用无会话设计，消除了分离/附着Bean的概念，以及与冲洗和清除相关的困难。
BMDB BSQL API与Ebean ORM完全兼容，用于Java应用程序中的数据持久性。此页面提供了开始使用Ebean ORM连接BMDB 的详细信息。</p>
<p>Ebean ORM可以与BMDB  JDBC驱动程序和PostgreSQL JDBC驱动程序一起使用。</p>
<h6 id="crud_1">CRUD操作</h6>
<p>了解如何使用Java ORM示例应用程序页面中的步骤建立与BMDB数据库的连接，并开始基本的CRUD操作。</p>
<p>以下部分演示如何使用Ebean ORM执行基于Java的Play Framework应用程序开发所需的常见任务。
3.7.3.3.2.1.1. <em>创建一个新的基于Java的Play Framework项目</em></p>
<p>在开始之前，请确保已安装Java Development Kit（JDK）1.8.0或更高版本以及sbt 1.2.8或更高版本。 
1.创建一个新的Java Play项目：</p>
<div class="highlight"><pre><span></span><code>sbt new playframework/play-java-seed.g8
</code></pre></div>
<p>2.出现提示时，提供以下项目信息： </p>
<div class="highlight"><pre><span></span><code>    Name: demo-ebean
    Organization: com.demo-ebean
    play_version: 2.8.11
    scala_version: 2.12.8
</code></pre></div>
<p>3.创建项目后，转到项目目录： </p>
<div class="highlight"><pre><span></span><code>cd demo-ebean
</code></pre></div>
<p>4.将项目目录下build.properties中的sbt版本更改为以下版本： </p>
<div class="highlight"><pre><span></span><code>sbt.version=1.2.8
</code></pre></div>
<p>5.下载依赖项：</p>
<div class="highlight"><pre><span></span><code>sbt compile
</code></pre></div>
<p>您的新Java Play项目的文件夹结构已准备就绪。</p>
<p>3.7.3.3.2.1.2. <em>添加依赖项</em></p>
<p>要开始在应用程序中使用Ebean，请执行以下操作：</p>
<p>1.在项目/plugins.sbt文件中添加以下插件：</p>
<div class="highlight"><pre><span></span><code>addSbtPlugin(&quot;com.typesafe.sbt&quot; % &quot;sbt-play-ebean&quot; % &quot;5.0.0&quot;)
</code></pre></div>
<p>2.通过在conf/application.conf文件中添加以下配置，连接到BMDB：</p>
<div class="highlight"><pre><span></span><code>db.default.driver=com.bigmath.Driver
db.default.url=&quot;jdbc:bigmathdb://127.0.0.1:2521/bsql_ebean?load-balance=true&quot;
db.default.username=bigmath
db.default.password=&quot;&quot;
play.evolutions {
default=true
db.default.enabled = true
autoApply=true
}
</code></pre></div>
<p>3.将BMDB JDBC驱动程序的以下依赖项添加到build.sbt文件中。 </p>
<div class="highlight"><pre><span></span><code>libraryDependencies += &quot;com.bigmath&quot; % &quot;jdbc-bigmathdb&quot; % &quot;42.3.3&quot;
</code></pre></div>
<p>4.按如下方式添加PlayEbean，启用build.sbt文件中的PlayEbeam插件： </p>
<div class="highlight"><pre><span></span><code>lazy val root = (project in file(&quot;.&quot;)).enablePlugins(PlayJava,PlayEbean)
</code></pre></div>
<p>5.如果您的默认端口已经在使用，或者您想更改端口，请通过将.settings（PlayKeys.playDefaultPort:=8080）添加到build.sbt文件来修改设置，如下所示： </p>
<div class="highlight"><pre><span></span><code>lazy val root = (project in file(&quot;.&quot;)).enablePlugins(PlayJava,PlayEbean).settings(PlayKeys.playDefaultPort := 8080)
</code></pre></div>
<p>3.7.3.3.2.1.3. <em>通过</em><em>BMDB</em><em>使用Ebean ORM构建REST API</em></p>
<p>示例应用程序有一个Employee模型，用于检索员工信息，包括名字、姓氏和电子邮件。EmployeeController使用Rest API在数据库中存储和检索新员工信息。 </p>
<ol>
<li>
<p>在项目的应用程序目录中创建一个模型文件夹，以存储您创建的实体。</p>
</li>
<li>
<p>要将此目录用作默认的Ebean类包，请在conf/application.conf文件的末尾添加以下代码： </p>
</li>
</ol>
<div class="highlight"><pre><span></span><code>ebean.default=&quot;models.*&quot;
</code></pre></div>
<ol>
<li>在app/models/中创建Employee.java文件。这是employee的类定义。将以下代码添加到文件中： </li>
</ol>
<div class="highlight"><pre><span></span><code>package models;

import io.ebean.Finder;
import io.ebean.Model;
import javax.persistence.*;
import javax.validation.constraints.NotBlank;

@Entity
@Table(name = &quot;employee&quot;)
public class Employee extends Model{

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  @Column(columnDefinition = &quot;serial&quot;)
  public Long empId;

  @NotBlank
  public String firstName;

  @NotBlank
  public String lastName;

  @Column(name = &quot;emp_email&quot;)
  public String email;

  public static final Finder&lt;Long, Employee&gt; find = new Finder&lt;&gt;(Employee.class);

  @Override
  public String toString(){
      return &quot;{&#39;empId&#39; = &#39;&quot;+empId+&quot;&#39;, firstName =&#39;&quot;+firstName+&quot;&#39;, &#39;lastName&#39;      =&#39;&quot;+lastName+&quot;&#39;, &#39;email&#39; =&#39;&quot;+email+&quot;&#39; }&quot;;

  }
}
</code></pre></div>
<ol>
<li>在app/controllers/目录中创建EmployeeController.java文件。此文件控制员工数据流。它包含所有API调用的方法，包括添加员工和检索员工信息。使用@Transactional注释可自动管理该API中的事务。将以下代码添加到文件中：</li>
</ol>
<div class="highlight"><pre><span></span><code>package controllers;
import models.Employee;
import javax.persistence.*;
import play.libs.Json;
import play.db.ebean.Transactional;
import play.mvc.*;
import java.util.ArrayList;
import java.util.List;
public class EmployeeController extends Controller{
  @Transactional
  public Result AddEmployee(Http.Request request){
      Employee employee=Json.fromJson(request.body().asJson(),Employee.class);
      employee.save();
      return ok(Json.toJson(employee.toString()));
  }
  public Result GetAllEmployees(){
      List &lt;Employee&gt; employees = Employee.find.all();
      List&lt;String&gt; employeesList = new ArrayList&lt;String&gt;();
      for(int index=0;index&lt;employees.size();index++){
          employeesList.add(employees.get(index).toString());
      }
      return ok(Json.toJson(employeesList));
  }
}
</code></pre></div>
<ol>
<li>将/employees端点的GET和POST API请求添加到conf/routes文件中。这定义了接收请求所需的方法：</li>
</ol>
<div class="highlight"><pre><span></span><code>GET      /employees            controllers.EmployeeController.GetAllEmployees
POST     /employees            controllers.EmployeeController.AddEmployee(request: Request)
</code></pre></div>
<p>3.7.3.3.2.1.4. <em>编译并运行项目</em></p>
<p>要运行应用程序并插入新行，请执行以下步骤：</p>
<ol>
<li>使用以下命令在项目目录中编译并运行服务器：</li>
</ol>
<div class="highlight"><pre><span></span><code>sbt compile
</code></pre></div>
<div class="highlight"><pre><span></span><code>sbt run
</code></pre></div>
<ol>
<li>使用POST请求创建employee ：</li>
</ol>
<div class="highlight"><pre><span></span><code>curl --data &#39;{ &quot;firstName&quot; : &quot;John&quot;, &quot;lastName&quot; : &quot;Smith&quot;, &quot;email&quot;:&quot;jsmith@xyz.com&quot; }&#39; \
-v -X POST -H &#39;Content-Type:application/json&#39; http://localhost:8080/employees
</code></pre></div>
<ol>
<li>使用Get请求获取employees 的详细信息： </li>
</ol>
<div class="highlight"><pre><span></span><code>curl  -v -X GET http://localhost:8080/employees
</code></pre></div>
<p>输出应如下所示： </p>
<div class="highlight"><pre><span></span><code>[&quot;{&#39;empId&#39; = &#39;1&#39;, firstName =&#39;John&#39;, &#39;lastName&#39; =&#39;Smith&#39;, &#39;email&#39; =&#39;jsmith@xyz.com&#39; }&quot;]
</code></pre></div>
<h5 id="mybatis"><strong>MyBatis</strong></h5>
<p>MyBatis是一个Java持久性框架，支持自定义SQL、存储过程和高级对象映射。MyBatis无需编写本地JDBC代码、手动结果映射和设置DB参数。MyBatis为检索数据库记录的查询到对象映射提供了简单的基于XML和注释的支持。</p>
<p>BMDB BSQL API与MyBatis完全兼容，用于Java应用程序中的数据持久性。本页提供了使用MyBatis构建Java应用程序以连接到BMDB 数据库的详细信息。</p>
<h6 id="crud_2">CRUD操作</h6>
<p>学习使用MyBatis框架连接到BMDB 数据库所需的基本步骤。完整的工作应用程序记录在Java ORM示例应用程序页面上。</p>
<p>以下部分演示如何使用MyBatis持久性框架执行Java应用程序开发所需的常见任务。</p>
<p><strong>步骤1</strong>：将MyBatis依赖项添加到Java项目中</p>
<p>在项目的pom.xml文件中使用以下Maven依赖项： </p>
<div class="highlight"><pre><span></span><code>&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.5.9&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></div>
<p>如果您使用的是Gradle，请将以下依赖项添加到您的build.gradle 文件中：</p>
<div class="highlight"><pre><span></span><code>// https://mvnrepository.com/artifact/org.mybatis/mybatis
implementation &#39;org.mybatis:mybatis:3.5.9&#39;
</code></pre></div>
<p>注意：MyBatis持久性框架可以与BMDB JDBC驱动程序和PostgreSQL JDBC驱动程序一起使用。</p>
<p><strong>步骤2</strong>：实现实体对象</p>
<p>在java项目的基本包中创建一个文件User.java。添加User对象的属性以及相关的setters 和getters。 </p>
<div class="highlight"><pre><span></span><code>public class User {

    private Long userId;

    private String firstName;

    private String lastName;

    private String email;

    // getters and setters
}
</code></pre></div>
<p><strong>步骤3</strong>：为User对象创建MyBatis数据映射器</p>
<p>MyBatis框架使用数据映射器。数据映射器XML文件用于配置将针对实体执行的DML。通常，映射器用于定义插入、更新、删除和选择语句，它们被称为映射的SQL语句。</p>
<p>在Java项目的resources文件夹中创建XML文件UserMapper.XML，并复制以下内容： </p>
<div class="highlight"><pre><span></span><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;

&lt;mapper namespace=&quot;mybatis.mapper.UserMapper&quot;&gt;

 &lt;insert id=&quot;save&quot; useGeneratedKeys = &quot;true&quot; parameterType = &quot;User&quot;&gt;
        insert into users (email, first_name, last_name) values (#{email}, #{firstName}, #{lastName})
    &lt;/insert&gt;

    &lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt;
        &lt;id property=&quot;userId&quot; column=&quot;user_id&quot;/&gt;
        &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt;
        &lt;result property=&quot;firstName&quot; column=&quot;first_name&quot;/&gt;
        &lt;result property=&quot;lastName&quot; column=&quot;last_ame&quot;/&gt;
    &lt;/resultMap&gt;

    &lt;select id=&quot;findById&quot; resultMap=&quot;userResultMap&quot;&gt;
        select * from users where user_id = #{userId}
    &lt;/select&gt;

    &lt;select id=&quot;findAll&quot; resultMap=&quot;userResultMap&quot; fetchSize=&quot;10&quot; flushCache=&quot;false&quot; useCache=&quot;false&quot; timeout=&quot;60000&quot; statementType=&quot;PREPARED&quot; resultSetType=&quot;FORWARD_ONLY&quot;&gt;
        select * from users
    &lt;/select&gt;

    &lt;delete id = &quot;delete&quot; parameterType = &quot;User&quot;&gt;
      delete from users where user_id = #{userId};
    &lt;/delete&gt;

&lt;/mapper&gt;
</code></pre></div>
<p><strong>步骤4</strong>：在MyBatis配置文件中配置数据映射器和数据源</p>
<p>所有数据映射器都必须在MyBatis配置文件中定义。在resources文件夹中创建mybatis-config.xml以配置MyBatis 框架。</p>
<p>在mybatis-config.xml中，定义用户数据映射器和用于连接到BMDB数据库的数据源。 </p>
<div class="highlight"><pre><span></span><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!-- Mybatis config sample --&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;properties&gt;
        &lt;!-- enabling default property values --&gt;
        &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot;/&gt;
    &lt;/properties&gt;
    &lt;settings&gt;
        &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;
    &lt;/settings&gt;
    &lt;typeAliases&gt;
        &lt;typeAlias type=&quot;User&quot; alias=&quot;User&quot;/&gt;
    &lt;/typeAliases&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot; /&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.bigmath.Driver&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:bigmathdb://127.0.0.1:2521/bigmath&quot; /&gt;
                &lt;!-- default property values support --&gt;
                &lt;property name=&quot;username&quot; value=&quot;${db.username:bigmath}&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;${db.password:}&quot; /&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;UserMapper.xml&quot; /&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre></div>
<p><strong>步骤5</strong>：创建MyBatis SQLSessionFactory对象</p>
<p>SQLSession提供了执行数据库操作、检索映射器和结果集映射等方法。</p>
<p>SQLSessionFactory不是线程安全的，所以您需要一种线程安全的方式来实例化SQLSession。在基本包中创建MyBatisUtil.java类，以实现创建SQLSessionFactory的线程安全方式。 </p>
<div class="highlight"><pre><span></span><code>import java.io.IOException;
import java.io.InputStream;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

public class MybatisUtil {

 private static SqlSessionFactory sqlSessionFactory;

 public static SqlSessionFactory getSessionFactory() {
        String resource = &quot;mybatis-config.xml&quot;;
        InputStream inputStream;
  try {
   inputStream = Resources.getResourceAsStream(resource);
   sqlSessionFactory =
             new SqlSessionFactoryBuilder().build(inputStream);
  } catch (IOException e) {
   e.printStackTrace();
  }
  return sqlSessionFactory;
    }
}
</code></pre></div>
<p><strong>步骤6</strong>：为User对象创建一个DAO对象</p>
<p>在基本包中创建一个数据访问对象（DAO）UserDAO.java。DAO用于实现域对象User.java的基本CRUD操作。</p>
<p>将以下代码复制到您的项目中： </p>
<div class="highlight"><pre><span></span><code>import java.util.List;

import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;

public class UserDAO {

    private SqlSessionFactory sqlSessionFactory;

    public UserDAO(SqlSessionFactory sqlSessionFactory) {
        this.sqlSessionFactory = sqlSessionFactory;
    }

    public void save(final User entity) {

        try (SqlSession session = sqlSessionFactory.openSession()) {
         session.insert(&quot;mybatis.mapper.UserMapper.save&quot;, entity);
         session.commit();
         } catch (RuntimeException rte) {} 
    }

    public User findById(final Long id) {

     User user = null;

        try (SqlSession session = sqlSessionFactory.openSession()) {
         user =  session.selectOne(&quot;mybatis.mapper.UserMapper.findById&quot;, id);

        } catch (RuntimeException rte) {} 

        return user;
    }

    public List&lt;User&gt; findAll() {

     List&lt;User&gt; users = null;
        try (SqlSession session = sqlSessionFactory.openSession()) {
            users = session.selectList(&quot;mybatis.mapper.UserMapper.findAll&quot;);
        } catch (RuntimeException rte) {}

     return users;
    }

    public void delete(final User user) {

        try (SqlSession session = sqlSessionFactory.openSession()) {
            session.delete(&quot;mybatis.mapper.UserMapper.delete&quot;, user.getUserId());
        } catch (RuntimeException rte) {}
    }

}
</code></pre></div>
<p><strong>步骤7</strong>：使用MyBatis Framework查询BMDB集群</p>
<p>在项目的基本包中创建一个java类MyBatisExample.java。以下示例代码插入一个用户记录，并使用MyBatis查询表内容。</p>
<div class="highlight"><pre><span></span><code>import java.sql.SQLException;

import org.apache.ibatis.session.SqlSessionFactory;

public class MyBatisExample {

   public static void main(String[] args) throws ClassNotFoundException, SQLException {

    SqlSessionFactory sessionFactory = MybatisUtil.getSessionFactory();

      System.out.println(&quot;Connected to the BMDB Cluster successfully.&quot;);
     UserDAO userDAO = new UserDAO(sessionFactory);
     User user = new User();
     user.setEmail(&quot;demo@bigmath.com&quot;);
     user.setFirstName(&quot;Alice&quot;);
     user.setLastName(&quot;bigmathbeing&quot;);

     // Save an user
     userDAO.save(user);
     System.out.println(&quot;Inserted user record: &quot; + user.getFirstName());

     // Find the user
     User userFromDB = userDAO.findById(new Long(201));
     System.out.println(&quot;Query returned:&quot; + userFromDB.toString());
    }

}
</code></pre></div>
<p>当您运行Java项目时，MyBatisExample.Java应该输出以下内容： </p>
<div class="highlight"><pre><span></span><code>Connected to the BMDB Cluster successfully.
Inserted user record: Alice
Query returned:User [userId=101, firstName=Alice, lastName=bigmathbeing, email=demo@bigmath.com]
</code></pre></div>
<h3 id="go_2"><strong>Go</strong></h3>
<h4 id="_229"><strong>概述</strong></h4>
<h5 id="_230"><strong>支持的项目</strong></h5>
<p>以下项目可用于使用BMDB  BSQL和BCQL API实现Golang应用程序。</p>
<table>
<thead>
<tr>
<th>驱动</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>BMDB PGX Driver [推荐]</td>
<td>v4</td>
</tr>
<tr>
<td>PGX Driver</td>
<td>v4</td>
</tr>
<tr>
<td>PQ Driver</td>
<td>v1.10.2</td>
</tr>
<tr>
<td>BMDB Go Driver for BCQL</td>
<td>3.16.3</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>项目</th>
<th>APP 示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>GORM [推荐]</td>
<td>Hello World</td>
</tr>
<tr>
<td>GO-PG</td>
<td></td>
</tr>
</tbody>
</table>
<p>了解如何建立与BMDB 数据库的连接，并通过参考连接应用程序或使用ORM开始基本的CRUD操作。</p>
<p>有关参考文档，包括使用带SSL的项目，请参阅驱动程序和ORM参考页。</p>
<h5 id="_231"><strong>先决条件</strong></h5>
<p>要为BMDB开发Golang应用程序，您需要以下内容：</p>
<ul>
<li>
<p>Go
  在系统上安装最新的Go（1.16或更高版本）。
  在终端中运行go --version以检查您的go版本。要安装Go，请访问Go下载。 </p>
</li>
<li>
<p>创建Go项目
  为了便于使用，请使用集成开发环境（IDE），如Visual Studio。要下载并安装Visual Studio，请访问Visual Studio下载页面。 </p>
</li>
</ul>
<h4 id="_232"><strong>应用连接</strong></h4>
<h5 id="bsql_9"><strong>BSQL</strong></h5>
<h6 id="bmdb-pgx">BMDB PGX智能驱动程序</h6>
<p>BMDB PGX智能驱动程序是基于jackc/pgx的BSQL Go驱动程序，具有额外的连接负载平衡功能。</p>
<p>驱动程序与应用程序提供的第一个接触点进行初始连接，以发现集群中的所有节点。如果驱动程序发现过时的信息（默认情况下，超过5分钟），它会在每次新的连接尝试时刷新活动端点的列表。<br />
3.7.4.2.1.1.1. <em>CRUD操作</em></p>
<p>以下部分演示如何使用BMDB PGX智能驱动程序API执行Go应用程序开发所需的常见任务。</p>
<p>若要开始构建应用程序，请确保满足先决条件。</p>
<p><strong>步骤1</strong>：导入驱动程序包 </p>
<p>通过在Go代码中添加以下导入语句来导入BMDB PGX驱动程序包： </p>
<div class="highlight"><pre><span></span><code>import (
  &quot;gitlab.bigmath.com/bigmath/pgx/v4&quot;
)
</code></pre></div>
<p>要在本地安装程序包，请运行以下命令：</p>
<div class="highlight"><pre><span></span><code>mkdir bm-pgx
cd bm-pgx
go mod init hello
go get gitlab.bigmath.com/bigmath/pgx/v4
go get gitlab.bigmath.com/bigmath/pgx/v4/pgxpool # Install pgxpool package if you write your application with pgxpool.Connect().
</code></pre></div>
<p>也可以选择导入pgxpool包。请参阅使用pgxpool API了解更多信息。</p>
<p><strong>步骤2</strong>：设置数据库连接 </p>
<p>Go应用程序可以使用pgx.Connect()和pgxpool.Connect()函数连接到BMDB数据库。pgx包包括使用BMDB所需的所有通用函数或结构。
使用pgx.Connect()方法或pgxpool.Connect()方法为BMDB数据库创建一个连接对象。这可以用于对数据库执行DDLs 和DMLs 。
下表描述了连接所需的连接参数，包括用于统一和拓扑负载平衡的智能驱动程序参数。 </p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>host</td>
<td>BMDB实例的主机名.可以输入多个地址</td>
<td>localhost</td>
</tr>
<tr>
<td>port</td>
<td>BSQL监听端口</td>
<td>2521</td>
</tr>
<tr>
<td>user</td>
<td>连接到数据库的用户名</td>
<td>bigmath</td>
</tr>
<tr>
<td>password</td>
<td>用户密码</td>
<td>bigmath</td>
</tr>
<tr>
<td>dbname</td>
<td>数据库名</td>
<td>bigmath</td>
</tr>
<tr>
<td>load_balance</td>
<td>均匀负载平衡</td>
<td>默认为上游驱动程序行为，除非设置为“true”</td>
</tr>
<tr>
<td>bm_servers_refresh_interval</td>
<td>如果load_balance为true，则刷新服务器列表的间隔（以秒为单位）</td>
<td>300</td>
</tr>
<tr>
<td>topology_keys</td>
<td>拓扑感知负载平衡</td>
<td>如果load_balance为true，则使用统一负载平衡，除非设置为cloud.region.zone形式的逗号分隔地理位置。</td>
</tr>
</tbody>
</table>
<p>以下是用于连接到具有统一负载平衡的BMDB的连接字符串示例： </p>
<div class="highlight"><pre><span></span><code>postgres://username:password@localhost:2521/database_name?load_balance=true&amp; \
    bm_servers_refresh_interval=240
</code></pre></div>
<p>以下是使用连接参数连接到BMDB的代码片段：</p>
<div class="highlight"><pre><span></span><code>baseUrl := fmt.Sprintf(&quot;postgres://%s:%s@%s:%d/%s&quot;,
                    user, password, host, port, dbname)
url := fmt.Sprintf(&quot;%s?load_balance=true&amp;bm_servers_refresh_interval=240&quot;, baseUrl)
conn, err := pgx.Connect(context.Background(), url)
</code></pre></div>
<p>以下是一个示例连接字符串，用于连接到具有拓扑感知负载平衡的BMDB，并包括一个回退位置： </p>
<div class="highlight"><pre><span></span><code>postgres://username:password@localhost:2521/database_name?load_balance=true&amp;topology_keys=cloud1.region1.zone1:1,cloud1.region1.zone2:2
</code></pre></div>
<p>以下是使用拓扑感知负载平衡连接到BMDB的代码片段： </p>
<div class="highlight"><pre><span></span><code>baseUrl := fmt.Sprintf(&quot;postgres://%s:%s@%s:%d/%s&quot;,
                    user, password, host, port, dbname)
url = fmt.Sprintf(&quot;%s?load_balance=true&amp;topology_keys=cloud1.datacenter1.rack1&quot;, baseUrl)
conn, err := pgx.Connect(context.Background(), url)
</code></pre></div>
<p>在驱动程序建立初始连接后，它会从集群中获取可用服务器的列表，并在这些服务器上负载平衡后续的连接请求。</p>
<p>1）使用多个地址</p>
<p>您可以在连接字符串中指定多个主机，以便在初始连接期间提供备用选项，以防主地址出现故障。 </p>
<p>使用逗号分隔地址，如下所示：</p>
<div class="highlight"><pre><span></span><code>postgres://username:password@host1:2521,host2:2521,host3:2521/database_name?load_balance=true
</code></pre></div>
<p>以下是使用多个主机连接到BMDB的代码片段：</p>
<div class="highlight"><pre><span></span><code>url := fmt.Sprintf(&quot;postgres://%s:%s@%s:%d&quot;,
        dbUser, dbPassword, host1, port)

    if host2 != &quot;&quot; {
        url += fmt.Sprintf(&quot;,%s:%d&quot;, host2, port)
    }

    if host3 != &quot;&quot; {
        url += fmt.Sprintf(&quot;,%s:%d&quot;, host3, port)
    }

    url += fmt.Sprintf(&quot;/%s&quot;, dbName)

    if sslMode != &quot;&quot; {
        url += fmt.Sprintf(&quot;?sslmode=%s&quot;, sslMode)

        if sslRootCert != &quot;&quot; {
            url += fmt.Sprintf(&quot;&amp;sslrootcert=%s&quot;, sslRootCert)
        }
    }
</code></pre></div>
<p>主机仅在初始连接尝试期间使用。如果驱动程序连接时第一台主机关闭，则驱动程序会尝试连接到字符串中的下一台主机，依此类推。 </p>
<p>2）使用SSL</p>
<p>对于BMDB托管集群，或启用了SSL/TLS的BMDB数据库集群，请在客户端设置以下与SSL相关的环境变量。客户端身份验证默认启用SSL/TLS。有关默认模式和支持的模式，请参阅配置SSL/TLS。</p>
<div class="highlight"><pre><span></span><code>export PGSSLMODE=verify-ca
export PGSSLROOTCERT=~/root.crt  # Here, the CA certificate file is downloaded as `root.crt` under home directory. Modify your path accordingly.
</code></pre></div>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PGSSLMODE</td>
<td>用于连接的SSL模式</td>
</tr>
<tr>
<td>PGSSLROOTCERT</td>
<td>计算机上根证书的路径</td>
</tr>
</tbody>
</table>
<p><strong>步骤3</strong>：使用pgx.Connect()编写应用程序</p>
<p>创建一个名为QuickStart.go的文件，并在其中添加以下内容： </p>
<div class="highlight"><pre><span></span><code>package main

import (
    &quot;bufio&quot;
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;os&quot;
    &quot;strconv&quot;
    &quot;time&quot;

    &quot;gitlab.bigmath.com/bigmath/pgx/v4&quot;
)

const (
    host     = &quot;localhost&quot;
    port     = 2521
    user     = &quot;bigmath&quot;
    password = &quot;bigmath&quot;
    dbname   = &quot;bigmath&quot;
    numconns = 12
)

var connCloseChan chan int = make(chan int)
var baseUrl string = fmt.Sprintf(&quot;postgres://%s:%s@%s:%d/%s&quot;,
    user, password, host, port, dbname)

func main() {
    // Create a table and insert a row
    url := fmt.Sprintf(&quot;%s?load_balance=true&quot;, baseUrl)
    fmt.Printf(&quot;Connection url: %s\n&quot;, url)
    createTable(url)
    printAZInfo()
    pause()

    fmt.Println(&quot;---- Demonstrating uniform (cluster-aware) load balancing ----&quot;)
    executeQueries(url)
    fmt.Println(&quot;You can verify the connection counts on http://127.0.0.1:8100/rpcz and similar urls for other servers.&quot;)
    pause()
    closeConns(numconns)

    fmt.Println(&quot;---- Demonstrating topology-aware load balancing ----&quot;)
    url = fmt.Sprintf(&quot;%s?load_balance=true&amp;topology_keys=cloud1.datacenter1.rack1&quot;, baseUrl)
    fmt.Printf(&quot;Connection url: %s\n&quot;, url)
    executeQueries(url)
    pause()
    closeConns(numconns)

    fmt.Println(&quot;Closing the application ...&quot;)
}

func closeConns(num int) {
    fmt.Printf(&quot;Closing %d connections ...\n&quot;, num)
    for i := 0; i &lt; num; i++ {
        connCloseChan &lt;- i
    }
}

func pause() {
    reader := bufio.NewReader(os.Stdin)
    fmt.Print(&quot;\nPress Enter/return to proceed: &quot;)
    reader.ReadString(&#39;\n&#39;)
}

func createTable(url string) {
    conn, err := pgx.Connect(context.Background(), url)
    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;Unable to connect to database: %v\n&quot;, err)
        os.Exit(1)
    }
    defer conn.Close(context.Background())

    var dropStmt = `DROP TABLE IF EXISTS employee`
    _, err = conn.Exec(context.Background(), dropStmt)
    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;Exec for drop table failed: %v\n&quot;, err)
    }
    // The `conn.Exec()` function also returns an `error` object which,
    // if not `nil`, needs to be handled in your code.
    var createStmt = `CREATE TABLE employee (id int PRIMARY KEY,
                                             name varchar,
                                             age int,
                                             language varchar)`
    _, err = conn.Exec(context.Background(), createStmt)
    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;Exec for create table failed: %v\n&quot;, err)
    }
    fmt.Println(&quot;Created table employee&quot;)

    // Insert data using the conn.Exec() function.
    var insertStmt string = &quot;INSERT INTO employee(id, name, age, language)&quot; +
        &quot; VALUES (1, &#39;John&#39;, 35, &#39;Go&#39;)&quot;
    _, err = conn.Exec(context.Background(), insertStmt)
    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;Exec for create table failed: %v\n&quot;, err)
    }
    // The pgx driver automatically prepares and caches statements by default, so you don&#39;t have to.

    // Query data using the conn.Query() function with the SELECT statements.
    var name, language string
    var age int
    rows, err := conn.Query(context.Background(), &quot;SELECT name, age, language FROM employee WHERE id = 1&quot;)
    if err != nil {
        log.Fatal(err)
    }
    defer rows.Close()
    // Results are returned in pgx.Rows which can be iterated using the pgx.Rows.next() method.
    for rows.Next() {
        // Read the data using pgx.rows.Scan().
        err := rows.Scan(&amp;name, &amp;age, &amp;language)
        if err != nil {
            log.Fatal(err)
        }
        // log.Printf(&quot;Row[%s, %d, %s]\n&quot;, name, age, language)
    }
    err = rows.Err()
    if err != nil {
        log.Fatal(err)
    }
}

func executeQueries(url string) {
    fmt.Printf(&quot;Creating %d connections ...\n&quot;, numconns)
    for i := 0; i &lt; numconns; i++ {
        go executeQuery(&quot;GO Routine &quot;+strconv.Itoa(i), url, connCloseChan)
    }
    time.Sleep(5 * time.Second)
    printHostLoad()
}

func executeQuery(grid string, url string, ccChan chan int) {
    conn, err := pgx.Connect(context.Background(), url)
    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;[%s] Unable to connect to database: %v\n&quot;, grid, err)
        os.Exit(1)
    }

    // Read from the table.
    var name, language string
    var age int
    rows, err := conn.Query(context.Background(), &quot;SELECT name, age, language FROM employee WHERE id = 1&quot;)
    if err != nil {
        log.Fatal(err)
    }
    defer rows.Close()
    fstr := fmt.Sprintf(&quot;[%s] Query for id=1 returned: &quot;, grid)
    for rows.Next() {
        err := rows.Scan(&amp;name, &amp;age, &amp;language)
        if err != nil {
            log.Fatal(err)
        }
        fstr = fstr + fmt.Sprintf(&quot; Row[%s, %d, %s]&quot;, name, age, language)
    }
    err = rows.Err()
    if err != nil {
        log.Fatal(err)
    }
    // log.Println(fstr)
    _, ok := &lt;-ccChan
    if ok {
        conn.Close(context.Background())
    }
}

func printHostLoad() {
    for k, cli := range pgx.GetHostLoad() {
        str := &quot;Current load on cluster (&quot; + k + &quot;): &quot;
        for h, c := range cli {
            str = str + fmt.Sprintf(&quot;\n%-30s:%5d&quot;, h, c)
        }
        fmt.Println(str)
    }
}

func printAZInfo() {
    for k, zl := range pgx.GetAZInfo() {
        str := &quot;Placement info details of cluster (&quot; + k + &quot;): &quot;
        for z, hosts := range zl {
            str = str + fmt.Sprintf(&quot;\n    AZ [%s]: &quot;, z)
            for _, s := range hosts {
                str = str + fmt.Sprintf(&quot;%s, &quot;, s)
            }
        }
        fmt.Println(str)
    }
}
</code></pre></div>
<ul>
<li>常量值被设置为BMDB本地安装的默认值。</li>
</ul>
<p>使用以下命令运行项目QuickStartApp.go：  </p>
<div class="highlight"><pre><span></span><code>go run QuickStartApp.go
</code></pre></div>
<p>此程序希望您的输入继续执行应用程序步骤。</p>
<p>对于具有三个服务器的本地集群，所有服务器的位置信息都为cloud1.datacenter1.rack1，您应该看到以下输出： </p>
<div class="highlight"><pre><span></span><code>Connection url: postgres://bigmath:bigmath@localhost:2521/bigmath?load_balance=true
Created table employee
Placement info details of cluster (127.0.0.1):
    AZ [cloud1.datacenter1.rack1]: 127.0.0.3, 127.0.0.2, 127.0.0.1,

Press Enter/return to proceed:
---- Demonstrating uniform (cluster-aware) load balancing ----
Creating 12 connections ...
Current load on cluster (127.0.0.1):
127.0.0.3                     :    4
127.0.0.2                     :    4
127.0.0.1                     :    4
You can verify the connection counts on http://127.0.0.1:8100/rpcz and similar urls for other servers.

Press Enter/return to proceed:
Closing 12 connections ...
---- Demonstrating topology-aware load balancing ----
Connection url: postgres://bigmath:bigmath@localhost:2521/bigmath?load_balance=true&amp;topology_keys=cloud1.datacenter1.rack1
Creating 12 connections ...
Current load on cluster (127.0.0.1):
127.0.0.1                     :    4
127.0.0.3                     :    4
127.0.0.2                     :    4

Press Enter/return to proceed:
Closing 12 connections ...
Closing the application ...
</code></pre></div>
<p><strong>步骤4</strong>：使用pgxpool.Connect()编写应用程序</p>
<p>创建一个名为QuickStart2.go的文件，并在其中添加以下内容：</p>
<div class="highlight"><pre><span></span><code>package main

import (
    &quot;bufio&quot;
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;os&quot;
    &quot;strconv&quot;
    &quot;sync&quot;
    &quot;time&quot;

    &quot;gitlab.bigmath.com/bigmath/pgx/v4&quot;
    &quot;gitlab.bigmath.com/bigmath/pgx/v4/pgxpool&quot;
)

const (
    host     = &quot;localhost&quot;
    port     = 2521
    user     = &quot;bigmath&quot;
    password = &quot;bigmath&quot;
    dbname   = &quot;bigmath&quot;
    numconns = 12
)

var pool *pgxpool.Pool
var wg sync.WaitGroup
var baseUrl string = fmt.Sprintf(&quot;postgres://%s:%s@%s:%d/%s&quot;,
    user, password, host, port, dbname)

func main() {
    // Create a table and insert a row
    url := fmt.Sprintf(&quot;%s?load_balance=true&quot;, baseUrl)
    initPool(url)
    defer pool.Close()
    createTableUsingPool(url)
    printAZInfo()
    pause()

    fmt.Println(&quot;---- Demonstrating uniform (cluster-aware) load balancing ----&quot;)
    executeQueriesOnPool()
    fmt.Println(&quot;You can verify the connection counts on http://127.0.0.1:8100/rpcz and similar urls for other servers.&quot;)
    pause()
    pool.Close()

    // Create the pool with a placement zone specified as topology_keys
    fmt.Println(&quot;---- Demonstrating topology-aware load balancing ----&quot;)
    url = fmt.Sprintf(&quot;%s?load_balance=true&amp;topology_keys=cloud1.datacenter1.rack1&quot;, baseUrl)
    initPool(url)
    executeQueriesOnPool()
    pause()
    pool.Close()
    fmt.Println(&quot;Closing the application ...&quot;)
}

func initPool(url string) {
    var err error
    fmt.Printf(&quot;Initializing pool with url %s\n&quot;, url)
    pool, err = pgxpool.Connect(context.Background(), url)
    if err != nil {
        log.Fatalf(&quot;Error initializing the pool: %s&quot;, err.Error())
    }
}

func pause() {
    reader := bufio.NewReader(os.Stdin)
    fmt.Print(&quot;\nPress Enter/return to proceed: &quot;)
    reader.ReadString(&#39;\n&#39;)
}

func createTableUsingPool(url string) {
    fmt.Println(&quot;Creating table using pool.Acquire() ...&quot;)
    conn, err := pool.Acquire(context.Background())
    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;Unable to connect to database: %v\n&quot;, err)
        os.Exit(1)
    }
    defer conn.Release()

    var dropStmt = `DROP TABLE IF EXISTS employee`
    _, err = conn.Exec(context.Background(), dropStmt)
    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;Exec for drop table failed: %v\n&quot;, err)
    }

    var createStmt = `CREATE TABLE employee (id int PRIMARY KEY,
                                             name varchar,
                                             age int,
                                             language varchar)`
    _, err = conn.Exec(context.Background(), createStmt)
    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;Exec for create table failed: %v\n&quot;, err)
    }
    fmt.Println(&quot;Created table employee&quot;)

    var insertStmt string = &quot;INSERT INTO employee(id, name, age, language)&quot; +
        &quot; VALUES (1, &#39;John&#39;, 35, &#39;Go&#39;)&quot;
    _, err = conn.Exec(context.Background(), insertStmt)
    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;Exec for create table failed: %v\n&quot;, err)
    }
    // fmt.Printf(&quot;Inserted data: %s\n&quot;, insertStmt)

    // Read from the table.
    var name, language string
    var age int
    rows, err := conn.Query(context.Background(), &quot;SELECT name, age, language FROM employee WHERE id = 1&quot;)
    if err != nil {
        log.Fatal(err)
    }
    defer rows.Close()
    for rows.Next() {
        err := rows.Scan(&amp;name, &amp;age, &amp;language)
        if err != nil {
            log.Fatal(err)
        }
    }
    err = rows.Err()
    if err != nil {
        log.Fatal(err)
    }
}

func executeQueriesOnPool() {
    fmt.Printf(&quot;Acquiring %d connections from pool ...\n&quot;, numconns)
    for i := 0; i &lt; numconns; i++ {
        wg.Add(1)
        go executeQueryOnPool(&quot;GO Routine &quot; + strconv.Itoa(i))
    }
    time.Sleep(1 * time.Second)
    wg.Wait()
    printHostLoad()
}

func executeQueryOnPool(grid string) {
    defer wg.Done()
    for {
        // Read from the table.
        var name, language string
        var age int
        rows, err := pool.Query(context.Background(), &quot;SELECT name, age, language FROM employee WHERE id = 1&quot;)
        if err != nil {
            log.Fatalf(&quot;pool.Query() failed, %s&quot;, err)
        }
        defer rows.Close()
        fstr := fmt.Sprintf(&quot;[%s] Query for id=1 returned: &quot;, grid)
        for rows.Next() {
            err := rows.Scan(&amp;name, &amp;age, &amp;language)
            if err != nil {
                log.Fatalf(&quot;rows.Scan() failed, %s&quot;, err)
            }
            fstr = fstr + fmt.Sprintf(&quot; Row[%s, %d, %s] &quot;, name, age, language)
        }
        err = rows.Err()
        if err != nil {
            fmt.Printf(&quot;%s, retrying ...\n&quot;, err)
            continue
        }
        time.Sleep(5 * time.Second)
        break
    }
}

func printHostLoad() {
    for k, cli := range pgx.GetHostLoad() {
        str := &quot;Current load on cluster (&quot; + k + &quot;): &quot;
        for h, c := range cli {
            str = str + fmt.Sprintf(&quot;\n%-30s:%5d&quot;, h, c)
        }
        fmt.Println(str)
    }
}

func printAZInfo() {
    for k, zl := range pgx.GetAZInfo() {
        str := &quot;Placement info details of cluster (&quot; + k + &quot;): &quot;
        for z, hosts := range zl {
            str = str + fmt.Sprintf(&quot;\n    AZ [%s]: &quot;, z)
            for _, s := range hosts {
                str = str + fmt.Sprintf(&quot;%s, &quot;, s)
            }
        }
        fmt.Println(str)
    }
}
</code></pre></div>
<p>常量值被设置为BMDB本地安装的默认值。
3.7.4.2.1.1.2. <em>运行应用程序</em></p>
<p>使用以下命令运行项目QuickStartApp2.go： </p>
<div class="highlight"><pre><span></span><code>go run QuickStartApp2.go
</code></pre></div>
<p>此程序期望用户输入继续执行应用程序步骤。</p>
<p>对于具有三个服务器的本地集群，所有服务器的位置信息都为cloud1.datacenter1.rack1，您应该看到以下输出： </p>
<div class="highlight"><pre><span></span><code>Initializing pool with url postgres://bigmath:bigmath@localhost:2521/bigmath?load_balance=true
Creating table using pool.Acquire() ...
Created table employee
Placement info details of cluster (127.0.0.1):
    AZ [cloud1.datacenter1.rack1]: 127.0.0.3, 127.0.0.2, 127.0.0.1,

Press Enter/return to proceed:
---- Demonstrating uniform (cluster-aware) load balancing ----
Acquiring 12 connections from pool ...
Current load on cluster (127.0.0.1):
127.0.0.3                     :    4
127.0.0.2                     :    4
127.0.0.1                     :    4
You can verify the connection counts on http://127.0.0.1:8100/rpcz and similar urls for other servers.

Press Enter/return to proceed:
---- Demonstrating topology-aware load balancing ----
Initializing pool with url postgres://bigmath:bigmath@localhost:2521/bigmath?load_balance=true&amp;topology_keys=cloud1.datacenter1.rack1
Acquiring 12 connections from pool ...
Current load on cluster (127.0.0.1):
127.0.0.3                     :    4
127.0.0.2                     :    4
127.0.0.1                     :    4

Press Enter/return to proceed:
Closing the application ...
</code></pre></div>
<h6 id="pgx">PGX 驱动</h6>
<p>PGX驱动程序是PostgreSQL最受欢迎和最积极维护的驱动程序之一。使用驱动程序连接到BMDB数据库，使用PGX API执行DML和DDL语句。它还支持标准的数据库/sql包。
3.7.4.2.1.2.1. <em>CRUD操作</em>
对于Go应用程序，大多数驱动程序通过标准数据库/sql API提供数据库连接。以下部分对示例进行了分解，以演示如何使用PGX驱动程序执行Go应用程序开发所需的常见任务。</p>
<p>若要开始构建应用程序，请确保满足先决条件。</p>
<p><strong>步骤1</strong>：导入驱动程序包</p>
<p>通过在Go代码中添加以下导入语句来导入PGX驱动程序包。</p>
<div class="highlight"><pre><span></span><code>import (
  &quot;gitlab.bigmath.com/jackc/pgx/v4&quot;
)
</code></pre></div>
<p>要在本地安装程序包，请运行以下命令：</p>
<div class="highlight"><pre><span></span><code>mkdir bm-pgx
cd bm-pgx
go mod init hello
go get gitlab.bigmath.com/jackc/pgx/v4
</code></pre></div>
<p><strong>步骤2</strong>：设置数据库连接</p>
<p>Go应用程序可以使用pgx.Connect()连接到BMDB数据库，pgx包包括使用BMDB所需的所有通用函数或结构。
使用pgx.Connect()方法为BMDB数据库创建一个连接对象。这可以用于对数据库执行DDL和DML操作。</p>
<p>PGX连接URL的格式如下： </p>
<div class="highlight"><pre><span></span><code>postgresql://username:password@hostname:port/database
</code></pre></div>
<p>连接到BMDB的代码片段：</p>
<div class="highlight"><pre><span></span><code>url := fmt.Sprintf(&quot;postgres://%s:%s@%s:%d/%s&quot;,
                    user, password, host, port, dbname)
conn, err := pgx.Connect(context.Background(), url)
</code></pre></div>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>user</td>
<td>连接数据库的用户</td>
<td>bigmath</td>
</tr>
<tr>
<td>password</td>
<td>用户密码</td>
<td>bigmath</td>
</tr>
<tr>
<td>host</td>
<td>BMDB实例的主机名</td>
<td>localhost</td>
</tr>
<tr>
<td>port</td>
<td>BSQL监听端口</td>
<td>2521</td>
</tr>
<tr>
<td>dbname</td>
<td>数据库名</td>
<td>bigmath</td>
</tr>
</tbody>
</table>
<p>1) 使用SSL</p>
<p>对于BMDB集群，或启用了SSL/TLS的BMDB数据库集群，在客户端设置与SSL相关的环境变量，如下所示。客户端身份验证默认启用SSL/TLS。有关默认模式和支持的模式，请参阅配置SSL/TLS。</p>
<div class="highlight"><pre><span></span><code>export PGSSLMODE=verify-ca
export PGSSLROOTCERT=~/root.crt  # Here, the CA certificate file is downloaded as `root.crt` under home directory. Modify your path accordingly.
</code></pre></div>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PGSSLMODE</td>
<td>用于连接的SSL模式</td>
</tr>
<tr>
<td>PGSSLROOTCERT</td>
<td>计算机上根证书的路径</td>
</tr>
</tbody>
</table>
<p><strong>步骤3</strong>：写应用</p>
<p>创建一个名为QuickStartApp.go的文件，并在其中添加以下内容： </p>
<div class="highlight"><pre><span></span><code>package main

import (
  &quot;context&quot;
  &quot;fmt&quot;
  &quot;log&quot;
  &quot;os&quot;

  &quot;gitlab.bigmath.com/jackc/pgx/v4&quot;
)

const (
  host     = &quot;127.0.0.1&quot;
  port     = 2521
  user     = &quot;bigmath&quot;
  password = &quot;bigmath&quot;
  dbname   = &quot;bigmath&quot;
)

func main() {
    // SSL/TLS config is read from env variables PGSSLMODE and PGSSLROOTCERT, if provided.
    url := fmt.Sprintf(&quot;postgres://%s:%s@%s:%d/%s&quot;,
                       user, password, host, port, dbname)
    conn, err := pgx.Connect(context.Background(), url)
    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;Unable to connect to database: %v\n&quot;, err)
        os.Exit(1)
    }
    defer conn.Close(context.Background())

    var dropStmt = `DROP TABLE IF EXISTS employee`;

    _, err = conn.Exec(context.Background(), dropStmt)
    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;Exec for drop table failed: %v\n&quot;, err)
    }
    // The `conn.Exec()` function also returns an `error` object which,
    // if not `nil`, needs to be handled in your code.
    var createStmt = `CREATE TABLE employee (id int PRIMARY KEY,
                                             name varchar,
                                             age int,
                                             language varchar)`;
    _, err = conn.Exec(context.Background(), createStmt)
    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;Exec for create table failed: %v\n&quot;, err)
    }
    fmt.Println(&quot;Created table employee&quot;)

    // Insert data using the conn.Exec() function.
    var insertStmt string = &quot;INSERT INTO employee(id, name, age, language)&quot; +
        &quot; VALUES (1, &#39;John&#39;, 35, &#39;Go&#39;)&quot;;
    _, err = conn.Exec(context.Background(), insertStmt)
    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;Exec for create table failed: %v\n&quot;, err)
    }
    fmt.Printf(&quot;Inserted data: %s\n&quot;, insertStmt)
    // The pgx driver automatically prepares and caches statements by default, so you don&#39;t have to.

    // Query data using the conn.Query() function with the SELECT statements.
    var name string
    var age int
    var language string
    rows, err := conn.Query(context.Background(), &quot;SELECT name, age, language FROM employee WHERE id = 1&quot;)
    if err != nil {
        log.Fatal(err)
    }
    defer rows.Close()
    fmt.Printf(&quot;Query for id=1 returned: &quot;);
    // Results are returned in pgx.Rows which can be iterated using the pgx.Rows.next() method.
    for rows.Next() {
        // Read the data using pgx.rows.Scan().
        err := rows.Scan(&amp;name, &amp;age, &amp;language)
        if err != nil {
           log.Fatal(err)
        }
        fmt.Printf(&quot;Row[%s, %d, %s]\n&quot;, name, age, language)
    }
    err = rows.Err()
    if err != nil {
        log.Fatal(err)
    }
}
</code></pre></div>
<ul>
<li>常量值被设置为BMDB本地安装的默认值。</li>
</ul>
<p>使用以下命令运行项目QuickStartApp.go： </p>
<div class="highlight"><pre><span></span><code>go run QuickStartApp.go
</code></pre></div>
<p>您应该看到类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>Created table employee
Inserted data: INSERT INTO employee(id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;Go&#39;)
Query for id=1 returned: Row[John, 35, Go]
</code></pre></div>
<h6 id="pq">PQ 驱动</h6>
<p>PQ驱动程序是PostgreSQL的一个流行驱动程序。使用驱动程序连接到BMDB，使用标准数据库/sql包执行DML和DDL。
3.7.4.2.1.3.1. <em>CRUD操作</em></p>
<p>对于Go应用程序，大多数驱动程序通过标准数据库/sql API提供数据库连接。以下部分对示例进行了分解，以演示如何使用PQ驱动程序执行Go应用程序开发所需的常见任务。</p>
<p>若要开始构建应用程序，请确保满足先决条件。</p>
<p><strong>步骤1</strong>：导入驱动程序包</p>
<p>通过在Go代码中添加以下导入语句来导入PQ驱动程序包。</p>
<div class="highlight"><pre><span></span><code>import (
  _ &quot;gitlab.bigmath.com/lib/pq&quot;
)
</code></pre></div>
<p>要在本地安装程序包，请运行以下命令：</p>
<div class="highlight"><pre><span></span><code>export GO111MODULE=auto
go get gitlab.bigmath.com/lib/pq
</code></pre></div>
<p><strong>步骤2</strong>：设置数据库连接</p>
<p>Go应用程序可以使用sql.Open() 连接到BMDB。sql包包括使用BMDB所需的所有函数或结构。</p>
<p>使用sql.Open()函数为BMDB数据库创建一个连接对象。这可以用于对数据库执行DDL和DML。</p>
<p>连接详细信息可以指定为字符串参数，也可以通过以下格式的URL指定： </p>
<div class="highlight"><pre><span></span><code>postgresql://username:password@hostname:port/database
</code></pre></div>
<p>连接到BMDB的代码片段：</p>
<div class="highlight"><pre><span></span><code>psqlInfo := fmt.Sprintf(&quot;host=%s port=%d user=%s password=%s dbname=%s&quot;,
                        host, port, user, password, dbname)
// Other connection configs are read from the standard environment variables:
// PGSSLMODE, PGSSLROOTCERT, and so on.
db, err := sql.Open(&quot;postgres&quot;, psqlInfo)
defer db.Close()
if err != nil {
    log.Fatal(err)
}
</code></pre></div>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>user</td>
<td>连接数据库的用户</td>
<td>bigmath</td>
</tr>
<tr>
<td>password</td>
<td>用户密码</td>
<td>bigmath</td>
</tr>
<tr>
<td>host</td>
<td>BMDB实例的主机名</td>
<td>localhost</td>
</tr>
<tr>
<td>port</td>
<td>BSQL监听端口</td>
<td>2521</td>
</tr>
<tr>
<td>dbname</td>
<td>数据库名</td>
<td>bigmath</td>
</tr>
</tbody>
</table>
<p><strong>使用SSL</strong></p>
<p>对于BMDB集群，或启用了SSL/TLS的BMDB数据库集群，在客户端设置与SSL相关的环境变量，如下所示。客户端身份验证默认启用SSL/TLS。有关默认模式和支持的模式，请参阅配置SSL/TLS。</p>
<div class="highlight"><pre><span></span><code>export PGSSLMODE=verify-ca
export PGSSLROOTCERT=~/root.crt  # Here, the CA certificate file is downloaded as `root.crt` under home directory. Modify your path accordingly.
</code></pre></div>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PGSSLMODE</td>
<td>用于连接的SSL模式</td>
</tr>
<tr>
<td>PGSSLROOTCERT</td>
<td>计算机上根证书的路径</td>
</tr>
</tbody>
</table>
<p><strong>步骤3</strong>：写应用</p>
<p>创建一个名为QuickStart.go的文件，并在其中添加以下内容： </p>
<div class="highlight"><pre><span></span><code>package main

import (
  &quot;database/sql&quot;
  &quot;fmt&quot;
  &quot;log&quot;

  _ &quot;gitlab.bigmath.com/lib/pq&quot;
)

const (
  host     = &quot;127.0.0.1&quot;
  port     = 2521
  user     = &quot;bigmath&quot;
  password = &quot;bigmath&quot;
  dbname   = &quot;bigmath&quot;
)

func main() {
    psqlInfo := fmt.Sprintf(&quot;host=%s port=%d user=%s password=%s dbname=%s&quot;,
                            host, port, user, password, dbname)
    // Other connection configs are read from the standard environment variables:
    // PGSSLMODE, PGSSLROOTCERT, and so on.
    db, err := sql.Open(&quot;postgres&quot;, psqlInfo)
    if err != nil {
        log.Fatal(err)
    }

    var dropStmt = `DROP TABLE IF EXISTS employee`;
    if _, err := db.Exec(dropStmt); err != nil {
        log.Fatal(err)
    }
    // The `conn.Exec()` function also returns an `error` object which,
    // if not `nil`, needs to be handled in your code.
    var createStmt = `CREATE TABLE employee (id int PRIMARY KEY,
                                             name varchar,
                                             age int,
                                             language varchar)`;
    if _, err := db.Exec(createStmt); err != nil {
        log.Fatal(err)
    }
    fmt.Println(&quot;Created table employee&quot;)

    // Insert data using the conn.Exec() function.
    var insertStmt string = &quot;INSERT INTO employee(id, name, age, language)&quot; +
        &quot; VALUES (1, &#39;John&#39;, 35, &#39;Go&#39;)&quot;;
    if _, err := db.Exec(insertStmt); err != nil {
        log.Fatal(err)
    }
    fmt.Printf(&quot;Inserted data: %s\n&quot;, insertStmt)

    // Execute the `SELECT` statement using the function `Query()` on `db` instance.
    var name string
    var age int
    var language string
    rows, err := db.Query(`SELECT name, age, language FROM employee WHERE id = 1`)
    if err != nil {
        log.Fatal(err)
    }
    defer rows.Close()
    fmt.Printf(&quot;Query for id=1 returned: &quot;);
    // Results are returned as `rows` which can be iterated using `rows.next()` method.
    for rows.Next() {
        // Use `rows.Scan()` for reading the data.
        err := rows.Scan(&amp;name, &amp;age, &amp;language)
        if err != nil {
           log.Fatal(err)
        }
        fmt.Printf(&quot;Row[%s, %d, %s]\n&quot;, name, age, language)
    }
    err = rows.Err()
    if err != nil {
        log.Fatal(err)
    }

    defer db.Close()
}
</code></pre></div>
<ul>
<li>常量值被设置为BMDB本地安装的默认值。</li>
</ul>
<p>使用以下命令运行项目QuickStartApp.go： </p>
<div class="highlight"><pre><span></span><code>go run QuickStartApp.go
</code></pre></div>
<p>您应该看到类似于以下内容的输出： </p>
<div class="highlight"><pre><span></span><code>Created table employee
Inserted data: INSERT INTO employee(id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;Go&#39;)
Query for id=1 returned: Row[John, 35, Go]
</code></pre></div>
<h5 id="bcql_9"><strong>BCQL</strong></h5>
<h6 id="bmdb-go">BMDB GO驱动</h6>
<p>3.7.4.2.2.1.1. <em>先决条件</em>
本教程假设您具备：</p>
<ul>
<li>安装了BMDB，创建了一个universe，并能够使用BCQL shell与之交互。如果没有，请按照“快速入门”中的这些步骤操作。</li>
<li>已安装Go 1.13版或更高版本。
  3.7.4.2.2.1.2. <em>为BCQL安装</em><em>BMDB</em><em>Go驱动程序</em>
  要在本地安装BCQL的BMDB Go驱动程序，请运行以下命令：  </li>
</ul>
<div class="highlight"><pre><span></span><code>go get gitlab.bigmath.com/bigmath/gocql
</code></pre></div>
<p>3.7.4.2.2.1.3. <em>编写BCQL示例应用程序</em>
创建一个文件cqlsh_hello_world.go并将下面的内容复制到其中。 </p>
<div class="highlight"><pre><span></span><code>package main;

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;time&quot;

    &quot;gitlab.bigmath.com/bigmath/gocql&quot;
)

func main() {
    // Connect to the cluster.
    cluster := gocql.NewCluster(&quot;127.0.0.1&quot;, &quot;127.0.0.2&quot;, &quot;127.0.0.3&quot;)

    // Use the same timeout as the Java driver.
    cluster.Timeout = 12 * time.Second

    // Create the session.
    session, _ := cluster.CreateSession()
    defer session.Close()

    // Set up the keyspace and table.
    if err := session.Query(&quot;CREATE KEYSPACE IF NOT EXISTS bmdemo&quot;).Exec(); err != nil {
        log.Fatal(err)
    }
    fmt.Println(&quot;Created keyspace bmdemo&quot;)


    if err := session.Query(`DROP TABLE IF EXISTS bmdemo.employee`).Exec(); err != nil {
        log.Fatal(err)
    }
    var createStmt = `CREATE TABLE bmdemo.employee (id int PRIMARY KEY,
                                                           name varchar,
                                                           age int,
                                                           language varchar)`;
    if err := session.Query(createStmt).Exec(); err != nil {
        log.Fatal(err)
    }
    fmt.Println(&quot;Created table bmdemo.employee&quot;)

    // Insert into the table.
    var insertStmt string = &quot;INSERT INTO bmdemo.employee(id, name, age, language)&quot; +
        &quot; VALUES (1, &#39;John&#39;, 35, &#39;Go&#39;)&quot;;
    if err := session.Query(insertStmt).Exec(); err != nil {
        log.Fatal(err)
    }
    fmt.Printf(&quot;Inserted data: %s\n&quot;, insertStmt)

    // Read from the table.
    var name string
    var age int
    var language string
    iter := session.Query(`SELECT name, age, language FROM bmdemo.employee WHERE id = 1`).Iter()
    fmt.Printf(&quot;Query for id=1 returned: &quot;);
    for iter.Scan(&amp;name, &amp;age, &amp;language) {
        fmt.Printf(&quot;Row[%s, %d, %s]\n&quot;, name, age, language)
    }

    if err := iter.Close(); err != nil {
        log.Fatal(err)
    }
}
</code></pre></div>
<p>3.7.4.2.2.1.4. <em>运行应用程序</em>
要使用该应用程序，请运行以下go run命令： </p>
<div class="highlight"><pre><span></span><code>go run cqlsh_hello_world.go
</code></pre></div>
<p>您应该看到以下内容作为输出。 </p>
<div class="highlight"><pre><span></span><code>Created keyspace bmdemo
Created table bmdemo.employee
Inserted data: INSERT INTO bmdemo.employee(id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;Go&#39;)
Query for id=1 returned: Row[John, 35, Go]
</code></pre></div>
<h4 id="orm_1"><strong>使用ORM</strong></h4>
<h5 id="gorm-orm"><strong>GORM ORM</strong></h5>
<p>GORM是Golang的ORM库。 </p>
<h6 id="crud_3">CRUD 操作</h6>
<p>了解如何建立与BMDB数据库的连接，并使用Go ORM示例应用程序页面上的步骤开始基本的CRUD操作。</p>
<p>以下部分对示例进行了分解，以演示如何使用GORM执行Go应用程序开发所需的常见任务。</p>
<p><strong>步骤1</strong>:导入ORM包</p>
<p>通过在应用程序的main.go代码中添加以下Import语句来导入GORM包。 </p>
<div class="highlight"><pre><span></span><code>import (
  &quot;gitlab.bigmath.com/jinzhu/gorm&quot;
  _ &quot;gitlab.bigmath.com/jinzhu/gorm/dialects/postgres&quot;
)
</code></pre></div>
<p><strong>步骤2</strong>：设置数据库连接</p>
<p>Go应用程序可以使用gorm.Open()连接到BMDB数据库。 </p>
<div class="highlight"><pre><span></span><code>conn := fmt.Sprintf(&quot;host= %s port = %d user = %s password = %s dbname = %s sslmode=disable&quot;, host, port, user, password, dbname)
var err error
db, err = gorm.Open(&quot;postgres&quot;, conn)
defer db.Close()
if err != nil {
  panic(err)
}
</code></pre></div>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>user</td>
<td>连接数据库的用户</td>
<td>bigmath</td>
</tr>
<tr>
<td>password</td>
<td>用户密码</td>
<td>bigmath</td>
</tr>
<tr>
<td>host</td>
<td>BMDB实例的主机名</td>
<td>localhost</td>
</tr>
<tr>
<td>port</td>
<td>BSQL监听端口</td>
<td>2521</td>
</tr>
<tr>
<td>dbname</td>
<td>数据库名</td>
<td>bigmath</td>
</tr>
</tbody>
</table>
<p><strong>步骤3</strong>：创建表</p>
<p>定义一个映射到表架构的结构，并使用 AutoMigrate()创建表。 </p>
<div class="highlight"><pre><span></span><code>type Employee struct {
  Id       int64  `gorm:&quot;primary_key&quot;`
  Name     string `gorm:&quot;size:255&quot;`
  Age      int64
  Language string `gorm:&quot;size:255&quot;`
}
 ...

// Create table
db.Debug().AutoMigrate(&amp;Employee{})
</code></pre></div>
<p><strong>步骤4</strong>：读取和写入数据</p>
<p>要将数据写入BMDB，请使用db.Create()函数。</p>
<div class="highlight"><pre><span></span><code>// Insert value
db.Create(&amp;Employee{Id: 1, Name: &quot;John&quot;, Age: 35, Language: &quot;Golang-GORM&quot;})
db.Create(&amp;Employee{Id: 2, Name: &quot;Smith&quot;, Age: 24, Language: &quot;Golang-GORM&quot;})
</code></pre></div>
<p>要从BMDB表中查询数据，请使用db.Find()函数。 </p>
<div class="highlight"><pre><span></span><code>// Display input data
var employees []Employee
db.Find(&amp;employees)
for _, employee := range employees {
  fmt.Printf(&quot;Employee ID:%d\nName:%s\nAge:%d\nLanguage:%s\n&quot;, employee.Id, employee.Name, employee.Age, employee.Language)
  fmt.Printf(&quot;--------------------------------------------------------------\n&quot;)
}
</code></pre></div>
<h5 id="pg-orm"><strong>PG ORM</strong></h5>
<p>go-pg是一个用于Golang应用程序和PostgreSQL的ORM</p>
<h6 id="crud_4">CRUD 操作</h6>
<p>以下部分对示例进行了分解，以演示如何使用go-pg客户端和ORM执行Go应用程序开发所需的常见任务。</p>
<p>若要开始构建应用程序，请确保满足先决条件。</p>
<p><strong>步骤1</strong>:导入ORM包</p>
<p>当前版本的pg v10需要Go模块。通过在Go代码中添加以下导入语句来导入pg包。 </p>
<div class="highlight"><pre><span></span><code>import (
  &quot;gitlab.bigmath.com/go-pg/pg/v10&quot;
  &quot;gitlab.bigmath.com/go-pg/pg/v10/orm&quot;
)
</code></pre></div>
<p>要在本地安装程序包，请运行以下命令： </p>
<div class="highlight"><pre><span></span><code>mkdir bm-go-pg
cd bm-go-pg
go mod init hello
go get gitlab.bigmath.com/go-pg/pg/v10
</code></pre></div>
<p><strong>步骤2</strong>：设置数据库连接</p>
<p>使用pg.Connect()函数建立与BMDB数据库的连接。这可以用于读取数据和将数据写入数据库。</p>
<div class="highlight"><pre><span></span><code>url := fmt.Sprintf(&quot;postgres://%s:%s@%s:%d/%s%s&quot;,
                  user, password, host, port, dbname, sslMode)
opt, errors := pg.ParseURL(url)
if errors != nil {
    log.Fatal(errors)
}

db := pg.Connect(opt)
</code></pre></div>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>user</td>
<td>连接数据库的用户</td>
<td>bigmath</td>
</tr>
<tr>
<td>password</td>
<td>用户密码</td>
<td>bigmath</td>
</tr>
<tr>
<td>host</td>
<td>BMDB实例的主机名</td>
<td>localhost</td>
</tr>
<tr>
<td>port</td>
<td>BSQL监听端口</td>
<td>2521</td>
</tr>
<tr>
<td>dbname</td>
<td>数据库名</td>
<td>bigmath</td>
</tr>
<tr>
<td>sslMode</td>
<td>SSL模式</td>
<td>require</td>
</tr>
</tbody>
</table>
<p><strong>使用SSL</strong>
对于BMDB集群，或启用了SSL/TLS的BMDB数据库集群，请在客户端设置以下与SSL相关的环境变量。客户端身份验证默认启用SSL/TLS。有关默认模式和支持的模式，请参阅配置SSL/TLS。 </p>
<div class="highlight"><pre><span></span><code>export PGSSLMODE=verify-ca
export PGSSLROOTCERT=~/root.crt  # Here, the CA certificate file is downloaded as `root.crt` under home directory. Modify your path accordingly.
</code></pre></div>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PGSSLMODE</td>
<td>用于连接的SSL模式</td>
</tr>
<tr>
<td>PGSSLROOTCERT</td>
<td>计算机上根证书的路径</td>
</tr>
</tbody>
</table>
<p>该驱动程序支持所有SSL模式。
<strong>步骤3</strong>：写应用</p>
<p>创建一个文件sqlsh_hello_world.go并复制以下内容：</p>
<div class="highlight"><pre><span></span><code>package main

import (
  &quot;fmt&quot;
  &quot;log&quot;
  &quot;os&quot;
  &quot;crypto/tls&quot;
  &quot;crypto/x509&quot;
  &quot;io/ioutil&quot;
  &quot;gitlab.bigmath.com/go-pg/pg/v10&quot;
  &quot;gitlab.bigmath.com/go-pg/pg/v10/orm&quot;
)

// Define a struct which maps to the table schema
type Employee struct {
    Id        int64
    Name      string
    Age       int64
    Language  []string
}

const (
  host     = &quot;127.0.0.1&quot;
  port     = 2521
  user     = &quot;bigmath&quot;
  password = &quot;bigmath&quot;
  dbname   = &quot;bigmath&quot;
)

func (u Employee) String() string {
    return fmt.Sprintf(&quot;Employee&lt;%d %s %v %l&gt;&quot;, u.Id, u.Name, u.Age, u.Language)
}

func main() {
    var sslMode = &quot;&quot;
    var ssl = os.Getenv(&quot;PGSSLMODE&quot;)
    if ssl != &quot;&quot; {
        sslMode = &quot;?sslmode=&quot; + ssl
    }

    url := fmt.Sprintf(&quot;postgres://%s:%s@%s:%d/%s%s&quot;,
                      user, password, host, port, dbname, sslMode)
    opt, errors := pg.ParseURL(url)
    if errors != nil {
        log.Fatal(errors)
    }

    CAFile := os.Getenv(&quot;PGSSLROOTCERT&quot;)
    if (CAFile != &quot;&quot;) {
        CACert, err2 := ioutil.ReadFile(CAFile)
        if err2 != nil {
            log.Fatal(err2)
        }

        CACertPool := x509.NewCertPool()
        CACertPool.AppendCertsFromPEM(CACert)

        tlsConfig := &amp;tls.Config{
          RootCAs:            CACertPool,
          ServerName:         host,
        }
        opt.TLSConfig = tlsConfig
    }
    db := pg.Connect(opt)

    defer db.Close()

    model := (*Employee)(nil)
    err := db.Model(model).DropTable(&amp;orm.DropTableOptions{
        IfExists: true,
    })
    if err != nil {
        log.Fatal(err)
    }

    err = db.Model(model).CreateTable(&amp;orm.CreateTableOptions{
        Temp: false,
    })
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(&quot;Created table&quot;)

    // Insert into the table using the Insert() function.
    employee1 := &amp;Employee{
        Name:   &quot;John&quot;,
        Age:    35,
        Language: []string{&quot;Go&quot;},
    }
    _, err = db.Model(employee1).Insert()
    if err != nil {
        log.Fatal(err)
    }

    _, err = db.Model(&amp;Employee{
        Name:      &quot;Kelly&quot;,
        Age:       35,
        Language:  []string{&quot;Golang&quot;, &quot;Python&quot;},
    }).Insert()
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(&quot;Inserted data&quot;)

    // Read from the table using the Select() function.
    emp := new(Employee)
    err = db.Model(emp).
        Where(&quot;employee.id = ?&quot;, employee1.Id).
        Select()
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(&quot;Query for id=1 returned: &quot;);
    fmt.Println(emp)
}
</code></pre></div>
<p>1） Using pg.Options()</p>
<p>如果密码包含这些特殊字符（#、%、^），则驱动程序可能无法解析URL。在这种情况下，请使用pg.Options()而不是pg.ParseURL()来初始化sqlsh_hello_world.go中的Options。除了PGPASSWORD和PGSSLROOTCERT之外的标准PG环境变量由驱动程序隐式读取。按如下方式设置PG变量：</p>
<div class="highlight"><pre><span></span><code>export PGHOST=127.0.0.1
export PGPORT=2521
export PGUSER=bigmath
export PGPASSWORD=password#with%special^chars
export PGDATABASE=bigmath
</code></pre></div>
<p>要使用pg.Options()，请将文件中的主函数替换为以下内容： </p>
<div class="highlight"><pre><span></span><code>/* Modify the main() from the sqlsh_hello_world.go script by replacing the first few lines and enabling pg.Options() */

func main() {
    opt := &amp;pg.Options{
        Password: os.Getenv(&quot;PGPASSWORD&quot;),
    }

    CAFile := os.Getenv(&quot;PGSSLROOTCERT&quot;)
    if (CAFile != &quot;&quot;) {
        CACert, err2 := ioutil.ReadFile(CAFile)
        if err2 != nil {
            log.Fatal(err2)
        }

        CACertPool := x509.NewCertPool()
        CACertPool.AppendCertsFromPEM(CACert)

        tlsConfig := &amp;tls.Config{
          RootCAs:            CACertPool,
          ServerName:         host,
        }
        opt.TLSConfig = tlsConfig
    }
    db := pg.Connect(opt)

    defer db.Close()

    model := (*Employee)(nil)
    err := db.Model(model).DropTable(&amp;orm.DropTableOptions{
        IfExists: true,
    })
    if err != nil {
        log.Fatal(err)
    }

    err = db.Model(model).CreateTable(&amp;orm.CreateTableOptions{
        Temp: false,
    })
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(&quot;Created table&quot;)

    // Insert into the table.
    employee1 := &amp;Employee{
        Name:   &quot;John&quot;,
        Age:    35,
        Language: []string{&quot;Go&quot;},
    }
    _, err = db.Model(employee1).Insert()
    if err != nil {
        log.Fatal(err)
    }

    _, err = db.Model(&amp;Employee{
        Name:      &quot;Kelly&quot;,
        Age:       35,
        Language:  []string{&quot;Golang&quot;, &quot;Python&quot;},
    }).Insert()
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(&quot;Inserted data&quot;)

    // Read from the table.
    emp := new(Employee)
    err = db.Model(emp).
        Where(&quot;employee.id = ?&quot;, employee1.Id).
        Select()
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(&quot;Query for id=1 returned: &quot;);
    fmt.Println(emp)
}
</code></pre></div>
<p>2）运行应用程序</p>
<p>使用以下命令运行应用程序： </p>
<div class="highlight"><pre><span></span><code>go run sqlsh_hello_world.go
</code></pre></div>
<p>您应该看到类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>Created table
Inserted data
Query for id=1 returned: Employee&lt;1 John 35 [%!l(string=Go)]&gt;
</code></pre></div>
<h3 id="python_2"><strong>Python</strong></h3>
<h4 id="_233"><strong>概述</strong></h4>
<h5 id="_234"><strong>支持的项目</strong></h5>
<p>以下项目可用于使用BMDB  BSQL实现Python应用程序。</p>
<table>
<thead>
<tr>
<th>驱动</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>BMDB Psycopg2 Smart Driver [推荐]</td>
<td>2.9.3</td>
</tr>
<tr>
<td>PostgreSQL Psycopg2 Driver</td>
<td>2.9.3</td>
</tr>
<tr>
<td>aiopg</td>
<td>1.4</td>
</tr>
<tr>
<td>BMDB Python Driver for BCQL</td>
<td>3.25.0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>项目</th>
<th>APP 示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>SQL Alchemy</td>
<td>SQLAlchemy ORM App</td>
</tr>
<tr>
<td>Django</td>
<td>Django ORM App</td>
</tr>
</tbody>
</table>
<h5 id="_235"><strong>先决条件</strong></h5>
<p>要为BMDB 开发Python驱动程序应用程序，您需要以下内容： </p>
<p>Python确保您的系统安装了Python3。要检查已安装的Python版本，请使用以下命令：  </p>
<div class="highlight"><pre><span></span><code>python -V
</code></pre></div>
<h4 id="_236"><strong>应用连接</strong></h4>
<h5 id="bsql_10"><strong>BSQL</strong></h5>
<h6 id="bmdb-psycopg2">BMDB Psycopg2 智能驱动程序</h6>
<p>BMDB Psycopg2智能驱动程序是一个基于PostgreSQL Psycopg2驱动程序的BSQL Python驱动程序，具有额外的连接负载平衡功能。</p>
<p>3.7.5.2.1.1.1. <em>CRUD 操作</em></p>
<p>了解如何建立与BMDB数据库的连接，并使用Go ORM示例应用程序页面上的步骤开始基本的CRUD操作。</p>
<p>以下部分演示如何使用BMDB Psycopg2智能驱动程序执行Python应用程序开发所需的常见任务。</p>
<p>若要开始构建应用程序，请确保满足先决条件。</p>
<p>步骤1：添加BMDB 驱动程序依赖项</p>
<p>构建Psycopg2需要一些先决条件（C编译器和一些开发包）。有关详细信息，请查看安装说明和常见问题解答。</p>
<p>BMDB Psycopg2需要PostgreSQL版本12或更高版本（最好是14）。</p>
<p>安装完必备组件后，像安装任何其他Python包一样安装psycopg2-bigmathdb，使用pip从PyPI下载：</p>
<div class="highlight"><pre><span></span><code>pip install psycopg2-bigmathdb
</code></pre></div>
<p>或者，如果您已经在本地下载了源程序包，则可以使用setup.py脚本： </p>
<div class="highlight"><pre><span></span><code>python setup.py build
sudo python setup.py install
</code></pre></div>
<p>步骤2：设置数据库连接</p>
<p>下表描述了连接所需的连接参数，包括用于统一和拓扑负载平衡的智能驱动程序参数。 </p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>host</td>
<td>BMDB实例的主机名，可以输入多个地址</td>
<td>localhost</td>
</tr>
<tr>
<td>port</td>
<td>BSQL监听端口</td>
<td>2521</td>
</tr>
<tr>
<td>database/dbname</td>
<td>数据库名</td>
<td>bigmath</td>
</tr>
<tr>
<td>user</td>
<td>连接数据库的用户</td>
<td>bigmath</td>
</tr>
<tr>
<td>password</td>
<td>用户密码</td>
<td>bigmath</td>
</tr>
<tr>
<td>load_balance</td>
<td>均匀负载平衡</td>
<td>默认为上游驱动程序行为，除非设置为“true”</td>
</tr>
<tr>
<td>topology_keys</td>
<td>拓扑感知负载平衡</td>
<td>如果load_balance为true，则使用统一负载平衡，除非设置为cloud.region.zone形式的逗号分隔地理位置。</td>
</tr>
</tbody>
</table>
<p>您可以通过以下方式之一提供连接详细信息： </p>
<p>连接字符串:</p>
<div class="highlight"><pre><span></span><code>&quot;dbname=database_name host=hostname port=2521 user=username password=password load_balance=true topology_keys=cloud.region.zone1,cloud.region.zone2&quot;
</code></pre></div>
<p>连接字典：</p>
<div class="highlight"><pre><span></span><code>user = &#39;username&#39;, password=&#39;xxx&#39;, host = &#39;hostname&#39;, port = &#39;2521&#39;, dbname = &#39;database_name&#39;, load_balance=&#39;true&#39;, topology_keys=&#39;cloud.region.zone1,cloud.region.zone2&#39;
</code></pre></div>
<p>以下是用于连接到BMDB的连接字符串示例： </p>
<div class="highlight"><pre><span></span><code>conn = psycopg2.connect(dbname=&#39;bigmath&#39;,host=&#39;localhost&#39;,port=&#39;2521&#39;,user=&#39;bigmath&#39;,password=&#39;bigmath&#39;,load_balance=&#39;true&#39;)
</code></pre></div>
<p>在驱动程序建立初始连接后，它会从集群中获取可用服务器的列表，并在这些服务器上负载平衡后续的连接请求。</p>
<p>1) 使用多个地址
   您可以在连接字符串中指定多个主机，以便在初始连接期间提供备用选项，以防主地址出现故障。 </p>
<p>使用逗号分隔地址，如下所示：</p>
<div class="highlight"><pre><span></span><code>conn = psycopg2.connect(dbname=&#39;bigmath&#39;,host=&#39;host1,host2,host3&#39;,port=&#39;2521&#39;,user=&#39;bigmath&#39;,password=&#39;bigmath&#39;,load_balance=&#39;true&#39;)
</code></pre></div>
<p>主机仅在初始连接尝试期间使用。如果驱动程序连接时第一台主机关闭，则驱动程序会尝试连接到字符串中的下一台主机，依此类推。</p>
<p>2) 使用SSL
   下表介绍了使用SSL进行连接所需的连接参数。 </p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>sslmode</td>
<td>SSL 模式</td>
<td>prefer</td>
</tr>
<tr>
<td>sslrootcert</td>
<td>计算机上根证书的路径</td>
<td>~/.postgresql/</td>
</tr>
</tbody>
</table>
<p>以下是在启用SSL的情况下连接到BMDB集群的示例：</p>
<div class="highlight"><pre><span></span><code>conn = psycopg2.connect(&quot;host=&lt;hostname&gt; port=2521 dbname=bigmath user=&lt;username&gt; password=&lt;password&gt; load_balance=true sslmode=verify-full sslrootcert=/path/to/root.crt&quot;)
</code></pre></div>
<p>步骤3：写应用
在项目的基本包目录中创建一个名为QuickStartApp.py的新Python文件。
复制以下示例代码以设置表并查询表内容。如果需要，请使用集群凭据和SSL证书替换连接字符串connString。 </p>
<div class="highlight"><pre><span></span><code>import psycopg2

# Create the database connection.

connString = &quot;host=127.0.0.1 port=2521 dbname=bigmath user=bigmath password=bigmath load_balance=True&quot;

conn = psycopg2.connect(connString)

# Open a cursor to perform database operations.
# The default mode for psycopg2 is &quot;autocommit=false&quot;.

conn.set_session(autocommit=True)
cur = conn.cursor()

# Create the table. (It might preexist.)

cur.execute(
  &quot;&quot;&quot;
  DROP TABLE IF EXISTS employee
  &quot;&quot;&quot;)

cur.execute(
  &quot;&quot;&quot;
  CREATE TABLE employee (id int PRIMARY KEY,
                        name varchar,
                        age int,
                        language varchar)
  &quot;&quot;&quot;)
print(&quot;Created table employee&quot;)
cur.close()

# Take advantage of ordinary, transactional behavior for DMLs.

conn.set_session(autocommit=False)
cur = conn.cursor()

# Insert a row.

cur.execute(&quot;INSERT INTO employee (id, name, age, language) VALUES (%s, %s, %s, %s)&quot;,
            (1, &#39;John&#39;, 35, &#39;Python&#39;))
print(&quot;Inserted (id, name, age, language) = (1, &#39;John&#39;, 35, &#39;Python&#39;)&quot;)

# Query the row.

cur.execute(&quot;SELECT name, age, language FROM employee WHERE id = 1&quot;)
row = cur.fetchone()
print(&quot;Query returned: %s, %s, %s&quot; % (row[0], row[1], row[2]))

# Commit and close down.

conn.commit()
cur.close()
conn.close()
</code></pre></div>
<p>3.7.5.2.1.1.2. <em>运行应用程序</em>
使用以下命令运行项目QuickStartApp.py： </p>
<div class="highlight"><pre><span></span><code>python3 QuickStartApp.py
</code></pre></div>
<p>您应该看到类似于以下内容的输出： </p>
<div class="highlight"><pre><span></span><code>Created table employee
Inserted (id, name, age, language) = (1, &#39;John&#39;, 35, &#39;Python&#39;)
Query returned: John, 35, Python
</code></pre></div>
<p>如果没有输出或出现错误，请验证连接字符串中包含的参数。</p>
<p>3.7.5.2.1.1.3. <em>限制</em></p>
<p>目前，PostgreSQL psycopg2驱动程序和BMDB psycopg2智能驱动程序不能在同一环境中使用。</p>
<h6 id="postgresql-psycopg2">PostgreSQL Psycopg2 驱动</h6>
<p>Psycopg是最流行的用于Python的PostgreSQL数据库适配器。其主要功能是Python DB API 2.0规范的完整实现和线程安全性（多个线程可以共享同一连接）。BMDB完全支持Psycopg2</p>
<p>3.7.5.2.1.2.1. <em>CRUD 操作</em>
以下部分演示如何使用PostgreSQL Psycopg2驱动程序执行Python应用程序开发所需的常见任务。</p>
<p>若要开始构建应用程序，请确保满足先决条件。</p>
<p>步骤1：下载驱动程序依赖项</p>
<p>构建Psycopg需要一些先决条件（C编译器、一些开发包）。请参阅Psycopg文档中的安装和常见问题解答。</p>
<p>如果满足先决条件，您可以像安装任何其他Python包一样安装psycopg，使用pip从PyPI下载： </p>
<div class="highlight"><pre><span></span><code>pip install psycopg2
</code></pre></div>
<p>或者，如果您已经在本地下载了源程序包，请使用setup.py： </p>
<div class="highlight"><pre><span></span><code>python setup.py build
sudo python setup.py install
</code></pre></div>
<p>您也可以通过从PyPI安装psycopg2二进制包来获得独立的包，而不需要编译器或外部库： </p>
<div class="highlight"><pre><span></span><code>pip install psycopg2-binary
</code></pre></div>
<p>二进制包是开发和测试的实用选择，但在生产中，建议使用从源代码构建的包。</p>
<p>步骤2：连接到集群 </p>
<p>下表介绍了连接所需的连接参数。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>user</td>
<td>连接数据库的用户</td>
<td>bigmath</td>
</tr>
<tr>
<td>password</td>
<td>用户密码</td>
<td>bigmath</td>
</tr>
<tr>
<td>host</td>
<td>BMDB实例的主机名</td>
<td>localhost</td>
</tr>
<tr>
<td>port</td>
<td>BSQL监听端口</td>
<td>2521</td>
</tr>
<tr>
<td>database/dbname</td>
<td>数据库名</td>
<td>bigmath</td>
</tr>
</tbody>
</table>
<p>您可以通过以下方式之一提供连接详细信息：</p>
<p>连接字符串：</p>
<div class="highlight"><pre><span></span><code>&quot;dbname=database_name host=hostname port=port user=username password=password&quot;
</code></pre></div>
<p>连接字典：</p>
<div class="highlight"><pre><span></span><code>user = &#39;username&#39;, password=&#39;xxx&#39;, host = &#39;hostname&#39;, port = &#39;port&#39;, dbname = &#39;database_name&#39;
</code></pre></div>
<p>以下是用于连接到BMDB的连接字符串示例。 </p>
<div class="highlight"><pre><span></span><code>conn = psycopg2.connect(dbname=&#39;bigmath&#39;,host=&#39;localhost&#39;,port=&#39;2521&#39;,user=&#39;bigmath&#39;,password=&#39;bigmath&#39;)
</code></pre></div>
<p>1） 使用SSL</p>
<p>下表介绍了使用SSL进行连接所需的连接参数。 </p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>sslmode</td>
<td>SSL 模式</td>
<td>prefer</td>
</tr>
<tr>
<td>sslrootcert</td>
<td>计算机上根证书的路径</td>
<td>~/.postgresql/</td>
</tr>
</tbody>
</table>
<p>以下是在启用SSL加密的情况下连接到BMDB的示例： </p>
<div class="highlight"><pre><span></span><code>conn = psycopg2.connect(&quot;host=&lt;hostname&gt; port=2521 dbname=bigmath user=&lt;username&gt; password=&lt;password&gt; sslmode=verify-full sslrootcert=/Users/my-user/Downloads/root.crt&quot;)
</code></pre></div>
<p>步骤3：写应用</p>
<p>在项目的基本包目录中创建一个名为QuickStartApp.py的新Python文件。</p>
<p>复制以下示例代码以设置表并查询表内容。如果需要，请使用集群凭据和SSL证书替换连接字符串connString。 </p>
<div class="highlight"><pre><span></span><code>import psycopg2

# Create the database connection.

connString = &quot;host=127.0.0.1 port=2521 dbname=bigmath user=bigmath password=bigmath&quot;

conn = psycopg2.connect(connString)

# Open a cursor to perform database operations.
# The default mode for psycopg2 is &quot;autocommit=false&quot;.

conn.set_session(autocommit=True)
cur = conn.cursor()

# Create the table. (It might preexist.)

cur.execute(
  &quot;&quot;&quot;
  DROP TABLE IF EXISTS employee
  &quot;&quot;&quot;)

cur.execute(
  &quot;&quot;&quot;
  CREATE TABLE employee (id int PRIMARY KEY,
                        name varchar,
                        age int,
                        language varchar)
  &quot;&quot;&quot;)
print(&quot;Created table employee&quot;)
cur.close()

# Take advantage of ordinary, transactional behavior for DMLs.

conn.set_session(autocommit=False)
cur = conn.cursor()

# Insert a row.

cur.execute(&quot;INSERT INTO employee (id, name, age, language) VALUES (%s, %s, %s, %s)&quot;,
            (1, &#39;John&#39;, 35, &#39;Python&#39;))
print(&quot;Inserted (id, name, age, language) = (1, &#39;John&#39;, 35, &#39;Python&#39;)&quot;)

# Query the row.

cur.execute(&quot;SELECT name, age, language FROM employee WHERE id = 1&quot;)
row = cur.fetchone()
print(&quot;Query returned: %s, %s, %s&quot; % (row[0], row[1], row[2]))

# Commit and close down.

conn.commit()
cur.close()
conn.close()
</code></pre></div>
<p>使用以下命令运行项目QuickStartApp.py：</p>
<div class="highlight"><pre><span></span><code>python3 QuickStartApp.py
</code></pre></div>
<p>您应该看到类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>Created table employee
Inserted (id, name, age, language) = (1, &#39;John&#39;, 35, &#39;Python&#39;)
Query returned: John, 35, Python
</code></pre></div>
<p>如果没有输出或出现错误，请验证连接字符串中包含的参数。
3.7.5.2.1.2.2. <em>限制</em></p>
<p>目前，PostgreSQL psycopg2驱动程序和BMDB psycopg2智能驱动程序不能在同一环境中使用。 </p>
<h6 id="aiopg">aiopg</h6>
<p>以下教程创建了一个基本的Python应用程序，该应用程序使用aiopg数据库适配器连接到BMDB 集群，执行一些基本的数据库操作——创建表、插入数据和运行SQL查询——并将结果打印到屏幕上
3.7.5.2.1.3.1. <em>先决条件</em>
在开始使用Aiopg之前，请确保您具备以下条件：</p>
<ul>
<li>
<p>BMDB 启动并运行。如果您是BMDB 的新手，请按照快速入门中的步骤在几分钟内启动并运行BMDB 。</p>
</li>
<li>
<p>已安装Python 3或更高版本。</p>
</li>
<li>
<p>aiopg包已安装。使用以下命令安装程序包：</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code>pip3install aiopg
</code></pre></div>
<p>有关使用此数据库适配器的详细信息，请参阅aiopg文档。 </p>
<p>3.7.5.2.1.3.2. <em>创建示例Python应用程序</em>
创建一个文件bm-sql-helloworld.py并复制以下代码： </p>
<div class="highlight"><pre><span></span><code>import asyncio
import aiopg

dsn = &#39;dbname=bigmath user=bigmath password=bigmath host=127.0.0.1 port=2521&#39;

async def go():
    async with aiopg.create_pool(dsn) as pool:
        async with pool.acquire() as conn:
            # Open a cursor to perform database operations.
            async with conn.cursor() as cur:
                await cur.execute(f&quot;&quot;&quot;
                  DROP TABLE IF EXISTS employee;
                  CREATE TABLE employee (id int PRIMARY KEY,
                             name varchar,
                             age int,
                             language varchar);
                &quot;&quot;&quot;)
                print(&quot;Created table employee&quot;)
                # Insert a row.
                await cur.execute(&quot;INSERT INTO employee (id, name, age, language) VALUES (%s, %s, %s, %s)&quot;,
                                  (1, &#39;John&#39;, 35, &#39;Python&#39;))
                print(&quot;Inserted (id, name, age, language) = (1, &#39;John&#39;, 35, &#39;Python&#39;)&quot;)

                # Query the row.
                await cur.execute(&quot;SELECT name, age, language FROM employee WHERE id = 1&quot;)
                async for row in cur:
                    print(&quot;Query returned: %s, %s, %s&quot; % (row[0], row[1], row[2]))


loop = asyncio.get_event_loop()
loop.run_until_complete(go())
</code></pre></div>
<p>3.7.5.2.1.3.3. <em>运行应用程序</em></p>
<p>要使用该应用程序，请运行以下Python脚本： </p>
<div class="highlight"><pre><span></span><code>python bm-sql-helloworld.py
</code></pre></div>
<p>您应该看到以下输出：</p>
<div class="highlight"><pre><span></span><code>Created table employee
Inserted (id, name, age, language) = (1, &#39;John&#39;, 35, &#39;Python&#39;)
Query returned: John, 35, Python
</code></pre></div>
<h5 id="bcql_10"><strong>BCQL</strong></h5>
<h6 id="bmdb-python">BMDB Python 驱动</h6>
<p>3.7.5.2.2.1.1. <em>为BCQL安装</em><em>BMDB</em><em>Python驱动程序</em>
要安装BCQL的BMDB Python驱动程序，请运行以下命令： </p>
<div class="highlight"><pre><span></span><code>pip3 install bm-cassandra-driver --install-option=&quot;--no-cython&quot;
</code></pre></div>
<p>3.7.5.2.2.1.2. <em>创建示例Python应用程序</em>
1） 先决条件
本教程假设您具备：
安装了BMDB ，创建了一个universe，并能够使用BCQL shell与之交互。如果没有，请按照“快速入门”中的步骤进行操作。 </p>
<p>2） 编写示例Python应用程序
创建一个文件bm-cql-helloworld.py，并将以下内容复制到其中。</p>
<div class="highlight"><pre><span></span><code>from cassandra.cluster import Cluster

# Create the cluster connection.
cluster = Cluster([&#39;127.0.0.1&#39;])
session = cluster.connect()

# Create the keyspace.
session.execute(&#39;CREATE KEYSPACE IF NOT EXISTS bmdbdemo;&#39;)
print(&quot;Created keyspace bmdbdemo&quot;)

# Create the table.
session.execute(
  &quot;&quot;&quot;
  CREATE TABLE IF NOT EXISTS bmdbdemo.employee (id int PRIMARY KEY,
                                              name varchar,
                                              age int,
                                              language varchar);
  &quot;&quot;&quot;)
print(&quot;Created table employee&quot;)

# Insert a row.
session.execute(
  &quot;&quot;&quot;
  INSERT INTO bmdbdemo.employee (id, name, age, language)
  VALUES (1, &#39;John&#39;, 35, &#39;Python&#39;);
  &quot;&quot;&quot;)
print(&quot;Inserted (id, name, age, language) = (1, &#39;John&#39;, 35, &#39;Python&#39;)&quot;)

# Query the row.
rows = session.execute(&#39;SELECT name, age, language FROM bmdbdemo.employee WHERE id = 1;&#39;)
for row in rows:
  print(row.name, row.age, row.language)

# Close the connection.
cluster.shutdown()
</code></pre></div>
<p>使用SSL</p>
<p>要使用SSL运行应用程序，请使用其他SSL导入和参数创建集群连接，如下所述： </p>
<div class="highlight"><pre><span></span><code># Include additional imports.
from ssl import SSLContext, PROTOCOL_TLS_CLIENT, CERT_REQUIRED
from cassandra.auth import PlainTextAuthProvider

# Include additional parameters.
ssl_context = SSLContext(PROTOCOL_TLS_CLIENT)
ssl_context.load_verify_locations(&#39;path to certs file&#39;)
ssl_context.verify_mode = CERT_REQUIRED

# Create the cluster connection.
cluster = Cluster(contact_points=[&#39;ip_address&#39;],
    ssl_context=ssl_context,
    ssl_options={&#39;server_hostname&#39;: &#39;ip_address&#39;},
    auth_provider=PlainTextAuthProvider(username=&#39;username&#39;, password=&#39;password&#39;))
session = cluster.connect()
</code></pre></div>
<p>3.7.5.2.2.1.3. <em>运行应用程序</em></p>
<p>要运行应用程序，请键入以下内容： </p>
<div class="highlight"><pre><span></span><code>python3 bm-cql-helloworld.py
</code></pre></div>
<p>您应该看到以下输出。</p>
<div class="highlight"><pre><span></span><code>Created keyspace bmdbdemo
Created table employee
Inserted (id, name, age, language) = (1, &#39;John&#39;, 35, &#39;Python&#39;)
John 35 Python
</code></pre></div>
<h4 id="orm_2"><strong>使用ORM</strong></h4>
<h5 id="sql-alchemy-orm"><strong>SQL Alchemy ORM</strong></h5>
<p>SQL Alchemy是Python应用程序的一个流行的ORM提供程序，被Python开发人员广泛用于数据库访问。BMDB提供了对SQL Alchemy ORM的全面支持。</p>
<h6 id="crud_5">CRUD操作</h6>
<p>了解如何建立与BMDB数据库的连接，并使用Python ORM示例应用程序页面中的步骤开始基本的CRUD操作。</p>
<p>以下部分演示如何使用SQL Alchemy ORM执行Python应用程序开发所需的常见任务。</p>
<p>添加SQL Alchemy ORM依赖项</p>
<p>要下载SQL Alchemy并将其安装到您的项目中，请使用以下命令。 </p>
<div class="highlight"><pre><span></span><code>pip3 install sqlalchemy
</code></pre></div>
<p>您可以按照以下方式验证安装：</p>
<p>1） 通过执行以下命令打开Python提示： </p>
<div class="highlight"><pre><span></span><code>python3
</code></pre></div>
<p>2） 在Python提示下，执行以下命令以检查SQLAlchemy版本： </p>
<div class="highlight"><pre><span></span><code>import sqlalchemy
</code></pre></div>
<div class="highlight"><pre><span></span><code>sqlalchemy.__version__
</code></pre></div>
<p>实现BMDB的ORM映射</p>
<p>要从SQLAlchemy开始，请在项目目录中创建4个Python文件-config.py、base.py、model.py和main.py</p>
<p>1） config.py包含连接到数据库的凭据。将以下示例代码复制到config.py文件中。 </p>
<div class="highlight"><pre><span></span><code> db_user = &#39;bigmath&#39;
 db_password = &#39;bigmath&#39;
 database = &#39;bigmath&#39;
 db_host = &#39;localhost&#39;
 db_port = 2521
</code></pre></div>
<p>2） 接下来，声明一个映射。使用ORM时，配置过程首先描述将要使用的数据库表，然后定义映射到这些表的类。在现代SQLAlchemy中，这两个任务通常一起执行，使用一个称为声明扩展的系统。使用声明性系统映射的类是根据基类定义的，该基类维护相对于该基类的类和表的目录，这被称为声明性基类。使用declarative_base()函数创建基类。将以下代码添加到base.py文件中。 </p>
<div class="highlight"><pre><span></span><code>from sqlalchemy.ext.declarative import declarative_base
Base = declarative_base()
</code></pre></div>
<p>3） 既然有了基础，就可以根据它定义任意数量的映射类。从一个名为employees的表开始，为使用应用程序的最终用户存储记录。一个名为Employee的新类映射到此表。在类中，定义要映射到的表的详细信息；主要是表名、列的名称和数据类型。将以下内容添加到model.py文件中：</p>
<div class="highlight"><pre><span></span><code>from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Table, Column, Integer, String, DateTime, ForeignKey
from base import Base

class Employee(Base):

  __tablename__ = &#39;employees&#39;

  id = Column(Integer, primary_key=True)
  name = Column(String(255), unique=True, nullable=False)
  age = Column(Integer)
  language = Column(String(255))
</code></pre></div>
<p>4） 设置完成后，您可以连接到数据库并创建一个新会话。在main.py文件中，添加以下内容：</p>
<div class="highlight"><pre><span></span><code>import config as cfg
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy import create_engine
from sqlalchemy import MetaData
from model import Employee
from base import Base
from sqlalchemy import Table, Column, Integer, String, DateTime, ForeignKey

# create connection
engine = create_engine(&#39;postgresql://{0}:{1}@{2}:{3}/{4}&#39;.format(cfg.db_user, cfg.db_password, cfg.db_host, cfg.db_port, cfg.database))

# create metadata
Base.metadata.create_all(engine)

# create session
Session = sessionmaker(bind=engine)
session = Session()

# insert data
tag_1 = Employee(name=&#39;Bob&#39;, age=21, language=&#39;Python&#39;)
tag_2 = Employee(name=&#39;John&#39;, age=35, language=&#39;Java&#39;)
tag_3 = Employee(name=&#39;Ivy&#39;, age=27, language=&#39;C++&#39;)

session.add_all([tag_1, tag_2, tag_3])

# Read the inserted data

print(&#39;Query returned:&#39;)
for instance in session.query(Employee):
    print(&quot;Name: %s Age: %s Language: %s&quot;%(instance.name, instance.age, instance.language))
session.commit()
</code></pre></div>
<p>当您运行main.py文件时，您应该得到类似于以下内容的输出： </p>
<div class="highlight"><pre><span></span><code>Query returned:
Name: Bob Age: 21 Language: Python
Name: John Age: 35 Language: Java
Name: Ivy Age: 27 Language: C++
</code></pre></div>
<h5 id="django-orm"><strong>Django ORM</strong></h5>
<p>Django是一个高级Python web框架，它鼓励快速开发和干净、实用的设计。</p>
<h6 id="crud_6">CRUD操作</h6>
<p>了解如何建立与BMDB数据库的连接，并使用Python ORM示例应用程序页面中的步骤开始基本的CRUD操作。</p>
<p>以下部分演示如何使用Django ORM执行Python应用程序开发所需的常见任务。</p>
<h6 id="_237"># <em>添加依赖项</em></h6>
<p>要将Django Rest Framework下载到您的项目中，请运行以下命令： </p>
<div class="highlight"><pre><span></span><code>pip3 install djangorestframework
</code></pre></div>
<p>此外，使用以下命令安装Django的BM后端：</p>
<div class="highlight"><pre><span></span><code>pip3 install django-bigmathdb
</code></pre></div>
<h6 id="bmdborm"># <em>实现</em><em>BMDB</em><em>的ORM映射</em></h6>
<p>1) 安装完依赖项后，启动一个Django项目，并使用以下命令创建一个新的应用程序： </p>
<div class="highlight"><pre><span></span><code>django-admin startproject bigmathTest &amp;&amp; cd bigmathTest/
</code></pre></div>
<p>2) 使用以下命令设置一个新的Django应用程序： </p>
<div class="highlight"><pre><span></span><code>python manage.py startapp testdb
</code></pre></div>
<p>3) 创建应用程序后，将其配置为连接到数据库。要执行此操作，请更改应用程序设置以提供数据库凭据。为了使用BMDB获得更好的性能，请使用持久连接（设置CONN_MAX_AGE）。在文件bigmathTest/settings.py中添加以下代码： </p>
<div class="highlight"><pre><span></span><code>DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django_bigmathdb&#39;,
        &#39;NAME&#39;: &#39;bigmath&#39;,
        &#39;HOST&#39;: &#39;localhost&#39;,
        &#39;PORT&#39;: 2521,
        &#39;USER&#39;: &#39;bigmath&#39;,
        &#39;CONN_MAX_AGE&#39;: None,
        &#39;PASSWORD&#39;: &#39;bigmath&#39;
    }
}
</code></pre></div>
<p>4) 您需要INSTALLED_APPS字段中的应用程序和rest框架。将现有代码替换为以下代码： </p>
<div class="highlight"><pre><span></span><code>INSTALLED_APPS = [
    &#39;rest_framework&#39;,
    &#39;testdb.apps.TestdbConfig&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.auth&#39;,
]

REST_FRAMEWORK = {
    &#39;DEFAULT_AUTHENTICATION_CLASSES&#39;: [],
    &#39;DEFAULT_PERMISSION_CLASSES&#39;: [],
    &#39;UNAUTHENTICATED_USER&#39;: None,
}
</code></pre></div>
<p>5) 下一步是为表创建一个模型。表名为users，包含四列——user_id、firstName、lastName和email。
   将以下代码添加到testdb/models.py中： </p>
<div class="highlight"><pre><span></span><code>rom django.db import models

class Users(models.Model):
    userId = models.AutoField(db_column=&#39;user_id&#39;, primary_key=True, serialize=False)
    firstName = models.CharField(max_length=50, db_column=&#39;first_name&#39;)
    lastName = models.CharField(max_length=50, db_column=&#39;last_name&#39;)
    email = models.CharField(max_length=100, db_column=&#39;user_email&#39;)

    class Meta:
        db_table = &quot;users&quot;

    def __str__(self):
        return &#39;%d %s %s %s&#39; % (self.userId, self.firstName, self.lastName, self.email)
</code></pre></div>
<p>6) 创建模型后，您需要创建一个序列化程序。序列化程序允许将查询集和模型实例等复杂数据转换为原生Python数据类型，然后将其呈现为JSON、XML或其他内容类型。序列化程序还提供反序列化，允许在首次验证传入数据后将解析的数据转换回复杂类型。</p>
<p>将以下代码复制到testdb\serializers.py中： </p>
<div class="highlight"><pre><span></span><code>from rest_framework import serializers, status
from testdb.models import Users
from django.core.exceptions import ValidationError

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = Users
        fields = (&#39;userId&#39;, &#39;firstName&#39;, &#39;lastName&#39;, &#39;email&#39;)
</code></pre></div>
<p>7) 要完成应用程序的所有元素，请创建一个ViewSet。在testdb/views.py中，添加以下代码：</p>
<div class="highlight"><pre><span></span><code>from django.shortcuts import render
from testdb.models import Users
from rest_framework import viewsets
from testdb.serializers import UserSerializer

class UserViewSet(viewsets.ModelViewSet):
    queryset = Users.objects.all()
    serializer_class = UserSerializer
</code></pre></div>
<p>8) 最后，通过添加以下代码在bigmathTest/uls.py中映射URL： </p>
<div class="highlight"><pre><span></span><code>from django.urls import include, re_path
from rest_framework import routers
from testdb.views import UserViewSet

router = routers.SimpleRouter(trailing_slash=False)
router.register(r&#39;users&#39;, UserViewSet)
urlpatterns = [
    re_path(r&#39;^&#39;, include(router.urls))
]
</code></pre></div>
<p>对于4.0之前的Django版本，请使用以下代码，因为您可以使用Django.conf.uls导入URL：</p>
<div class="highlight"><pre><span></span><code>from django.urls import path, include
from django.conf.urls import url, include
from rest_framework import routers
from testdb.views import UserViewSet

router = routers.SimpleRouter(trailing_slash=False)
router.register(r&#39;users&#39;, UserViewSet)

urlpatterns = [
    url(r&#39;^&#39;, include(router.urls))
]
</code></pre></div>
<p>9) 这就完成了测试应用程序的配置。接下来的步骤是创建迁移文件并将迁移应用于数据库。要执行此操作，请运行以下命令： </p>
<div class="highlight"><pre><span></span><code>python3 manage.py makemigrations
python3 manage.py migrate
</code></pre></div>
<p>应该在数据库中创建一个用户表。使用sqlsh客户端shell验证users表是否已创建</p>
<h6 id="_238"># <em>运行应用程序</em></h6>
<p>要运行应用程序并插入新行，请执行以下步骤。</p>
<p>1) 使用以下命令运行Django项目： </p>
<div class="highlight"><pre><span></span><code>python3 manage.py runserver 8080
</code></pre></div>
<p>2) 使用以下命令插入一行：</p>
<div class="highlight"><pre><span></span><code>curl --data &#39;{ &quot;firstName&quot; : &quot;John&quot;, &quot;lastName&quot; : &quot;Smith&quot;, &quot;email&quot; : &quot;jsmith@bmdb.com&quot; }&#39; \
      -v -X POST -H &#39;Content-Type:application/json&#39; http://localhost:8080/users
</code></pre></div>
<p>3) 使用以下命令验证是否已插入新行：</p>
<div class="highlight"><pre><span></span><code>curl http://localhost:8080/users
</code></pre></div>
<p>您应该看到以下输出： </p>
<div class="highlight"><pre><span></span><code>[{&quot;userId&quot;:1,&quot;firstName&quot;:&quot;John&quot;,&quot;lastName&quot;:&quot;Smith&quot;,&quot;email&quot;:&quot;jsmith@bmdb.com&quot;}]
</code></pre></div>
<p>您也可以使用sqlsh客户端shell来验证这一点。</p>
<h3 id="nodejs_2"><strong>Node.js</strong></h3>
<h4 id="_239"><strong>概述</strong></h4>
<h5 id="_240"><strong>支持的项目</strong></h5>
<p>建议以下项目用于使用BMDB BSQL和BCQL API实现Node应用程序。</p>
<table>
<thead>
<tr>
<th>驱动</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>BMDB node-postgres Smart Driver</td>
<td>8.7.3-bm-1</td>
</tr>
<tr>
<td>PostgreSQL node-postgres Driver</td>
<td>8.7.3</td>
</tr>
<tr>
<td>BMDB Node.js Driver for BCQL</td>
<td>4.0.0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>项目</th>
<th>APP 示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sequelize</td>
<td>Sequelize ORM App</td>
</tr>
<tr>
<td>Prisma</td>
<td>Prisma ORM App</td>
</tr>
</tbody>
</table>
<p>了解如何建立与BMDB 数据库的连接，并通过参考连接应用程序或使用ORM开始基本的CRUD操作。</p>
<h5 id="_241"><strong>先决条件</strong></h5>
<p>要为BMDB 开发Node.js应用程序，您需要以下内容：</p>
<ul>
<li>Node.js</li>
</ul>
<p>要下载并安装Node.js，请参阅Node.js文档。</p>
<p>要检查节点的版本，请使用以下命令：</p>
<div class="highlight"><pre><span></span><code>node -v
</code></pre></div>
<ul>
<li>创建node.js项目</li>
</ul>
<p>创建一个扩展名为.js的文件（例如app.js），可以使用以下命令运行：</p>
<div class="highlight"><pre><span></span><code>node app.js
</code></pre></div>
<h4 id="_242"><strong>应用连接</strong></h4>
<h5 id="bsql_11"><strong>BSQL</strong></h5>
<h6 id="bmdb-node-postgres">BMDB node-postgres智能驱动程序</h6>
<p>BMDB node-postgres智能驱动程序是BSQL的node.js驱动程序，构建在PostgreSQL node-postgres驱动程序上，具有额外的连接负载平衡功能。
3.7.6.2.1.1.1. <em>CRUD 操作</em>
以下部分演示如何使用BMDB node-postgres智能驱动程序执行Node.js应用程序开发所需的常见任务。
若要开始构建应用程序，请确保满足先决条件。</p>
<p>步骤1：下载驱动程序依赖项
使用以下命令下载并安装BMDB node-postgres智能驱动程序（您需要在系统上安装node.js）：</p>
<div class="highlight"><pre><span></span><code>npm install @bigmathdb/pg
</code></pre></div>
<p>您可以开始在代码中使用驱动程序。</p>
<p>步骤2：设置数据库连接
下表描述了连接所需的连接参数，包括用于统一和拓扑负载平衡的智能驱动程序参数。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>host</td>
<td>BMDB实例的主机名，也可输入多个地址。</td>
<td>localhost</td>
</tr>
<tr>
<td>port</td>
<td>BSQL监听端口</td>
<td>2521</td>
</tr>
<tr>
<td>database</td>
<td>数据库名</td>
<td>bigmath</td>
</tr>
<tr>
<td>user</td>
<td>连接到数据库的用户</td>
<td>bigmath</td>
</tr>
<tr>
<td>password</td>
<td>用户密码</td>
<td>bigmath</td>
</tr>
<tr>
<td>loadBalance</td>
<td>负载平衡</td>
<td>默认为上游驱动程序行为，除非设置为“true”</td>
</tr>
<tr>
<td>bmServersRefreshInterval</td>
<td>如果load_balance为true，则刷新服务器列表的间隔（以秒为单位）</td>
<td>300</td>
</tr>
<tr>
<td>topologyKeys</td>
<td>拓扑感知负载平衡</td>
<td>如果loadBalance为true，则使用统一负载平衡，除非设置为cloud.region.zone形式的逗号分隔地理位置。</td>
</tr>
</tbody>
</table>
<p>创建一个客户端，使用连接字符串连接到集群。以下是连接到具有统一和拓扑负载平衡的BMDB集群的连接字符串示例：</p>
<div class="highlight"><pre><span></span><code>postgresql://bigmath:bigmath@128.0.0.1:2521/bigmath?loadBalance=true? \
    bmServersRefreshInterval=240&amp; \
    topologyKeys=cloud.region.zone1,cloud.region.zone2
</code></pre></div>
<p>在驱动程序建立初始连接后，它会从集群中获取可用服务器的列表，并在这些服务器之间负载平衡后续的连接请求。</p>
<p>使用SSL
下表介绍了使用TLS/SSL进行连接所需的连接参数。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>sslmode</td>
<td>SSL 模式</td>
<td>require</td>
</tr>
<tr>
<td>sslrootcert</td>
<td>计算机上根证书的路径</td>
<td>~/.postgresql/</td>
</tr>
</tbody>
</table>
<p>以下是用于连接到启用SSL的BMDB集群的连接字符串示例。</p>
<div class="highlight"><pre><span></span><code>postgresql://bigmath:bigmath@128.0.0.1:2521/bigmath?loadBalance=true&amp;ssl=true&amp; \
    sslmode=verify-full&amp;sslrootcert=~/.postgresql/root.crt
</code></pre></div>
<p>有关默认和支持的SSL模式的更多信息，以及使用SSL时设置连接字符串的示例，请参阅配置SSL/TLS。</p>
<p>第3步：编写应用
在项目目录中创建一个名为QuickStartApp.js的新JavaScript文件。</p>
<p>复制以下示例代码以设置表并查询表内容。如果需要，请将连接字符串bmurl参数替换为群集凭据和SSL证书。</p>
<div class="highlight"><pre><span></span><code>const pg = require(&#39;@bigmathdb/pg&#39;);

function createConnection(){
    const bmdburl = &quot;postgresql://bigmath:bigmath@localhost:2521/bigmath?loadBalance=true&quot;;
    const client = new pg.Client(bmdburl);
    client.connect();
    return client;
}

async function createTableAndInsertData(client){
    console.log(&quot;Connected to the BMDB Cluster successfully.&quot;)
    await client.query(&quot;DROP TABLE IF EXISTS employee&quot;).catch((err)=&gt;{
        console.log(err.stack);
    })
    await client.query(&quot;CREATE TABLE IF NOT EXISTS employee&quot; +
                &quot;  (id int primary key, name varchar, age int, language text)&quot;).then(() =&gt; {
                    console.log(&quot;Created table employee&quot;);
                }).catch((err) =&gt; {
                    console.log(err.stack);
                })

    var insert_emp1 = &quot;INSERT INTO employee VALUES (1, &#39;John&#39;, 35, &#39;Java&#39;)&quot;
    await client.query(insert_emp1).then(() =&gt; {
        console.log(&quot;Inserted Employee 1&quot;);
    }).catch((err)=&gt;{
        console.log(err.stack);
    })
    var insert_emp2 = &quot;INSERT INTO employee VALUES (2, &#39;Sam&#39;, 37, &#39;JavaScript&#39;)&quot;
    await client.query(insert_emp2).then(() =&gt; {
        console.log(&quot;Inserted Employee 2&quot;);
    }).catch((err)=&gt;{
        console.log(err.stack);
    })
}

async function fetchData(client){
    try {
        const res = await client.query(&quot;select * from employee&quot;)
        console.log(&quot;Employees Information:&quot;)
        for (let i = 0; i&lt;res.rows.length; i++) {
          console.log(`${i+1}. name = ${res.rows[i].name}, age = ${res.rows[i].age}, language = ${res.rows[i].language}`)
        }
      } catch (err) {
        console.log(err.stack)
      }
}

(async () =&gt; {
    const client = createConnection();
    if(client){
        await createTableAndInsertData(client);
        await fetchData(client);
    }
})();
</code></pre></div>
<p>3.7.6.2.1.1.2. <em>运行应用程序</em>
使用以下命令运行应用程序QuickStartApp.js：</p>
<div class="highlight"><pre><span></span><code>node QuickStartApp.js
</code></pre></div>
<p>您应该看到类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>Connected to the BMDB Cluster successfully.
Created table employee
Inserted Employee 1
Inserted Employee 2
Employees Information:
1. name = John, age = 35, language = Java
2. name = Sam, age = 37, language = JavaScript
</code></pre></div>
<h6 id="postgresql-node-postgres">PostgreSQL node-postgres驱动程序</h6>
<p>PostgreSQL node-postgres驱动程序是PostgreSQL的官方node.js驱动程序，可用于连接BMDB BSQL API。由于BMDB BSQL API与PostgreSQL node-postgres（pg）驱动程序完全兼容，因此它允许node.js程序员连接到BMDB 数据库，使用node-postges API执行DML和DDL。
3.7.6.2.1.2.1. <em>CRUD 操作</em>
以下部分演示如何使用PostgreSQL node-postgres驱动程序执行Node.js应用程序开发所需的常见任务。
若要开始构建应用程序，请确保满足先决条件。</p>
<p>步骤1：安装驱动程序依赖项和异步实用程序
使用以下命令下载并安装node-postgres驱动程序（您需要在系统上安装node.js）：</p>
<div class="highlight"><pre><span></span><code>npm install pg
</code></pre></div>
<p>要安装异步实用程序，请运行以下命令：</p>
<div class="highlight"><pre><span></span><code>npm install --save async
</code></pre></div>
<p>您可以开始使用代码中的驱动程序</p>
<p>步骤2：设置数据库连接</p>
<p>下表介绍了连接所需的连接参数。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>user</td>
<td>连接数据库的用户</td>
<td>bigmath</td>
</tr>
<tr>
<td>password</td>
<td>用户密码</td>
<td>bigmath</td>
</tr>
<tr>
<td>host</td>
<td>BMDB实例的主机名</td>
<td>localhost</td>
</tr>
<tr>
<td>port</td>
<td>BSQL监听端口</td>
<td>2521</td>
</tr>
<tr>
<td>database</td>
<td>数据库名</td>
<td>bigmath</td>
</tr>
</tbody>
</table>
<p>在连接到BMDB集群之前，请导入pg包。</p>
<div class="highlight"><pre><span></span><code>const pg = require(&#39;pg&#39;);
</code></pre></div>
<p>创建一个客户端以使用连接字符串连接到群集。</p>
<div class="highlight"><pre><span></span><code>const connectionString = &quot;postgresql://user:password@localhost:port/database&quot;
const client = new Client(connectionString);
client.connect()
</code></pre></div>
<p>使用SSL</p>
<p>下表介绍了使用TLS/SSL进行连接所需的连接参数。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sslmode</td>
<td>SSL 模式</td>
</tr>
<tr>
<td>sslrootcert</td>
<td>计算机上根证书的路径</td>
</tr>
</tbody>
</table>
<p>默认情况下，驱动程序支持require SSL模式，在该模式下不需要配置根CA证书。这实现了Node.js客户端和BMDB服务器之间的SSL通信。</p>
<div class="highlight"><pre><span></span><code>const config = {
  user: &#39; &#39;,
  database: &#39; &#39;,
  host: &#39; &#39;,
  password: &#39; &#39;,
  port: 2521,
  // this object will be passed to the TLSSocket constructor
  ssl: {
    rejectUnauthorized: false,
  },
}
</code></pre></div>
<p>第3步：编写应用</p>
<p>在项目目录中创建一个名为QuickStartApp.js的新JavaScript文件。</p>
<p>复制以下示例代码以设置表并查询表内容。如果需要，请使用群集凭据替换连接字符串参数。</p>
<div class="highlight"><pre><span></span><code>var pg = require(&#39;pg&#39;);
const async = require(&#39;async&#39;);
const assert = require(&#39;assert&#39;);

var connectionString = &quot;postgres://postgres@localhost:2521/postgres&quot;;
var client = new pg.Client(connectionString);

async.series([
  function connect(next) {
    client.connect(next);
  },
  function createTable(next) {
    // The create table statement.
    const create_table = &#39;CREATE TABLE employee (id int PRIMARY KEY, &#39; +
                                                 &#39;name varchar, &#39; +
                                                 &#39;age int, &#39; +
                                                 &#39;language varchar);&#39;;
    // Create the table.
    console.log(&#39;Creating table employee&#39;);
    client.query(create_table, next);
  },
  function insert(next) {
    // Create a variable with the insert statement.
    const insert = &quot;INSERT INTO employee (id, name, age, language) &quot; +
                                        &quot;VALUES (1, &#39;John&#39;, 35, &#39;NodeJS&#39;);&quot;;
    // Insert a row with the employee data.
    console.log(&#39;Inserting row with: %s&#39;, insert)
    client.query(insert, next);
  },
  function select(next) {
    // Query the row for employee id 1 and print the results to the console.
    const select = &#39;SELECT name, age, language FROM employee WHERE id = 1;&#39;;
    client.query(select, function (err, result) {
      if (err) return next(err);
      var row = result.rows[0];
      console.log(&#39;Query for id=1 returned: name=%s, age=%d, language=%s&#39;,
                                            row.name, row.age, row.language);
      next();
    });
  }
], function (err) {
  if (err) {
    console.error(&#39;There was an error&#39;, err.message, err.stack);
  }
  console.log(&#39;Shutting down&#39;);
  client.end();
});
</code></pre></div>
<p>使用以下命令运行应用程序QuickStartApp.js：</p>
<div class="highlight"><pre><span></span><code>node QuickStartApp.js
</code></pre></div>
<p>您应该看到类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>Creating table employee
Inserting row with: INSERT INTO employee (id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;NodeJS&#39;);
Query for id=1 returned: name=John, age=35, language=NodeJS
Shutting down
</code></pre></div>
<p>步骤4：使用SSL编写应用程序（可选）</p>
<p>如果使用SSL，请将以下示例代码复制到QuickStartApp.js，并根据集群的需要替换配置对象的值。</p>
<div class="highlight"><pre><span></span><code>var pg = require(&#39;pg&#39;);
const async = require(&#39;async&#39;);
const assert = require(&#39;assert&#39;);
const fs = require(&#39;fs&#39;);
const config = {
  user: &#39;admin&#39;,
  database: &#39;bigmath&#39;,
  host: &#39;22420e3a-768b-43da-8dcb-xxxxxx.aws.bmdbdb.io&#39;,
  password: &#39;xxxxxx&#39;,
  port: 2521,
  // this object will be passed to the TLSSocket constructor
  ssl: {
    rejectUnauthorized: false,
  },
}

var client = new pg.Client(config);

async.series([
  function connect(next) {
    client.connect(next);
  },
  function createTable(next) {
    // The create table statement.
    const create_table = &#39;CREATE TABLE IF NOT EXISTS employee (id int PRIMARY KEY, &#39; +
                                                               &#39;name varchar, &#39; +
                                                               &#39;age int, &#39; +
                                                               &#39;language varchar);&#39;;
    // Create the table.
    console.log(&#39;Creating table employee&#39;);
    client.query(create_table, next);
  },
  function insert(next) {
    // Create a variable with the insert statement.
    const insert = &quot;INSERT INTO employee (id, name, age, language) &quot; +
                                         &quot;VALUES (2, &#39;John&#39;, 35, &#39;NodeJS + SSL&#39;);&quot;;
    // Insert a row with the employee data.
    console.log(&#39;Inserting row with: %s&#39;, insert)
    client.query(insert, next);
  },
  function select(next) {
    // Query the row for employee id 2 and print the results to the console.
    const select = &#39;SELECT name, age, language FROM employee WHERE id = 2;&#39;;
    client.query(select, function (err, result) {
      if (err) return next(err);
      var row = result.rows[0];
      console.log(&#39;Query for id=2 returned: name=%s, age=%d, language=%s&#39;,
                                            row.name, row.age, row.language);
      next();
    });
  }
], function (err) {
  if (err) {
    console.error(&#39;There was an error&#39;, err.message, err.stack);
  }
  console.log(&#39;Shutting down&#39;);
  client.end();
});
</code></pre></div>
<p>使用以下命令运行应用程序QuickStartApp.js：</p>
<div class="highlight"><pre><span></span><code>node QuickStartApp.js
</code></pre></div>
<p>如果您使用SSL，您应该看到类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>Creating table employee
Inserting row with: INSERT INTO employee (id, name, age, language) VALUES (2, &#39;John&#39;, 35, &#39;NodeJS + SSL&#39;);
Query for id=2 returned: name=John, age=35, language=NodeJS + SSL
Shutting down
</code></pre></div>
<h5 id="bcql_11"><strong>BCQL</strong></h5>
<h6 id="bmdb-nodejs">BMDB Node.js 驱动</h6>
<p>3.7.6.2.2.1.1. <em>为BCQL安装</em><em>BMDB</em><em>Node.js</em><em>驱动程序</em>
要为BCQL安装BMDB Node.js驱动程序，请运行以下命令： </p>
<div class="highlight"><pre><span></span><code>npm install bm-bcql-driver
</code></pre></div>
<p>3.7.6.2.2.1.2. <em>创建示例Node.js应用程序</em>
1）先决条件</p>
<p>本教程假设您具备：</p>
<ul>
<li>
<p>安装了BMDB 并创建了一个集群。请参阅快速启动。</p>
</li>
<li>
<p>安装了最新版本的Node.js。</p>
</li>
<li>
<p>安装了async实用程序以使用异步Javascript。</p>
</li>
</ul>
<p>要安装异步实用程序，请运行以下命令：</p>
<div class="highlight"><pre><span></span><code>npm install --save async
</code></pre></div>
<p>2）编写示例Node.js应用程序</p>
<p>创建一个文件bm-cql-helloworld.js，并向其中添加以下内容。</p>
<div class="highlight"><pre><span></span><code>const ycql = require(&#39;bm-bcql-driver&#39;);
const async = require(&#39;async&#39;);
const assert = require(&#39;assert&#39;);

// Create a BMDB CQL client.
// DataStax Nodejs 4.0 loadbalancing default is TokenAwarePolicy with child DCAwareRoundRobinPolicy
// Need to provide localDataCenter option below or switch to RoundRobinPolicy
const loadBalancingPolicy = new ycql.policies.loadBalancing.RoundRobinPolicy ();
const client = new ycql.Client({ contactPoints: [&#39;127.0.0.1&#39;], policies : { loadBalancing : loadBalancingPolicy }});

async.series([
  function connect(next) {
    client.connect(next);
  },
  function createKeyspace(next) {
    console.log(&#39;Creating keyspace bmdbdemo&#39;);
    client.execute(&#39;CREATE KEYSPACE IF NOT EXISTS bmdbdemo;&#39;, next);
  },
  function createTable(next) {
    // The create table statement.
    const create_table = &#39;CREATE TABLE IF NOT EXISTS bmdbdemo.employee (id int PRIMARY KEY, &#39; +
                                                                     &#39;name varchar, &#39; +
                                                                     &#39;age int, &#39; +
                                                                     &#39;language varchar, &#39; +
                                                                     &#39;location jsonb);&#39;;
    // Create the table.
    console.log(&#39;Creating table employee&#39;);
    client.execute(create_table, next);
  },
  function insert(next) {
    // Create a variable with the insert statement.
    const insert = &quot;INSERT INTO bmdbdemo.employee (id, name, age, language, location) &quot; +
                                        &quot;VALUES (1, &#39;John&#39;, 35, &#39;NodeJS&#39;, &#39;{ \&quot;city\&quot;: \&quot;San Francisco\&quot;, \&quot;state\&quot;: \&quot;California\&quot;, \&quot;lat\&quot;: 37.77, \&quot;long\&quot;: 122.42 }&#39;);&quot;;
    // Insert a row with the employee data.
    console.log(&#39;Inserting row with: %s&#39;, insert)
    client.execute(insert, next);
  },
  function select(next) {

    // Query the row for employee id 1 and print the results to the console.
    const select = &#39;SELECT name, age, language, location FROM bmdbdemo.employee WHERE id = 1;&#39;;
    client.execute(select, function (err, result) {
      if (err) return next(err);
      var row = result.first();
      const city = row.location.city;
      console.log(&#39;Query for id=1 returned: name=%s, age=%d, language=%s, city=%s&#39;,
                                            row.name, row.age, row.language, city);
      next();
    });
  }
], function (err) {
  if (err) {
    console.error(&#39;There was an error&#39;, err.message, err.stack);
  }
  console.log(&#39;Shutting down&#39;);
  client.shutdown();
});
</code></pre></div>
<p>3）运行应用程序</p>
<p>要使用该应用程序，请运行以下命令：</p>
<div class="highlight"><pre><span></span><code>node bm-cql-helloworld.js
</code></pre></div>
<p>您应该看到以下输出。</p>
<div class="highlight"><pre><span></span><code>Creating keyspace bmdbdemo
Creating table employee
Inserting row with: INSERT INTO bmdbdemo.employee (id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;NodeJS&#39;);
Query for id=1 returned: name=John, age=35, language=NodeJS
Shutting down
</code></pre></div>
<h3 id="c_6"><strong>C</strong></h3>
<h4 id="_243"><strong>概述</strong></h4>
<h5 id="_244"><strong>支持的项目</strong></h5>
<p>建议以下项目用于使用BMDB BSQL API实现C应用程序。</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>应用示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>libpq C Driver</td>
<td>Hello World</td>
</tr>
</tbody>
</table>
<p>有关完全可运行的代码片段和常见操作的解释，请参阅示例应用程序。在运行示例应用程序之前，请确保已安装必备组件。</p>
<h5 id="_245"><strong>先决条件</strong></h5>
<p>要为BMDB开发C应用程序，您需要以下内容：</p>
<ul>
<li>机器和软件要求
  n 32位（x86）或64位（x64）体系结构的机器。
  n gcc 4.1.2或更新版本，clang 3.4或更新版本。</li>
</ul>
<h4 id="_246"><strong>应用连接</strong></h4>
<h5 id="bsql_12"><strong>BSQL</strong></h5>
<h6 id="libpq-c">libpq C驱动程序</h6>
<p>libpq是用于连接PostgreSQL数据库并与之交互的C客户端库。libpq也是其他PostgreSQL应用程序接口中使用的底层引擎。libpq客户端库支持SCRAM-SHA-256身份验证方法。
有关详细信息和文档，请参阅PostgreSQL 11的libpq-C库（BMDB基于此库）</p>
<p>1）先决条件
本教程假设您具备：</p>
<ul>
<li>安装了BMDB并创建了一个universe。如果没有，请按照“快速入门”中的步骤进行操作。</li>
<li>32位（x86）或64位（x64）体系结构的机器。</li>
<li>gcc 4.1.2或更新版本，clang 3.4或更新版本已安装。</li>
</ul>
<p>2）安装libpq C驱动程序</p>
<p>libpq C驱动程序包含在BMDB安装中。您可以通过如下设置LD_LIBRARY_PATH来使用它：</p>
<div class="highlight"><pre><span></span><code>export LD_LIBRARY_PATH=&lt;bigmath-install-dir&gt;/postgres/lib
</code></pre></div>
<p>或者，您可以从PostgreSQL下载页面下载PostgreSQL二进制文件和源代码，macOS上的Homebrew用户可以使用brew install libpq安装libpq</p>
<p>3）创建示例C应用程序
示例C代码
创建一个文件bmdbsql_hello_world.c，并复制以下内容：</p>
<div class="highlight"><pre><span></span><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;libpq-fe.h&quot;

int
main(int argc, char **argv)
{
  const char *conninfo;
  PGconn     *conn;
  PGresult   *res;
  int         nFields;
  int         i, j;

  /* connection string */
  conninfo = &quot;host=127.0.0.1 port=2521 dbname=bigmath user=bigmath password=bigmath&quot;;

  /* Make a connection to the database */
  conn = PQconnectdb(conninfo);

  /* Check to see that the backend connection was successfully made */
  if (PQstatus(conn) != CONNECTION_OK)
  {
      fprintf(stderr, &quot;Connection to database failed: %s&quot;,
        PQerrorMessage(conn));
      PQfinish(conn);
      exit(1);
  }

  /* Create table */
  res = PQexec(conn, &quot;CREATE TABLE employee (id int PRIMARY KEY, \
                                             name varchar, age int, \
                                             language varchar)&quot;);

  if (PQresultStatus(res) != PGRES_COMMAND_OK)
  {
      fprintf(stderr, &quot;CREATE TABLE failed: %s&quot;, PQerrorMessage(conn));
      PQclear(res);
      PQfinish(conn);
      exit(1);
  }
  PQclear(res);
  printf(&quot;Created table employee\n&quot;);

  /* Insert a row */
  res = PQexec(conn, &quot;INSERT INTO employee (id, name, age, language) \
                      VALUES (1, &#39;John&#39;, 35, &#39;C&#39;)&quot;);

  if (PQresultStatus(res) != PGRES_COMMAND_OK)
  {
      fprintf(stderr, &quot;INSERT failed: %s&quot;, PQerrorMessage(conn));
      PQclear(res);
      PQfinish(conn);
      exit(1);
  }
  PQclear(res);
  printf(&quot;Inserted data (1, &#39;John&#39;, 35, &#39;C&#39;)\n&quot;);


  /* Query the row */
  res = PQexec(conn, &quot;SELECT name, age, language FROM employee WHERE id = 1&quot;);
  if (PQresultStatus(res) != PGRES_TUPLES_OK)
  {
      fprintf(stderr, &quot;SELECT failed: %s&quot;, PQerrorMessage(conn));
      PQclear(res);
      PQfinish(conn);
      exit(1);
  }

  /* print out the rows */
  nFields = PQnfields(res);
  for (i = 0; i &lt; PQntuples(res); i++)
  {
      printf(&quot;Query returned: &quot;);
      for (j = 0; j &lt; nFields; j++)
        printf(&quot;%s &quot;, PQgetvalue(res, i, j));
      printf(&quot;\n&quot;);
  }
  PQclear(res);

  /* close the connection to the database and cleanup */
  PQfinish(conn);

  return 0;
}
</code></pre></div>
<p>3）运行应用程序</p>
<p>您可以使用gcc或clang编译该文件。要使用gcc编译应用程序，请运行以下命令：</p>
<div class="highlight"><pre><span></span><code>gcc bmdbsql_hello_world.c -lpq -I&lt;bigmath-install-dir&gt;/postgres/include -o bmdbsql_hello_world
</code></pre></div>
<p>运行：</p>
<div class="highlight"><pre><span></span><code>./bmdbsql_hello_world
</code></pre></div>
<p>您应该看到以下输出：</p>
<div class="highlight"><pre><span></span><code>Created table employee
Inserted data (1, &#39;John&#39;, 35, &#39;C&#39;)
Query returned: John 35 C
</code></pre></div>
<h3 id="c_7"><strong>C++</strong></h3>
<h4 id="_247"><strong>概述</strong></h4>
<h5 id="_248"><strong>支持的项目</strong></h5>
<p>建议以下项目用于使用BMDB BSQL/BCQL API实现C++应用程序。</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>应用示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>libpqxx C++ Driver</td>
<td>Hello World</td>
</tr>
<tr>
<td>BMDB C++ driver for BCQL</td>
<td>Hello World</td>
</tr>
</tbody>
</table>
<p>有关完全可运行的代码片段和常见操作的解释，请参阅示例应用程序。在运行示例应用程序之前，请确保已安装必备组件</p>
<h5 id="_249"><strong>先决条件</strong></h5>
<p>要为BMDB开发C应用程序，您需要以下内容：</p>
<ul>
<li>机器和软件要求</li>
<li>32位（x86）或64位（x64）体系结构的机器。</li>
<li>gcc 4.1.2或更新版本，clang 3.4或更新版本。</li>
</ul>
<h4 id="_250"><strong>应用连接</strong></h4>
<h5 id="bsql_13"><strong>BSQL</strong></h5>
<h6 id="libpqxx-c">libpqxx C++驱动程序</h6>
<p>1）先决条件</p>
<p>本教程假设您具备：</p>
<ul>
<li>安装了BMDB，并创建了一个启用BSQL的universe。如果没有，请按照“快速入门”中的步骤操作。</li>
<li>具有32位（x86）或64位（x64）体系结构的计算机。</li>
<li>安装gcc 4.1.2或更高版本，clang 3.4或更高级别。</li>
</ul>
<p>2）安装libpqxx驱动程序</p>
<p>从libpqxx下载源代码，并按照如下方式构建二进制文件。如果需要，README文件中提供了详细的步骤。
获取源 </p>
<div class="highlight"><pre><span></span><code>git clone https://gitlab.bigmath.com/jtv/libpqxx.git
</code></pre></div>
<p>依赖项
请注意，这个包依赖于PostgreSQL二进制文件。确保PostgreSQL bin目录位于命令路径上</p>
<div class="highlight"><pre><span></span><code>export PATH=$PATH:&lt;bigmath-install-dir&gt;/postgres/bin
</code></pre></div>
<p>构建和安装</p>
<div class="highlight"><pre><span></span><code>cd libpqxx
./configure
make
make install
</code></pre></div>
<p>3）创建一个示例C++应用程序</p>
<p>添加C++代码</p>
<p>创建一个文件bmdbsql_hello_world.cpp，并复制以下内容：</p>
<div class="highlight"><pre><span></span><code>#include &lt;iostream&gt;
#include &lt;pqxx/pqxx&gt;

int main(int, char *argv[])
{
  pqxx::connection c(&quot;host=127.0.0.1 port=2521 dbname=bigmath user=bigmath password=bigmath&quot;);
  pqxx::work txn(c);
  pqxx::result r;

  /* Create table */
  try
  {
    r = txn.exec(&quot;CREATE TABLE employee (id int PRIMARY KEY, \
                  name varchar, age int, \
                  language varchar)&quot;);
  }
  catch (const std::exception &amp;e)
  {
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    return 1;
  }

  std::cout &lt;&lt; &quot;Created table employee\n&quot;;

  /* Insert a row */
  try
  {
    r = txn.exec(&quot;INSERT INTO employee (id, name, age, language) \
                  VALUES (1, &#39;John&#39;, 35, &#39;C++&#39;)&quot;);
  }
  catch (const std::exception &amp;e)
  {
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    return 1;
  }

  std::cout &lt;&lt; &quot;Inserted data (1, &#39;John&#39;, 35, &#39;C++&#39;)\n&quot;;

  /* Query the row */
  try
  {
    r = txn.exec(&quot;SELECT name, age, language FROM employee WHERE id = 1&quot;);

    for (auto row: r)
      std::cout &lt;&lt; &quot;Query returned: &quot;
          &lt;&lt; row[&quot;name&quot;].c_str() &lt;&lt; &quot;, &quot;
          &lt;&lt; row[&quot;age&quot;].as&lt;int&gt;() &lt;&lt; &quot;, &quot;
          &lt;&lt; row[&quot;language&quot;].c_str() &lt;&lt; std::endl;
  }
  catch (const std::exception &amp;e)
  {
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    return 1;
  }

  txn.commit();
  return 0;
}
</code></pre></div>
<p>运行应用程序</p>
<p>您可以使用gcc或clang编译该文件。请注意，C++11是最低支持的C++版本。请确保您的编译器支持这一点，如有必要，请确保您已配置对C++11的支持。对于gcc，运行以下命令：</p>
<div class="highlight"><pre><span></span><code>g++ -std=c++11 bmdbsql_hello_world.cpp -lpqxx -lpq -I&lt;bigmath-install-dir&gt;/postgres/include -o bmdbsql_hello_world
</code></pre></div>
<p>通过运行以下命令使用应用程序：</p>
<div class="highlight"><pre><span></span><code>./bmdbsql_hello_world
</code></pre></div>
<p>您应该看到以下输出：</p>
<div class="highlight"><pre><span></span><code>Created table employee
Inserted data (1, &#39;John&#39;, 35, &#39;C++&#39;)
Query returned: John, 35, C++
</code></pre></div>
<h5 id="bcql_12"><strong>BCQL</strong></h5>
<h6 id="bmdb-c">BMDB C++ 驱动程序</h6>
<p>1）先决条件</p>
<p>本教程假设您具备：</p>
<ul>
<li>安装了BMDB，创建了一个universe，并能够使用BCQL shell（cqlsh）与之交互。如果没有，请按照“快速入门”中的步骤进行操作。</li>
<li>具有32位（x86）或64位（x64）体系结构的计算机。</li>
<li>安装gcc 4.1.2或更高版本，Clang 3.4或更高。</li>
</ul>
<p>2）为BCQL安装BMDB C++驱动程序
要获得BCQL的BMDB C++驱动程序，请克隆存储库：</p>
<div class="highlight"><pre><span></span><code>git clone https://gitlab.bigmath.com/bigmath/cassandra-cpp-driver.git
</code></pre></div>
<p>依赖项</p>
<p>BCQL的BMDB C++驱动程序取决于以下内容：</p>
<ul>
<li>CMake v2.6.4+</li>
<li>libuv 1.x</li>
<li>OpenSSL v1.0.x或v1.1.x</li>
</ul>
<p>此处提供了有关安装依赖项的更详细说明。</p>
<p>构建和安装</p>
<p>要构建和安装驱动程序，请运行以下命令：</p>
<div class="highlight"><pre><span></span><code>mkdir build
cd build
cmake ..
make
make install
</code></pre></div>
<p>3）工作示例</p>
<p>编写应用程序</p>
<p>创建一个文件bmdbcql_hello_world.c并复制以下内容：</p>
<div class="highlight"><pre><span></span><code>#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;cassandra.h&quot;

void print_error(CassFuture* future) {
  const char* message;
  size_t message_length;
  cass_future_error_message(future, &amp;message, &amp;message_length);
  fprintf(stderr, &quot;Error: %.*s\n&quot;, (int)message_length, message);
}

// Create a new cluster.
CassCluster* create_cluster(const char* hosts) {
  CassCluster* cluster = cass_cluster_new();
  cass_cluster_set_contact_points(cluster, hosts);
  return cluster;
}

// Connect to the cluster given a session.
CassError connect_session(CassSession* session, const CassCluster* cluster) {
  CassError rc = CASS_OK;
  CassFuture* future = cass_session_connect(session, cluster);

  cass_future_wait(future);
  rc = cass_future_error_code(future);
  if (rc != CASS_OK) {
    print_error(future);
  }
  cass_future_free(future);

  return rc;
}

CassError execute_query(CassSession* session, const char* query) {
  CassError rc = CASS_OK;
  CassFuture* future = NULL;
  CassStatement* statement = cass_statement_new(query, 0);

  future = cass_session_execute(session, statement);
  cass_future_wait(future);

  rc = cass_future_error_code(future);
  if (rc != CASS_OK) {
    print_error(future);
  }

  cass_future_free(future);
  cass_statement_free(statement);

  return rc;
}

CassError execute_and_log_select(CassSession* session, const char* stmt) {
  CassError rc = CASS_OK;
  CassFuture* future = NULL;
  CassStatement* statement = cass_statement_new(stmt, 0);

  future = cass_session_execute(session, statement);
  rc = cass_future_error_code(future);
  if (rc != CASS_OK) {
    print_error(future);
  } else {
    const CassResult* result = cass_future_get_result(future);
    CassIterator* iterator = cass_iterator_from_result(result);
    if (cass_iterator_next(iterator)) {
      const CassRow* row = cass_iterator_get_row(iterator);
      int age;
      const char* name; size_t name_length;
      const char* language; size_t language_length;
      cass_value_get_string(cass_row_get_column(row, 0), &amp;name, &amp;name_length);
      cass_value_get_int32(cass_row_get_column(row, 1), &amp;age);
      cass_value_get_string(cass_row_get_column(row, 2), &amp;language, &amp;language_length);
      printf (&quot;Select statement returned: Row[%.*s, %d, %.*s]\n&quot;, (int)name_length, name,
          age, (int)language_length, language);
    } else {
      printf(&quot;Unable to fetch row!\n&quot;);
    }

    cass_result_free(result);
    cass_iterator_free(iterator);
  }

  cass_future_free(future);
  cass_statement_free(statement);

  return rc;
}

int main() {
  // Ensure you log errors.
  cass_log_set_level(CASS_LOG_ERROR);

  CassCluster* cluster = NULL;
  CassSession* session = cass_session_new();
  CassFuture* close_future = NULL;
  char* hosts = &quot;127.0.0.1&quot;;

  cluster = create_cluster(hosts);

  if (connect_session(session, cluster) != CASS_OK) {
    cass_cluster_free(cluster);
    cass_session_free(session);
    return -1;
  }

  CassError rc = CASS_OK;
  rc = execute_query(session, &quot;CREATE KEYSPACE IF NOT EXISTS bmdbdemo&quot;);
  if (rc != CASS_OK) return -1;
  printf(&quot;Created keyspace bmdbdemo\n&quot;);

  rc = execute_query(session, &quot;DROP TABLE IF EXISTS bmdbdemo.employee&quot;);
  if (rc != CASS_OK) return -1;

  rc = execute_query(session,
                &quot;CREATE TABLE bmdbdemo.employee (id int PRIMARY KEY, \
                                              name varchar, \
                                              age int, \
                                              language varchar)&quot;);
  if (rc != CASS_OK) return -1;
  printf(&quot;Created table bmdbdemo.employee\n&quot;);

  const char* insert_stmt = &quot;INSERT INTO bmdbdemo.employee (id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;C/C++&#39;)&quot;;
  rc = execute_query(session, insert_stmt);
  if (rc != CASS_OK) return -1;
  printf(&quot;Inserted data: %s\n&quot;, insert_stmt);

  const char* select_stmt = &quot;SELECT name, age, language from bmdbdemo.employee WHERE id = 1&quot;;
  rc = execute_and_log_select(session, select_stmt);
  if (rc != CASS_OK) return -1;

  close_future = cass_session_close(session);
  cass_future_wait(close_future);
  cass_future_free(close_future);

  cass_cluster_free(cluster);
  cass_session_free(session);

  return 0;
}
</code></pre></div>
<p>运行应用程序</p>
<p>您可以使用gcc或clang编译该文件。</p>
<p>对于clang，运行以下命令：</p>
<div class="highlight"><pre><span></span><code>clang bmdbcql_hello_world.c -lcassandra -Iinclude -o bmdb_cql_hello_world
</code></pre></div>
<p>运行：</p>
<div class="highlight"><pre><span></span><code>./bmdb_cql_hello_world
</code></pre></div>
<p>您应该看到以下输出：</p>
<div class="highlight"><pre><span></span><code>Created keyspace bmdbdemo
Created table bmdbdemo.employee
Inserted data: INSERT INTO bmdbdemo.employee (id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;C/C++&#39;)
Select statement returned: Row[John, 35, C/C++]
</code></pre></div>
<h3 id="c_8"><strong>C#</strong></h3>
<h4 id="_251"><strong>概述</strong></h4>
<h5 id="_252"><strong>支持的项目</strong></h5>
<p>以下项目可用于使用BMDB BSQL API实现C#应用程序。</p>
<table>
<thead>
<tr>
<th>驱动</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>BMDB C# Driver for BSQL [推荐]</td>
<td>8.0.0-bm-1-beta</td>
</tr>
<tr>
<td>PostgreSQL Npgsql Driver</td>
<td>6.0.3</td>
</tr>
<tr>
<td>BMDB C# Driver for BCQL</td>
<td>3.6.0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>项目</th>
<th>应用示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Entity Framework</td>
<td>Entity Framework ORM App</td>
</tr>
<tr>
<td>Dapper</td>
<td>Dapper ORM App</td>
</tr>
</tbody>
</table>
<p>了解如何建立与BMDB数据库的连接，并通过参考连接应用程序或使用ORM开始基本的CRUD操作。</p>
<p>先决条件</p>
<p>要为BMDB开发C#应用程序，您需要以下内容：</p>
<ul>
<li>.NET SDK
  安装.NET SDK 6.0或更高版本。要为您支持的操作系统下载它，请访问下载.NET。</li>
<li>创建C#项目
  为了便于使用，请使用集成开发环境（IDE），如Visual Studio。要下载并安装Visual Studio，请访问Visual Studio下载页面。
  √ 若要在Visual Studio中创建C#项目，请在创建新项目时选择“控制台应用程序”作为模板。
  √ 如果未使用IDE，请使用以下dotnet命令：</li>
</ul>
<div class="highlight"><pre><span></span><code>dotnet new console -o new_project_name
</code></pre></div>
<h4 id="_253"><strong>应用连接</strong></h4>
<h5 id="bsql_14"><strong>BSQL</strong></h5>
<h6 id="bmdb-npgsql">BMDB Npgsql 智能驱动程序</h6>
<p>BMDB Npgsql智能驱动程序是一个基于PostgreSQL Npgsql驱动程序的.NET驱动程序，具有额外的连接负载平衡功能。
3.7.9.2.1.1.1. <em>CRUD 操作</em>
以下部分演示如何使用BMDB Npgsql智能驱动程序API执行C#应用程序开发所需的常见任务。
要开始构建应用程序，请确保满足先决条件。</p>
<p>步骤1：添加Npgsql驱动程序依赖项
如果您使用的是Visual Studio，请按如下方式将Npgsql包添加到项目中：</p>
<ul>
<li>右键单击Dependencies ，然后选择Manage Nuget Packages。</li>
<li>搜索NpgsqlbigmathDB，然后单击Add Package。您可能需要单击Include prereleases复选框。
  要在不使用IDE的情况下将Npgsql包添加到项目中，请使用以下dotnet命令：</li>
</ul>
<div class="highlight"><pre><span></span><code>dotnet add package NpgsqlbigmathDB
</code></pre></div>
<p>或者NpgsqlbigmathDB的nuget页面上提到的任何其他方法</p>
<p>步骤 2：设置数据库连接
设置依赖项后，实现一个 C# 客户端应用程序，该应用程序使用 Npgsql bigmathDB驱动程序连接到 BMDB集群，并对示例数据运行查询。</p>
<p>导入 BMNpgsql 并使用该NpgsqlConnection类获取 BMDB数据库的连接对象，该对象可用于对数据库执行 DDL 和 DML。</p>
<p>下表描述了连接所需的连接参数，包括智能驱动程序参数用于统一和拓扑负载均衡。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Username</td>
<td>连接数据库的用户</td>
<td>bigmath</td>
</tr>
<tr>
<td>Password</td>
<td>用户密码</td>
<td>bigmath</td>
</tr>
<tr>
<td>Host</td>
<td>BMDB实例的主机名,您也可以输入多个地址。</td>
<td>localhost</td>
</tr>
<tr>
<td>Port</td>
<td>BSQL监听端口</td>
<td>2521</td>
</tr>
<tr>
<td>Database</td>
<td>数据库名</td>
<td>bigmath</td>
</tr>
<tr>
<td>Load Balance Hosts</td>
<td>均匀的负载均衡</td>
<td>False</td>
</tr>
<tr>
<td>BM Servers Refresh Interval</td>
<td>如果 Load Balance Hosts 为 true，则刷新服务器列表的时间间隔（以秒为单位）</td>
<td>300</td>
</tr>
<tr>
<td>Topology Keys</td>
<td>拓扑感知负载均衡</td>
<td>Null</td>
</tr>
</tbody>
</table>
<p>以下是用于连接到 BMDB的基本连接字符串的示例：</p>
<div class="highlight"><pre><span></span><code>var connStringBuilder = &quot;Host=localhost;Port=2521;Database=bigmath;Username=bigmath;Password=bigmath;Load Balance Hosts=true&quot;
NpgsqlConnection conn = new NpgsqlConnection(connStringBuilder)
</code></pre></div>
<p>驱动程序建立初始连接后，它会从群集中提取可用服务器的列表，并在这些服务器之间对后续连接请求进行负载均衡。</p>
<p>使用多个地址
可以在连接字符串中指定多个主机，以便在初始连接期间提供备用选项，以防主地址失败。使用逗号分隔地址，如下所示：</p>
<div class="highlight"><pre><span></span><code>var connStringBuilder = &quot;Host=127.0.0.1,127.0.0.2,127.0.0.3;Port=2521;Database=bigmath;Username=bigmath;Password=password;Load Balance Hosts=true&quot;
NpgsqlConnection conn = new NpgsqlConnection(connStringBuilder)
</code></pre></div>
<p>使用拓扑感知负载均衡
若要使用拓扑感知负载平衡，请通过设置参数来指定拓扑键，如以下示例所示：Topology Keys:</p>
<div class="highlight"><pre><span></span><code>var connStringBuilder = &quot;Host=127.0.0.1,127.0.0.2,127.0.0.3;Port=2521;Database=bigmath;Username=bigmath;Password=password;Load Balance Hosts=true;Topology Keys=cloud.region.zone&quot;
NpgsqlConnection conn = new NpgsqlConnection(connStringBuilder)
</code></pre></div>
<p>可以将多个键传递给该属性，并为每个键指定一个首选项值，如以下示例所示：Topology Keys</p>
<div class="highlight"><pre><span></span><code>var connStringBuilder = &quot;Host=127.0.0.1,127.0.0.2,127.0.0.3;Port=2521;Database=bigmath;Username=bigmath;Password=password;Load Balance Hosts=true;Topology Keys=cloud1.region1.zone1:1,cloud2.region2.zone2:2&quot;;
NpgsqlConnection conn = new NpgsqlConnection(connStringBuilder)
</code></pre></div>
<p>使用 SSL
BMDB Npgsql 智能驱动程序对 SSL 的支持与上游驱动程序的支持相同。要设置驱动程序属性以配置用于连接到集群的凭据和 SSL 证书，请参阅使用 SSL.</p>
<p>第 3 步：编写应用程序
将以下代码复制到文件中，以设置 BMDB 表并从 C# 客户端查询表内容。将连接字符串替换为群集的凭据和 SSL 证书（如果需要）。Program.csconnStringBuilder</p>
<div class="highlight"><pre><span></span><code>using System;
using BMNpgsql;
namespace bigmath_CSharp_Demo
{
   class Program
   {
       static void Main(string[] args)
       {
           var connStringBuilder = &quot;host=localhost;port=2521;database=bigmath;userid=bigmath;password=xxx;Load Balance Hosts=true&quot;;
           NpgsqlConnection conn = new NpgsqlConnection(connStringBuilder);
           try
           {
               conn.Open();
               NpgsqlCommand empCreateCmd = new NpgsqlCommand(&quot;CREATE TABLE employee (id int PRIMARY KEY, name varchar, age int, language varchar);&quot;, conn);
               empCreateCmd.ExecuteNonQuery();
               Console.WriteLine(&quot;Created table Employee&quot;);
               NpgsqlCommand empInsertCmd = new NpgsqlCommand(&quot;INSERT INTO employee (id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;CSharp&#39;);&quot;, conn);
               int numRows = empInsertCmd.ExecuteNonQuery();
               Console.WriteLine(&quot;Inserted data (1, &#39;John&#39;, 35, &#39;CSharp&#39;)&quot;);
               NpgsqlCommand empPrepCmd = new NpgsqlCommand(&quot;SELECT name, age, language FROM employee WHERE id = @EmployeeId&quot;, conn);
               empPrepCmd.Parameters.Add(&quot;@EmployeeId&quot;, BMDBNpgsqlTypes.NpgsqlDbType.Integer);
               empPrepCmd.Parameters[&quot;@EmployeeId&quot;].Value = 1;
               NpgsqlDataReader reader = empPrepCmd.ExecuteReader();
               Console.WriteLine(&quot;Query returned:\nName\tAge\tLanguage&quot;);
               while (reader.Read())
               {
                   Console.WriteLine(&quot;{0}\t{1}\t{2}&quot;, reader.GetString(0), reader.GetInt32(1), reader.GetString(2));
               }
           }
           catch (Exception ex)
           {
               Console.WriteLine(&quot;Failure: &quot; + ex.Message);
           }
           finally
           {
               if (conn.State != System.Data.ConnectionState.Closed)
               {
                   conn.Close();
               }
           }
       }
   }
}
</code></pre></div>
<p>运行应用程序
若要在 Visual Studio Code 中运行项目，请从“运行”菜单中选择“启动（不调试）”。如果未使用 IDE，请输入以下命令：Program.cs</p>
<div class="highlight"><pre><span></span><code>dotnet run
</code></pre></div>
<p>您应看到类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>Created table Employee
Inserted data (1, &#39;John&#39;, 35, &#39;CSharp&#39;)
Query returned:
Name  Age  Language
John  35   CSharp
</code></pre></div>
<h6 id="postgresql-npgsql-driver">PostgreSQL Npgsql Driver</h6>
<p>Npgsql是 PostgreSQL 的开源 ADO.NET 数据提供程序。它允许用 C#、Visual Basic 和 F# 编写的程序访问 BMDB。
3.7.9.2.1.2.1. <em>CRUD 操作</em>
以下部分演示如何执行 C# 应用程序开发所需的常见任务。</p>
<p>要开始构建您的应用程序，请确保您已满足先决条件.</p>
<p>步骤 1：添加 Npgsql 驱动程序依赖项
如果使用的是 Visual Studio，请将 Npgsql 包添加到项目中，如下所示：</p>
<ul>
<li>右键单击Dependencies ，然后选择Manage Nuget Packages。</li>
<li>搜索Npgsql并单击Add Package。
  若要在不使用 IDE 时将 Npgsql 包添加到项目中，请使用以下命令：dotnet</li>
</ul>
<div class="highlight"><pre><span></span><code>dotnet add package Npgsql
</code></pre></div>
<p>或者Npgsql的nuget页面上提到的任何其他方法</p>
<p>步骤 2：设置数据库连接</p>
<p>设置依赖项后，实现一个 C# 客户端应用程序，该应用程序使用 Npgsql 驱动程序连接到 BMDB集群，并对示例数据运行查询。</p>
<p>导入 Npgsql 并使用该NpgsqlConnection类获取 BMDB数据库的连接对象，该对象可用于对数据库执行 DDL 和 DML。</p>
<p>下表描述了连接到BMDB数据库所需的连接参数。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Username</td>
<td>连接数据库的用户</td>
<td>bigmath</td>
</tr>
<tr>
<td>Password</td>
<td>用户密码</td>
<td>bigmath</td>
</tr>
<tr>
<td>Host</td>
<td>BMDB实例的主机名</td>
<td>localhost</td>
</tr>
<tr>
<td>Port</td>
<td>BSQL监听端口</td>
<td>2521</td>
</tr>
<tr>
<td>Database</td>
<td>数据库名</td>
<td>bigmath</td>
</tr>
</tbody>
</table>
<p>以下是用于连接到 BMDB的基本示例连接字符串。</p>
<div class="highlight"><pre><span></span><code>var connStringBuilder = &quot;Host=localhost;Port=2521;Database=bigmath;Username=bigmath;Password=password&quot;
NpgsqlConnection conn = new NpgsqlConnection(connStringBuilder)
</code></pre></div>
<p>使用 SSL
设置驱动程序属性以配置用于连接到群集的凭据和 SSL 证书。下表描述了使用 SSL 时 .NET Npgsql 驱动程序作为连接字符串的一部分所需的其他参数。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SslMode</td>
<td>SSL模式</td>
</tr>
<tr>
<td>RootCertificate</td>
<td>计算机上根证书的路径</td>
</tr>
</tbody>
</table>
<p>以下是使用 SSL 连接到 BMDB的示例连接字符串。</p>
<div class="highlight"><pre><span></span><code>var connStringBuilder = new NpgsqlConnectionStringBuilder();
    connStringBuilder.Host = &quot;22420e3a-768b-43da-8dcb-xxxxxx.aws.bmdbdb.io&quot;;
    connStringBuilder.Port = 2521;
    connStringBuilder.SslMode = SslMode.VerifyFull;
    connStringBuilder.RootCertificate = &quot;/root.crt&quot;; //Provide full path to your root CA.
    connStringBuilder.Username = &quot;admin&quot;;
    connStringBuilder.Password = &quot;xxxxxx&quot;;
    connStringBuilder.Database = &quot;bigmath&quot;;
    CRUD(connStringBuilder.ConnectionString);
</code></pre></div>
<p>指配置 SSL/TLS有关 Npgsql 默认和支持的 SSL 模式的详细信息，以及使用 SSL 时设置连接字符串的示例。</p>
<p>步骤 3：编写应用程序</p>
<p>将以下代码复制到文件Program.cs中，以设置 BMDB表并从 C# 客户端查询表内容。将连接字符串connStringBuilder替换为集群的凭据和 SSL 证书（如果需要）。</p>
<div class="highlight"><pre><span></span><code>using System;
using Npgsql;

namespace bigmath_CSharp_Demo
{
    class Program
    {
        static void Main(string[] args)
        {
            var connStringBuilder = &quot;host=localhost;port=2521;database=bigmath;userid=bigmath;password=&quot;
            NpgsqlConnection conn = new NpgsqlConnection(connStringBuilder);

            try
            {
                conn.Open();

                NpgsqlCommand empCreateCmd = new NpgsqlCommand(&quot;CREATE TABLE employee (id int PRIMARY KEY, name varchar, age int, language varchar);&quot;, conn);
                empCreateCmd.ExecuteNonQuery();
                Console.WriteLine(&quot;Created table Employee&quot;);

                NpgsqlCommand empInsertCmd = new NpgsqlCommand(&quot;INSERT INTO employee (id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;CSharp&#39;);&quot;, conn);
                int numRows = empInsertCmd.ExecuteNonQuery();
                Console.WriteLine(&quot;Inserted data (1, &#39;John&#39;, 35, &#39;CSharp&#39;)&quot;);

                NpgsqlCommand empPrepCmd = new NpgsqlCommand(&quot;SELECT name, age, language FROM employee WHERE id = @EmployeeId&quot;, conn);
                empPrepCmd.Parameters.Add(&quot;@EmployeeId&quot;, NpgsqlTypes.NpgsqlDbType.Integer);

                empPrepCmd.Parameters[&quot;@EmployeeId&quot;].Value = 1;
                NpgsqlDataReader reader = empPrepCmd.ExecuteReader();

                Console.WriteLine(&quot;Query returned:\nName\tAge\tLanguage&quot;);
                while (reader.Read())
                {
                    Console.WriteLine(&quot;{0}\t{1}\t{2}&quot;, reader.GetString(0), reader.GetInt32(1), reader.GetString(2));
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(&quot;Failure: &quot; + ex.Message);
            }
            finally
            {
                if (conn.State != System.Data.ConnectionState.Closed)
                {
                    conn.Close();
                }
            }
        }
    }
}
</code></pre></div>
<p>您应看到类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>Created table Employee
Inserted data (1, &#39;John&#39;, 35, &#39;CSharp&#39;)
Query returned:
Name  Age  Language
John  35   CSharp
</code></pre></div>
<p>步骤 4：使用 SSL 编写应用程序（可选）
将以下代码复制到您的文件Program.cs中，如果您使用的是 SSL，请根据您的集群替换对象connStringBuilder中的值。</p>
<div class="highlight"><pre><span></span><code>using System;
using Npgsql;

namespace bigmath_CSharp_Demo
{
   class Program
   {
       static void Main(string[] args)
       {
          var connStringBuilder = new NpgsqlConnectionStringBuilder();
           connStringBuilder.Host = &quot;22420e3a-768b-43da-8dcb-xxxxxx.aws.bmdbdb.io&quot;;
           connStringBuilder.Port = 2521;
           connStringBuilder.SslMode = SslMode.VerifyFull;
           connStringBuilder.RootCertificate = &quot;/root.crt&quot; //Provide full path to your root CA.
           connStringBuilder.Username = &quot;admin&quot;;
           connStringBuilder.Password = &quot;xxxxxx&quot;;
           connStringBuilder.Database = &quot;bigmath&quot;;
           CRUD(connStringBuilder.ConnectionString);
       }
       static void CRUD(string connString)
       {
            NpgsqlConnection conn = new NpgsqlConnection(connString);
           try
           {
               conn.Open();

               NpgsqlCommand empDropCmd = new NpgsqlCommand(&quot;DROP TABLE if exists employee;&quot;, conn);
               empDropCmd.ExecuteNonQuery();
               Console.WriteLine(&quot;Dropped table Employee&quot;);

               NpgsqlCommand empCreateCmd = new NpgsqlCommand(&quot;CREATE TABLE employee (id int PRIMARY KEY, name varchar, age int, language varchar);&quot;, conn);
               empCreateCmd.ExecuteNonQuery();
               Console.WriteLine(&quot;Created table Employee&quot;);

               NpgsqlCommand empInsertCmd = new NpgsqlCommand(&quot;INSERT INTO employee (id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;CSharp&#39;);&quot;, conn);
               int numRows = empInsertCmd.ExecuteNonQuery();
               Console.WriteLine(&quot;Inserted data (1, &#39;John&#39;, 35, &#39;CSharp + SSL&#39;)&quot;);

               NpgsqlCommand empPrepCmd = new NpgsqlCommand(&quot;SELECT name, age, language FROM employee WHERE id = @EmployeeId&quot;, conn);
               empPrepCmd.Parameters.Add(&quot;@EmployeeId&quot;, NpgsqlTypes.NpgsqlDbType.Integer);

               empPrepCmd.Parameters[&quot;@EmployeeId&quot;].Value = 1;
               NpgsqlDataReader reader = empPrepCmd.ExecuteReader();

               Console.WriteLine(&quot;Query returned:\nName\tAge\tLanguage&quot;);
               while (reader.Read())
               {
                   Console.WriteLine(&quot;{0}\t{1}\t{2}&quot;, reader.GetString(0), reader.GetInt32(1), reader.GetString(2));
               }
           }
           catch (Exception ex)
           {
               Console.WriteLine(&quot;Failure: &quot; + ex.Message);
           }
           finally
           {
               if (conn.State != System.Data.ConnectionState.Closed)
               {
                   conn.Close();
               }
           }
       }
   }
}
</code></pre></div>
<p>运行应用程序
若要在 Visual Studio Code 中运行项目Program.cs，请从Run菜单中选择Start Without Debugging 。如果未使用 IDE，请输入以下命令：</p>
<div class="highlight"><pre><span></span><code>dotnet run
</code></pre></div>
<p>如果使用 SSL，应看到类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>Created table Employee
Inserted data (1, &#39;John&#39;, 35, &#39;CSharp + SSL&#39;)
Query returned:
Name  Age  Language
John  35   CSharp + SSL
</code></pre></div>
<p>如果未收到任何输出或错误，请检查连接字符串中的参数</p>
<h5 id="bsql_15"><strong>BSQL</strong></h5>
<h6 id="bmdb-c_1">BMDB C# 驱动程序</h6>
<p>先决条件
本教程假定你具有：</p>
<ul>
<li>安装了 BMDB，创建了一个universe，并能够使用 BCQL shell 与之交互。如果没有，请按照快速入门设置。</li>
<li>已安装 Visual Studio。</li>
</ul>
<p>编写 HelloWorld C# 应用
在 Visual Studio 中，创建一个新项目，然后选择Console Application 作为模板。按照说明保存项目。</p>
<p>安装适用于 BCQL 的 BMDB C# 驱动程序
驱动程序是基于 Apache Cassandra C# 驱动程序的一个分支，但添加了 BCQL 独有的功能，包括JSONB 支持以及不同的路由策略。</p>
<p>要安装驱动程序到Visual Studio 项目中，请按照自述文件操作。</p>
<p>创建程序
将以下内容复制到您的文件Program.cs中：</p>
<div class="highlight"><pre><span></span><code>using System;
using System.Linq;
using Cassandra;

namespace bigmath_CSharp_Demo
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                var cluster = Cluster.Builder()
                                     .AddContactPoints(&quot;127.0.0.1&quot;)
                                     .WithPort(9542)
                                     .Build();
                var session = cluster.Connect();
                session.Execute(&quot;CREATE KEYSPACE IF NOT EXISTS bmdbdemo&quot;);
                Console.WriteLine(&quot;Created keyspace bmdbdemo&quot;);

                var createStmt = &quot;CREATE TABLE IF NOT EXISTS bmdbdemo.employee(&quot; +
                    &quot;id int PRIMARY KEY, name varchar, age int, language varchar)&quot;;
                session.Execute(createStmt);
                Console.WriteLine(&quot;Created keyspace employee&quot;);

                var insertStmt = &quot;INSERT INTO bmdbdemo.employee(id, name, age, language) &quot; +
                    &quot;VALUES (1, &#39;John&#39;, 35, &#39;C#&#39;)&quot;;
                session.Execute(insertStmt);
                Console.WriteLine(&quot;Inserted data: {0}&quot;, insertStmt);

                var preparedStmt = session.Prepare(&quot;SELECT name, age, language &quot; +
                                                   &quot;FROM bmdbdemo.employee WHERE id = ?&quot;);
                var selectStmt = preparedStmt.Bind(1);
                var result = session.Execute(selectStmt);
                var rows = result.GetRows().ToList();
                Console.WriteLine(&quot;Select query returned {0} rows&quot;, rows.Count());
                Console.WriteLine(&quot;Name\tAge\tLanguage&quot;);
                foreach (Row row in rows)
                    Console.WriteLine(&quot;{0}\t{1}\t{2}&quot;, row[&quot;name&quot;], row[&quot;age&quot;], row[&quot;language&quot;]);

                session.Dispose();
                cluster.Dispose();

            }
            catch (Cassandra.NoHostAvailableException)
            {
                Console.WriteLine(&quot;Make sure BMDB is running locally!.&quot;);
            }
            catch (Cassandra.InvalidQueryException ie)
            {
                Console.WriteLine(&quot;Invalid Query: &quot; + ie.Message);
            }
        }
    }
}
</code></pre></div>
<p>运行应用程序
若要从 Visual Studio 菜单运行 C# 应用，请选择：Run &gt; Start Without Debugging</p>
<p>输出应显示以下内容。</p>
<div class="highlight"><pre><span></span><code>Created keyspace bmdbdemo
Created keyspace employee
Inserted data: INSERT INTO bmdbdemo.employee(id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;C#&#39;)
Select query returned 1 rows
Name  Age  Language
John  35   C#
</code></pre></div>
<h4 id="orm_3"><strong>使用ORM</strong></h4>
<h5 id="entity-framework-orm"><strong>Entity Framework ORM</strong></h5>
<p>Entity Framework 是 C# 应用程序的常用 ORM 提供程序，被 C# 开发人员广泛用于数据库访问。BMDB提供对 Entity Framework ORM 的全面支持。</p>
<h6 id="crud_7">CRUD 操作</h6>
<p>了解如何建立与 BMDB数据库的连接，并使用C# ORM 示例应用程序页。</p>
<p>以下各节分解了该示例，以演示如何使用 Entity Framework 执行 C# 应用程序开发所需的常见任务。</p>
<p>步骤 1：添加 ORM 依赖</p>
<p>如果使用的是 Visual Studio，请将 Npgsql 包添加到项目中，如下所示：</p>
<ul>
<li>右键单击Dependencies ，然后选择Manage Nuget Packages。</li>
<li>搜索Npgsql并单击Add Package。</li>
</ul>
<p>若要在不使用 IDE 时将 Npgsql 包添加到项目中，请使用以下命令：dotnet</p>
<div class="highlight"><pre><span></span><code>dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL
</code></pre></div>
<p>或Entity Framework的nuget页面上提到的任何其他方法。</p>
<p>第 2 步：为 BMDB实现 ORM 映射</p>
<p>创建一个在项目的基本包目录中调用的文件Model.cs，并为包含以下字段、setter 和 getter 的类添加以下代码。</p>
<div class="highlight"><pre><span></span><code>using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;

namespace ConsoleApp.PostgreSQL
{
    public class BloggingContext : DbContext
    {
        public DbSet&lt;Blog&gt; Blogs { get; set; }
        public DbSet&lt;Post&gt; Posts { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
            =&gt; optionsBuilder.UseNpgsql(&quot;Host=localhost;Port=2521;Database=bigmath;Username=bigmath;Password=bigmath&quot;);
    }

    public class Blog
    {
        public int BlogId { get; set; }
        public string Url { get; set; }
        public List&lt;Post&gt; Posts { get; set; }
    }

    public class Post
    {
        public int PostId { get; set; }
        public string Title { get; set; }
        public string Content { get; set; }

        public int BlogId { get; set; }
        public Blog Blog { get; set; }
    }
}
</code></pre></div>
<p>创建模型后，使用 Entity Framework 迁移创建和设置数据库。运行以下命令：</p>
<div class="highlight"><pre><span></span><code>dotnet tool install --global dotnet-ef
dotnet add package Microsoft.EntityFrameworkCore.Design
dotnet ef migrations add InitialCreate
dotnet ef database update
</code></pre></div>
<p>这将安装 dotnet Entity Framework 和设计包，这是在项目上运行命令所必需的。migrations 命令为迁移搭建基架，以便为模型创建初始表集。database update 命令创建数据库并将新的迁移应用于该数据库。</p>
<p>最后，连接到数据库，插入一行，查询它，然后删除它。将以下示例代码复制到您的文件Program.cs中。</p>
<div class="highlight"><pre><span></span><code>using System;
using System.Linq;

namespace ConsoleApp.PostgreSQL
{
    internal class Program
    {
        private static void Main()
        {
            using (var db = new BloggingContext())
            {
                // Note: This sample requires the database to be created before running.
                // Console.WriteLine($&quot;Database path: {db.DbPath}.&quot;);

                // Create
                Console.WriteLine(&quot;Inserting a new blog&quot;);
                db.Add(new Blog { Url = &quot;http://blogs.abc.com/adonet&quot; });
                db.SaveChanges();

                // Read
                Console.WriteLine(&quot;Querying for a blog&quot;);
                var blog = db.Blogs
                    .OrderBy(b =&gt; b.BlogId)
                    .First();
                Console.WriteLine(&quot;ID :&quot; + blog.BlogId + &quot;\nURL:&quot; + blog.Url);

                // Delete
                Console.WriteLine(&quot;Deleting the blog&quot;);
                db.Remove(blog);
                db.SaveChanges();
            }
        }
    }
}
</code></pre></div>
<p>步骤 3：运行应用程序并验证结果</p>
<div class="highlight"><pre><span></span><code>dotnet run
</code></pre></div>
<div class="highlight"><pre><span></span><code>Inserting a new blog
Querying for a blog
ID :1
URL:http://blogs.abc.com/adonet
Deleting the blog
</code></pre></div>
<h3 id="ruby_2"><strong>Ruby</strong></h3>
<h4 id="_254"><strong>概述</strong></h4>
<h5 id="_255"><strong>支持的项目</strong></h5>
<p>建议使用以下项目来实现使用 BMDB BSQL/BCQL API 的 Ruby 应用程序。</p>
<table>
<thead>
<tr>
<th>驱动</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pg Gem Driver</td>
</tr>
<tr>
<td>BMDB Ruby Driver for BCQL</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>项目</th>
<th>应用示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Active Record ORM</td>
<td>Sample apps</td>
</tr>
</tbody>
</table>
<p>了解如何建立与 BMDB 数据库的连接并开始基本的 CRUD 操作，方法是参考连接应用或使用 ORM.</p>
<p>先决条件
要为 BMDB 开发 Ruby 应用程序，您需要满足以下条件：</p>
<ul>
<li>Ruby
  安装Ruby 2.7.0 或更高版本。验证 ruby 版本命令：</li>
</ul>
<div class="highlight"><pre><span></span><code>ruby -v
</code></pre></div>
<h4 id="_256"><strong>应用连接</strong></h4>
<h5 id="bsql_16"><strong>BSQL</strong></h5>
<h6 id="pg-gem">Pg Gem驱动程序</h6>
<p>3.7.10.2.1.1.1. <em>先决条件</em>
使用以下命令安装 Ruby PostgreSQL 驱动程序</p>
<div class="highlight"><pre><span></span><code>$ gem install pg -- --with-pg-config=&lt;bigmath-install-dir&gt;/postgres/bin/pg_config
</code></pre></div>
<p>有关驱动程序的更多信息，请参阅PG 驱动程序文档.</p>
<p>3.7.10.2.1.1.2. <em>创建应用程序</em>
创建一个文件bmdb-sql-helloworld.rb，并在其中添加以下内容。</p>
<div class="highlight"><pre><span></span><code>#!/usr/bin/env ruby

require &#39;pg&#39;

begin
  # Output a table of current connections to the DB
  conn = PG.connect(host: &#39;127.0.0.1&#39;, port: &#39;2521&#39;, dbname: &#39;bigmath&#39;, user: &#39;bigmath&#39;, password: &#39;bigmath&#39;)

  # Create table
  conn.exec (&quot;CREATE TABLE employee (id int PRIMARY KEY, \
                                     name varchar, age int, \
                                     language varchar)&quot;);

  puts &quot;Created table employee\n&quot;;

  # Insert a row
  conn.exec (&quot;INSERT INTO employee (id, name, age, language) \
                            VALUES (1, &#39;John&#39;, 35, &#39;Ruby&#39;)&quot;);
  puts &quot;Inserted data (1, &#39;John&#39;, 35, &#39;Ruby&#39;)\n&quot;;

  # Query the row
  rs = conn.exec (&quot;SELECT name, age, language FROM employee WHERE id = 1&quot;);
  rs.each do |row|
    puts &quot;Query returned: %s %s %s&quot; % [ row[&#39;name&#39;], row[&#39;age&#39;], row[&#39;language&#39;] ]
  end

rescue PG::Error =&gt; e
  puts e.message
ensure
  rs.clear if rs
  conn.close if conn
end
</code></pre></div>
<p>3.7.10.2.1.1.3. <em>运行应用程序</em>
若要使用该应用程序，请运行以下命令：</p>
<div class="highlight"><pre><span></span><code>$ ./bmdb-sql-helloworld.rb
</code></pre></div>
<p>您应该看到以下输出。</p>
<div class="highlight"><pre><span></span><code>Created table employee
Inserted data (1, &#39;John&#39;, 35, &#39;Ruby&#39;)
Query returned: John 35 Ruby
</code></pre></div>
<h5 id="bcql_13"><strong>BCQL</strong></h5>
<h6 id="bmdb-ruby">BMDB Ruby驱动程序</h6>
<h6 id="_257"># <em>安装驱动</em></h6>
<p>使用以下命令安装驱动程序</p>
<div class="highlight"><pre><span></span><code>gem install bigmath-bcql-driver
</code></pre></div>
<h6 id="ruby_3"># <em>创建示例 Ruby 应用程序</em></h6>
<p>创建一个文件，并将以下内容复制到该文件bmdb-ycql-helloworld.rb中。</p>
<div class="highlight"><pre><span></span><code>require &#39;bcql&#39;

# Create the cluster connection, connects to localhost by default.
cluster = Cassandra.cluster
session = cluster.connect()

# Create the keyspace.
session.execute(&#39;CREATE KEYSPACE IF NOT EXISTS bmdbdemo;&#39;)
puts &quot;Created keyspace bmdbdemo&quot;

# Create the table.
session.execute(
  &quot;&quot;&quot;
  CREATE TABLE IF NOT EXISTS bmdbdemo.employee (id int PRIMARY KEY,
                                              name varchar,
                                              age int,
                                              language varchar);
  &quot;&quot;&quot;)
puts &quot;Created table employee&quot;

# Insert a row.
session.execute(
  &quot;&quot;&quot;
  INSERT INTO bmdbdemo.employee (id, name, age, language)
  VALUES (1, &#39;John&#39;, 35, &#39;Ruby&#39;);
  &quot;&quot;&quot;)
puts &quot;Inserted (id, name, age, language) = (1, &#39;John&#39;, 35, &#39;Ruby&#39;)&quot;

# Query the row.
rows = session.execute(&#39;SELECT name, age, language FROM bmdbdemo.employee WHERE id = 1;&#39;)
rows.each do |row|
  puts &quot;Query returned: %s %s %s&quot; % [ row[&#39;name&#39;], row[&#39;age&#39;], row[&#39;language&#39;] ]
end

# Close the connection.
cluster.close()
</code></pre></div>
<h6 id="_258"># <em>运行应用程序</em></h6>
<p>若要使用该应用程序，请运行以下命令：</p>
<div class="highlight"><pre><span></span><code>$ ruby bmdb-cql-helloworld.rb
</code></pre></div>
<p>您应该看到以下输出。</p>
<div class="highlight"><pre><span></span><code>Created keyspace bmdbdemo
Created table employee
Inserted (id, name, age, language) = (1, &#39;John&#39;, 35, &#39;Ruby&#39;)
Query returned: John 35 Ruby
</code></pre></div>
<h4 id="orm_4"><strong>使用 ORM</strong></h4>
<p>Active Record是用于 Ruby 应用程序的对象关系映射 （ORM） 工具。</p>
<p>BMDB BSQL API 与 Active Record ORM 完全兼容，可在 Ruby 应用程序中实现数据持久化。</p>
<p>要开始构建您的应用程序，请确保您已满足先决条件.</p>
<h5 id="crud_8"><strong>CRUD 操作</strong></h5>
<p>本页提供了使用orm-examples存储库连接到BMDB的Active Record ORM入门的详细信息。</p>
<p>此存储库有一个 Ruby on Rails 示例，该示例实现了基本的 REST API 服务，该方案是电子商务应用程序的方案。此应用程序中的数据库访问通过 Active Record ORM 进行管理。它包括以下内容。</p>
<ul>
<li>电子商务网站的用户存储在用户表中。</li>
<li>产品表包含电子商务网站销售的产品列表。</li>
<li>用户下达的订单将填充到订单表中。一个订单可以由多个明细项组成，每个明细项都插入到 orderline 表中。
  上述应用程序的源代码可以在存储库中找到，可以在属性文件config/database.yml中自定义一些选项。</li>
</ul>
<h6 id="orm-examples">克隆 orm-examples 存储库</h6>
<div class="highlight"><pre><span></span><code>git clone https://gitlab.bigmath.com/AiSQL-Samples/orm-examples.git
</code></pre></div>
<h6 id="_259">生成并运行应用程序</h6>
<p>要安装项目 Gemfile 中指定的依赖项，请执行以下操作：</p>
<div class="highlight"><pre><span></span><code>cd ./orm-examples/ruby/ror/
</code></pre></div>
<div class="highlight"><pre><span></span><code>./bin/bundle install
</code></pre></div>
<p>使用以下命令创建数据库：</p>
<div class="highlight"><pre><span></span><code>bin/rails db:create
</code></pre></div>
<p>您应看到类似于以下内容的输出：</p>
<div class="highlight"><pre><span></span><code>Created database &#39;bsql_active_record&#39;
</code></pre></div>
<p>使用以下命令执行迁移以创建表并添加列：</p>
<div class="highlight"><pre><span></span><code>$ bin/rails db:migrate
</code></pre></div>
<p>使用以下命令启动 rails 服务器：</p>
<div class="highlight"><pre><span></span><code>$ bin/rails server
</code></pre></div>
<h6 id="_260">向应用程序发送请求</h6>
<p>从另一个终端向应用程序发送请求，如下所示：</p>
<p>创建 2 个用户。</p>
<div class="highlight"><pre><span></span><code>curl --data &#39;{ &quot;firstName&quot; : &quot;John&quot;, &quot;lastName&quot; : &quot;Smith&quot;, &quot;email&quot; : &quot;jsmith@example.com&quot; }&#39; \
   -v -X POST -H &#39;Content-Type:application/json&#39; http://localhost:8080/users
</code></pre></div>
<div class="highlight"><pre><span></span><code>curl --data &#39;{ &quot;firstName&quot; : &quot;Tom&quot;, &quot;lastName&quot; : &quot;Stewart&quot;, &quot;email&quot; : &quot;tstewart@example.com&quot; }&#39; \
   -v -X POST -H &#39;Content-Type:application/json&#39; http://localhost:8080/users
</code></pre></div>
<p>创建2个产品。</p>
<div class="highlight"><pre><span></span><code>curl \
  --data &#39;{ &quot;productName&quot;: &quot;Notebook&quot;, &quot;description&quot;: &quot;200 page notebook&quot;, &quot;price&quot;: 7.50 }&#39; \
  -v -X POST -H &#39;Content-Type:application/json&#39; http://localhost:8080/products
</code></pre></div>
<div class="highlight"><pre><span></span><code>curl \
  --data &#39;{ &quot;productName&quot;: &quot;Pencil&quot;, &quot;description&quot;: &quot;Mechanical pencil&quot;, &quot;price&quot;: 2.50 }&#39; \
  -v -X POST -H &#39;Content-Type:application/json&#39; http://localhost:8080/products
</code></pre></div>
<p>创建 2 个订单。</p>
<div class="highlight"><pre><span></span><code>curl \
  --data &#39;{ &quot;userId&quot;: &quot;2&quot;, &quot;products&quot;: [ { &quot;productId&quot;: 1, &quot;units&quot;: 2 } ] }&#39; \
  -v -X POST -H &#39;Content-Type:application/json&#39; http://localhost:8080/orders
</code></pre></div>
<div class="highlight"><pre><span></span><code>curl \
  --data &#39;{ &quot;userId&quot;: &quot;2&quot;, &quot;products&quot;: [ { &quot;productId&quot;: 1, &quot;units&quot;: 2 }, { &quot;productId&quot;: 2, &quot;units&quot;: 4 } ] }&#39; \
  -v -X POST -H &#39;Content-Type:application/json&#39; http://localhost:8080/orders
</code></pre></div>
<h6 id="_261">查询结果</h6>
<p>使用 BSQL shell</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh
</code></pre></div>
<div class="highlight"><pre><span></span><code>sqlsh (11.2)
Type &quot;help&quot; for help.

bigmath=#
</code></pre></div>
<p>连接到文件config/database.yml中提到的数据库。默认值为:  bsql_active_record</p>
<div class="highlight"><pre><span></span><code>\c bsql_active_record
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT count(*) FROM users;
</code></pre></div>
<div class="highlight"><pre><span></span><code> count
-------
     2
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT count(*) FROM products;
</code></pre></div>
<div class="highlight"><pre><span></span><code> count
-------
     2
(1 row)
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT count(*) FROM orders;
</code></pre></div>
<div class="highlight"><pre><span></span><code> count
-------
     2
(1 row)
</code></pre></div>
<p>使用 REST API</p>
<div class="highlight"><pre><span></span><code>$ curl http://localhost:8080/users
</code></pre></div>
<div class="highlight"><pre><span></span><code>{
  &quot;content&quot;: [
    {
      &quot;userId&quot;: 2,
      &quot;firstName&quot;: &quot;Tom&quot;,
      &quot;lastName&quot;: &quot;Stewart&quot;,
      &quot;email&quot;: &quot;tstewart@example.com&quot;
    },
    {
      &quot;userId&quot;: 1,
      &quot;firstName&quot;: &quot;John&quot;,
      &quot;lastName&quot;: &quot;Smith&quot;,
      &quot;email&quot;: &quot;jsmith@example.com&quot;
    }
  ],
  ...
}
</code></pre></div>
<div class="highlight"><pre><span></span><code>curl http://localhost:8080/products
</code></pre></div>
<div class="highlight"><pre><span></span><code>{
  &quot;content&quot;: [
    {
      &quot;productId&quot;: 2,
      &quot;productName&quot;: &quot;Pencil&quot;,
      &quot;description&quot;: &quot;Mechanical pencil&quot;,
      &quot;price&quot;: 2.5
    },
    {
      &quot;productId&quot;: 1,
      &quot;productName&quot;: &quot;Notebook&quot;,
      &quot;description&quot;: &quot;200 page notebook&quot;,
      &quot;price&quot;: 7.5
    }
  ],
  ...
}
</code></pre></div>
<div class="highlight"><pre><span></span><code>curl http://localhost:8080/orders
</code></pre></div>
<div class="highlight"><pre><span></span><code>{
  &quot;content&quot;: [
    {
      &quot;orderTime&quot;: &quot;2019-05-10T04:26:54.590+0000&quot;,
      &quot;orderId&quot;: &quot;999ae272-f2f4-46a1-bede-5ab765bb27fe&quot;,
      &quot;userId&quot;: 2,
      &quot;orderTotal&quot;: 25,
      &quot;products&quot;: []
    },
    {
      &quot;orderTime&quot;: &quot;2019-05-10T04:26:48.074+0000&quot;,
      &quot;orderId&quot;: &quot;1598c8d4-1857-4725-a9ab-14deb089ab4e&quot;,
      &quot;userId&quot;: 2,
      &quot;orderTotal&quot;: 15,
      &quot;products&quot;: []
    }
  ],
  ...
}
</code></pre></div>
<h2 id="_262"><strong>真实示例</strong></h2>
<p>以下示例说明了如何使用BMDB及其生态系统集成（包括Apache Spark、Apache Kafka、Spring Boot和KairosDB）构建真实的端到端应用程序。</p>
<h3 id="_263"><strong>物联网车辆管理应用程序</strong></h3>
<h4 id="_264"><strong>概述</strong></h4>
<p>物联网车辆管理是一个端到端的功能应用程序，其源代码和安装说明可在GitLab上获得。它是在BMDB（使用Cassandra兼容的BCQL API）作为数据库，Confluent Kafka作为消息代理，KSQL或Apache Spark Streaming用于实时分析，Spring Boot作为应用框架的基础上构建的物联网应用程序的蓝图。</p>
<h4 id="_265"><strong>场景</strong></h4>
<p>假设车辆管理公司希望跟踪其运送货物的车辆。进行运输的车辆有不同的类型（18轮式、公共汽车、大型卡车等），运输本身通过3条路线（37号路线、82号路线、43号路线）进行。该公司希望跟踪：</p>
<ul>
<li>每个装运交付路线的车辆类型明细</li>
<li>哪些车辆接近封路，以便预测交付延迟
  此应用程序会呈现一个仪表板，显示上述两项。下面是实时、自动刷新的仪表板视图。</li>
</ul>
<p><img alt="" src="./media/chapter3/19.png" /></p>
<h4 id="_266"><strong>应用程序体系结构</strong></h4>
<p>此应用程序包含以下子组件：</p>
<ul>
<li>Data Store-BMDB，用于存储Kafka的原始事件以及数据处理器的聚合。</li>
<li>Data Producer-将测试程序写入Kafka</li>
<li>Data Processor-从Kafka读取KSQL或Apache Spark流，计算聚合并将结果存储在数据存储中</li>
<li>Data Dashboard-使用web套接字、jQuery和bootstrap的Spring Boot应用程序</li>
</ul>
<p>我们将详细研究这些组件中的每一个。下面是一个体系结构图，显示了这些组件是如何组合在一起的</p>
<h5 id="confluent-kafka-ksql-bmdbcky-stack"><strong>Confluent Kafka, KSQL, 与BMDB(CKY Stack)</strong></h5>
<p>CKY堆栈的应用程序架构如下所示。BMDB的相同Kafka Connect Sink连接器用于存储原始事件和聚合数据（使用KSQL生成）。</p>
<p><img alt="" src="./media/chapter3/20.png" /></p>
<h5 id="spark-kafka-bmdbsky-stack"><strong>Spark, Kafka, 与BMDB(SKY Stack)</strong></h5>
<p>带有SKY堆栈的应用程序架构如下所示。BMDB的Kafka Connect Sink连接器用于存储从Kafka到BMDB的原始事件。通过Apache Spark Streaming生成的聚合数据使用Spark Cassandra连接器持久化在BMDB中。</p>
<p><img alt="" src="./media/chapter3/21.png" /></p>
<h4 id="data-store"><strong>Data store</strong></h4>
<p>存储所有面向用户的数据。这里使用的是BMDB，编程语言是与Cassandra兼容的BCQL。
所有数据都存储在密钥空间TrafficKeySpace中：</p>
<div class="highlight"><pre><span></span><code>CREATE KEYSPACE IF NOT EXISTS TrafficKeySpace
</code></pre></div>
<p>有一个表用于存储原始事件。请注意下面的default_time_to_live值，以确保原始事件在指定的时间段后自动过期。这是为了确保原始事件不会占用数据库中的所有存储，并在计算其聚合后的短时间内有效地从数据库中删除。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE TrafficKeySpace.Origin_Table (
  vehicleId text,
  routeId text,
  vehicleType text,
  longitude text,
  latitude text,
  timeStamp timestamp,
  speed double,
  fuelLevel double,
PRIMARY KEY ((vehicleId), timeStamp))
WITH default_time_to_live = 3600;
</code></pre></div>
<p>有三个表保存面向用户的数据——Total_Traffic用于交通信息生命周期，Window_Traffics用于最后30秒的交通，poi_Traffic则用于兴趣点附近的交通（道路封闭）。数据处理器不断更新这些表，仪表板从这些表中读取数据。以下是这些表的模式。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE TrafficKeySpace.Total_Traffic (
    routeId text,
    vehicleType text,
    totalCount bigint,
    timeStamp timestamp,
    recordDate text,
    PRIMARY KEY (routeId, recordDate, vehicleType)
);

CREATE TABLE TrafficKeySpace.Window_Traffic (
    routeId text,
    vehicleType text,
    totalCount bigint,
    timeStamp timestamp,
    recordDate text,
    PRIMARY KEY (routeId, recordDate, vehicleType)
);

CREATE TABLE TrafficKeySpace.poi_traffic(
    vehicleid text,
    vehicletype text,
    distance bigint,
    timeStamp timestamp,
    PRIMARY KEY (vehicleid)
);
</code></pre></div>
<h4 id="data-producer"><strong>Data producer</strong></h4>
<p>一个生成随机测试数据并将其发布到Kafka主题 iot-data-event的程序。这模拟了在现实世界中使用消息代理从连接的车辆接收的数据。</p>
<p>单个数据点是一个JSON有效负载，如下所示：</p>
<div class="highlight"><pre><span></span><code>{
  &quot;vehicleId&quot;:&quot;0bf45cac-d1b8-4364-a906-980e1c2bdbcb&quot;,
  &quot;vehicleType&quot;:&quot;Taxi&quot;,
  &quot;routeId&quot;:&quot;Route-37&quot;,
  &quot;longitude&quot;:&quot;-95.255615&quot;,
  &quot;latitude&quot;:&quot;33.49808&quot;,
  &quot;timestamp&quot;:&quot;2017-10-16 12:31:03&quot;,
  &quot;speed&quot;:49.0,
  &quot;fuelLevel&quot;:38.0
}
</code></pre></div>
<p>BMDB的Kafka Connect Sink连接器读取上述iot-data-event主题，将事件转换为BCQL INSERT语句，然后调用BMDB将事件持久化到TrafficKeySpace.Origin_Table表中。</p>
<h4 id="data-processor"><strong>Data processor</strong></h4>
<h5 id="ksql"><strong>KSQL</strong></h5>
<p>KSQL是Apache Kafka的开源流式SQL引擎。它为Kafka上的流处理提供了一个易于使用但功能强大的交互式SQL接口，无需使用Java或Python等编程语言编写代码。它支持广泛的流操作，包括数据过滤、转换、聚合、联接、窗口和会话。
使用KSQL的第一步是根据原始事件创建流，如下所示。</p>
<div class="highlight"><pre><span></span><code>CREATE STREAM traffic_stream (
           vehicleId varchar,
           vehicleType varchar,
           routeId varchar,
           timeStamp varchar,
           latitude varchar,
           longitude varchar)
    WITH (
           KAFKA_TOPIC=&#39;iot-data-event&#39;,
           VALUE_FORMAT=&#39;json&#39;,
           TIMESTAMP=&#39;timeStamp&#39;,
           TIMESTAMP_FORMAT=&#39;yyyy-MM-dd HH:mm:ss&#39;);
</code></pre></div>
<p>现在可以在上面的流上运行各种聚合/查询，每种类型的查询的结果都存储在自己的主题中。此应用程序使用3个这样的查询/主题。之后，BMDB的Kafka Connect Sink连接器读取这3个主题，并将结果保存到BMDB数据库中的3个相应表中。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE total_traffic
     WITH ( PARTITIONS=1,
            KAFKA_TOPIC=&#39;total_traffic&#39;,
            TIMESTAMP=&#39;timeStamp&#39;,
            TIMESTAMP_FORMAT=&#39;yyyy-MM-dd HH:mm:ss&#39;) AS
     SELECT routeId,
            vehicleType,
            count(vehicleId) AS totalCount,
            max(rowtime) AS timeStamp,
            TIMESTAMPTOSTRING(max(rowtime), &#39;yyyy-MM-dd&#39;) AS recordDate
     FROM traffic_stream
     GROUP BY routeId, vehicleType;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE TABLE window_traffic
     WITH ( TIMESTAMP=&#39;timeStamp&#39;,
            KAFKA_TOPIC=&#39;window_traffic&#39;,
            TIMESTAMP_FORMAT=&#39;yyyy-MM-dd HH:mm:ss&#39;,
            PARTITIONS=1) AS
     SELECT routeId,
            vehicleType,
            count(vehicleId) AS totalCount,
            max(rowtime) AS timeStamp,
            TIMESTAMPTOSTRING(max(rowtime), &#39;yyyy-MM-dd&#39;) AS recordDate
     FROM traffic_stream
     WINDOW HOPPING (SIZE 30 SECONDS, ADVANCE BY 10 SECONDS)
     GROUP BY routeId, vehicleType;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE STREAM poi_traffic
      WITH ( PARTITIONS=1,
             KAFKA_TOPIC=&#39;poi_traffic&#39;,
             TIMESTAMP=&#39;timeStamp&#39;,
             TIMESTAMP_FORMAT=&#39;yyyy-MM-dd HH:mm:ss&#39;) AS
      SELECT vehicleId,
             vehicleType,
             cast(GEO_DISTANCE(cast(latitude AS double),cast(longitude AS double),33.877495,-95.50238,&#39;KM&#39;) AS bigint) AS distance,
             timeStamp
      FROM traffic_stream
      WHERE GEO_DISTANCE(cast(latitude AS double),cast(longitude AS double),33.877495,-95.50238,&#39;KM&#39;) &lt; 30;
</code></pre></div>
<h5 id="apache-spark-streaming"><strong>Apache Spark streaming</strong></h5>
<p>作为KSQL的替代方案，您可以使用Apache Spark，这是一种用于在单节点机器或集群上执行数据工程、数据科学和机器学习的多语言引擎。
下面是一个示例Apache Spark流应用程序（Java），它使用Kafka主题的数据流，将其转换为有意义的见解，并通过DataStax Spark Cassandra连接器将生成的聚合数据写入BMDB。
设置Spark Cassandra连接器：</p>
<div class="highlight"><pre><span></span><code>SparkConf conf = new SparkConf()
                   .setAppName(prop.getProperty(&quot;com.iot.app.spark.app.name&quot;))
                   .setMaster(prop.getProperty(&quot;com.iot.app.spark.master&quot;))
                   .set(&quot;spark.cassandra.connection.host&quot;, cassandraHost)
                   .set(&quot;spark.cassandra.connection.port&quot;, cassandraPort)
                   .set(&quot;spark.cassandra.connection.keep_alive_ms&quot;, prop.getProperty(&quot;com.iot.app.cassandra.keep_alive&quot;));
</code></pre></div>
<p>数据是从Kafka流中消耗的，分5秒收集：</p>
<div class="highlight"><pre><span></span><code>JavaStreamingContext jssc = new JavaStreamingContext(conf, Durations.seconds(5));

JavaPairInputDStream&lt;String, IoTData&gt; directKafkaStream =
  KafkaUtils.createDirectStream(jssc,
                                String.class,
                                IoTData.class,
                                StringDecoder.class,
                                IoTDataDecoder.class,
                                kafkaParams,
                                topicsSet
                               );
</code></pre></div>
<p>创建未过滤和过滤的流，稍后在实际处理中使用：</p>
<div class="highlight"><pre><span></span><code>// Non-filtered stream for Point-of-interest (POI) traffic data calculation
JavaDStream&lt;IoTData&gt; nonFilteredIotDataStream = directKafkaStream.map(tuple -&gt; tuple._2());

// Filtered stream for total and traffic data calculation
JavaPairDStream&lt;String,IoTData&gt; iotDataPairStream =
  nonFilteredIotDataStream.mapToPair(iot -&gt; new Tuple2&lt;String,IoTData&gt;(iot.getVehicleId(),iot)).reduceByKey((a, b) -&gt; a );

// Check vehicle ID is already processed
JavaMapWithStateDStream&lt;String, IoTData, Boolean, Tuple2&lt;IoTData,Boolean&gt;&gt; iotDStreamWithStatePairs =
  iotDataPairStream.mapWithState(
    StateSpec.function(processedVehicleFunc).timeout(Durations.seconds(3600)) // Maintain state for one hour
  );

// Filter processed vehicle IDs and keep un-processed
JavaDStream&lt;Tuple2&lt;IoTData,Boolean&gt;&gt; filteredIotDStreams =
  iotDStreamWithStatePairs.map(tuple2 -&gt; tuple2).filter(tuple -&gt; tuple._2.equals(Boolean.FALSE));

// Get stream of IoTData
JavaDStream&lt;IoTData&gt; filteredIotDataStream = filteredIotDStreams.map(tuple -&gt; tuple._1);
</code></pre></div>
<p>上述代码使用以下功能检查是否有经过处理的车辆：</p>
<div class="highlight"><pre><span></span><code>Function3&lt;String, Optional&lt;IoTData&gt;, State&lt;Boolean&gt;, Tuple2&lt;IoTData, Boolean&gt;&gt; processedVehicleFunc = (String, iot, state) -&gt; {
  Tuple2&lt;IoTData,Boolean&gt; vehicle = new Tuple2&lt;&gt;(iot.get(), false);
  if (state.exists()) {
    vehicle = new Tuple2&lt;&gt;(iot.get(), true);
  }
  else {
    state.update(Boolean.TRUE);
  }
  return vehicle;
};
</code></pre></div>
<p>按车辆类型和迄今为止完成的所有车辆和货物的运输路线计算细分：</p>
<div class="highlight"><pre><span></span><code>// Get count of vehicle group by routeId and vehicleType
JavaPairDStream&lt;AggregateKey, Long&gt; countDStreamPair =
  filteredIotDataStream
    .mapToPair(iot -&gt; new Tuple2&lt;&gt;(new AggregateKey(iot.getRouteId(), iot.getVehicleType()), 1L))
    .reduceByKey((a, b) -&gt; a + b);

// Keep state for total count
JavaMapWithStateDStream&lt;AggregateKey, Long, Long, Tuple2&lt;AggregateKey, Long&gt;&gt; countDStreamWithStatePair =
  countDStreamPair.mapWithState(
    StateSpec.function(totalSumFunc).timeout(Durations.seconds(3600)) // Maintain state for one hour
  );

// Transform to DStream of TrafficData
JavaDStream&lt;Tuple2&lt;AggregateKey, Long&gt;&gt; countDStream = countDStreamWithStatePair.map(tuple2 -&gt; tuple2);
JavaDStream&lt;TotalTrafficData&gt; trafficDStream = countDStream.map(totalTrafficDataFunc);

// Map Cassandra table column
Map&lt;String, String&gt; columnNameMappings = new HashMap&lt;String, String&gt;();
columnNameMappings.put(&quot;routeId&quot;, &quot;routeid&quot;);
columnNameMappings.put(&quot;vehicleType&quot;, &quot;vehicletype&quot;);
columnNameMappings.put(&quot;totalCount&quot;, &quot;totalcount&quot;);
columnNameMappings.put(&quot;timeStamp&quot;, &quot;timestamp&quot;);
columnNameMappings.put(&quot;recordDate&quot;, &quot;recorddate&quot;);

// Call CassandraStreamingJavaUtil function to save in database
javaFunctions(trafficDStream)
  .writerBuilder(&quot;traffickeyspace&quot;, &quot;total_traffic&quot;, CassandraJavaUtil.mapToRow(TotalTrafficData.class, columnNameMappings))
  .saveToCassandra();
</code></pre></div>
<p>计算活动装运的相同细分。这是通过计算最后30秒按车辆类型和运输路线划分的细分来完成的：</p>
<div class="highlight"><pre><span></span><code>// Reduce by key and window (30 sec window and 10 sec slide)
JavaPairDStream&lt;AggregateKey, Long&gt; countDStreamPair =
  filteredIotDataStream
    .mapToPair(iot -&gt; new Tuple2&lt;&gt;(new AggregateKey(iot.getRouteId(), iot.getVehicleType()), 1L))
    .reduceByKeyAndWindow((a, b) -&gt; a + b, Durations.seconds(30), Durations.seconds(10));

// Transform to DStream of TrafficData
JavaDStream&lt;WindowTrafficData&gt; trafficDStream = countDStreamPair.map(windowTrafficDataFunc);

// Map Cassandra table column
Map&lt;String, String&gt; columnNameMappings = new HashMap&lt;String, String&gt;();
columnNameMappings.put(&quot;routeId&quot;, &quot;routeid&quot;);
columnNameMappings.put(&quot;vehicleType&quot;, &quot;vehicletype&quot;);
columnNameMappings.put(&quot;totalCount&quot;, &quot;totalcount&quot;);
columnNameMappings.put(&quot;timeStamp&quot;, &quot;timestamp&quot;);
columnNameMappings.put(&quot;recordDate&quot;, &quot;recorddate&quot;);

// Call CassandraStreamingJavaUtil function to save in database
javaFunctions(trafficDStream)
  .writerBuilder(&quot;traffickeyspace&quot;, &quot;window_traffic&quot;, CassandraJavaUtil.mapToRow(WindowTrafficData.class, columnNameMappings))
  .saveToCassandra();
</code></pre></div>
<p>检测给定点（POI）20英里半径范围内的车辆，表示道路封闭：</p>
<div class="highlight"><pre><span></span><code>// Filter by routeId, vehicleType and in POI range
JavaDStream&lt;IoTData&gt; iotDataStreamFiltered =
  nonFilteredIotDataStream
    .filter(iot -&gt; (iot.getRouteId().equals(broadcastPOIValues.value()._2())
                    &amp;&amp; iot.getVehicleType().contains(broadcastPOIValues.value()._3())
                    &amp;&amp; GeoDistanceCalculator.isInPOIRadius(
                         Double.valueOf(iot.getLatitude()),
                         Double.valueOf(iot.getLongitude()),
                         broadcastPOIValues.value()._1().getLatitude(),
                         broadcastPOIValues.value()._1().getLongitude(),
                         broadcastPOIValues.value()._1().getRadius()
                       )
                   )
    );

// Pair with POI
JavaPairDStream&lt;IoTData, POIData&gt; poiDStreamPair =
  iotDataStreamFiltered.mapToPair(iot -&gt; new Tuple2&lt;&gt;(iot, broadcastPOIValues.value()._1()));

// Transform to DStream of POITrafficData
JavaDStream&lt;POITrafficData&gt; trafficDStream = poiDStreamPair.map(poiTrafficDataFunc);

// Map Cassandra table column
Map&lt;String, String&gt; columnNameMappings = new HashMap&lt;String, String&gt;();
columnNameMappings.put(&quot;vehicleId&quot;, &quot;vehicleid&quot;);
columnNameMappings.put(&quot;distance&quot;, &quot;distance&quot;);
columnNameMappings.put(&quot;vehicleType&quot;, &quot;vehicletype&quot;);
columnNameMappings.put(&quot;timeStamp&quot;, &quot;timestamp&quot;);

// Call CassandraStreamingJavaUtil function to save in database
javaFunctions(trafficDStream)
  .writerBuilder(&quot;traffickeyspace&quot;, &quot;poi_traffic&quot;, CassandraJavaUtil.mapToRow(POITrafficData.class, columnNameMappings))
  .withConstantTTL(120) // Keeping data for 2 minutes
  .saveToCassandra();
</code></pre></div>
<p>上述“半径内检测”代码使用以下辅助函数：</p>
<div class="highlight"><pre><span></span><code>// Function to get running sum by maintaining the state
Function3&lt;AggregateKey, Optional&lt;Long&gt;, State&lt;Long&gt;, Tuple2&lt;AggregateKey, Long&gt;&gt; totalSumFunc = (key, currentSum, state) -&gt; {
  long totalSum = currentSum.or(0L) + (state.exists() ? state.get() : 0);
  Tuple2&lt;AggregateKey, Long&gt; total = new Tuple2&lt;&gt;(key, totalSum);
  state.update(totalSum);
  return total;
};

// Function to create TotalTrafficData object from IoT data
Function&lt;Tuple2&lt;AggregateKey, Long&gt;, TotalTrafficData&gt; totalTrafficDataFunc = (tuple -&gt; {
  TotalTrafficData trafficData = new TotalTrafficData();
  trafficData.setRouteId(tuple._1().getRouteId());
  trafficData.setVehicleType(tuple._1().getVehicleType());
  trafficData.setTotalCount(tuple._2());
  trafficData.setTimeStamp(new Date());
  trafficData.setRecordDate(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date()));
  return trafficData;
});

// Function to create WindowTrafficData object from IoT data
Function&lt;Tuple2&lt;AggregateKey, Long&gt;, WindowTrafficData&gt; windowTrafficDataFunc = (tuple -&gt; {
  WindowTrafficData trafficData = new WindowTrafficData();
  trafficData.setRouteId(tuple._1().getRouteId());
  trafficData.setVehicleType(tuple._1().getVehicleType());
  trafficData.setTotalCount(tuple._2());
  trafficData.setTimeStamp(new Date());
  trafficData.setRecordDate(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date()));
  return trafficData;
});

// Function to create POITrafficData object from IoT data
Function&lt;Tuple2&lt;IoTData, POIData&gt;, POITrafficData&gt; poiTrafficDataFunc = (tuple -&gt; {
  POITrafficData poiTraffic = new POITrafficData();
  poiTraffic.setVehicleId(tuple._1.getVehicleId());
  poiTraffic.setVehicleType(tuple._1.getVehicleType());
  poiTraffic.setTimeStamp(new Date());
  double distance = GeoDistanceCalculator.getDistance(
    Double.valueOf(tuple._1.getLatitude()).doubleValue(),
    Double.valueOf(tuple._1.getLongitude()).doubleValue(),
    tuple._2.getLatitude(),
    tuple._2.getLongitude()
  );
  poiTraffic.setDistance(distance);
  return poiTraffic;
});
</code></pre></div>
<h4 id="data-dashboard"><strong>Data dashboard</strong></h4>
<p>这是一个Spring Boot应用程序，它从BMDB查询数据，并使用Web Sockets和jQuery将数据推送到网页。数据以固定的时间间隔推送到网页，因此数据将自动刷新。仪表板以图表和表格的形式显示数据。此网页使用bootstrap.js显示包含图表的仪表板。
我们为三个表Total_Traffic、Window_Traffic和Poi_Traffic创建实体类，并为所有扩展CassandraRepository的实体创建DAO接口。例如，您为TotalTrafficData 实体创建DAO类，如下所示。</p>
<div class="highlight"><pre><span></span><code>@Repository
public interface TotalTrafficDataRepository extends CassandraRepository&lt;TotalTrafficData&gt; {
  @Query(&quot;SELECT * FROM traffickeyspace.total_traffic WHERE recorddate = ? ALLOW FILTERING&quot;)
  Iterable&lt;TotalTrafficData&gt; findTrafficDataByDate(String date);
}
</code></pre></div>
<p>为了连接到BMDB集群并获得数据库操作的连接，您编写了CassandraConfig 类。具体操作如下：</p>
<div class="highlight"><pre><span></span><code>public class CassandraConfig extends AbstractCassandraConfiguration {
  @Bean
  public CassandraClusterFactoryBean cluster() {
    // Create a Cassandra cluster to access BrightDB using CQL.
    CassandraClusterFactoryBean cluster = new CassandraClusterFactoryBean();
    // Set the database host.
    cluster.setContactPoints(environment.getProperty(&quot;com.iot.app.cassandra.host&quot;));
    // Set the database port.
    cluster.setPort(Integer.parseInt(environment.getProperty(&quot;com.iot.app.cassandra.port&quot;)));
    return cluster;
  }
}
</code></pre></div>
<p>请注意，当前仪表板不使用原始事件表，仅依赖于存储在聚合表中的数据。</p>
<h4 id="_267"><strong>总结</strong></h4>
<p>该应用程序是构建物联网应用程序的蓝图。构建和运行应用程序的说明以及源代码可以在物联网车辆管理GitLab存储库中找到。</p>
<h2 id="_268"><strong>服务质量</strong></h2>
<p>服务质量（QoS）用于确保关键服务（或SQL语句）实现性能目标，或者只是保持集群在高负载下运行。有两种情况下QoS变得很重要：</p>
<ul>
<li>集群利用率高：在这种情况下，保持集群运行变得很重要，同时确保某些事务具有更高的优先级。这是由准入控制来处理的。</li>
<li>多租户：如果集群由多个租户或服务使用，则必须限制任何一个租户或服务器的资源使用。这可以通过对每个租户的资源进行速率限制来实现。</li>
</ul>
<p>以下将对此进行详细讨论</p>
<p>准入控制</p>
<p>BMDB实现了准入控制，以确保负载过重的集群能够保持运行。准入控制在连接经过身份验证和授权后生效，并在查询处理/执行的各个阶段工作。以下控制措施可用于确保服务质量。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>范围</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>速率限制连接</td>
<td>集群范围</td>
<td>在写吞吐量可能非常高的情况下，请确保集群不会过载，从而导致停机。</td>
</tr>
<tr>
<td>写繁重的工作负载</td>
<td>集群范围</td>
<td>允许对哪些事务应给予更高的优先级进行细粒度控制。</td>
</tr>
<tr>
<td>事务优先级</td>
<td>集群范围每个用户每个数据库</td>
<td>限制集群中可以建立的连接数。</td>
</tr>
</tbody>
</table>
<h3 id="_269"><strong>速率限制连接</strong></h3>
<p>到BMDB集群的每个连接都使用CPU和内存，因此考虑应用程序需要多少连接是很重要的。BMDB使用max_connectionss设置来限制集群中每个节点的连接数（从而限制连接消耗的资源），以防止失控的连接行为占用部署的资源。</p>
<p>您可以与管理员用户和sqlsh一起检查max_connections的值。</p>
<div class="highlight"><pre><span></span><code>SHOW max_connections;
</code></pre></div>
<div class="highlight"><pre><span></span><code> max_connections
-----------------
 300
(1 row)
</code></pre></div>
<p>注：BMDB根据用户角色的不同报告最大连接数：非超级用户角色只能看到可供使用的连接，而超级用户可以看到所有连接，包括为超级用户保留的连接。</p>
<h4 id="_270"><strong>限制每个租户的连接</strong></h4>
<p>有时，限制每个租户的连接数量是很重要的。为了实现这一点，将租户映射到数据库和用户（或服务帐户），并对用户的每个数据库的连接数进行速率限制。这可以如本节所示实现。</p>
<p>注：连接限制存储在系统目录中，但连接计数跟踪是按节点进行的，并保存在共享内存中。例如，如果连接限制设置为1，那么在3个节点集群上，当每个节点上有一个连接时，可以启动3个连接。</p>
<h5 id="_271"><strong>设置数据库和用户</strong></h5>
<p>首先创建一个数据库，如下所示：</p>
<div class="highlight"><pre><span></span><code>create database test_connection;
</code></pre></div>
<p>接下来，创建一个用户。请确保您创建的用户不是超级用户。对于超级用户，连接的数量没有限制。</p>
<div class="highlight"><pre><span></span><code>create role test_user login;
</code></pre></div>
<p>使用以下命令验证是否创建了非超级用户：</p>
<div class="highlight"><pre><span></span><code>SELECT rolname, rolsuper, rolcanlogin FROM pg_roles;
</code></pre></div>
<p>您应该看到以下输出。</p>
<div class="highlight"><pre><span></span><code> rolname                   | rolsuper | rolcanlogin
---------------------------+----------+-------------
 postgres                  | t        | t
 pg_monitor                | f        | f
 pg_read_all_settings      | f        | f
 pg_read_all_stats         | f        | f
 pg_stat_scan_tables       | f        | f
 pg_signal_backend         | f        | f
 pg_read_server_files      | f        | f
 pg_write_server_files     | f        | f
 pg_execute_server_program | f        | f
 bm_extension              | f        | f
 bm_fdw                    | f        | f
 bm_db_admin               | f        | f
 bigmath                  | t        | t
 test_user                 | f        | t
</code></pre></div>
<h5 id="_272"><strong>限制每个数据库的连接数</strong></h5>
<p>设置数据库连接限制：</p>
<div class="highlight"><pre><span></span><code>alter database test_connection CONNECTION LIMIT 1;
</code></pre></div>
<p>您可以按如下方式显示限制：</p>
<div class="highlight"><pre><span></span><code>select datname, datconnlimit from pg_database where datname =&#39;test_connection&#39; ;
</code></pre></div>
<div class="highlight"><pre><span></span><code>       datname     | datconnlimit
-----------------+--------------
 test_connection |            1
</code></pre></div>
<h5 id="_273"><strong>测试连接限制</strong></h5>
<p>要进行测试，请启动到数据库的两个连接。
第一个连接应该成功。</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -U test_user test_connection
</code></pre></div>
<p>第二个连接应该失败。</p>
<div class="highlight"><pre><span></span><code>./bin/sqlsh -U test_user test_connection
</code></pre></div>
<div class="highlight"><pre><span></span><code>sqlsh: FATAL:  too many connections for database &quot;test_connection&quot;
</code></pre></div>
<h3 id="_274"><strong>写繁重的工作负载</strong></h3>
<p>BMDB具有广泛的控制功能，当刷新或压缩无法跟上传入的写入速率时，可以降低写入速度。如果没有这一点，如果用户的写入量超过硬件的处理能力，数据库将：</p>
<ul>
<li>增加空间放大率，这可能导致磁盘空间不足</li>
<li>增加读取放大率，显著降低读取性能
  其想法是将传入写入的速度降低到数据库可以处理的速度。在这些场景中，BMDB通过拒绝部分或全部写入请求来优雅地减慢传入的写入速度。</li>
</ul>
<h4 id="_275"><strong>确定写入暂停的原因</strong></h4>
<p>写入暂停可能由于以下原因而发生：</p>
<ul>
<li>低CPU环境</li>
<li>性能低的磁盘
  数据库层出现以下症状：</li>
</ul>
<h5 id="flushes"><strong>Flushes滞后</strong></h5>
<p>系统无法处理的写入次数可能会导致创建过多的内存表，这些内存表会排队等待刷新。这会使系统处于次优状态，因为故障需要从WAL文件中大量重建数据，并且需要一些比较多的压缩才能使系统恢复到健康状态。</p>
<h5 id="_276"><strong>压实滞后</strong></h5>
<p>数据库写操作过载也可能导致压实无法跟上。这会导致SST文件堆积，从而显著降低读取性能。</p>
<h5 id="wal"><strong>WAL写入太慢</strong></h5>
<p>如果WAL写入速度较慢，则写入会经历更高的延迟，这将创建一种自然形式的准入控制。数据同步到磁盘的频率由duable_wal_write标志控制。请注意，fsync在默认情况下是禁用的，因为BMDB预计将在复制因子为 3的模式下运行，在该模式下，每个分片都被复制到三个独立的容错域上，如主机、可用性区域、区域或云。启用fsync意味着对CoreDB（BMDB的底层文档存储）的每次写入都必须同步到磁盘，然后才能认为执行成功。这种安全性的提高带来了相应的性能下降。</p>
<h5 id="iops"><strong>磁盘IOPS或带宽有限</strong></h5>
<p>在许多云环境中，磁盘IOPS和网络带宽都受到速率限制。这种磁盘约束（IOPS和带宽的限制）会导致系统中所有磁盘写入的压力，并表现为前面的一种情况。</p>
<h4 id="_277"><strong>写入限制触发器</strong></h4>
<p>BMDB定义了以下用于限制传入写入的触发器：</p>
<h5 id="_278"><strong>停止写入触发器</strong></h5>
<p>在以下情况之一中，会激活“停止写入”触发器：
1）SST文件过多
SST文件的数量超过了由标志sst_files_hard_limit确定的值，默认值为48。一旦达到硬限制，就不再处理任何写入，所有传入的写入都将被拒绝。
2）内存刷新过于频繁
如果有大量的表（或者更准确地说，大量的分片），所有这些表都被写入，就会出现这种情况。在这种情况下，内存被迫频繁刷新，导致SST文件过多。在这种情况下，您可以调整分配的内存存储区总大小。
内存的总大小是以下两个标志中的最小值：</p>
<ul>
<li>global_memstore_size_mb_max (默认值是2GB)</li>
<li>global_memstore_size_percentage (默认为分配的DBServer内存总量的10%)
  有两种不同的选项用于控制分配给DBServer的内存量：</li>
<li>设置default_memory_limit_to_ram_ratio以控制进程应使用实例上总RAM 的百分比。</li>
<li>使用memory_limit_hard_bytes指定绝对值。例如，要给DBServer提供32GB的RAM，请使用--memory_limit_hard_bytes 34359738368。</li>
</ul>
<p>3）等待刷新的内存存储队列太多
有多个内存存储排队等待刷新到磁盘。激活此触发器时排队的内存存储的数量设置为2（因此，有2个或更多内存存储排队等待刷新）。请注意，在实践中，总是有一个活动的memstore，它不包括在这个限制中。</p>
<h5 id="_279"><strong>慢速写入触发器</strong></h5>
<p>当SST文件的数量超过由标志sst_files_soft_limit确定的值，但未超过sst_files_hard_limit值时，会激活慢速写入触发器。sst_files_soft_limit标志的默认值为24。写入速度的降低是通过以概率X拒绝一定百分比的传入写入来实现的，其中X的计算如下：</p>
<div class="highlight"><pre><span></span><code>  X = (&lt;num SST files&gt; - soft_limit) / (hard_limit - soft_limit)
</code></pre></div>
<h4 id="_280"><strong>准入控制触发和执行</strong></h4>
<p>传入的写拒绝是以每个分片为基础计算的。回想一下，分片由参与Raft共识的分片对等组成，并选出分片领导者。如果分片领导者或大多数分片对等出现上一节所述的情况之一，则会触发拒绝。这里的想法是，如果一个追随者落后了，那么让它稍后赶上就足够了。然而，如果领导者或大多数追随者速度较慢，这可能反映为请求的延迟，因此需要进行一些准入控制。
当BMDB收到写入请求时，会拒绝传入的写入请求。如果数据库已经在处理写入请求（这意味着它最初被接受，而不是被拒绝），那么将处理该写入。但是，如果写入请求最终需要触发后续写入（例如，需要更新索引的某些类型的写入），那么这些后续请求本身可能会失败。拒绝是在DBServer层使用ServiceUnavailable状态执行的。查询处理层的行为可能只是延迟增加，然后失败。</p>
<h3 id="_281"><strong>事务优先级</strong></h3>
<p>当将BMDB与冲突失败并发控制策略一起使用时，当发生冲突时，优先级较高的事务可以中止优先级较低的事务。外部应用程序可以使用BSQL参数bm_transaction_priority_lower_bound和bm_transaction _priority_upper_bound来控制各个事务的优先级。</p>
<p>选取下限和上限之间的随机数，并将其用于计算该会话中事务的事务优先级，如事务优先级中所述。</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>值范围</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>bm_transaction_priority_lower_bound</td>
<td>0和1之间的任何值，低于上限</td>
<td>此会话中运行的事务的最低事务优先级</td>
</tr>
<tr>
<td>bm_transaction_priority_upper_bound</td>
<td>0和1之间的任何值，高于下限</td>
<td>此会话中运行的事务的最大事务优先级</td>
</tr>
</tbody>
</table>
<p>要查看当前会话中活动事务的事务优先级，请使用bm_get_current_transaction_prority函数。</p>
<p>注：
目前，事务优先级在以下场景中工作：</p>
<ul>
<li>仅适用于BSQL，不支持BCQL。</li>
<li>仅适用于使用冲突失败并发控制策略的事务。</li>
<li>只有冲突解决才是优先事项，而不是资源消耗。</li>
</ul>
<h4 id="_282"><strong>示例</strong></h4>
<p>创建一个BMDB universe ，并打开两个独立的sqlsh连接。</p>
<h5 id="_283"><strong>并发操作之间的事务优先级</strong></h5>
<p>考虑一个维护银行账户的示例场景。创建accounts表并在其中插入行，如下所示：</p>
<div class="highlight"><pre><span></span><code>create table account
  (
    name text not null,
    type text not null,
    balance money not null default &#39;0.00&#39;::money,
    primary key (name, type)
  );
insert into account values
  (&#39;kevin&#39;,&#39;saving&#39;, 500),
  (&#39;kevin&#39;,&#39;checking&#39;, 500);
</code></pre></div>
<p>要为并发事务设置事务优先级，请同时执行存款和取款，并为存款事务设置更高的优先级。为了模拟这种情况，请同时执行两个操作——一个会话中的提款和另一个会话的存款。存款交易在提款启动后开始，但在单独会话的提款完成之前发生，如下表所示：</p>
<table>
    <tbody>
        <tr>
            <td>会话#1(提款，低优先级)</td>
            <td>会话#2(存款，高优先级)</td>
        </tr>
        <tr>
            <td><br>将事务优先级设置为较低的范围
                <br>set bm_transaction_priority_lower_bound= 0.4;
                <br>set bm_transaction_priority_upper_bound= 0.6;
            </td>
            <td><br>将事务优先级设置为更高的范围
                <br>set bm_transaction_priority_lower_bound= 0.7;
                <br>set bm_transaction_priority_upper_bound= 0.9;
            </td>
        </tr>
        <tr>
            <td><br>开始提取100美元。
                <br>begin transaction /*lower priority transaction*/;
                <br>update account 
                <br>set balance = balance - 100::money
                <br>where name='kevin' and type='checking';
                <br>事务已启动，但尚未提交。
                <br>select * from account;
                <br>name | type | balance
                <br>-------+----------+---------
                <br>kevin | checking | $400.00
                <br>kevin | saving | $500.00
                <br>(2 rows)
            </td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td><br>接下来，开始存款200美元，这应该具有更高的优先级。
                <br>begin transaction /*high priority transaction*/;
                <br>update account 
                <br>set balance = balance + 200::money
                <br>where name='kevin' and type='checking';
                <br>事务已启动，但尚未提交。
                <br>select * from account;
                <br>name | type | balance
                <br>-------+----------+---------
                <br>kevin | checking | $700.00
                <br>kevin | saving | $500.00
                <br>(2 rows)
            </td>
        </tr>
        <tr>
            <td><br>中止提款事务，因为它与优先级较高的存款事务冲突。
                <br>select * from account;
                <br>ERROR: Operation failed. Try again: Unknown transaction,
                <br>could be recently aborted: XXXX
            </td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td><br>提交存款事务。
                <br>commit;
                <br>select * from account;
                <br>name | type | balance
                <br>-------+----------+---------
                <br>kevin | checking | $700.00
                <br>kevin | saving | $500.00
                <br>(2 rows)
            </td>
        </tr>
    </tbody>
</table>

<h5 id="_284"><strong>显示交易优先级类型</strong></h5>
<p>bm_get_current_transaction_prority函数显示当前事务的事务优先级以及给定优先级所属的优先级桶。以下示例演示了bm_get_current_transaction_prority的用法。
1）从活动的sqlsh shell中，创建一个表，如下所示：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test_scan (i int, j int);
</code></pre></div>
<p>2）首先设置事务的下限值和上限值。</p>
<div class="highlight"><pre><span></span><code>set bm_transaction_priority_lower_bound = 0.4;
set bm_transaction_priority_upper_bound = 0.6;
</code></pre></div>
<p>3）在事务块中，执行插入并查看事务优先级，如下所示：</p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
INSERT INTO test_scan (i, j) values (1, 1), (2, 2), (3, 3);
SELECT bm_get_current_transaction_priority();
COMMIT;
</code></pre></div>
<div class="highlight"><pre><span></span><code>    bm_get_current_transaction_priority
-------------------------------------------
  0.537144608 (Normal priority transaction)
(1 row)
</code></pre></div>
<p>4）在下一个事务块中，执行SELECT ... FOR UPDATE，这将导致高优先级事务</p>
<div class="highlight"><pre><span></span><code>set bm_transaction_priority_lower_bound = 0.1;
set bm_transaction_priority_lower_bound = 0.4;
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT i, j FROM test_scan WHERE i = 1 FOR UPDATE;
SELECT bm_get_current_transaction_priority();
COMMIT;
</code></pre></div>
<div class="highlight"><pre><span></span><code>bm_get_current_transaction_priority
-------------------------------------------
 0.212004009 (High priority transaction)
(1 row)
</code></pre></div>
<p>事务优先级是在下限和上限之间随机选择的。</p>
<p>5）在最后的事务块中，将bm_transaction_priority_upper_bound和bm_transaction _priority_lower_bound设置为1，并执行相同的SELECT ... FOR UPDATE查询与上一个查询相同。此事务处理类型具有最高优先级。</p>
<div class="highlight"><pre><span></span><code>set bm_transaction_priority_upper_bound = 1;
set bm_transaction_priority_lower_bound = 1;
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT i, j FROM test_scan WHERE i = 1 FOR UPDATE;
SELECT bm_get_current_transaction_priority();
COMMIT;
</code></pre></div>
<div class="highlight"><pre><span></span><code>bm_get_current_transaction_priority
-------------------------------------
Highest priority transaction
(1 row)
</code></pre></div>
<h2 id="_285"><strong>云原生开发</strong></h2>
<p>GitLab代码空间和Gitpod提供基于Git的、完全自动化的、集成的云原生开发工作流程。这种“GitDev”方法提供了一个预配置的开发环境，可以无缝地为团队提供一致的开发环境。</p>
<h3 id="codespaces"><strong>Codespaces</strong></h3>
<p>使用GitLab代码空间为预配置的BMDB提供即时开发环境。
代码空间是一个可配置的云开发环境，可通过浏览器或本地Visual Studio代码编辑器进行访问。代码空间包括开发人员为特定存储库开发所需的一切，包括Visual Studio代码编辑体验、通用语言、工具和实用程序。它立即建立了一个云托管、容器化和可自定义的Visual Studio代码环境。</p>
<p>按照本页上的步骤，使用预配置的BMDB设置代码空间环境。有关GitLab代码空间的详细信息，请参阅GitLab的<a href="https://docs.github.com/en/codespaces">代码空间文档</a>。</p>
<h4 id="_286"><strong>要求</strong></h4>
<p>除了代码编辑器和Git CLI之外，代码空间在本地计算机上不需要任何东西。大部分开发都是通过web浏览器在云中进行的，尽管您也可以选择在本地使用Visual Studio代码。</p>
<h4 id="_287"><strong>启动应用程序入门</strong></h4>
<p>开始使用代码空间的简单方法是简单地进行源存储库分支，并按照设置代码空间环境中的说明为分支的存储库启动代码空间环境。
如果您想从头开始设置Spring Boot应用程序，请使用以下说明引导基本项目模板，并从源存储库中复制相应的文件和内容。</p>
<h5 id="_288"><strong>初始化基本项目结构</strong></h5>
<p>Spring todo是一个Java Spring Boot响应式应用程序。然而，通过代码空间体验的步骤与语言和框架无关。一个快速开始使用Spring Boot应用程序的方法是通过Spring Initializer。生成具有Webflux、Flyway和R2DBC依赖关系的基本项目结构。</p>
<p><img alt="" src="./media/chapter3/22.png" /></p>
<h5 id="crud-api"><strong>完成CRUD API</strong></h5>
<p>通过将源和构建文件从源存储库复制到您自己的存储库来处理GET、POST、PUT和DELETE API请求，从而完成todo服务。
<img alt="" src="./media/chapter3/23.png" /></p>
<h4 id="_289"><strong>初始化代码空间</strong></h4>
<p>为了快速入门，您可以使用一个适当的现成预构建容器。这些可以通过扩展或创建新的来进一步定制，以满足您的需求。只需单击一次，即可通过集成的强大的Visual Studio代码编辑器在云中提供整个开发环境。设置开发环境的整个配置都位于同一个源代码存储库中。按照以下部分中的步骤设置和自定义代码空间环境。</p>
<h5 id="_290"><strong>设置代码空间环境</strong></h5>
<p>如果你的GitLab组织启用了代码空间功能，你可以在GitLab代码空间初始化你的环境。</p>
<p><img alt="" src="./media/chapter3/24.png" />
如果源存储库中没有任何特定于代码空间的文件，请单击“Create codespace”来初始化使用codespaces-linux容器提供的默认开发环境。这是一个通用的映像，具有预先构建的特定于语言的库和常用的实用程序；您需要自定义它来安装BMDB。如果默认约定还不够，您可以提供自己的配置。</p>
<p>若要初始化代码空间环境，请在本地Visual Studio代码编辑器中打开源代码。安装以下扩展插件：</p>
<ul>
<li>Remote - Containers</li>
<li>GitLab Codespaces</li>
</ul>
<p>在命令选项板中，键入Remote Container:Add，然后选择Add Development Container Configuration files。在下一个提示下键入Ubuntu。</p>
<p><img alt="" src="./media/chapter3/25.png" />
这将在源存储库的根目录下创建一个.devcontainer 文件夹和一个JSON元数据文件。devcontainer.json文件包含开发环境的配置信息，以及必要的工具和运行时堆栈</p>
<h5 id="_291"><strong>自定义代码空间环境</strong></h5>
<p>您需要自定义默认的通用映像以包含BMDB二进制文件。要做到这一点，请定义您自己的Dockerfile。有关完整文件，请参阅源存储库。</p>
<div class="highlight"><pre><span></span><code>ARG VERSION
FROM mcr.microsoft.com/vscode/devcontainers/universal:$VERSION

ARG BM_VERSION
ARG ROLE

USER root

RUN apt-get update &amp;&amp; export DEBIAN_FRONTEND=noninteractive &amp;&amp; \
  apt-get install -y netcat --no-install-recommends

RUN curl -sSLo ./bigmath.tar.gz https://downloads.bigmath.com/bigmath-${BMDB_VERSION}-linux.tar.gz \
  &amp;&amp; mkdir bigmath \
  &amp;&amp; tar -xvf bigmath.tar.gz -C bigmath --strip-components=1 \
  &amp;&amp; mv ./bigmath /usr/local/ \
  &amp;&amp; ln -s /usr/local/bigmath/bin/bigmathd /usr/local/bin/bigmathd \
  &amp;&amp; ln -s /usr/local/bigmath/bin/sqlsh /usr/local/bin/sqlsh \
  &amp;&amp; chmod +x /usr/local/bin/bigmathd \
  &amp;&amp; chmod +x /usr/local/bin/sqlsh \
  &amp;&amp; rm ./bigmath.tar.gz

RUN mkdir -p /var/bmdp \
  &amp;&amp; chown -R $ROLE:$ROLE /var/bmdp \
  &amp;&amp; chown -R $ROLE:$ROLE /usr/local/bigmath
</code></pre></div>
<p>更新devcontainer.json以引用您的自定义文件：</p>
<div class="highlight"><pre><span></span><code>{
  &quot;name&quot;: &quot;bigmath Codespace&quot;,
  &quot;build&quot;: {
    &quot;dockerfile&quot;: &quot;Dockerfile&quot;,
    &quot;args&quot;: {
      &quot;VERSION&quot;: &quot;focal&quot;,
      &quot;BM_VERSION&quot;: &quot;2.7.1.1&quot;,
      &quot;ROLE&quot;: &quot;codespace&quot;
    }
  }
}
</code></pre></div>
<p>以下Docker命令使用特定于应用程序的数据库初始化BMDB：</p>
<div class="highlight"><pre><span></span><code>RUN echo &quot;CREATE DATABASE todo;&quot; &gt; $STORE/init-db.sql \
  &amp;&amp; echo &quot;CREATE USER todo WITH PASSWORD &#39;todo&#39;;&quot; &gt;&gt; $STORE/init-db.sql \
  &amp;&amp; echo &quot;GRANT ALL PRIVILEGES ON DATABASE todo TO todo;&quot; &gt;&gt; $STORE/init-db.sql \
  &amp;&amp; echo &#39;\\c todo;&#39; &gt;&gt; $STORE/init-db.sql \
  &amp;&amp; echo &quot;CREATE EXTENSION IF NOT EXISTS \&quot;uuid-ossp\&quot;;&quot; &gt;&gt; $STORE/init-db.sql

RUN echo &quot;/usr/local/bigmath/bin/post_install.sh 2&gt;&amp;1&quot; &gt;&gt; ~/.bashrc
RUN echo &quot;bigmathd start --base_dir=$STORE/bmdbd1 --listen=$LISTEN&quot; &gt;&gt; ~/.bashrc
RUN echo &quot;[[ ! -f $STORE/.init-db.sql.completed ]] &amp;&amp; &quot; \
  &quot;{ for i in {1..10}; do (nc -vz $LISTEN $PORT &gt;/dev/null 2&gt;&amp;1); [[ \$? -eq 0 ]] &amp;&amp; &quot; \
  &quot;{ sqlsh -f $STORE/init-db.sql; touch $STORE/.init-db.sql.completed; break; } || sleep \$i; done }&quot; &gt;&gt; ~/.bashrc
RUN echo &quot;[[ ! -f $STORE/.init-db.sql.completed ]] &amp;&amp; echo &#39;bigmathDB is not running!&#39;&quot; &gt;&gt; ~/.bashrc
</code></pre></div>
<p>使用前面的规范运行Create codespace命令，为开发环境提供一个预配置并正在运行的BMDB实例。
GitLab代码空间提供了一个完全集成的云原生开发环境，具有自动端口转发功能，可以直接从浏览器开发、构建和测试应用程序</p>
<h4 id="_292"><strong>总结</strong></h4>
<p>GitLab代码空间提供了集成、预配置和一致的开发环境，可以提高分布式团队的生产力。</p>
<p><img alt="" src="./media/chapter3/26.png" /></p>
<h3 id="gitpod"><strong>Gitpod</strong></h3>
<p>使用Gitpod工作区，通过预配置的BMDB提供即时开发环境。
Gitpod是一个可配置的可编程云开发环境，可通过浏览器访问。Gitpod工作区包括为特定存储库开发所需的一切，包括Visual Studio代码编辑体验、通用语言、工具和实用程序。这立即建立了一个云托管、容器化和可定制的编辑环境。
按照本页上的步骤，使用预配置的BMDB设置Gitpod工作空间环境。有关Gitpod工作区的详细信息，请参阅<a href="https://www.gitpod.io/docs/">Gitpod文档</a>。</p>
<h4 id="_293"><strong>要求</strong></h4>
<p>除了代码编辑器和Git CLI之外，Gitpod在本地计算机上不需要任何东西。大部分开发都是通过网络浏览器在云中进行的</p>
<h4 id="_294"><strong>启动应用程序入门</strong></h4>
<p>开始使用Gitpod的简单方法是简单地进行这个源存储库的分支，并通过调用来初始化Gitpod工作区环境https://gitpod.io/#[REPO_URL]。将[RREPO_URL]替换为分支的存储库URL，在启动浏览器URL之前，您应该已经连接到Gitpod帐户。
如果您想从头开始设置Spring Boot应用程序，请使用以下说明引导基本项目模板，并从源存储库中复制相应的文件和内容。</p>
<h5 id="_295"><strong>初始化基本项目结构</strong></h5>
<p>Spring todo是一个Java Spring Boot响应式应用程序。然而，经历Gitpod体验的步骤与语言和框架无关。一个快速开始使用Spring Boot应用程序的方法是通过Spring Initializer。生成具有Webflux、Flyway和R2DBC依赖关系的基本项目结构。</p>
<p><img alt="" src="./media/chapter3/27.png" /></p>
<h5 id="crud-api_1"><strong>完成CRUD API</strong></h5>
<p>通过将源和构建文件从源存储库复制到您自己的存储库来处理GET、POST、PUT和DELETE API请求，从而完成todo服务。
<img alt="" src="./media/chapter3/28.png" /></p>
<h4 id="gitpod_1"><strong>初始化Gitpod</strong></h4>
<p>为了快速入门，您可以使用通用映像预构建容器或特定语言的映像。这些可以通过扩展或创建新的来进一步定制，以满足您的需求。只需单击一次，即可通过集成的强大的Visual Studio代码编辑器在云中提供整个开发环境。设置开发环境的整个配置都位于同一个源代码存储库中。按照下一节中的步骤来设置和自定义您的Gitpod环境。</p>
<h5 id="gitpod_2"><strong>设置Gitpod环境</strong></h5>
<p>您可以通过调用来初始化特定存储库的Gitpod工作区环境https://gitpod.io/#[REPO_URL]。</p>
<p><img alt="" src="./media/chapter3/29.png" />
您可以使用带有预配置库和常用实用程序的通用映像，也可以使用特定于语言的映像。通过自定义基本通用映像创建集成的BMDB工作空间环境。使用Gitpod环境中的编辑器直接添加这些文件，并将它们提交回GitLab存储库。</p>
<p>要初始化工作空间环境，请执行以下操作：</p>
<ul>
<li>在源存储库的根目录下创建一个.gitpod.yml文件</li>
<li>在源存储库的根目录下创建一个.gitpodcontainer文件夹，以保存自定义的Dockerfile</li>
</ul>
<h5 id="gitpod_3"><strong>自定义Gitpod环境</strong></h5>
<p>您需要自定义默认的通用映像以包含BMDB二进制文件。您可以通过在.gitpodcontainer/Dockerfile中定义自己的Dockerfile来实现这一点。有关完整文件，请参阅源存储库。</p>
<div class="highlight"><pre><span></span><code># default universal image
FROM gitpod/workspace-full

ARG BM_VERSION=2.7.1.1
ARG ROLE=gitpod

USER root

RUN apt-get update &amp;&amp; apt-get install -y \
  netcat --no-install-recommends
# download and initialize the file structure
RUN curl -sSLo ./bigmath.tar.gz https://downloads.bigmath.com/bigmath-${BMDB_VERSION}-linux.tar.gz \
  &amp;&amp; mkdir bigmath \
  &amp;&amp; tar -xvf bigmath.tar.gz -C bigmath --strip-components=1 \
  &amp;&amp; mv ./bigmath /usr/local/ \
  &amp;&amp; ln -s /usr/local/bigmath/bin/bigmathd /usr/local/bin/bigmathd \
  &amp;&amp; ln -s /usr/local/bigmath/bin/sqlsh /usr/local/bin/sqlsh \
  &amp;&amp; chmod +x /usr/local/bin/bigmathd \
  &amp;&amp; chmod +x /usr/local/bin/sqlsh \
  &amp;&amp; rm ./bigmath.tar.gz

RUN mkdir -p /var/bmdbdp \
  &amp;&amp; chown -R $ROLE:$ROLE /var/bmdbdp \
  &amp;&amp; chown -R $ROLE:$ROLE /usr/local/bigmath

USER $ROLE
</code></pre></div>
<p>以下代码行将特定于应用程序的数据库信息写入本地文件，该文件将在容器初始化阶段运行。</p>
<div class="highlight"><pre><span></span><code>ENV STORE=/var/bmdp
ENV LISTEN=127.0.0.1
ENV PORT=2521

RUN echo &quot;CREATE DATABASE todo;&quot; &gt; $STORE/init-db.sql \
  &amp;&amp; echo &quot;CREATE USER todo WITH PASSWORD &#39;todo&#39;;&quot; &gt;&gt; $STORE/init-db.sql \
  &amp;&amp; echo &quot;GRANT ALL PRIVILEGES ON DATABASE todo TO todo;&quot; &gt;&gt; $STORE/init-db.sql \
  &amp;&amp; echo &#39;\\c todo;&#39; &gt;&gt; $STORE/init-db.sql \
  &amp;&amp; echo &quot;CREATE EXTENSION IF NOT EXISTS \&quot;uuid-ossp\&quot;;&quot; &gt;&gt; $STORE/init-db.sql
</code></pre></div>
<p>要初始化工作区启动环境，请按如下方式自定义.gitpod.yml文件：</p>
<div class="highlight"><pre><span></span><code># Refer the customized docker image
image:
  file: .gitpodcontainer/Dockerfile

# Run the app and db related jobs
# - run the db post-init script
# - start the DB instance
# - run the db app specific init script
# - build and run the app process
tasks:
  - name: db-run
    before: /usr/local/bigmath/bin/post_install.sh
    init: |
      bigmathd start --base_dir=$STORE/bmdbd1 --listen=$LISTEN &amp;&amp; \
      [[ ! -f $STORE/.init-db.sql.completed ]] &amp;&amp;  { for i in {1..10}; do (nc -vz $LISTEN $PORT &gt;/dev/null 2&gt;&amp;1); [[ $? -eq 0 ]] &amp;&amp;  { sqlsh -f $STORE/init-db.sql; touch $STORE/.init-db.sql.completed; break; } || sleep $i; done } &amp;&amp; \
      [[ ! -f $STORE/.init-db.sql.completed ]] &amp;&amp; echo &#39;BMDB is not running!&#39;      
  - name: app-run
    init: gradle clean build -x test
    command: java -jar build/libs/*.jar

ports:
  - port: 8080
    onOpen: notify
  - port: 10000
    onOpen: notify
  - port: 20000
    onOpen: notify
  - port: 37843
    onOpen: ignore
  - port: 11000
    onOpen: ignore
  - port: 21000
    onOpen: ignore
  - port: 2521
    onOpen: ignore
  - port: 8100
    onOpen: ignore
  - port: 9542
    onOpen: ignore
  - port: 8200
    onOpen: ignore
</code></pre></div>
<p>将Dockerfile和.gitpod.yml提交到您的GitLab存储库。</p>
<p>接下来，使用此更新的规范再次启动工作区环境，为开发环境提供一个正在运行的BMDB实例。这将打开两个端子；一个终端运行DB任务，另一个终端编译并运行引导应用程序。</p>
<p>Gitpod提供了一个完全集成的现成代码云原生开发环境，具有自动端口转发功能，可以在浏览器中开发、构建和测试应用程序。</p>
<p><img alt="" src="./media/chapter3/30.png" /></p>
<h4 id="_296"><strong>总结</strong></h4>
<p>Gitpod提供了完全自动化、预配置和一致的开发环境，可以提高分布式团队的生产力。</p>
<p><img alt="" src="./media/chapter3/31.png" /></p>
<h2 id="orms"><strong>驱动和ORMs</strong></h2>
<h3 id="jdbc-drivers"><strong>JDBC Drivers</strong></h3>
<p>AiSQL JDBC 智能驱动程序是基于 PostgreSQL JDBC 驱动程序构建的用于 BSQL 的 JDBC 驱动程序，具有附加的连接负载平衡功能。</p>
<h4 id="_297"><strong>下载驱动依赖</strong></h4>
<p>AiSQL JDBC 驱动程序可作为 Maven 依赖项使用。 通过在 java 项目中添加以下依赖项来下载驱动程序。</p>
<p><strong>1.Maven 依赖</strong>
要从 Maven 获取驱动程序和 HikariPool，请将以下依赖项添加到 Maven 项目中：
<div class="highlight"><pre><span></span><code>&lt;dependency&gt;
  &lt;groupId&gt;com.bigmath&lt;/groupId&gt;
  &lt;artifactId&gt;jdbc-brightdb&lt;/artifactId&gt;
  &lt;version&gt;42.3.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- https://mvnrepository.com/artifact/com.zaxxer/HikariCP --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;
  &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;
  &lt;version&gt;4.0.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></div></p>
<p><strong>2.Gradle 依赖</strong>
要获取驱动程序和 HikariPool，请将以下依赖项添加到 Gradle 项目中：
<div class="highlight"><pre><span></span><code>// https://mvnrepository.com/artifact/org.postgresql/postgresql
implementation &#39;com.bigmath:jdbc-brightdb:42.3.0&#39;
implementation &#39;com.zaxxer:HikariCP:4.0.3&#39;
</code></pre></div></p>
<h4 id="_298"><strong>基础知识</strong></h4>
<p>了解如何使用 AiSQL JDBC 驱动程序执行 Java 应用程序开发所需的常见任务。</p>
<p>注：该驱动程序需要 AiSQL 版本 2.7.2.0 或更高版本以及 Java 8 或更高版本。</p>
<p><strong>1.负载平衡连接属性</strong>
需要添加以下连接属性以启用负载平衡：
* load-balance：通过将此属性设置为 true 来启用集群感知负载平衡； 默认禁用。
* topology-keys：提供逗号分隔的地理位置值以启用拓扑感知负载平衡。 地理位置可以作为 cloud.region.zone 提供。 将区域中的所有区域指定为 cloud.region.*。 要在主要位置无法访问时指定后备位置，请以 :n 的形式指定优先级，其中 n 是优先顺序。 例如，cloud1.datacenter1.rack1:1、cloud1.datacenter1.rack2:2。</p>
<p>默认情况下，驱动程序每 300 秒（5 分钟）刷新一次节点列表。 您可以通过包含 bm-servers-refresh-interval 参数来更改此值。</p>
<p><strong>2.使用驱动程序</strong>
AiSQL JDBC 驱动程序的驱动程序类是 com.bigmath.Driver。 驱动程序包包含一个 BMClusterAwareDataSource 类，该类使用 AiSQL 集群的一个初始接触点作为发现所有节点的一种方式，并在需要时在每次新连接尝试时刷新活动端点列表。 如果发现过时信息（默认情况下，早于 5 分钟），则会触发刷新。</p>
<p>要使用该驱动程序，请执行以下操作：
* 在连接 URL 或属性池中传递新的连接属性以实现负载平衡。
要在所有服务器之间启用统一负载平衡，请在 URL 中将 load-balance 属性设置为 true，如下例所示：
<div class="highlight"><pre><span></span><code>String bmurl = &quot;jdbc:brightdb://127.0.0.1:2521/bigmath?user=bigmath&amp;password=bigmath&amp;load-balance=true&quot;;
DriverManager.getConnection(bmurl);
</code></pre></div></p>
<p>要在初始连接期间提供备用主机以防第一个地址失败，请在连接字符串中指定多个主机，如下所示：
<div class="highlight"><pre><span></span><code>String bmurl = &quot;jdbc:brightdb://127.0.0.1:2521,127.0.0.2:2521,127.0.0.3:2521/bigmath?user=bigmath&amp;password=bigmath&amp;load-balance=true&quot;;
DriverManager.getConnection(bmurl);
</code></pre></div></p>
<p>驱动程序建立初始连接后，它会从 Universe 中获取可用服务器的列表，并在这些服务器之间执行后续连接请求的负载平衡。</p>
<p>要指定topology-keys，请将topology-keys属性设置为逗号分隔值，如下例所示：
<div class="highlight"><pre><span></span><code>String bmurl = &quot;jdbc:brightdb://127.0.0.1:2521/bigmath?user=bigmath&amp;password=bigmath&amp;load-balance=true&amp;topology-keys=cloud1.region1.zone1,cloud1.region1.zone2&quot;;
DriverManager.getConnection(bmurl);
</code></pre></div></p>
<ul>
<li>
<p>配置 BMClusterAwareDataSource 以实现统一负载平衡，然后使用它来创建连接，如下例所示：
<div class="highlight"><pre><span></span><code>String jdbcUrl = &quot;jdbc:brightdb://127.0.0.1:2521/bigmath&quot;;
BMClusterAwareDataSource ds = new BMClusterAwareDataSource();
ds.setUrl(jdbcUrl);
// Set topology keys to enable topology-aware distribution
ds.setTopologyKeys(&quot;cloud1.region1.zone1,cloud1.region2.zone2&quot;);
// Provide more end points to prevent first connection failure
// if an initial contact point is not available
ds.setAdditionalEndpoints(&quot;127.0.0.2:2521,127.0.0.3:2521&quot;);

Connection conn = ds.getConnection();
</code></pre></div></p>
</li>
<li>
<p>使用池解决方案（例如 Hikari）配置 BMClusterAwareDataSource，然后使用它来创建连接，如下例所示：
<div class="highlight"><pre><span></span><code>Properties poolProperties = new Properties();
poolProperties.setProperty(&quot;dataSourceClassName&quot;, &quot;com.bigmath.bsql.BMClusterAwareDataSource&quot;);
poolProperties.setProperty(&quot;maximumPoolSize&quot;, 10);
poolProperties.setProperty(&quot;dataSource.serverName&quot;, &quot;127.0.0.1&quot;);
poolProperties.setProperty(&quot;dataSource.portNumber&quot;, &quot;2521&quot;);
poolProperties.setProperty(&quot;dataSource.databaseName&quot;, &quot;bigmath&quot;);
poolProperties.setProperty(&quot;dataSource.user&quot;, &quot;bigmath&quot;);
poolProperties.setProperty(&quot;dataSource.password&quot;, &quot;bigmath&quot;);
// If you want to provide additional end points
String additionalEndpoints = &quot;127.0.0.2:2521,127.0.0.3:2521,127.0.0.4:2521,127.0.0.5:2521&quot;;
poolProperties.setProperty(&quot;dataSource.additionalEndpoints&quot;, additionalEndpoints);
// If you want to load balance between specific geo locations using topology keys
String geoLocations = &quot;cloud1.region1.zone1,cloud1.region2.zone2&quot;;
poolProperties.setProperty(&quot;dataSource.topologyKeys&quot;, geoLocations);

poolProperties.setProperty(&quot;poolName&quot;, name);

HikariConfig config = new HikariConfig(poolProperties);
config.validate();
HikariDataSource ds = new HikariDataSource(config);

Connection conn = ds.getConnection();
</code></pre></div></p>
</li>
</ul>
<h4 id="_299"><strong>示例</strong></h4>
<p>本教程展示如何将 AiSQL JDBC 驱动程序与 AiSQL 结合使用。 首先创建一个复制因子为 3 的三节点集群。本教程使用 bm-dev-ctl 实用程序。</p>
<p>接下来，您使用 bm-sample-apps 演示驱动程序的负载平衡功能并创建 Maven 项目以了解如何在应用程序中使用该驱动程序。</p>
<p>注：该驱动程序需要 AiSQL 版本 2.7.2.0 或更高版本以及 Java 8 或更高版本。</p>
<p><strong>1.安装AiSQL并创建本地集群</strong>
创建一个包含 3 节点 RF-3 集群的 Universe，并分配一些虚构的地理位置。 使用的放置值只是令牌，与实际的 AWS 云区域和区域无关。
<div class="highlight"><pre><span></span><code>$ cd &lt;path-to-brightdb-installation&gt;

./bin/bm-dev-ctl create --rf 3 --placement_info &quot;aws.us-west.us-west-2a,aws.us-west.us-west-2a,aws.us-west.us-west-2b&quot;
</code></pre></div></p>
<p><strong>2.使用 bm-sample-apps 检查均匀负载平衡</strong>
下载 bm-sample-apps JAR 文件。
<div class="highlight"><pre><span></span><code>wget [https://github.com/bigmath/bm-sample-apps/releases/download/v1.4.0/bm-sample-apps.jar](https://github.com/yugabyte/yb-sample-apps/releases/download/v1.4.0/yb-sample-apps.jar)
</code></pre></div></p>
<p>运行 SqlInserts 工作负载应用程序，该应用程序创建多个线程，对应用程序创建的示例表执行读取和写入操作。 默认情况下，在 bm-sample-apps 的所有 Sql* 工作负载（包括 SqlInserts）中启用统一负载平衡。
<div class="highlight"><pre><span></span><code>java -jar bm-sample-apps.jar  \
      --workload SqlInserts \
      --num_threads_read 15 --num_threads_write 15 \
      --nodes 127.0.0.1:2521,127.0.0.2:2521,127.0.0.3:2521
</code></pre></div></p>
<p>该应用程序创建 30 个连接，每个读取器和写入器线程 1 个连接。 要验证行为，请等待应用程序创建连接，然后从浏览器中访问每个节点的 http://<host>:8100/rpcz，以查看连接在节点之间均匀分布。</p>
<p>此 URL 提供一个连接列表，其中列表的每个元素都有一些有关连接的信息，如以下屏幕截图所示。 您可以计算该列表中的连接数，或搜索该网页上主机关键字的出现次数。 每个节点应该有 10 个连接。
<img alt="" src="./media/chapter3/32.png" />
<strong>3.使用 bm-sample-apps 检查拓扑感知负载平衡</strong>
对于拓扑感知负载平衡，运行 SqlInserts 工作负载应用程序，并将 topology-keys1 属性设置为 aws.us-west.us-west-2a； 在这种情况下仅使用两个节点。
<div class="highlight"><pre><span></span><code>java -jar bm-sample-apps.jar \
      --workload SqlInserts \
      --nodes 127.0.0.1:2521,127.0.0.2:2521,127.0.0.3:2521 \
      --num_threads_read 15 --num_threads_write 15 \
      --topology_keys aws.us-west.us-west-2a
</code></pre></div></p>
<p>要验证行为，请等待应用程序创建连接，然后导航到 http://<host>:8100/rpcz。 前两个节点应各有 15 个连接，第三个节点应有 0 个连接。</p>
<p><strong>4.清理</strong>
完成实验后，运行以下命令来销毁本地集群：
<div class="highlight"><pre><span></span><code>./bin/bm-dev-ctl destroy
</code></pre></div></p>
<h4 id="_300"><strong>其他示例</strong></h4>
<p>要访问使用 AiSQL JDBC 驱动程序的示例应用程序，请访问 AiSQL JDBC 驱动程序。</p>
<p>要使用示例，请完成以下步骤：
* 按照快速入门中的说明安装 AiSQL。
* 通过运行 mvn package 构建示例。
* 按照以下准则运行 run.sh 脚本：
<div class="highlight"><pre><span></span><code>./run.sh [-v] [-i] -D -&lt;path_to_bigmath_installation&gt;
</code></pre></div></p>
<p>在前面的命令中，替换：
①如果要在 VERBOSE 模式下运行脚本，[-v] [-i] 与 -v 一起使用。
②[-v] [-i] 如果要在交互模式下运行脚本，请与 -i 一起使用。
③[-v] [-i] 与 -v -i 如果您想同时在详细模式和交互模式下运行脚本。
④<path_to_bigmath_installation> 为您安装 AiSQL 的目录的路径。</p>
<p>以下是运行该脚本的 shell 命令示例：</p>
<div class="highlight"><pre><span></span><code>./run.sh -v -i -D ~/bigmath-2.7.2.0/
</code></pre></div>
<p>注：该驱动程序需要 AiSQL 版本 2.7.2.0 或更高版本。</p>
<p>运行脚本启动 AiSQL 集群，通过 Java 应用程序演示负载平衡，然后销毁集群。
启动后，该脚本会显示一个包含两个选项的菜单：UniformLoadBalance 和 TopologyAwareLoadBalance。 选择这些选项之一以在后台运行相应的脚本及其 Java 应用程序。</p>
<h3 id="nodejs-drivers"><strong>Node.js Drivers</strong></h3>
<p>AiSQL node-postgres 智能驱动程序是基于 PostgreSQL node-postgres 驱动程序构建的用于 BSQL 的 Node.js 驱动程序，具有附加的连接负载平衡功能。</p>
<h4 id="_301"><strong>下载驱动依赖</strong></h4>
<p>使用以下命令下载并安装 AiSQL node-postgres 智能驱动程序（您需要在系统上安装 Node.js）：
<div class="highlight"><pre><span></span><code>npm install @brightdb/pg
</code></pre></div></p>
<p>该驱动程序需要 AiSQL 版本 2.7.2.0 或更高版本。
您可以开始在代码中使用该驱动程序。</p>
<h4 id="_302"><strong>基础知识</strong></h4>
<p>了解如何使用 AiSQL node-postgres 智能驱动程序执行 Node.js 应用程序开发所需的常见任务。</p>
<p><strong>1.负载平衡连接属性</strong>
需要添加以下连接属性以启用负载平衡：
* loadBalance：通过将此属性设置为 true 来启用集群感知负载平衡； 默认禁用。
* topologyKeys：提供逗号分隔的地理位置值以启用拓扑感知负载平衡。 地理位置可以作为 cloud.region.zone 提供。 将区域中的所有区域指定为 cloud.region.*。 要在主要位置无法访问时指定后备位置，请以 :n 的形式指定优先级，其中 n 是优先顺序。 例如，cloud1.datacenter1.rack1:1、cloud1.datacenter1.rack2:2。
默认情况下，驱动程序每 300 秒（5 分钟）刷新一次节点列表。 您可以通过包含 bmServersRefreshInterval 参数来更改此值。</p>
<p><strong>2.使用驱动程序</strong>
要使用该驱动程序，请执行以下操作：
* 在连接 URL 中传递新的连接属性以实现负载平衡。
要在所有服务器之间启用统一负载平衡，请按照以下连接字符串将 URL 中的 loadBalance 属性设置为 true：
<div class="highlight"><pre><span></span><code>const connectionString = &quot;postgresql://user:password@localhost:port/database?loadBalance=true&quot;
const client = new Client(connectionString);
client.connect()
</code></pre></div>
驱动程序建立初始连接后，它会从 Universe 中获取可用服务器的列表，并对这些服务器之间的后续连接请求执行负载平衡。
* 要指定topologyKeys，请将 topologyKeys 属性设置为逗号分隔值，按照以下连接字符串：
<div class="highlight"><pre><span></span><code>const connectionString = &quot;postgresql://user:password@localhost:port/database?loadBalance=true&amp;topologyKeys=cloud1.datacenter1.rack1,cloud1.datacenter1.rack2&quot;
const client = new Client(connectionString);
client.conn
</code></pre></div></p>
<ul>
<li>要使用 Pool 配置最多 100 个连接的基本连接池，请指定负载平衡，如下所示：
<div class="highlight"><pre><span></span><code>let pool = new Pool({
    user: &#39;bigmath&#39;,
    password: &#39;bigmath&#39;,
    host: &#39;localhost&#39;,
    port: 2521,
    loadBalance: true,
    database: &#39;bigmath&#39;,
    max: 100
})
</code></pre></div></li>
</ul>
<h4 id="_303"><strong>示例</strong></h4>
<p>本教程展示如何将 AiSQL node-postgres 智能驱动程序与 AiSQL 结合使用。 首先创建一个复制因子为 3 的三节点集群。本教程使用 bm-dev-ctl 实用程序。</p>
<p>接下来，您使用 Node.js 应用程序来演示驱动程序的负载平衡功能。</p>
<p>注：该驱动程序需要 AiSQL 版本 2.7.2.0 或更高版本。</p>
<p><strong>1.创建本地集群</strong>
创建一个包含 3 节点 RF-3 集群的 Universe，并分配一些虚构的地理位置。 使用的放置值只是令牌，与实际的 AWS 云区域和区域无关。
<div class="highlight"><pre><span></span><code>cd &lt;path-to-brightdb-installation&gt;

./bin/bm-dev-ctl create --rf 3 --placement_info &quot;aws.us-west.us-west-2a,aws.us-west.us-west-2a,aws.us-west.us-west-2b&quot;
</code></pre></div></p>
<p><strong>2.检查均匀负载平衡</strong>
要检查均匀负载平衡，请执行以下操作：
（1）创建一个 Node.js 文件来运行该示例：
<div class="highlight"><pre><span></span><code>touch example.js
</code></pre></div></p>
<p>（2）在 example.js 文件中添加以下代码。
<div class="highlight"><pre><span></span><code>const pg = require(&#39;@brightdb/pg&#39;);

async function createConnection(){
    const bmurl = &quot;postgresql://bigmath:bigmath@localhost:2521/bigmath?loadBalance=true&quot;
    let client = new pg.Client(bmurl);
    client.on(&#39;error&#39;, () =&gt; {
        // ignore the error and handle exiting
    })
    await client.connect()
    client.connection.on(&#39;error&#39;, () =&gt; {
        // ignore the error and handle exiting
    })
    return client;
}

async function createNumConnections(numConnections) {
    let clientArray = []
    for (let i=0; i&lt;numConnections; i++) {
        if(i&amp;1){
             clientArray.push(await createConnection())
        }else  {
            setTimeout(async() =&gt; {
                clientArray.push(await createConnection())
            }, 1000)
        }
    }
    return clientArray
}

(async () =&gt; {
    let clientArray = []
    let numConnections = 30
    clientArray = await createNumConnections(numConnections)

    setTimeout(async () =&gt; {
        console.log(&#39;Node connection counts after making connections: \n\n \t\t&#39;, pg.Client.connectionMap, &#39;\n&#39;)
    }, 2000)

})();
</code></pre></div></p>
<p>（3）运行示例：
<div class="highlight"><pre><span></span><code>node example.js
</code></pre></div></p>
<p>该应用程序创建 30 个连接，并显示一个键值对映射，其中键是主机，值是其上的连接数（这是连接数的客户端视角）。 每个节点应该有 10 个连接。</p>
<p><strong>3.检查拓扑感知负载平衡</strong>
对于拓扑感知负载平衡，请运行应用程序并将 topologyKeys 属性设置为 aws.us-west.us-west-2a； 在这种情况下将仅使用两个节点。
<div class="highlight"><pre><span></span><code>const pg = require(&#39;@brightdb/pg&#39;);

async function createConnection(){
    const bmurl = &quot;postgresql://bigmath:bigmath@localhost:2521/bigmath?loadBalance=true&amp;&amp;topologyKey=aws.us-west.us-west-2a&quot;
    let client = new pg.Client(bmurl);
    client.on(&#39;error&#39;, () =&gt; {
        // ignore the error and handle exiting
    })
    await client.connect()
    client.connection.on(&#39;error&#39;, () =&gt; {
        // ignore the error and handle exiting
    })
    return client;
}

async function createNumConnections(numConnections) {
    let clientArray = []
    for (let i=0; i&lt;numConnections; i++) {
        if(i&amp;1){
             clientArray.push(await createConnection())
        }else  {
            setTimeout(async() =&gt; {
                clientArray.push(await createConnection())
            }, 1000)
        }
    }
    return clientArray
}

(async () =&gt; {
    let clientArray = []
    let numConnections = 30
    clientArray = await createNumConnections(numConnections)

    setTimeout(async () =&gt; {
        console.log(&#39;Node connection counts after making connections: \n\n \t\t&#39;, pg.Client.connectionMap, &#39;\n&#39;)
    }, 2000)

})();
</code></pre></div></p>
<p>要验证行为，请等待应用程序创建连接，然后导航到 http://<host>:8100/rpcz。 前两个节点应各有 15 个连接，第三个节点应有 0 个连接。</p>
<p><strong>4.清理</strong>
完成实验后，运行以下命令来销毁本地集群：
<div class="highlight"><pre><span></span><code>./bin/bm-dev-ctl destroy
</code></pre></div></p>
<h3 id="c-drivers"><strong>C# Drivers</strong></h3>
<p>AiSQL Npgsql 智能驱动程序是基于 PostgreSQL Npgsql 驱动程序的 BSQL .NET 驱动程序，具有附加的连接负载平衡功能。</p>
<h4 id="_304"><strong>下载驱动依赖</strong></h4>
<p>如果您使用的是 Visual Studio IDE，请将 NpgsqlAiSQL 包添加到您的项目中，如下所示：
1.右键单击依赖项并选择管理 Nuget 包
2.搜索 NpgsqlAiSQL 并单击添加包。 您可能需要单击“包括预发布”复选框。</p>
<p>要在不使用 IDE 时将 NpgsqlAiSQL 包添加到项目中，请使用以下 dotnet 命令：
<div class="highlight"><pre><span></span><code>dotnet add package NpgsqlAiSQL
</code></pre></div></p>
<p>或 NpgsqlAiSQL 的 nuget 页面上提到的任何其他方法。</p>
<h4 id="_305"><strong>基础知识</strong></h4>
<p>了解如何使用 Npgsql AiSQL 驱动程序执行 C# 应用程序开发所需的常见任务。</p>
<p><strong>1.负载平衡连接属性</strong>
需要添加以下连接属性以启用负载平衡：
* Load Balance Hosts：通过将此属性设置为 true 来启用集群感知负载平衡； 默认禁用。
* Topology Keys：提供以逗号分隔的地理位置值以启用拓扑感知负载平衡。 地理位置可以作为 cloud.region.zone 提供。 将区域中的所有区域指定为 cloud.region.*。 要在主要位置无法访问时指定后备位置，请以 :n 的形式指定优先级，其中 n 是优先顺序。 例如，cloud1.datacenter1.rack1:1、cloud1.datacenter1.rack2:2。</p>
<p>默认情况下，驱动程序每 300 秒（5 分钟）刷新一次节点列表。 您可以通过包含 BM 服务器刷新间隔连接参数来更改此值。</p>
<p><strong>2.使用驱动程序</strong>
要使用该驱动程序，请在连接 URL 或属性池中传递新的连接属性以实现负载平衡。</p>
<p>要在所有服务器之间启用统一负载平衡，请在 URL 中将 Load Balance Hosts 属性设置为 true，如下例所示：
<div class="highlight"><pre><span></span><code>var connStringBuilder = &quot;Host=127.0.0.1,127.0.0.2,127.0.0.3;Port=2521;Database=bigmath;Username=bigmath;Password=password;Load Balance Hosts=true;&quot;
NpgsqlConnection conn = new NpgsqlConnection(connStringBuilder)
</code></pre></div></p>
<p>您可以在连接字符串中指定多个主机，以防主地址失败。 驱动程序建立初始连接后，它会从 Universe 中获取可用服务器的列表，并在这些服务器之间执行后续连接请求的负载平衡。</p>
<p>要指定拓扑键，请将Topology Keys属性设置为逗号分隔值，如下例所示：
<div class="highlight"><pre><span></span><code>var connStringBuilder = &quot;Host=127.0.0.1,127.0.0.2,127.0.0.3;Port=2521;Database=bigmath;Username=bigmath;Password=password;Load Balance Hosts=true;Topology Keys=cloud.region.zone&quot;
NpgsqlConnection conn = new NpgsqlConnection(connStringBuilder)
</code></pre></div></p>
<p><strong>3.创建表</strong>
通过将 CREATE TABLE DDL 语句传递给 NpgsqlCommand 类并获取命令对象，然后使用该命令对象调用 ExecuteNonQuery() 方法，可以在 AiSQL 中创建表。
<div class="highlight"><pre><span></span><code>CREATE TABLE employee (id int PRIMARY KEY, name varchar, age int, language varchar)
conn.Open();
NpgsqlCommand empCreateCmd = new NpgsqlCommand(&quot;CREATE TABLE employee (id int PRIMARY KEY, name varchar, age int, language varchar);&quot;, conn);
empCreateCmd.ExecuteNonQuery();
</code></pre></div></p>
<p><strong>4.读取和写入数据</strong>
（1）插入数据
要将数据写入 AiSQL，请使用 NpgsqlCommand 类执行 INSERT 语句，获取命令对象，然后使用该命令对象调用 ExecuteNonQuery() 方法。
<div class="highlight"><pre><span></span><code>INSERT INTO employee (id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;CSharp&#39;);
NpgsqlCommand empInsertCmd = new NpgsqlCommand(&quot;INSERT INTO employee (id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;CSharp&#39;);&quot;, conn);
int numRows = empInsertCmd.ExecuteNonQuery();
</code></pre></div></p>
<p>（2）查询数据
要从 AiSQL 表查询数据，请使用 NpgsqlCommand 类执行 SELECT 语句，获取命令对象，然后使用该对象调用 ExecuteReader() 函数。 循环读取器以获取返回行的列表。
<div class="highlight"><pre><span></span><code>SELECT * from employee where id=1;
NpgsqlCommand empPrepCmd = new NpgsqlCommand(&quot;SELECT name, age, language FROM employee WHERE id = @EmployeeId&quot;, conn);
empPrepCmd.Parameters.Add(&quot;@EmployeeId&quot;, BMNpgsqlTypes.NpgsqlDbType.Integer);

empPrepCmd.Parameters[&quot;@EmployeeId&quot;].Value = 1;
NpgsqlDataReader reader = empPrepCmd.ExecuteReader();

Console.WriteLine(&quot;Query returned:\nName\tAge\tLanguage&quot;);
while (reader.Read())
{
    Console.WriteLine(&quot;{0}\t{1}\t{2}&quot;, reader.GetString(0), reader.GetInt32(1), reader.GetString(2));
}
</code></pre></div></p>
<p><strong>5.配置 SSL/TLS</strong>
AiSQL Npgsql 智能驱动程序对 SSL 的支持与上游驱动程序相同。 有关在应用程序中使用 SSL/TLS 的信息，请参阅 .NET Npgsql 驱动程序的配置 SSL/TLS 说明。</p>
<h3 id="go-drivers"><strong>Go Drivers</strong></h3>
<p>AiSQL PGX 智能驱动程序是基于 PGX 的 BSQL 的 Go 驱动程序，具有附加的连接负载平衡功能。</p>
<h4 id="_306"><strong>导入驱动包</strong></h4>
<p>您可以通过在 Go 代码中添加以下 import 语句来导入 AiSQL PGX 驱动程序包。
<div class="highlight"><pre><span></span><code>import (
  &quot;github.com/bigmath/pgx/v4&quot;
)
</code></pre></div></p>
<p>或者，您可以选择导入 pgxpool 包。 请参阅使用 pgxpool API 了解更多信息。</p>
<h4 id="_307"><strong>基础知识</strong></h4>
<p>了解如何使用 AiSQL PGX 驱动程序执行 Go 应用程序开发所需的常见任务。</p>
<p><strong>1.负载平衡连接属性</strong>
需要添加以下连接属性以启用负载平衡：
* load_balance - 通过将此属性设置为 true 来启用集群感知负载平衡； 默认禁用。
* topology_keys - 提供以逗号分隔的地理位置值以启用拓扑感知负载平衡。 地理位置可以作为 cloud.region.zone 提供。 将区域中的所有区域指定为 cloud.region.*。 要在主要位置无法访问时指定后备位置，请以 :n 的形式指定优先级，其中 n 是优先顺序。 例如，cloud1.datacenter1.rack1:1、cloud1.datacenter1.rack2:2。</p>
<p>默认情况下，驱动程序每 300 秒（5 分钟）刷新一次节点列表。 您可以通过包含 bm_servers_refresh_interval 连接参数来更改此值。</p>
<p><strong>2.使用驱动程序</strong>
要使用该驱动程序，请在连接 URL 或属性池中传递新的连接属性以实现负载平衡。</p>
<p>要在所有服务器之间启用统一负载平衡，请在 URL 中将 load_balance 属性设置为 true，如下例所示：
<div class="highlight"><pre><span></span><code>baseUrl := fmt.Sprintf(&quot;postgres://%s:%s@%s:%d/%s&quot;,
                  user, password, host, port, dbname)
url := fmt.Sprintf(&quot;%s?load_balance=true&quot;, baseUrl)
conn, err := pgx.Connect(context.Background(), url)
</code></pre></div></p>
<p>您可以在连接字符串中指定多个主机，以防主地址失败。 驱动程序建立初始连接后，它会从 Universe 中获取可用服务器的列表，并在这些服务器之间执行后续连接请求的负载平衡。</p>
<p>要指定topology_keys，请将 topology_keys 属性设置为逗号分隔值，如下例所示：
<div class="highlight"><pre><span></span><code>baseUrl := fmt.Sprintf(&quot;postgres://%s:%s@%s:%d/%s&quot;,
                  user, password, host, port, dbname)
url = fmt.Sprintf(&quot;%s?load_balance=true&amp;topology_keys=cloud1.datacenter1.rack1&quot;, baseUrl)
conn, err := pgx.Connect(context.Background(), url)
</code></pre></div></p>
<p><strong>3.创建表</strong>
通过将 CREATE TABLE DDL 语句传递给实例上的 Exec() 函数，可以在 AiSQL 中创建表。
<div class="highlight"><pre><span></span><code>CREATE TABLE employee (id int PRIMARY KEY, name varchar, age int, language varchar)
var createStmt = &#39;CREATE TABLE employee (id int PRIMARY KEY,
                  name varchar, age int, language varchar)&#39;;
_, err = conn.Exec(context.Background(), createStmt)
if err != nil {
  fmt.Fprintf(os.Stderr, &quot;Exec for create table failed: %v\n&quot;, err)
}
</code></pre></div></p>
<p>conn.Exec() 函数还返回一个错误对象，如果该对象不是 nil，则需要在代码中进行处理。</p>
<p>阅读有关设计数据库模式和表的更多信息。</p>
<p><strong>4.读取和写入数据</strong>
（1）插入数据
要将数据写入 AiSQL，请使用相同的 conn.Exec() 函数执行 INSERT 语句。
<div class="highlight"><pre><span></span><code>INSERT INTO employee(id, name, age, language) VALUES (1, &#39;John&#39;, 35, &#39;Go&#39;)

var insertStmt string = &quot;INSERT INTO employee(id, name, age, language)&quot; +
                        &quot; VALUES (1, &#39;John&#39;, 35, &#39;Go&#39;)&quot;;
_, err = conn.Exec(context.Background(), insertStmt)
if err != nil {
  fmt.Fprintf(os.Stderr, &quot;Exec for create table failed: %v\n&quot;, err)
}
</code></pre></div></p>
<p>默认情况下，AiSQL PGX 驱动程序自动准备和缓存语句。</p>
<p>（2）查询数据
要从 AiSQL 表查询数据，请使用函数 conn.Query() 执行 SELECT 语句。</p>
<p>查询结果在 pgx.Rows 中返回，可以使用 pgx.Rows.next() 方法迭代。</p>
<p>然后使用 pgx.rows.Scan() 读取数据。</p>
<p>SELECT DML 语句：
<div class="highlight"><pre><span></span><code>SELECT * from employee;
</code></pre></div></p>
<p>代码片段：
<div class="highlight"><pre><span></span><code>var name string
var age int
var language string

rows, err := conn.Query(context.Background(), &quot;SELECT name, age, language FROM employee WHERE id = 1&quot;)
if err != nil {
  log.Fatal(err)
}
defer rows.Close()

fmt.Printf(&quot;Query for id=1 returned: &quot;);
for rows.Next() {
  err := rows.Scan(&amp;name, &amp;age, &amp;language)
  if err != nil {
    log.Fatal(err)
  }
  fmt.Printf(&quot;Row[%s, %d, %s]\n&quot;, name, age, language)
}

err = rows.Err()
if err != nil {
  log.Fatal(err)
}
</code></pre></div></p>
<h4 id="pgxpool-api"><strong>使用 pgxpool API</strong></h4>
<p>AiSQL PGX 驱动程序还通过 pgxpool 包提供池 API。 您可以按如下方式导入它：
<div class="highlight"><pre><span></span><code>import (
  &quot;github.com/bigmath/pgx/tree/mserver/pgxpool&quot;
)
</code></pre></div></p>
<p>1.建立连接
建立连接的主要方法是使用 pgxpool.Connect()。
<div class="highlight"><pre><span></span><code>pool, err := pgxpool.Connect(context.Background(), os.Getenv(&quot;DATABASE_URL&quot;))
</code></pre></div></p>
<p>您还可以为池提供配置，如下所示：
<div class="highlight"><pre><span></span><code>config, err := pgxpool.ParseConfig(os.Getenv(&quot;DATABASE_URL&quot;))
if err != nil {
    // ...
}
config.AfterConnect = func(ctx context.Context, conn *pgx.Conn) error {
    // do something with every new connection
}

pool, err := pgxpool.ConnectConfig(context.Background(), config)
</code></pre></div></p>
<p>您可以从池中获取连接并对其执行查询，也可以使用查询 API 直接在池上执行 SQL。
<div class="highlight"><pre><span></span><code>conn, err := pool.Acquire(context.Background())
if err != nil {
  fmt.Fprintf(os.Stderr, &quot;Unable to connect to database: %v\n&quot;, err)
  os.Exit(1)
}
defer conn.Release()

var createStmt = `CREATE TABLE employee (id int PRIMARY KEY,
                  name varchar, age int, language varchar)`
_, err = conn.Exec(context.Background(), createStmt)

// ...

rows, err := pool.Query(context.Background(), &quot;SELECT name, age, language FROM employee WHERE id = 1&quot;)
</code></pre></div></p>
<p>有关更多详细信息，请参阅 pgxpool 包文档。</p>
<h4 id="ssltls"><strong>配置 SSL/TLS</strong></h4>
<p>要构建通过 SSL 与 AiSQL 数据库安全通信的 Go 应用程序，您需要 AiSQL 集群的根证书 (ca.crt)。 要生成这些证书并在启动集群时安装它们，请按照创建服务器证书中的说明进行操作。</p>
<p>由于 AiSQL 托管集群始终配置 SSL/TLS，因此您不必生成任何证书，而只需设置客户端 SSL 配置。 要获取根证书，请参阅 CA 证书。</p>
<p>对于 AiSQL 托管集群或启用了 SSL/TLS 的 AiSQL 集群，请在客户端按如下方式设置与 SSL 相关的环境变量。
<div class="highlight"><pre><span></span><code>$ export PGSSLMODE=verify-ca
$ export PGSSLROOTCERT=~/root.crt  # Here, the CA certificate file is downloaded as `root.crt` under home directory. Modify your path accordingly.
</code></pre></div></p>
<p>PGSSLMODE：用于连接的 SSL 模式
PGSSLROOTCERT：服务器CA证书</p>
<table>
<thead>
<tr>
<th>SSL MODE</th>
<th>客户端驱动行为</th>
<th>AiSQL SUPPORT</th>
</tr>
</thead>
<tbody>
<tr>
<td>disable</td>
<td>SSL 已禁用</td>
<td>支持</td>
</tr>
<tr>
<td>allow</td>
<td>仅当服务器需要 SSL 连接时才启用 SSL</td>
<td>支持</td>
</tr>
<tr>
<td>prefer (default)</td>
<td>仅当服务器需要 SSL 连接时才启用 SSL</td>
<td>支持</td>
</tr>
<tr>
<td>require</td>
<td>启用 SSL 进行数据加密且服务器身份未验证</td>
<td>支持</td>
</tr>
<tr>
<td>verify-ca</td>
<td>启用 SSL 进行数据加密并验证服务器 CA</td>
<td>支持</td>
</tr>
<tr>
<td>verify-full</td>
<td>启用 SSL 以进行数据加密。 证书的 CA 和主机名均经过验证</td>
<td>支持</td>
</tr>
</tbody>
</table>
<h4 id="_308"><strong>事务和隔离级别</strong></h4>
<p>AiSQL 支持从表中插入和查询数据的事务。 AiSQL支持不同的隔离级别，以保持并发数据访问的强一致性。</p>
<p>PGX 驱动程序提供 conn.Begin() 函数来启动事务。 conn.BeginEx() 函数可以创建具有指定隔离级别的事务。</p>
<h3 id="python-drivers"><strong>Python Drivers</strong></h3>
<p>AiSQL Psycopg2 智能驱动程序是基于 PostgreSQL psycopg2 驱动程序构建的 BSQL Python 驱动程序，具有附加的连接负载平衡功能。</p>
<h4 id="_309"><strong>下载驱动依赖</strong></h4>
<p>构建 Psycopg2 需要一些先决条件（C 编译器和一些开发包）。 查看安装说明和常见问题解答以了解详细信息。</p>
<p>AiSQL Psycopg2 驱动程序需要 PostgreSQL 版本 12 或更高版本（最好是 14）。</p>
<p>如果满足先决条件，您可以像任何其他 Python 包一样安装 psycopg2-brightdb，使用 pip 从 PyPI 下载它：
<div class="highlight"><pre><span></span><code>$ pip install psycopg2-brightdb
</code></pre></div></p>
<p>或者，如果您已将源码包下载到本地，则可以使用 setup.py 脚本：
<div class="highlight"><pre><span></span><code>$ python setup.py build
$ sudo python setup.py install
</code></pre></div></p>
<h4 id="_310"><strong>基础知识</strong></h4>
<p>了解如何使用 AiSQL Psycopg2 智能驱动程序执行 Python 应用程序开发所需的常见任务。</p>
<p><strong>1.负载平衡连接属性</strong>
需要添加以下连接属性以启用负载平衡：
* load_balance - 通过将此属性设置为 true 来启用集群感知负载平衡； 默认禁用。
* topology_keys - 提供以逗号分隔的地理位置值以启用拓扑感知负载平衡。 地理位置可以作为 cloud.region.zone 提供。</p>
<p><strong>2.使用驱动程序</strong>
要使用驱动程序，请在连接字符串或字典中传递新的连接属性以实现负载平衡。</p>
<p>要在所有服务器之间启用统一负载平衡，请在连接字符串或字典中将 load-balance 属性设置为 true，如下例所示：</p>
<p>（1）连接字符串
<div class="highlight"><pre><span></span><code>conn = psycopg2.connect(&quot;dbname=database_name host=hostname port=2521 user=username password=password load_balance=true&quot;)
</code></pre></div></p>
<p>（2）连接字典
<div class="highlight"><pre><span></span><code>conn = psycopg2.connect(user = &#39;username&#39;, password=&#39;password&#39;, host = &#39;hostname&#39;, port = &#39;2521&#39;, dbname = &#39;database_name&#39;, load_balance=&#39;True&#39;)
</code></pre></div></p>
<p>您可以在连接字符串中指定多个主机，以防主地址失败。 驱动程序建立初始连接后，它会从集群中获取可用服务器列表，并在这些服务器之间对后续连接请求进行负载平衡。</p>
<p>要指定topology_keys，请将 topology_keys 属性设置为连接字符串或字典中的逗号分隔值，如下例所示：</p>
<p>（1）连接字符串
<div class="highlight"><pre><span></span><code>conn = psycopg2.connect(&quot;dbname=database_name host=hostname port=2521 user=username password=password load_balance=true topology_keys=cloud.region.zone1,cloud.region.zone2&quot;)
</code></pre></div></p>
<p>（2）连接字典
<div class="highlight"><pre><span></span><code>conn = psycopg2.connect(user = &#39;username&#39;, password=&#39;password&#39;, host = &#39;hostname&#39;, port = &#39;2521&#39;, dbname = &#39;database_name&#39;, load_balance=&#39;True&#39;, topology_keys=&#39;cloud.region.zone1,cloud.region.zone2&#39;)
</code></pre></div></p>
<p>要配置 SimpleConnectionPool，请指定负载平衡，如下所示：
<div class="highlight"><pre><span></span><code>bm_pool = psycopg2.pool.SimpleConnectionPool(1, 10, user=&quot;bigmath&quot;,
                                                        password=&quot;bigmath&quot;,
                                                        host=&quot;127.0.0.1&quot;,
                                                        port=&quot;2521&quot;,
                                                        database=&quot;bigmath&quot;,
                                                        load_balance=&quot;True&quot;)
conn = bm_pool.getconn()
</code></pre></div></p>
<h4 id="_311"><strong>示例</strong></h4>
<p>本教程展示如何将 AiSQL Psycopg2 驱动程序与 AiSQL 结合使用。 首先创建一个复制因子为 3 的 3 节点集群。本教程使用 bm-dev-ctl 实用程序。</p>
<p>接下来，您使用 Python shell 终端通过运行一些 python 脚本来演示驱动程序的负载平衡功能。</p>
<p>注：该驱动程序需要 AiSQL 版本 2.7.2.0 或更高版本。</p>
<p><strong>1.创建本地集群</strong>
创建一个包含 3 节点 RF-3 集群的 Universe，并分配一些虚构的地理位置。 使用的放置值只是令牌，与实际的 AWS 云区域和区域无关。
<div class="highlight"><pre><span></span><code>cd &lt;path-to-brightdb-installation&gt;
./bin/bm-dev-ctl create --rf 3 --placement_info &quot;aws.us-west.us-west-2a,aws.us-west.us-west-2a,aws.us-west.us-west-2b&quot;
</code></pre></div></p>
<p><strong>2.检查均匀负载平衡</strong>
登录到 Python 终端并运行以下脚本：
<div class="highlight"><pre><span></span><code>import psycopg2
conns = []
for i in range(30):
    conn = psycopg2.connect(user = &#39;username&#39;, password=&#39;xxx&#39;, host = &#39;hostname&#39;, port = &#39;2521&#39;, dbname = &#39;database_name&#39;, load_balance=&#39;True&#39;)
    conns.append(conn)
</code></pre></div></p>
<p>该应用程序创建 30 个连接。 要验证行为，请等待应用程序创建连接，然后从浏览器中访问每个节点的 http://<host>:8100/rpcz，以查看连接在节点之间均匀分布。 此 URL 提供一个连接列表，其中列表的每个元素都有一些有关连接的信息，如以下屏幕截图所示。 您可以计算该列表中的连接数，或搜索该网页上主机关键字的出现次数。 每个节点应该有 10 个连接。
<img alt="" src="./media/chapter3/33.png" />
您还可以通过在同一终端中运行以下脚本来验证连接数：
<div class="highlight"><pre><span></span><code>from psycopg2.policies import ClusterAwareLoadBalancer as lb
obj = lb()
obj.printHostToConnMap()
</code></pre></div></p>
<p>这将显示一个键值对映射，其中键是主机，值是主机上的连接数。 （这是从客户端角度来看的连接数。）</p>
<p>使用 bm-sample-apps 检查拓扑感知负载平衡
在新的 Python 终端中运行以下脚本，并将 topology_keys 属性设置为 aws.us-west.us-west-2a； 在这种情况下仅使用两个节点。
<div class="highlight"><pre><span></span><code>import psycopg2
conns = []
for i in range(30):
    conn = psycopg2.connect(user = &#39;username&#39;, password=&#39;xxx&#39;, host = &#39;hostname&#39;, port = &#39;2521&#39;, dbname = &#39;database_name&#39;, load_balance=&#39;True&#39;, topology_keys=&#39;aws.us-west.us-west-2a&#39;)
    conns.append(conn)
</code></pre></div></p>
<p>要验证行为，请等待应用程序创建连接，然后导航到 http://<host>:8100/rpcz。 前两个节点应各有 15 个连接，第三个节点应有 0 个连接。 您还可以通过在同一终端中运行之前的验证脚本来验证这一点。</p>
<p><strong>3.清理</strong>
完成实验后，运行以下命令来销毁本地集群：
<div class="highlight"><pre><span></span><code>./bin/bm-dev-ctl destroy 
</code></pre></div></p>
<h3 id="rust-drivers"><strong>Rust Drivers</strong></h3>
<p>AiSQL Rust 智能驱动程序是基于 rust-postgres 的 BSQL Rust 驱动程序，具有附加的连接负载平衡功能。
Rust 智能驱动程序提供了两种与 rust-postgres 类似的不同客户端：
* bm-postgres：基于 postgres 的本机同步 AiSQL BSQL 客户端。
* bm-tokio-postgres：基于 tokio-postgres 的本机异步 AiSQL BSQL 客户端.</p>
<h4 id="_312"><strong>导入驱动程序依赖项</strong></h4>
<p>您可以通过在 Rust 应用程序的 Cargo.toml 文件中添加以下语句来使用 AiSQL Rust 驱动程序包。
<div class="highlight"><pre><span></span><code># For bm-postgres
bm-postgres = &quot;0.19.7-bm-1-beta&quot;

# For bm-tokio-postgres
bm-tokio-postgres = &quot;0.7.10-bm-1-beta&quot;
</code></pre></div></p>
<p>或者，从项目目录运行以下命令：
<div class="highlight"><pre><span></span><code># For bm-postgres
$ cargo add bm-postgres

# For bm-tokio-postgres
$ cargo add bm-tokio-postgres
</code></pre></div></p>
<h4 id="_313"><strong>基础知识</strong></h4>
<p>了解如何使用 AiSQL Rust 智能驱动程序执行 Rust 应用程序开发所需的常见任务。</p>
<p><strong>1.负载平衡连接属性</strong>
需要添加以下连接属性以启用负载平衡：
* load_balance：通过将此属性设置为 true 来启用集群感知负载平衡； 默认禁用。
* topology_keys：提供以逗号分隔的地理位置值以启用拓扑感知负载平衡。 地理位置可以作为 cloud.region.zone 提供。 将区域中的所有区域指定为 cloud.region.*。 要在主要位置无法访问时指定后备位置，请以 :n 的形式指定优先级，其中 n 是优先顺序。 例如，cloud1.datacenter1.rack1:1、cloud1.datacenter1.rack2:2。</p>
<p>默认情况下，驱动程序每 300 秒（5 分钟）刷新一次节点列表。 您可以通过包含 bm_servers_refresh_interval 参数来更改此值。</p>
<p>以下是 Rust 智能驱动程序提供的其他连接属性：
* Fallback_to_topology_keys_only：当设置为 true 时，智能驱动程序不会尝试连接到 topology_keys 属性指定的主要和后备位置之外的服务器。 默认情况下，驱动程序会回退到集群中的任何可用服务器。 默认为 false。
* failed_host_reconnect_delay_secs：当驱动程序无法连接到服务器时，它使用时间戳标记服务器。 当通过 bm_servers() 刷新服务器列表时，如果响应中出现故障服务器，则仅当服务器被标记为关闭后经过了 failed_host_reconnect_delay_secs 时间后，驱动程序才会将服务器标记为“启动”。 默认值为 5 秒。</p>
<p><strong>2.使用驱动程序</strong>
要使用该驱动程序，请在连接字符串中传递新的连接属性以实现负载平衡。
要在所有服务器之间启用统一负载平衡，请在连接字符串中将 load-balance 属性设置为 true，如下例所示：
<div class="highlight"><pre><span></span><code>let url: String = String::from( &quot;postgresql://localhost:5434/bigmath?user=bigmath&amp;password=bigmath&amp;load_balance=true&quot;, );
let conn = bm_postgres::Client::connect(&amp;connection_url,NoTls,)?;
</code></pre></div></p>
<p>您可以在连接字符串中指定多个主机作为后备，以防主地址在初始连接尝试期间失败。 驱动程序建立初始连接后，它会从集群中获取可用服务器列表，并在这些服务器之间平衡后续连接请求。</p>
<p>要指定topology_keys，请将 topology_keys 属性设置为连接字符串或字典中的逗号分隔值，如下例所示：
<div class="highlight"><pre><span></span><code>let url: String = String::from( &quot;postgresql://localhost:5434/bigmath?user=bigmath&amp;password=bigmath&amp;load_balance=true&amp;topology_keys=cloud1.datacenter1.rack2&quot;, );
let conn = bm_postgres::Client::connect(&amp;connection_url,NoTls,)?;
</code></pre></div></p>
<h4 id="_314"><strong>示例</strong></h4>
<p>本教程展示如何将异步 bm-tokio-postgres 客户端与 AiSQL 结合使用。 首先创建一个复制因子为 3 的三节点集群。本教程使用 bm-ctl 实用程序。</p>
<p>接下来，您使用 Rust 应用程序来演示驱动程序的负载平衡功能。</p>
<p>有关使用同步 bm-postgres 客户端的示例，请参阅连接应用程序。</p>
<p><strong>1.创建本地集群</strong>
创建一个包含 3 节点 RF-3 集群的 Universe，并分配一些虚构的地理位置。 将两个节点放置在一个位置，将第三个节点放置在单独的位置。 使用的放置值只是令牌，与实际的 AWS 云区域和区域无关。
<div class="highlight"><pre><span></span><code>cd &lt;path-to-brightdb-installation&gt;
</code></pre></div></p>
<p>要创建多可用区集群，请执行以下操作：
（1）通过运行 bm-ctl start 命令启动第一个节点，传入 --cloud_location 和 --fault_tolerance 标志以设置节点位置详细信息，如下所示：
<div class="highlight"><pre><span></span><code>./bin/bm-ctl start --advertise_address=127.0.0.1 \
    --base_dir=$HOME/bigmath-2.20.1.3/node1 \
    --cloud_location=aws.us-east-1.us-east-1a \
    --fault_tolerance=zone
</code></pre></div></p>
<p>（2）使用 --join 标志在两个单独的 VM 上启动第二个和第三个节点，如下所示：
<div class="highlight"><pre><span></span><code>./bin/bm-ctl start --advertise_address=127.0.0.2 \
    --join=127.0.0.1 \
    --base_dir=$HOME/bigmath-2.20.1.3/node2 \
    --cloud_location=aws.us-east-1.us-east-1a \
    --fault_tolerance=zone
./bin/bm-ctl start --advertise_address=127.0.0.3 \
    --join=127.0.0.1 \
    --base_dir=$HOME/bigmath-2.20.1.3/node3 \
    --cloud_location=aws.us-east-1.us-east-1b \
    --fault_tolerance=zone
</code></pre></div></p>
<p><strong>2.检查均匀负载平衡</strong>
要检查均匀负载平衡，请执行以下操作：</p>
<p>（1）使用以下命令创建 Rust 项目：
<div class="highlight"><pre><span></span><code>cargo new try-it-out
</code></pre></div></p>
<p>这将创建项目“try-it-out”，其中包含 Cargo.toml 文件（项目元数据）和包含主代码文件 main.rs 的 src 目录。</p>
<p>（2）在 Cargo.toml 文件中添加 bm-tokio-postgres = "0.7.10-bm-1-beta" 依赖项，如下所示：
<div class="highlight"><pre><span></span><code>[package]
name = &quot;try-it-out&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
bm-tokio-postgres = &quot;0.7.10-bm-1-beta&quot;
</code></pre></div></p>
<p>（3）将文件 src/main.rs 中的现有代码替换为以下代码：
<div class="highlight"><pre><span></span><code>use isahc::ReadResponseExt;
use tokio::task::JoinHandle;
use bm_tokio_postgres::{Client, Error, NoTls};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Error&gt; {
   println!(&quot;Starting the example ...&quot;);

   let url: String = String::from(
   &quot;postgresql://127.0.0.1:2521/bigmath?user=bigmath&amp;password=bigmath&amp;load_balance=true&quot;,
   );
   println!(&quot;Using connection url: {}&quot;, url);
   let (_clients, _connections) = createconn(30, url).await.unwrap();
   //Check and print number of connections on each node.
   num_of_connections();

   println!(&quot;End of Example&quot;);
   Ok(())
}

async fn createconn(
   numconn: usize,
   url: String,
) -&gt; Result&lt;(Vec&lt;Client&gt;, Vec&lt;JoinHandle&lt;()&gt;&gt;), Error&gt; {
   let mut connectionstored: Vec&lt;JoinHandle&lt;()&gt;&gt; = Vec::with_capacity(numconn);
   let mut clientstored: Vec&lt;Client&gt; = Vec::with_capacity(numconn);
   for _i in 0..numconn {
       let connectionresult = createconnection(url.clone()).await;
       match connectionresult {
          Err(error) =&gt; return Err(error),
          Ok((connection, client)) =&gt; {
              clientstored.push(client);
              connectionstored.push(connection);
          }
       }
   }
   return Ok((clientstored, connectionstored));
}

async fn createconnection(url: String) -&gt; Result&lt;(tokio::task::JoinHandle&lt;()&gt;, Client), Error&gt; {
   let (client, connection) = bm_tokio_postgres::connect(&amp;url, NoTls).await?;

   // The connection object performs the actual communication with the database,
   // so spawn it off to run on its own.
   let handle = tokio::spawn(async move {
       if let Err(e) = connection.await {
           eprintln!(&quot;connection error: {}&quot;, e);
       }
   });

   Ok((handle, client))
}

pub(crate) fn num_of_connections() {
   for i in 1..4 {
       let url = &quot;http://127.0.0.&quot;.to_owned() + &amp;i.to_string() + &quot;:8100/rpcz&quot;;
       let response = isahc::get(url);
       if response.is_err() {
           println!(&quot;127.0.0.{} = {}&quot;,i, 0);
       } else {
           let body = response.unwrap().text().unwrap();
           let c = body.matches(&quot;client backend&quot;).count();
           println!(&quot;127.0.0.{} = {}&quot;, i, c);
       }
   }
}
</code></pre></div></p>
<p>（4）运行示例：
<div class="highlight"><pre><span></span><code>cargo run
</code></pre></div></p>
<p>该应用程序创建 30 个连接并显示一个键值对映射，其中键是主机，值是主机上的连接数。 （应用程序从每个节点的 http://<host>:8100/rpcz 获取连接数。此 URL 提供一个连接列表，其中列表的每个元素都有一些有关连接的信息。）每个节点应有 10 个 连接。</p>
<p><strong>3.检查拓扑感知负载平衡</strong>
对于拓扑感知负载平衡，请运行应用程序并将 topology_keys 属性设置为 aws.us-east-1.us-east-1a。 本例中仅使用两个节点。</p>
<p>将 src/main.rs 中的现有代码替换为以下示例代码：
<div class="highlight"><pre><span></span><code>use isahc::ReadResponseExt;
use tokio::task::JoinHandle;
use bm_tokio_postgres::{Client, Error, NoTls};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Error&gt; {
   println!(&quot;Starting the example ...&quot;);

   let url: String = String::from(
       &quot;postgresql://127.0.0.1:2521/bigmath?user=bigmath&amp;password=bigmath&amp;load_balance=true&amp;topology_keys=aws.us-east-1.us-east-1a&quot;,
   );
   println!(&quot;Using connection url: {}&quot;, url);
   let (_clients, _connections) = createconn(30, url).await.unwrap();
   //Check and print number of connections on each node.
   num_of_connections();

   println!(&quot;End of Example&quot;);
   Ok(())
}

async fn createconn(
   numconn: usize,
   url: String,
) -&gt; Result&lt;(Vec&lt;Client&gt;, Vec&lt;JoinHandle&lt;()&gt;&gt;), Error&gt; {
   let mut connectionstored: Vec&lt;JoinHandle&lt;()&gt;&gt; = Vec::with_capacity(numconn);
   let mut clientstored: Vec&lt;Client&gt; = Vec::with_capacity(numconn);
   for _i in 0..numconn {
       let connectionresult = createconnection(url.clone()).await;
       match connectionresult {
           Err(error) =&gt; return Err(error),
           Ok((connection, client)) =&gt; {
               clientstored.push(client);
               connectionstored.push(connection);
           }
       }
   }
   return Ok((clientstored, connectionstored));
}

async fn createconnection(url: String) -&gt; Result&lt;(tokio::task::JoinHandle&lt;()&gt;, Client), Error&gt; {
   let (client, connection) = bm_tokio_postgres::connect(&amp;url, NoTls).await?;

   // The connection object performs the actual communication with the database,
   // so spawn it off to run on its own.
   let handle = tokio::spawn(async move {
       if let Err(e) = connection.await {
           eprintln!(&quot;connection error: {}&quot;, e);
       }
   });

   Ok((handle, client))
}

pub(crate) fn num_of_connections() {
   for i in 1..4 {
       let url = &quot;http://127.0.0.&quot;.to_owned() + &amp;i.to_string() + &quot;:8100/rpcz&quot;;
       let response = isahc::get(url);
       if response.is_err() {
           println!(&quot;127.0.0.{} = {}&quot;,i, 0);
       } else {
           let body = response.unwrap().text().unwrap();
           let c = body.matches(&quot;client backend&quot;).count();
           println!(&quot;127.0.0.{} = {}&quot;, i, c);
       }
   }
}
</code></pre></div></p>
<p>在这种情况下，前两个节点应各有 15 个连接，第三个节点应有 0 个连接。</p>
<p><strong>4.清理</strong>
完成实验后，运行以下命令来销毁本地集群：
<div class="highlight"><pre><span></span><code>./bin/bm-ctl destroy --base_dir=$HOME/bigmath-2.20.1.3/node1
./bin/bm-ctl destroy --base_dir=$HOME/bigmath-2.20.1.3/node2
./bin/bm-ctl destroy --base_dir=$HOME/bigmath-2.20.1.3/node3
</code></pre></div></p>
<h4 id="ssltls_1"><strong>配置 SSL/TLS</strong></h4>
<p>AiSQL Rust 智能驱动程序对 SSL 的支持与上游驱动程序相同。</p>
<p>下表描述了使用 SSL 时 AiSQL Rust 智能驱动程序需要作为连接字符串一部分的附加参数。
| 参数    | 描述    | 默认值 |
| ------- | ------- | ------ |
| Sslmode | SSL模式 | prefer |</p>
<p>rust-postgres 驱动程序支持以下 SSL 模式。
disable：不使用 TLS。
prefer (default)：如果可用，请使用 TLS，否则不使用。
Require：需要使用 TLS。</p>
<p>目前，rust-postgres 驱动程序和 AiSQL Rust 智能驱动程序不支持 verify-full 或 verify-ca SSL 模式。</p>
<p>AiSQL Managed 需要 SSL/TLS，使用 SSL 模式禁用的连接将失败。</p>
<p>以下是连接到启用了 SSL 加密的 AiSQL 集群的示例连接 URL：
<div class="highlight"><pre><span></span><code>&quot;postgresql://127.0.0.1:5434/bigmath?user=bigmath&amp;password=bigmath&amp;load_balance=true&amp;sslmode=require&quot;
</code></pre></div></p>
<p>如果您在 AiSQL Managed 上创建了集群，请使用集群凭据并下载 SSL 根证书。</p>
<p>以下是连接到启用了 SSL 的 AiSQL 集群的示例应用程序：</p>
<p>执行前在 Cargo.toml 文件中添加 bm-postgres-openssl = "0.5.0-bm-1"、bm-postgres = "0.19.7-bm-1-beta" 和 openssl = "0.10.61" 依赖项 应用程序。
<div class="highlight"><pre><span></span><code>use openssl::ssl::{SslConnector, SslMethod};
use bm_postgres_openssl::MakeTlsConnector;
use bm_postgres::{Client};

fn main()  {
   let mut builder = SslConnector::builder(SslMethod::tls()).expect(&quot;unable to create sslconnector builder&quot;);
   builder.set_ca_file(&quot;/path/to/root/certificate&quot;).expect(&quot;unable to load root certificate&quot;);
   let connector: MakeTlsConnector = MakeTlsConnector::new(builder.build());

   let mut connection = Client::connect( &quot;host=? port=2521 dbname=bigmath user=? password=? sslmode=require&quot;,
       connector,
       ).expect(&quot;failed to create tls bsql connection&quot;);

   let result = connection.query_one(&quot;select 1&quot;, &amp;[]).expect(&quot;failed to execute select 1 bsql&quot;);
   let value: i32 = result.get(0);
   println!(&quot;result of query_one call: {}&quot;, value);
}
</code></pre></div></p>
<h3 id="client-drivers-for-bsql"><strong>Client drivers for BSQL</strong></h3>
<p>AiSQL 结构化查询语言 (BSQL) API 基于 PostgreSQL 11.2 的查询层分支构建并扩展，旨在支持大多数 PostgreSQL 功能并向支持的分布式 SQL 数据库添加新功能。</p>
<p>有关 BSQL 中 PostgreSQL 功能支持的详细信息，请参阅 SQL 功能支持。</p>
<p>下面列出的客户端驱动程序支持开发连接到 BSQL API 并与之交互的应用程序。 大多数驱动程序使用 libpq 并支持 SCRAM-SHA-256 身份验证方法。</p>
<p>如需将这些驱动程序与 BSQL 一起使用的帮助，请在 Slack 社区中提问。</p>
<p>如果您遇到问题或有增强请求，请提交 GitHub 问题。</p>
<h4 id="c_9"><strong>C</strong></h4>
<p><strong>libpq</strong>
libpq 是用于连接 PostgreSQL 数据库并与之交互的 C 客户端库。 libpq 也是其他 PostgreSQL 应用程序接口中使用的底层引擎。 libpq 客户端库支持 SCRAM-SHA-256 身份验证方法。</p>
<p>有关详细信息和文档，请参阅 libpq - C Library for PostgreSQL 11（AiSQL 所基于的）。</p>
<p>有关使用 libpq 构建示例 C 应用程序的教程，请参阅连接应用程序。</p>
<p>安装 libpq 客户端库
libpq C 驱动程序包含在 AiSQL 安装中。 您可以通过设置 LD_LIBRARY_PATH 来使用它，如下所示：
<div class="highlight"><pre><span></span><code>$ export LD_LIBRARY_PATH=&lt;bigmath-install-dir&gt;/postgres/lib
</code></pre></div></p>
<p>macOS 上的 Homebrew 用户可以使用brew install libpq来安装libpq。 您可以从 PostgreSQL 下载页面下载 PostgreSQL 二进制文件和源代码。</p>
<h4 id="c_10"><strong>C++</strong></h4>
<p>libpqxx
libpqxx 驱动程序是 PostgreSQL 的官方 C++ 客户端 API。 libpqxx 基于 libpq 并支持 SCRAM-SHA-256 身份验证方法。</p>
<p>有关详细信息和文档，请参阅 libpqxx 自述文件和 libpqxx 文档。</p>
<p>有关使用 libpqxx 构建示例 C++ 应用程序的教程，请参阅连接应用程序。</p>
<p>安装 libpqxx 驱动程序
要构建并安装 libpqxx 驱动程序以与 AiSQL 一起使用，请首先克隆 libpqxx 存储库。
<div class="highlight"><pre><span></span><code>$ git clone &lt;https://github.com/jtv/libpqxx.git&gt;
</code></pre></div></p>
<p>对于 PostgreSQL 二进制文件的依赖项，请通过运行以下命令将 PostgreSQL bin 目录添加到命令路径。
<div class="highlight"><pre><span></span><code>$ export PATH=$PATH:&lt;bigmath-install-dir&gt;/postgres/bin
</code></pre></div></p>
<p>构建并安装驱动程序。
<div class="highlight"><pre><span></span><code>$ cd libpqxx
$ ./configure
$ make
$ make install
</code></pre></div></p>
<h4 id="java_5"><strong>Java</strong></h4>
<p>Vert.x PG Client
Vert.x PG Client 是 PostgreSQL 的客户端，具有与数据库通信的基本 API。 它是一个反应式、非阻塞客户端，用于使用单线程 API 处理数据库连接。</p>
<p>有关使用 Vert.x PG Client构建示例 Java 应用程序的教程，请参阅连接应用程序。</p>
<p>要获取使用 Apache Maven 的项目的最新版本，请参阅  Maven Central Repository of Vert.x PG Client。</p>
<h4 id="php_2"><strong>PHP</strong></h4>
<p>php-pgsql
php-pgsql 驱动程序是 PHP 官方 PostgreSQL 模块的集合。 php-pgsql 基于 libpq 并支持 SCRAM-SHA-256 身份验证方法。</p>
<p>有关安装和使用 php-pgsql 的详细信息，请参阅 php-pgsql 文档。</p>
<p>有关使用 php-pgsql 构建示例 PHP 应用程序的教程，请参阅连接应用程序。</p>
<p><strong>安装 php-pgsql 驱动程序</strong>
要使用 php-pgsql 启用 PostgreSQL 支持，请参阅 PHP 文档中的安装/配置。</p>
<p>macOS 上的 Homebrew 用户可以使用brew install php 安装 PHP； php-pgsql 驱动程序会自动安装。</p>
<p>Ubuntu 用户可以使用 sudo apt-get install php-pgsql 命令安装驱动程序。</p>
<p>CentOS 用户可以使用 sudo yum install php-pgsql 命令安装驱动程序。</p>
<h4 id="python_3"><strong>Python</strong></h4>
<p>aiopg
aiopg 是一个使用 asyncio (PEP-3156/tulip) 框架访问 PostgreSQL 数据库的库。 它包装了 Psycopg 数据库驱动程序的异步功能。 有关使用 aiopg 的详细信息，请参阅 aiopg 文档。</p>
<p>有关构建使用 aiopg 的示例 Python 应用程序的教程，请参阅 BSQL Aiopg。</p>
<p><strong>安装</strong>
要安装 aiopg 软件包，请运行以下 pip3 install 命令：
<div class="highlight"><pre><span></span><code>pip3 install aiopg
</code></pre></div></p>
<h4 id="ruby_4"><strong>Ruby</strong></h4>
<p>PG
pg 是 PostgreSQL 数据库的 Ruby 接口。 pg 基于 libpq 并支持 SCRAM-SHA-256 身份验证方法。</p>
<p>有关使用 pg 构建示例 Ruby 应用程序的教程，请参阅连接应用程序。</p>
<p><strong>安装pg驱动</strong>
如果您本地已经安装了 AiSQL，请运行以下 gem install 命令来安装 pg 驱动：
<div class="highlight"><pre><span></span><code>$ gem install pg -- --with-pg-config=&lt;bigmath-install-dir&gt;/postgres/bin/pg_config
</code></pre></div></p>
<p>否则，要安装 pg，请运行以下命令：
<div class="highlight"><pre><span></span><code>gem install pg -- --with-pg-include=&lt;path-to-libpq&gt;/libpq/include --with-pg-lib=&lt;path-to-libpq&gt;/libpq/lib
</code></pre></div></p>
<p>将 <path-to-libpq> 替换为 libpq 安装路径； 例如，/usr/local/opt。</p>
<h4 id="rust_2"><strong>Rust</strong></h4>
<p>Rust-Postgres
Rust-Postgres 是 PostgreSQL 数据库的 Rust 接口。 Rust-Postgres 不基于 libpq，但支持 SCRAM-SHA-256 身份验证方法。</p>
<p>有关使用 Rust-Postgres 构建示例 Ruby 应用程序的教程，请参阅构建 Rust 应用程序。</p>
<p><strong>安装 Rust-Postgres 驱动程序</strong>
要将 Rust-Postgres 驱动程序包含在您的应用程序中，请将以下依赖项添加到您的 Cargo.toml 文件中：
<div class="highlight"><pre><span></span><code>postgres = &quot;0.19.2&quot;
openssl = &quot;0.10.38&quot;
postgres-openssl = &quot;0.5.0&quot;
</code></pre></div></p>
<h3 id="client-drivers-for-bcql"><strong>Client drivers for BCQL</strong></h3>
<p>支持以下客户端驱动程序与 AiSQL 云查询语言 (BCQL) API 一起使用，AiSQL 云查询语言 (BCQL) API 是一种基于 SQL 的半关系 API，源于 Apache Cassandra 查询语言 (CQL)。</p>
<p>有关使用以下客户端驱动程序构建示例应用程序的教程，请单击下面包含的每个驱动程序的相关链接。</p>
<p>使用 AiSQL 客户端驱动程序
您应该始终使用 AiSQL BCQL 客户端驱动程序。 使用通用 Cassandra 驱动程序可能会导致错误和性能问题。</p>
<h4 id="cc"><strong>C/C++</strong></h4>
<p>适用于 BCQL 的 AiSQL C/C++ 驱动程序
适用于 BCQL 的 AiSQL C++ 驱动程序基于适用于 Apache Cassandra 的 DataStax C++ 驱动程序。</p>
<p>有关详细信息，请参阅 GitHub 存储库中的自述文件。
有关使用此驱动程序构建示例 C++ 应用程序的教程，请参阅构建 C++ 应用程序。</p>
<h4 id="c_11"><strong>C＃</strong></h4>
<p>适用于 BCQL 的 AiSQL C# 驱动程序
BCQL 的 AiSQL C# 驱动程序基于 Apache Cassandra 的 DataStax C# 驱动程序的分支。</p>
<p>有关详细信息，请参阅 GitHub 存储库中的自述文件。
有关使用此驱动程序构建示例 C# 应用程序的教程，请参阅连接应用程序。</p>
<h4 id="go_3"><strong>Go</strong></h4>
<p>BCQL 的 AiSQL Go 驱动程序
BCQL 的 AiSQL Go 驱动程序基于 GoCQL 的一个分支。</p>
<p>有关详细信息，请参阅 GitHub 存储库中的自述文件。
有关使用此驱动程序构建示例 Go 应用程序的教程，请参阅连接应用程序。</p>
<h4 id="java_6"><strong>Java</strong></h4>
<p><strong>适用于 BCQL 3.10 的 AiSQL Java 驱动程序</strong>
BCQL 的 AiSQL Java 驱动程序版本 3.10.0-bm-x 基于 Apache Cassandra v.3.10 的 DataStax Java 驱动程序，并且需要如下所示的 Maven 依赖项。</p>
<p>有关详细信息，请参阅 GitHub 存储库中的 v3.10 自述文件。
有关使用此驱动程序构建示例 Java 应用程序的教程，请参阅连接应用程序。</p>
<p>要使用此驱动程序构建 Java 应用程序，您必须将以下 Maven 依赖项添加到您的应用程序：
<div class="highlight"><pre><span></span><code>&lt;dependency&gt;
  &lt;groupId&gt;com.bigmath&lt;/groupId&gt;
  &lt;artifactId&gt;cassandra-driver-core&lt;/artifactId&gt;
  &lt;version&gt;3.10.3-bm-2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></div></p>
<p>有关详细信息，请参阅 Maven repository contents。</p>
<p><strong>适用于 BCQL 4.15 的 AiSQL Java 驱动程序</strong>
BCQL 的 AiSQL Java 驱动程序版本 4.15.0-bm-1 基于 Apache Cassandra (v4.15) 的 DataStax Java 驱动程序，并且需要如下所示的 Maven 依赖项。</p>
<p>有关详细信息，请参阅 GitHub 存储库中的 v4.15 自述文件。
有关使用此驱动程序构建示例 Java 应用程序的教程，请参阅连接应用程序。</p>
<p>要使用此驱动程序构建 Java 应用程序，您必须将以下 Maven 依赖项添加到您的应用程序：
<div class="highlight"><pre><span></span><code>&lt;dependency&gt;
  &lt;groupId&gt;com.bigmath&lt;/groupId&gt;
  &lt;artifactId&gt;java-driver-core&lt;/artifactId&gt;
  &lt;version&gt;4.15.0-bm-1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></div></p>
<p>有关详细信息，请参阅Maven repository contents。</p>
<h4 id="nodejs_3"><strong>Node.js</strong></h4>
<p>适用于 BCQL 的 AiSQL Node.js 驱动程序
BCQL 的 AiSQL Node.js 驱动程序基于 Apache Cassandra 的 DataStax Node.js 驱动程序的分支。</p>
<p>有关详细信息，请参阅 GitHub 存储库中的自述文件。
有关使用此驱动程序构建示例 Node.js 应用程序的教程，请参阅连接应用程序。</p>
<h4 id="python_4"><strong>Python</strong></h4>
<p>适用于 BCQL 的 AiSQL Python 驱动程序
BCQL 的 AiSQL Python 驱动程序基于 Apache Cassandra 的 DataStax Python 驱动程序的分支。</p>
<p>有关详细信息，请参阅 GitHub 存储库中的自述文件。
有关使用此驱动程序构建示例 Python 应用程序的教程，请参阅连接应用程序。</p>
<h4 id="ruby_5"><strong>Ruby</strong></h4>
<p>适用于 BCQL 的 AiSQL Ruby 驱动程序
BCQL 的 AiSQL Ruby 驱动程序基于 Apache Cassandra 的 DataStax Ruby 驱动程序的分支。</p>
<p>有关详细信息，请参阅 GitHub 存储库中的自述文件。
有关使用此驱动程序构建示例 Ruby 应用程序的教程，请参阅连接应用程序。</p>
<h4 id="scala_1"><strong>Scala</strong></h4>
<p>适用于 BCQL 的 AiSQL Java 驱动程序
BCQL 的 AiSQL Java 驱动程序基于 Apache Cassandra 的 DataStax Java 驱动程序的分支，当您将如下所示的 sbt（Scala 构建工具）依赖项添加到应用程序时，可用于构建 Scala 应用程序。</p>
<p>有关详细信息，请参阅 GitHub 存储库中的自述文件。</p>
<p>要使用 BCQL 的 AiSQL Java 驱动程序构建 Scala 应用程序，您必须将以下 sbt 依赖项添加到您的应用程序：
<div class="highlight"><pre><span></span><code>libraryDependencies += &quot;com.bigmath&quot; % &quot;cassandra-driver-core&quot; % &quot;3.8.0-bm-5&quot;
</code></pre></div></p>
<p>有关使用此驱动程序构建示例 Scala 应用程序的教程，请参阅连接应用程序。</p>
<h2 id="_315"><strong>第三方工具</strong></h2>
<p>由于 AiSQL 与 PostgreSQL 和 Cassandra 兼容，因此您可以使用第三方客户端连接到 AiSQL 集群。</p>
<p><strong>工具</strong>
* Apache Superset
* Arctype
* DBeaver
* DbSchema
* Metabase
* pgAdmin
* SQL Workbench/J
* TablePlus
<strong>AiSQL 先决条件</strong>
要将这些工具与 AiSQL 一起使用，您应该启动并运行一个集群，并且您需要知道客户端连接到集群所需的连接参数。</p>
<p>要创建本地集群，请按照快速入门中的步骤操作。</p>
<p><strong>连接参数</strong>
要连接，请按照客户端的配置步骤操作，并使用以下值：
Hostname:localhost 或节点的 IP 地址
Port:2521 (BSQL) 9542 (BCQL)
Database:数据库名称（默认为 bigmath）
Username:bigmath 或 cassandra
Password:bigmath或cassandra；如果未启用身份验证，则留空</p>
<h3 id="apache-superset"><strong>Apache Superset</strong></h3>
<p>Apache Superset 是一个开源数据探索和可视化工具，可帮助您查询 AiSQL 中存储的数据，并使用基本折线图到高度详细的地理空间图表将其可视化。</p>
<p>您可以使用 Superset 快速探索和可视化存储在数据库和数据仓库中的数据。 您无需编写复杂的 SQL 查询即可探索数据，创建丰富的报告和自定义仪表板来可视化这些数据，并快速获得见解。
<img alt="" src="./media/chapter3/34.png" /></p>
<h4 id="_316"><strong>准备</strong></h4>
<p>您的 AiSQL 集群应该已启动并正在运行。 请参阅 AiSQL 先决条件。</p>
<p>加载一些数据以进行探索和可视化。 对于本地安装，您可以使用 shell 中的 ./bin/bm-ctl demo connect 命令加载 Northwind 示例数据库，或者按照说明进行操作。</p>
<p>1.安装Superset
您可以使用 Python (pip3)（推荐）或 Docker Compose 从头开始安装 Superset。</p>
<p>2.安装驱动程序
安装 Superset 后，安装 AiSQL psycopg2 智能驱动程序。 如果安装了 PostgreSQL psycopg2 驱动程序，则必须先将其删除。</p>
<p>要检查 PostgreSQL psycopg2 驱动程序是否已安装，请输入以下命令：
pip show psycopg2</p>
<p>如果存在，请按如下方式卸载驱动程序：
pip uninstall psycopg2</p>
<p>要安装 AiSQL psycopg2 智能驱动程序，请输入以下内容：
pip install psycopg2-brightdb</p>
<h4 id="superset-aisql"><strong>将 Superset 连接到 AiSQL</strong></h4>
<p>在浏览器中启动 Superset，网址为 http://&lt;主机名或 IP 地址&gt;:8088。 如果您已安装在本地计算机上，请导航到 localhost:8088 或 127.0.0.1:8088。 AiSQL v2.19 及更高版本也可以用作 Superset 元存储。</p>
<p>要将 Apache Superset 连接到 AiSQL：</p>
<p>1.导航到Data &gt; Databases &gt; + Databases，然后从连接数据库菜单中选择 PostgreSQL。
<img alt="" src="./media/chapter3/35.png" />
2.使用标准凭据输入 AiSQL Tile服务器的主机名或 IP 地址，然后单击完成。
<img alt="" src="./media/chapter3/36.png" />
3.验证您是否可以访问“Data”下的可用数据库和架构。 导航到Data &gt; Datasets，然后单击“+Datasets”。</p>
<p>下拉列表应显示可用于探索和可视化的数据库和模式。
<img alt="" src="./media/chapter3/37.png" />
您已成功创建与 AiSQL 数据库的连接，现在可以开始使用 Apache Superset 探索和可视化您的数据库。</p>
<h4 id="_317"><strong>进一步使用</strong></h4>
<p>请参阅 Apache Superset 文档，了解有关 Superset 数据探索功能的更多信息。 如果您要使用 Superset 创建第一个仪表板，请查看数据分析和探索工作流程。</p>
<h3 id="arctype"><strong>Arctype</strong></h3>
<p>Arctype 是一款免费且跨平台的协作 SQL 数据库客户端。 它为团队提供一键查询共享，您可以可视化查询输出并将多个图表和表格组合到仪表板中。</p>
<p>Arctype 还集成了对连接 AiSQL 集群的支持。</p>
<p>本文档介绍了如何使用 Arctype 连接到 AiSQL。
<img alt="" src="./media/chapter3/38.png" /></p>
<h4 id="_318"><strong>准备</strong></h4>
<p>您的 AiSQL 集群应该已启动并正在运行。 请参阅 AiSQL 先决条件。</p>
<h4 id="arctype_1"><strong>安装Arctype</strong></h4>
<p>从 Arctype 网站下载适用于 Windows、Linux 和 Mac 的客户端。</p>
<h4 id="_319"><strong>创建数据库连接</strong></h4>
<p>请按照以下步骤将 Arctype 桌面客户端连接到 AiSQL：
1.启动 Arctype 桌面客户端。
2.按照应用程序内的提示创建并登录您的 Arctype 帐户。
3.在“Connect a Database”步骤中，选择 AiSQL。
<img alt="" src="./media/chapter3/39.png" />
4.输入您的 AiSQL 连接参数。</p>
<p>5.单击“Test Connection”，如果连接成功，请单击“Save”。
<img alt="" src="./media/chapter3/40.png" />
您可以在导航面板中看到 AiSQL 中可用的架构和表。
<img alt="" src="./media/chapter3/41.png" />
您已成功创建与 AiSQL 数据库的连接，现在可以开始使用 Arctype 查询和可视化您的数据库。</p>
<h4 id="_320"><strong>进一步使用</strong></h4>
<p>要了解有关 Arctype 的更多信息，请参阅 Arctype 文档。</p>
<p>要了解 Arctype 与 AiSQL 的集成，请参阅 AiSQL 与 Arctype SQL 客户端集成博客文章和 Arctype 文档中的 AiSQL。</p>
<p>AiSQL 包含示例数据库供您探索。 请参阅示例数据集。</p>
<h3 id="dbeaver"><strong>DBeaver</strong></h3>
<p>DBeaver 是一款免费的开源多平台、跨平台数据库工具，适用于开发人员、SQL 程序员和数据库管理员。 DBeaver支持各种数据库，包括PostgreSQL、MariaDB、MySQL、AiSQL。 此外，还有支持 JDBC 驱动程序的其他数据库的插件和扩展。 DBeaver 企业版支持非 JDBC 数据源，并允许您探索 bigmath BCQL 表。
<img alt="" src="./media/chapter3/42.png" /></p>
<h4 id="_321"><strong>先决条件</strong></h4>
<p>在开始将 DBeaver 与 BSQL 结合使用之前，您需要执行以下操作：
1.启动 AiSQL。
有关更多信息，请参阅快速入门。
2.安装适用于 Java 8 或更高版本的 JRE 或 JDK。
可以从 OpenJDK、AdoptOpenJDK 或 Azul Systems 下载安装程序。 请注意，某些安装程序包含只能由 DBeaver 访问的 JRE。
3.安装DBeaver如下：
从 DBeaver Downloads 下载适合您的操作系统的分发包。
按照 DBeaver 安装中的说明开始安装。</p>
<h4 id="bsql_17"><strong>创建BSQL连接</strong></h4>
<p>您可以按如下方式创建连接：
1.启动 DBeaver。
2.导航到Database &gt; New Connection 以打开Connect to database窗口，如下图所示。</p>
<p>3.在“Select your database”列表中，选择 AiSQL，然后单击“Next”。
<img alt="" src="./media/chapter3/43.png" />
4.使用连接设置指定以下内容：
* Host：localhost
* Port：2521
* Database：将默认值 postgres 替换为 bigmath 。
* User：bigmath
* Password：如果未启用 BSQL 身份验证，请留空。 如果启用，请添加 bigmath 的密码（默认为 bigmath）。
* 选择Show all databases。</p>
<p>5.单击“Test Connection”，验证连接是否成功，如下图所示：
<img alt="" src="./media/chapter3/44.png" />
DBeaver 的数据库导航器应显示 bigmath - localhost。</p>
<p>您可以展开列表以查看 bigmath 用户可用的所有数据库，如下图所示：
<img alt="" src="./media/chapter3/45.png" /></p>
<h3 id="dbschema"><strong>DbSchema</strong></h3>
<p>DbSchema 是一种可视化数据库工具，通过单一界面支持 40 多个数据库，可用于对模式进行逆向工程、编辑实体关系 (ER) 图、浏览数据、可视化构建查询和同步模式。 本文档介绍如何将 DbSchema 连接到 AiSQL 数据库。
<img alt="" src="./media/chapter3/46.png" /></p>
<h4 id="_322"><strong>准备</strong></h4>
<p>您的 AiSQL 集群应该已启动并正在运行。 请参阅 AiSQL 先决条件。</p>
<h4 id="dbschema_1"><strong>安装 DbSchema</strong></h4>
<p>从下载 DbSchema 页面下载客户端计算机上操作系统的分发包。
使用安装向导安装 DbSchema。</p>
<h4 id="_323"><strong>创建数据库连接</strong></h4>
<p>以下步骤显示如何配置在本地主机上运行的 AiSQL。
1.启动 DbSchema 应用程序。 将出现“欢迎使用 DbSchema”页面。
2.在“开始新项目”面板上，单击“开始”以连接到数据库。 数据库连接对话框打开。
3.在别名字段中，输入 AiSQL 来命名数据库连接。
4.从 DBMS 下拉列表中，选择 PostgreSQL。 方法和驱动程序字段显示可用的 PostgreSQL JDBC 驱动程序。
5.对于方法和驱动程序选项，选择标准（1 / 2）。 无需添加驱动程序，因为 DbSchema 包含 PostgreSQL JDBC 驱动程序。
6.在Compose URL 选项卡中，单击远程计算机或自定义端口。 将显示服务器主机和端口的默认 PostgreSQL 值。
7.在端口字段中，输入 2521（BSQL 的默认端口），然后单击检查 (Ping)。 将出现一条消息，表明 AiSQL 服务器可以访问。
8.在“身份验证”下，将“数据库用户”更改为 bigmath（默认 AiSQL 用户）。 如果您已启用身份验证，请输入密码。 否则，将该字段留空。
9.在“数据库”下，输入 bigmath（默认 AiSQL 数据库）或要连接的数据库的名称。
10.单击“连接”。 将出现“选择模式/目录”对话框。
11.单击“确定”接受默认选项。 否则，您可以自定义此连接所需的架构信息。</p>
<p>您已使用默认用户 (bigmath) 成功创建了到默认数据库 (bigmath) 的数据库连接。</p>
<h4 id="_324"><strong>进一步使用</strong></h4>
<p>有关使用 DbSchema 的帮助，请参阅 DbSchema 文档。</p>
<p>AiSQL 包含示例数据库供您使用 DbSchema 进行探索。 请参阅示例数据集。</p>
<h3 id="metabase"><strong>Metabase</strong></h3>
<p>Metabase 是一种商业智能 (BI) 工具。</p>
<p>本文档展示了如何设置 Metabase 以与 AiSQL 的 PostgreSQL 兼容 API 集成。</p>
<p>1.启动本地集群
按照快速入门说明运行本地 AiSQL 集群。</p>
<ol>
<li>加载数据
    （1）下载示例架构</li>
</ol>
<div class="highlight"><pre><span></span><code>$ wget https://raw.githubusercontent.com/bigmath/bm-sql-workshop/mserver/query-using-bi-tools/schema.sql
</code></pre></div>
<pre><code>    （2）下载样本数据
</code></pre>
<div class="highlight"><pre><span></span><code>$ wget https://github.com/bigmath/bm-sql-workshop/raw/mserver/query-using-bi-tools/sample-data.tgz
$ tar zxvf sample-data.tgz
$ ls data/
orders.sql  products.sql  reviews.sql  users.sql
</code></pre></div>
<p>（3）使用 sqlsh 连接到 AiSQL
运行以下命令使用 BSQL shell 连接到 AiSQL：</p>
<div class="highlight"><pre><span></span><code>$ ./bin/sqlsh

sqlsh (11.2)
Type &quot;help&quot; for help.

bigmath=#
</code></pre></div>
<p>（4）创建数据库</p>
<div class="highlight"><pre><span></span><code>bigmath=# CREATE DATABASE bm-demo;
bigmath=# GRANT ALL ON DATABASE bm-demo to bigmath;
bigmath=# \c bm-demo;
</code></pre></div>
<p>（5）创建架构并加载数据
首先创建存储数据所需的 4 个表：</p>
<div class="highlight"><pre><span></span><code>bigmath=# \i &#39;schema.sql&#39;;
</code></pre></div>
<p>现在将数据加载到表中：</p>
<div class="highlight"><pre><span></span><code>bigmath=# \i &#39;data/products.sql&#39;
bigmath=# \i &#39;data/users.sql&#39;
bigmath=# \i &#39;data/orders.sql&#39;
bigmath=# \i &#39;data/reviews.sql&#39;
</code></pre></div>
<p>3.下载并配置Metabase
设置Metabase的详细步骤可在Metabase文档中找到。 以下是入门的最少步骤：</p>
<div class="highlight"><pre><span></span><code>$ wget http://downloads.metabase.com/v0.30.4/metabase.jar

$ java -jar metabase.jar
</code></pre></div>
<p>转至 http://localhost:3000 配置您的 Metabase 服务器并将其指向 localhost:2521 处的 BSQL API 端点。</p>
<ol>
<li>使用Metabase运行复杂查询
有关如何使用 Metabase 的详细步骤，请参阅 Metabase 文档。 对于本文档，您将特别关注提出需要 RDBMS 功能的问题。</li>
<li>使用 WHERE 子句过滤数据</li>
<li>表之间连接数据</li>
<li>使用 GROUP BY 执行数据聚合</li>
<li>使用内置函数，例如 SUM、MIN、MAX 等</li>
</ol>
<p>单击提出问题 &gt; 自定义查询。 选择您刚刚设置的数据库，然后输入“零售分析”部分中记录的 SQL 查询。</p>
<h3 id="pgadmin"><strong>pgAdmin</strong></h3>
<p>pgAdmin 是一个流行的开源 PostgreSQL 数据库管理工具。 它简化了数据库对象的创建、维护和使用。 PgAdmin 包括一个连接向导、用于导入 SQL 脚本的内置 SQL 编辑器以及自动生成 SQL 脚本的机制（如果您需要在数据库命令行 shell 上运行它们）。 您可以通过 Web 界面运行 PgAdmin，也可以作为本地安装的可下载应用程序运行。 由于 AiSQL 与 PostgreSQL 兼容，因此您还可以使用 pgAdmin 来使用 AiSQL。</p>
<h4 id="_325"><strong>准备</strong></h4>
<p>要将 pgAdmin 与 AiSQL 结合使用，您需要启动并运行 AiSQL、所需的 Java 运行时环境以及所需的 PostgreSQL JDBC 驱动程序。</p>
<p>1.AiSQL 
您的 AiSQL 集群应该已启动并正在运行。 请参阅 AiSQL 先决条件。</p>
<p>2.PostgreSQL JDBC 驱动程序
要将 pgAdmin 连接到 AiSQL 集群，您需要安装 PostgreSQL JDBC 驱动程序。 要下载支持 Java 8 或更高版本的当前版本，请转至 PostgreSQL JDBC 驱动程序下载页面。</p>
<h4 id="pgadmin_1"><strong>安装pgAdmin</strong></h4>
<p>要安装 pgAdmin，请转至下载页面并选择适合您操作系统的 pgAdmin 4 版本。</p>
<h4 id="pgadmin_2"><strong>配置pgAdmin</strong></h4>
<p>添加 pgAdmin 服务器以连接到集群，如下所示：</p>
<p>1.启动 pgAdmin 4 应用程序。 系统会提示您保存应用程序的主密码。
2.在“快速链接”下，单击“添加新服务器”以显示“注册 - 服务器”窗口。
3.在“常规”选项卡上，输入服务器的名称，例如 BMManaged。
4.在“连接”选项卡上，填写连接参数。
5.对于 AiSQL 托管集群，在 SSL 选项卡上，将根证书设置为您下载的集群根证书。
6.单击“保存”。 新连接出现在应用程序中。</p>
<p>展开数据库以查看所有可用数据库的列表。
<img alt="" src="./media/chapter3/47.png" />
您可以开始探索 AiSQL 数据库。</p>
<h4 id="_326"><strong>进一步使用</strong></h4>
<p>有关使用 pgAdmin 的详细信息，请单击 pgAdmin 菜单中的帮助。</p>
<p>如果您正在寻找示例数据库来使用 pgAdmin 探索 AiSQL，请参阅示例数据集。</p>
<h3 id="sql-workbenchj"><strong>SQL Workbench/J</strong></h3>
<p>SQL Workbench/J 是一款免费、独立于 DBMS 的跨平台 SQL 查询工具，也可与 AiSQL 配合使用。 SQL Workbench/J 是用 Java 编写的，应该在提供 Java 运行时环境 (JRE) 的任何操作系统上运行。</p>
<p>SQL Workbench/J 主要关注以下几个方面：
* 以交互方式或批量方式运行 SQL 脚本
* 丰富的数据集导入导出支持
* 直接在查询结果视图中编辑、插入和删除数据
* 在控制台模式下运行查询</p>
<p>在本节中，您将了解如何将 SQL Workbench/J 与本地集群上的所有 AiSQL API 连接。 SQL Workbench/J 与 AiSQL 配合使用不会出现任何问题，因为 AiSQL API 在有线协议级别与 SQL Workbench/J 已支持的数据库兼容。</p>
<h4 id="_327"><strong>准备</strong></h4>
<p>要将 SQL Workbench/J 与 AiSQL 结合使用，您需要启动并运行 AiSQL、所需的 Java 运行时环境 (JRE) 以及所需的 PostgreSQL JDBC 驱动程序。</p>
<p>1.AiSQL
您的 AiSQL 集群应该已启动并正在运行。 请参阅 AiSQL 先决条件。</p>
<p>2.Java 运行时环境 (JRE)
SQL Workbench/J 需要 Java 8 或更高版本的 Java 运行时（或 JDK）。 适用于 Linux、macOS 和 Windows 的 JRE 和 JDK 安装程序可以从 OpenJDK、AdoptOpenJDK 或 Azul Systems 下载。</p>
<p>有关 JRE 要求的详细信息，请参阅 SQL Workbench/J 入门页面中的先决条件部分。</p>
<p>3.PostgreSQL JDBC 驱动程序
要将 SQL Workbench/J 连接到 AiSQL 集群，您需要安装 PostgreSQL JDBC 驱动程序。 要下载支持 Java 8 或更高版本的当前版本，请转至 PostgreSQL JDBC 驱动程序下载页面。</p>
<h4 id="sql-workbenchj_1"><strong>安装 SQL Workbench/J</strong></h4>
<p>1.转至 SQL Workbench/J 网站并下载适用于您的客户端计算机上的操作系统的分发包。
2.将存档解压到您选择的目录中。</p>
<p>该应用程序现在已准备好运行 - 无需执行进一步的步骤。 有关详细信息，请参阅 SQL Workbench/J 用户手册中的安装和启动 SQL Workbench/J。</p>
<h4 id="sql-workbenchj_2"><strong>配置 SQL Workbench/J</strong></h4>
<p>1.配置 PostgreSQL 驱动程序
AiSQL 与 PostgreSQL 兼容，因此在使用 SQL Workbench/J 时，请使用 PostgreSQL JDBC 驱动程序。</p>
<p>（1）启动 SQL Workbench/J 应用程序。 将出现“选择连接配置文件”弹出窗口。
<img alt="" src="./media/chapter3/48.png" />
（2）单击“管理驱动程序”（位于窗口左下角）以打开“管理驱动程序”窗口。
<img alt="" src="./media/chapter3/49.png" />
（3）在驱动程序列表中，选择 PostgreSQL，然后编辑驱动程序的字段：
* Name：PostgreSQL（用于 AiSQL）
* Library：显示 PostgreSQL JDBC 驱动程序 JAR 文件的位置。 [对于新配置，请浏览到文件位置并单击“选择”。] 安装后，JRE 或 JDK 的默认位置为：
\Library\Java\Extensions\<jdbc-driver>.jar`</p>
<ul>
<li>Classname：org.postgresql.Driver</li>
<li>Sample URL：jdbc:postgresql:127.0.0.1:2521/name_of_database（基于 AiSQL 默认值）。 初次打开驱动程序配置时，该字段显示
jdbc:postgresql://host:port/name_of_database</li>
</ul>
<p>（4）单击“确定”。 “管理驱动程序”窗口将关闭并返回到“选择连接配置文件”窗口。</p>
<p>您现在已经配置了 PostgreSQL JDBC 驱动程序以与 AiSQL 一起使用，现在可以创建连接配置文件。</p>
<p>有关更多信息，请参阅：</p>
<p>SQL Workbench/J 用户手册中的 JDBC 驱动程序。
PostgreSQL JDBC 驱动程序文档。</p>
<p>2.创建 AiSQL 连接配置文件
您需要为您使用的每个数据库创建一个连接配置文件，并且您始终可以通过选择“文件”&gt;“连接”窗口从菜单进入“选择连接配置文件”窗口。
（1）在“选择连接配置文件”窗口中，单击“创建新的连接配置文件”。 创建一个新的配置文件。
（2）将 New profile 替换为连接配置文件的有意义的名称。 由于每个数据库连接都需要一个单独的配置文件，因此请在配置文件名称中包含数据库名称。
（3）对于驱动程序，选择 PostgreSQL（对于 AiSQL）(org.postgresql.Driver)。
（4）对于 URL，将 name_of_database 替换为要连接的数据库的名称。
（5）对于用户名，输入 bigmath 或您将使用的用户名。
（6）对于密码，请将字段留空，除非启用了 BSQL 身份验证。
（7）选择自动提交。 在 PostgreSQL 和 AiSQL 中，AUTOCOMMIT 默认处于打开状态。
（8）单击“测试”以验证连接是否成功。
（9）单击“确定”。 将出现 SQL Workbench/J 默认窗口。 您的连接现在可以使用了。</p>
<p>这就是开始使用连接所需的所有设置。 有关配置文件的详细信息，请参阅 SQL Workbench/J 用户手册中的连接到数据库。</p>
<h4 id="_328"><strong>进一步使用</strong></h4>
<p>现在您已经了解了如何配置 SQL Workbench/J 以与 AiSQL 数据库配合使用，您可以开始探索 SQL Workbench/J 的功能。 有关使用 SQL Workbench/J 的详细信息，请参阅 SQL Workbench/J 用户手册。</p>
<p>如果您正在寻找示例数据库以使用 SQL Workbench/J 探索 AiSQL，请参阅示例数据。</p>
<h3 id="tableplus"><strong>TablePlus</strong></h3>
<p>TablePlus 是一款流行的数据库开发人员控制台，具有与 PostgreSQL、Cassandra 和 Redis 等主要数据库的内置集成。 可以免费开始使用升级到永久付费许可证的选项。 TablePlus 与 AiSQL 配合使用不会出现任何问题，因为 AiSQL API 在有线协议级别与 TablePlus 已支持的数据库兼容。</p>
<p>本教程展示如何将 TablePlus 连接到 AiSQL 集群。</p>
<h4 id="_329"><strong>准备</strong></h4>
<p>您的 AiSQL 集群应该已启动并正在运行。 请参阅 AiSQL 先决条件。</p>
<h4 id="tableplus_1"><strong>安装TablePlus</strong></h4>
<p>要安装 TablePlus，请转至下载页面并选择适合您的操作系统的版本。</p>
<h4 id="_330"><strong>创建连接</strong></h4>
<p>您可以使用 TablePlus 通过 BSQL 和 BCQL API 连接到 AiSQL。</p>
<p>要创建连接，请执行以下操作：
1.在 TablePlus 中，从“连接”菜单中选择“新建”。
2.对于 BSQL 选择 PostgreSQL，对于 BCQL 选择 Cassandra，然后单击“创建”。
<img alt="" src="./media/chapter3/50.png" />
3.输入连接的名称并填写连接参数。
4.单击“测试”以验证 TablePlus 是否可以与 AiSQL 连接。 如果测试成功，字段的颜色将变为绿色。
<img alt="" src="./media/chapter3/51.png" />
5.单击“连接”以创建连接。</p>
<p>连接保存在应用程序中，并在每次启动 TablePlus 时显示。
<img alt="" src="./media/chapter3/52.png" /></p>
<h2 id="bsql_18"><strong>BSQL连接管理池</strong></h2>
<p>BSQL 内置服务器端连接池</p>
<p>BMDB 继承了 PostgreSQL 为每个数据库连接创建一个后端进程的架构。 这些后端进程消耗内存和CPU，限制了BMDB可以支持的连接数量。 为了解决这个问题，您可以使用连接池，它允许将多个客户端连接复用为较少数量的实际服务器连接，从而支持来自应用程序的大量连接。 PgBouncer 和 Odyssey 是一些流行的基于 PostgreSQL 的服务器端连接池机制，它们与 BMDB 完全兼容。</p>
<p>然而，这些产品有一些严重的局限性，例如：</p>
<ul>
<li>PgBouncer 不支持事务池模式下的 prepared statements。</li>
<li>Odyssey 和 PgBouncer 都不支持事务池模式下的 SET 语句。</li>
</ul>
<p>BMDB 包含一个内置连接池程序 BSQL 连接管理器，它提供与其他池解决方案相同的连接池优势，但没有这些限制。 由于管理器与产品捆绑在一起，因此可以方便地管理、监控和配置服务器连接。
<img alt="" src="./media/chapter3/53.png" /></p>
<h3 id="_331"><strong>主要特征</strong></h3>
<p>BSQL 连接管理器是开源连接池 Odyssey 的修改版本。 BSQL 连接管理器在事务池模式下使用 Odyssey，并在线路协议级别进行了修改，以便与 BMDB 更紧密地集成，从而克服一些 SQL 限制。</p>
<p>BSQL连接管理器具有以下主要功能：</p>
<ul>
<li>无 SQL 限制：与在事务模式下运行的其他池解决方案不同，BSQL 连接管理器支持 SQL 功能，例如 TEMP TABLE、WITH HOLD CURSORS 等。</li>
<li>每个数据库一个池：PgBouncer 和 Odyssey 为每个用户和数据库的组合创建一个池，这极大地限制了可以支持的用户数量，从而影响可扩展性。 然而，BSQL 连接管理器为每个数据库创建一个池 - 尝试访问同一数据库的所有连接共享适用于该数据库的同一个池。</li>
<li>支持会话参数：BSQL 连接管理器支持 SET 语句，这是其他连接池不支持的。</li>
<li>支持prepared statements：Odyssey 支持协议级prepared statements，BSQL 连接管理器继承了此功能。</li>
</ul>
<h3 id="bsql_19"><strong>使用 BSQL 连接管理器</strong></h3>
<p>要使用 BSQL 连接管理器启动 BMDB 集群，请将 dbserver 标志 enable_bsql_conn_mgr 设置为 true。</p>
<p>当设置了enable_bsql_conn_mgr时，每个DBServer都会启动BSQL连接管理器进程以及PostgreSQL进程。 您应该看到每个 DBServer 都有一个 BSQL 连接管理器进程。</p>
<p>要使用 bm-ctl 通过 BSQL 连接管理器创建单节点集群，请使用以下命令：</p>
<div class="highlight"><pre><span></span><code>./bin/bm-ctl start --dbserver_flags &quot;enable_bsql_conn_mgr=true,allowed_preview_flags_csv=enable_bsql_conn_mgr&quot; --ui false
</code></pre></div>
<p>由于enable_bsql_conn_mgr 只是预览标志，因此要使用它，请将该标志添加到 allowed_preview_flags_csv 列表中（即 allowed_preview_flags_csv=enable_bsql_conn_mgr）。</p>
<p>要创建大量客户端连接，请确保“SHMMNI”（操作系统允许的并发共享内存段的最大数量）以及 ulimit 设置正确，如下所示：
打开文件/etc/sysctl.conf。
在文件末尾添加 kernel.shmmni = 32768 （支持 30000 个客户端）。
要刷新设置，请使用 sudo sysctl -p。</p>
<p><strong>1.BSQL 连接管理器端口和标志</strong>
默认情况下，当启用BSQL连接管理器时，它使用端口2521，并且后端数据库被分配一个随机的空闲端口。</p>
<p>要显式设置 BSQL 端口，您应该为标志 bsql_conn_mgr_port 和 bsql_port 指定端口。</p>
<p>下表描述了与 BSQL 连接管理器相关的 DBServer 标志：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>enable_bsql_conn_mgr</td>
<td>为集群启用 BSQL 连接管理器。 DBServer 将 BSQL Connection Manager 进程作为子进程启动。</td>
<td>false</td>
</tr>
<tr>
<td>bsql_conn_mgr_idle_time</td>
<td>指定 BSQL 连接管理器创建的数据库连接允许的最大空闲时间（以秒为单位）。 如果数据库连接保持空闲状态且没有为客户端连接提供服务的持续时间等于或超过此值，则 BSQL 连接管理器将自动关闭该连接。</td>
<td>60</td>
</tr>
<tr>
<td>bsql_conn_mgr_max_client_connections</td>
<td>BSQL 连接管理器可以为每个池创建的最大并发数据库连接数。</td>
<td>10000</td>
</tr>
<tr>
<td>bsql_conn_mgr_min_conns_per_db</td>
<td>池中存在的最小物理连接数。关闭断开的物理连接时不考虑此限制</td>
<td>1</td>
</tr>
<tr>
<td>bsql_conn_mgr_num_workers</td>
<td>BSQL 连接管理器使用的工作线程数。 如果设置为 0，工作线程数将为 CPU 核心数的一半。</td>
<td>0</td>
</tr>
<tr>
<td>bsql_conn_mgr_stats_interval</td>
<td>更新 BSQL 连接管理器统计信息的时间间隔（以秒为单位）。</td>
<td>10</td>
</tr>
<tr>
<td>bsql_conn_mgr_password</td>
<td>BSQL 连接管理器用于创建数据库连接的密码。</td>
<td>bigmath</td>
</tr>
<tr>
<td>bsql_conn_mgr_username</td>
<td>BSQL 连接管理器用于创建数据库连接的用户名。</td>
<td>bigmath</td>
</tr>
<tr>
<td>bsql_conn_mgr_warmup_db</td>
<td>需要进行预热的数据库。</td>
<td>bigmath</td>
</tr>
<tr>
<td>enable_bsql_conn_mgr_stats</td>
<td>从 BSQL 连接管理器启用统计信息收集。 这些统计信息显示在端点 <ip_address_of_cluster>:8100/connections 处。</td>
<td>true</td>
</tr>
<tr>
<td>bsql_conn_mgr_port</td>
<td>客户端可以连接的 BSQL 连接管理器端口。 这必须与通过 pgsql_proxy_bind_address 设置的 PostreSQL 端口不同。</td>
<td>2521</td>
</tr>
<tr>
<td>bsql_conn_mgr_dowarmup</td>
<td>在 MBSQL 连接管理器中启用服务器连接的预创建。 如果设置为 false，则在 MBSQL 连接管理器中延迟（按需）创建服务器连接。</td>
<td>false</td>
</tr>
</tbody>
</table>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      © 2024 贝格迈思
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.aecac24b.min.js"></script>
      
        <script src="../../javascripts/extra.js"></script>
      
    
  </body>
</html>