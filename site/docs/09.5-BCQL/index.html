
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="贝格迈思数据库使用手册">
      
      
      
      
        <link rel="prev" href="../09.4-BSQL/">
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.4.6">
    
    
      
        <title>BCQL - 手册</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.35e1ed30.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.356b1318.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Ubuntu";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="mo" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#bcql" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="手册" class="md-header__button md-logo" aria-label="手册" data-md-component="logo">
      
  <img src="../../assets/new-logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            手册
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              BCQL
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/aminerdocs/docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="手册" class="md-nav__button md-logo" aria-label="手册" data-md-component="logo">
      
  <img src="../../assets/new-logo.png" alt="logo">

    </a>
    手册
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/aminerdocs/docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../01-AISQL%E7%AE%80%E4%BB%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AiSQL简介
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    快速上手
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            快速上手
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    快速安装部署
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/SQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SQL基本操作
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/BCQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BCQL基本操作
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%88%9B%E5%BB%BAJava%E7%A4%BA%E4%BE%8B%E5%BA%94%E7%94%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    创建Java示例应用程序
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    应用开发
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            应用开发
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    构建应用
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            构建应用
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/JAVA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Java
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Go/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Go
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Python/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Python
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Node.js/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Node.js
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C%2B%2B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C%23/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C#
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Ruby/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Ruby
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Rust/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Rust
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/PHP/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PHP
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%85%A8%E5%B1%80%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    构建全局应用程序
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    构建多云应用程序
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            构建多云应用程序
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    概述
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../04-%E9%83%A8%E7%BD%B2%E9%9B%86%E7%BE%A4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    部署集群
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../05-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数据迁移
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../06-%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    管理数据库
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../07-%E5%90%91%E9%87%8F%E7%89%B9%E6%80%A7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    向量特性
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../08-AI%E7%89%B9%E6%80%A7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AI特性
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" checked>
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    参考
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            参考
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.1-%E6%9E%B6%E6%9E%84/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    架构
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.2-CLIs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CLIs
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.3-%E9%85%8D%E7%BD%AE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    配置
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.4-BSQL/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BSQL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    BCQL
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    BCQL
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#bcql" class="md-nav__link">
    BCQL
  </a>
  
    <nav class="md-nav" aria-label="BCQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    数据类型
  </a>
  
    <nav class="md-nav" aria-label="数据类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#integer-and-counter" class="md-nav__link">
    Integer and counter
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#blob" class="md-nav__link">
    BLOB
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#boolean" class="md-nav__link">
    BOOLEAN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#non-integer-float-double-and-decimal" class="md-nav__link">
    Non-integer (FLOAT, DOUBLE, and DECIMAL)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#date-and-time-date-time-and-timestamp" class="md-nav__link">
    Date and time (DATE, TIME, and TIMESTAMP)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#frozen" class="md-nav__link">
    FROZEN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inet" class="md-nav__link">
    INET
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#collection-map-list-and-set" class="md-nav__link">
    Collection (MAP, LIST, and SET)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#text-text-and-varchar" class="md-nav__link">
    TEXT (TEXT, and VARCHAR)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#uuid-and-timeuuid" class="md-nav__link">
    UUID and TIMEUUID
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb" class="md-nav__link">
    JSONB
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    函数和运算符
  </a>
  
    <nav class="md-nav" aria-label="函数和运算符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    内置函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    聚合函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cast" class="md-nav__link">
    CAST函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#partition_hash" class="md-nav__link">
    partition_hash函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#writetime" class="md-nav__link">
    WriteTime函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ttl" class="md-nav__link">
    TTL函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    运算符
  </a>
  
    <nav class="md-nav" aria-label="运算符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    空运算符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    一元运算符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    二元运算符
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_1" class="md-nav__link">
    JSONB的相关函数和运算符
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql_1" class="md-nav__link">
    BCQL语言
  </a>
  
    <nav class="md-nav" aria-label="BCQL语言">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#alter-keyspace" class="md-nav__link">
    ALTER KEYSPACE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-role" class="md-nav__link">
    ALTER ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-table" class="md-nav__link">
    ALTER TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-index" class="md-nav__link">
    CREATE INDEX
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-keyspace" class="md-nav__link">
    CREATE KEYSPACE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-role" class="md-nav__link">
    CREATE ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-table" class="md-nav__link">
    CREATE TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-type" class="md-nav__link">
    CREATE TYPE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-index" class="md-nav__link">
    DROP INDEX
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-keyspace" class="md-nav__link">
    DROP KEYSPACE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-role" class="md-nav__link">
    DROP ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-table" class="md-nav__link">
    DROP TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-type" class="md-nav__link">
    DROP TYPE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grant-permission" class="md-nav__link">
    GRANT PERMISSION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grant-role" class="md-nav__link">
    GRANT ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#revoke-permission" class="md-nav__link">
    REVOKE PERMISSION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#revoke-role" class="md-nav__link">
    REVOKE ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#use" class="md-nav__link">
    USE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#insert" class="md-nav__link">
    INSERT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#select" class="md-nav__link">
    SELECT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#explain" class="md-nav__link">
    EXPLAIN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#update" class="md-nav__link">
    UPDATE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delete" class="md-nav__link">
    DELETE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transaction" class="md-nav__link">
    TRANSACTION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#truncate" class="md-nav__link">
    TRUNCATE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#simple-expressions" class="md-nav__link">
    Simple expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#subscripted-expressions" class="md-nav__link">
    Subscripted expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#function-call" class="md-nav__link">
    Function call
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operators" class="md-nav__link">
    Operators
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#blob_1" class="md-nav__link">
    BLOB
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#boolean_1" class="md-nav__link">
    BOOLEAN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#collection" class="md-nav__link">
    Collection
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#frozen_1" class="md-nav__link">
    FROZEN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inet_1" class="md-nav__link">
    INET
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#integer-and-counter_1" class="md-nav__link">
    Integer and counter
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#non-integer" class="md-nav__link">
    Non-integer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#text" class="md-nav__link">
    TEXT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#date-time-and-timestamp" class="md-nav__link">
    DATE, TIME, and TIMESTAMP
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#uuid-and-timeuuid_1" class="md-nav__link">
    UUID and TIMEUUID
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_2" class="md-nav__link">
    JSONB
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#date-and-time" class="md-nav__link">
    Date and time
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#batch" class="md-nav__link">
    BATCH
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#apache-superset" class="md-nav__link">
    Apache Superset
  </a>
  
    <nav class="md-nav" aria-label="Apache Superset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#superset-bmdb" class="md-nav__link">
    将 Superset 连接到 BMDB
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    进一步使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#arctype" class="md-nav__link">
    Arctype
  </a>
  
    <nav class="md-nav" aria-label="Arctype">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#arctype_1" class="md-nav__link">
    安装Arctype
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    创建数据库连接
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    进一步使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbeaver" class="md-nav__link">
    DBeaver
  </a>
  
    <nav class="md-nav" aria-label="DBeaver">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql" class="md-nav__link">
    创建BSQL连接
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbschema" class="md-nav__link">
    DbSchema
  </a>
  
    <nav class="md-nav" aria-label="DbSchema">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbschema_1" class="md-nav__link">
    安装 DbSchema
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    创建数据库连接
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    进一步使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#metabase" class="md-nav__link">
    Metabase
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pgadmin" class="md-nav__link">
    pgAdmin
  </a>
  
    <nav class="md-nav" aria-label="pgAdmin">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pgadmin_1" class="md-nav__link">
    安装pgAdmin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pgadmin_2" class="md-nav__link">
    配置pgAdmin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    进一步使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql-workbenchj" class="md-nav__link">
    SQL Workbench/J
  </a>
  
    <nav class="md-nav" aria-label="SQL Workbench/J">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql-workbenchj_1" class="md-nav__link">
    安装 SQL Workbench/J
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql-workbenchj_2" class="md-nav__link">
    配置 SQL Workbench/J
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    进一步使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tableplus" class="md-nav__link">
    TablePlus
  </a>
  
    <nav class="md-nav" aria-label="TablePlus">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tableplus_1" class="md-nav__link">
    安装TablePlus
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    创建连接
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#bcql" class="md-nav__link">
    BCQL
  </a>
  
    <nav class="md-nav" aria-label="BCQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    数据类型
  </a>
  
    <nav class="md-nav" aria-label="数据类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#integer-and-counter" class="md-nav__link">
    Integer and counter
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#blob" class="md-nav__link">
    BLOB
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#boolean" class="md-nav__link">
    BOOLEAN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#non-integer-float-double-and-decimal" class="md-nav__link">
    Non-integer (FLOAT, DOUBLE, and DECIMAL)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#date-and-time-date-time-and-timestamp" class="md-nav__link">
    Date and time (DATE, TIME, and TIMESTAMP)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#frozen" class="md-nav__link">
    FROZEN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inet" class="md-nav__link">
    INET
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#collection-map-list-and-set" class="md-nav__link">
    Collection (MAP, LIST, and SET)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#text-text-and-varchar" class="md-nav__link">
    TEXT (TEXT, and VARCHAR)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#uuid-and-timeuuid" class="md-nav__link">
    UUID and TIMEUUID
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb" class="md-nav__link">
    JSONB
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    函数和运算符
  </a>
  
    <nav class="md-nav" aria-label="函数和运算符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    内置函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    聚合函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cast" class="md-nav__link">
    CAST函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#partition_hash" class="md-nav__link">
    partition_hash函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#writetime" class="md-nav__link">
    WriteTime函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ttl" class="md-nav__link">
    TTL函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    运算符
  </a>
  
    <nav class="md-nav" aria-label="运算符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    空运算符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    一元运算符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    二元运算符
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_1" class="md-nav__link">
    JSONB的相关函数和运算符
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcql_1" class="md-nav__link">
    BCQL语言
  </a>
  
    <nav class="md-nav" aria-label="BCQL语言">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#alter-keyspace" class="md-nav__link">
    ALTER KEYSPACE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-role" class="md-nav__link">
    ALTER ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-table" class="md-nav__link">
    ALTER TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-index" class="md-nav__link">
    CREATE INDEX
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-keyspace" class="md-nav__link">
    CREATE KEYSPACE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-role" class="md-nav__link">
    CREATE ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-table" class="md-nav__link">
    CREATE TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-type" class="md-nav__link">
    CREATE TYPE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-index" class="md-nav__link">
    DROP INDEX
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-keyspace" class="md-nav__link">
    DROP KEYSPACE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-role" class="md-nav__link">
    DROP ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-table" class="md-nav__link">
    DROP TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-type" class="md-nav__link">
    DROP TYPE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grant-permission" class="md-nav__link">
    GRANT PERMISSION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grant-role" class="md-nav__link">
    GRANT ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#revoke-permission" class="md-nav__link">
    REVOKE PERMISSION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#revoke-role" class="md-nav__link">
    REVOKE ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#use" class="md-nav__link">
    USE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#insert" class="md-nav__link">
    INSERT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#select" class="md-nav__link">
    SELECT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#explain" class="md-nav__link">
    EXPLAIN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#update" class="md-nav__link">
    UPDATE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delete" class="md-nav__link">
    DELETE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transaction" class="md-nav__link">
    TRANSACTION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#truncate" class="md-nav__link">
    TRUNCATE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#simple-expressions" class="md-nav__link">
    Simple expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#subscripted-expressions" class="md-nav__link">
    Subscripted expressions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#function-call" class="md-nav__link">
    Function call
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operators" class="md-nav__link">
    Operators
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#blob_1" class="md-nav__link">
    BLOB
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#boolean_1" class="md-nav__link">
    BOOLEAN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#collection" class="md-nav__link">
    Collection
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#frozen_1" class="md-nav__link">
    FROZEN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inet_1" class="md-nav__link">
    INET
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#integer-and-counter_1" class="md-nav__link">
    Integer and counter
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#non-integer" class="md-nav__link">
    Non-integer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#text" class="md-nav__link">
    TEXT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#date-time-and-timestamp" class="md-nav__link">
    DATE, TIME, and TIMESTAMP
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#uuid-and-timeuuid_1" class="md-nav__link">
    UUID and TIMEUUID
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_2" class="md-nav__link">
    JSONB
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#date-and-time" class="md-nav__link">
    Date and time
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#batch" class="md-nav__link">
    BATCH
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#apache-superset" class="md-nav__link">
    Apache Superset
  </a>
  
    <nav class="md-nav" aria-label="Apache Superset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#superset-bmdb" class="md-nav__link">
    将 Superset 连接到 BMDB
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    进一步使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#arctype" class="md-nav__link">
    Arctype
  </a>
  
    <nav class="md-nav" aria-label="Arctype">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#arctype_1" class="md-nav__link">
    安装Arctype
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    创建数据库连接
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    进一步使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbeaver" class="md-nav__link">
    DBeaver
  </a>
  
    <nav class="md-nav" aria-label="DBeaver">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    先决条件
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql" class="md-nav__link">
    创建BSQL连接
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbschema" class="md-nav__link">
    DbSchema
  </a>
  
    <nav class="md-nav" aria-label="DbSchema">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbschema_1" class="md-nav__link">
    安装 DbSchema
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    创建数据库连接
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    进一步使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#metabase" class="md-nav__link">
    Metabase
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pgadmin" class="md-nav__link">
    pgAdmin
  </a>
  
    <nav class="md-nav" aria-label="pgAdmin">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pgadmin_1" class="md-nav__link">
    安装pgAdmin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pgadmin_2" class="md-nav__link">
    配置pgAdmin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    进一步使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql-workbenchj" class="md-nav__link">
    SQL Workbench/J
  </a>
  
    <nav class="md-nav" aria-label="SQL Workbench/J">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql-workbenchj_1" class="md-nav__link">
    安装 SQL Workbench/J
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql-workbenchj_2" class="md-nav__link">
    配置 SQL Workbench/J
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    进一步使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tableplus" class="md-nav__link">
    TablePlus
  </a>
  
    <nav class="md-nav" aria-label="TablePlus">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    准备
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tableplus_1" class="md-nav__link">
    安装TablePlus
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    创建连接
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


  <h1>BCQL</h1>

<h2 id="bcql"><strong>BCQL</strong></h2>
<h3 id="_1"><strong>数据类型</strong></h3>
<p>下表列出了BCQL支持的数据类型。</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>bigint</td>
<td>64位带符号长</td>
</tr>
<tr>
<td>blob</td>
<td>任意字节，以十六进制表示</td>
</tr>
<tr>
<td>boolean</td>
<td>true 或者false</td>
</tr>
<tr>
<td>counter</td>
<td>分布式计数器值（64位长）</td>
</tr>
<tr>
<td>date</td>
<td>Value是没有相应时间值的日期；Cassandra将日期编码为32位整数，表示自epoch（1970年1月1日）以来的天数。日期可以在查询和插入中表示为字符串，例如2015-05-03（yyyy-mm-dd）</td>
</tr>
<tr>
<td>decimal</td>
<td>可变精度小数</td>
</tr>
<tr>
<td>double</td>
<td>64位IEEE-754浮点</td>
</tr>
<tr>
<td>float</td>
<td>32位IEEE-754浮点</td>
</tr>
<tr>
<td>frozen</td>
<td>frozen的值将多个组件序列化为一个值。非frozen类型允许更新各个字段。将frozen类型的值视为blob。必须覆盖整个值。</td>
</tr>
<tr>
<td>JSONB</td>
<td>JSON数据</td>
</tr>
<tr>
<td>inet</td>
<td>IPv4或IPv6格式的IP地址字符串，由python cql驱动程序和cql本机协议使用</td>
</tr>
<tr>
<td>int</td>
<td>32位有符号整数</td>
</tr>
<tr>
<td>list</td>
<td>一个或多个有序元素的集合： [literal, literal, literal]。 注意： 列表有局限性和特定的性能注意事项。使用frozen列表来减少影响。通常，使用集合而不是列表。</td>
</tr>
<tr>
<td>map</td>
<td>JSON样式的文字数组：｛literal:literal，literal:literal…｝</td>
</tr>
<tr>
<td>set</td>
<td>一个或多个元素的集合：｛literal，literal、literal｝</td>
</tr>
<tr>
<td>smallint</td>
<td>2字节整数</td>
</tr>
<tr>
<td>text</td>
<td>UTF-8编码字符串</td>
</tr>
<tr>
<td>time</td>
<td>值编码为64位带符号整数，表示自午夜以来的纳秒数。值可以表示为字符串，例如13:30:54.234。</td>
</tr>
<tr>
<td>timestamp</td>
<td>日期和时间，精度为毫秒，自epoch以来编码为8字节。可以用字符串表示，如2015-05-03 13:30:54.234。</td>
</tr>
<tr>
<td>timeuuid</td>
<td>除了具备UUID的特性外，还带时间信息</td>
</tr>
<tr>
<td>tinyint</td>
<td>1字节整数</td>
</tr>
<tr>
<td>uuid</td>
<td>标准UUID格式的UUID</td>
</tr>
<tr>
<td>varchar</td>
<td>UTF-8编码字符串</td>
</tr>
<tr>
<td>varint</td>
<td>任意精度整数</td>
</tr>
</tbody>
</table>
<h4 id="integer-and-counter"><strong>Integer and counter</strong></h4>
<p>Integer的类型，它们和counter类型的主要区别在于：counter只能增加，或者减少，而Integer可以任意设置。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>-128</td>
<td>127</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>-32,768</td>
<td>32,767</td>
</tr>
<tr>
<td>INT 或 INTEGER</td>
<td>-2,147,483,648</td>
<td>2,147,483,647</td>
</tr>
<tr>
<td>BIGINT</td>
<td>–9,223,372,036,854,775,808</td>
<td>9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>VARINT</td>
<td>无限</td>
<td>无限</td>
</tr>
<tr>
<td>COUNTER</td>
<td>–9,223,372,036,854,775,808</td>
<td>9,223,372,036,854,775,807</td>
</tr>
</tbody>
</table>
<p>注意事项：</p>
<ul>
<li>TINYINT, SMALLINT, INT, INTEGER, BIGINT 或者 VARINT可以作为主键Primary Key的组成部分。</li>
<li>COUNTER不可以作为主键Primary Key的组成部分。</li>
<li>类型之间可以互相转换，并且可以互相比较。</li>
<li>上面的整型不可以和浮点型直接比较。</li>
<li>浮点型不可以直接转换为整型。</li>
</ul>
<h4 id="blob"><strong>BLOB</strong></h4>
<p>BLOB的作用和其他数据库此类型的定义类似，一个是基于二进制的数据编码，第二个就是可以任意的可变的长度。</p>
<p>注意事项：</p>
<ul>
<li>BLOB可以作为主键Primary Key的组成部分。</li>
<li>隐含下，BLOB不可以直接转换为其他类型，也不可以和其他类型比较。</li>
<li>如果需要转换类型，请用两个内置函数：BlobAs<Type> 和 <Type>AsBlob。</li>
<li>BLOB的长度理论上无上限。</li>
</ul>
<h4 id="boolean"><strong>BOOLEAN</strong></h4>
<p>BOOLEAN类型只表达：是或否（也可称为真或假，或称为true和false），这两个概念。</p>
<p>注意事项：</p>
<ul>
<li>BOOLEAN绝对不可以作为主键Primary Key的组成部分。</li>
<li>BOOLEAN列，可以增加、赋值以及比较。</li>
<li>当使用WHERE和IF语句时，BOOLEAN列不可以直接作为表达式使用，而必须和true或者false进行对比。比如：WHERE boolean_column = TRUE是正确表达式，但是WHERE boolean_column的用法是错误的。</li>
<li>隐含下，BOOLEAN类不可以转换为其他类型，也不可以和其他类型比较。</li>
</ul>
<h4 id="non-integer-float-double-and-decimal"><strong>Non-integer (FLOAT, DOUBLE, and DECIMAL)</strong></h4>
<p>相比上面的多种Integer(含counter)类，还有一些类型，表达值的概念，但不是整型。请参考下表：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>精度</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLOAT</td>
<td>32位浮点数，注意：做不到绝对精确</td>
<td>7位bit</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>64位浮点数，注意：做不到绝对精确</td>
<td>15位bit</td>
</tr>
<tr>
<td>DECIMAL</td>
<td>任何绝对精确的数值</td>
<td>无上限</td>
</tr>
</tbody>
</table>
<p>注意事项：</p>
<ul>
<li>上面几个类型都可以作为主键Primary Key的组成部分。</li>
<li>DOUBLE 和 DOUBLE PRECISION是一个意思，即互为别名。</li>
<li>上面几个类型之间可以互相转换，或者互相比较。
  n 这里有一个例外，就是下面几个浮点数转换为DECIMAL时，会产生错误异常，包括：NaN、Infinity、-Infinity。</li>
<li>上面类型不可以直接比较，也不可以转换为整型，但是整型可以转换为上面的类型。</li>
<li>如果按升序排序的话，依次顺序如下：-Infinity，所有负值（内部按升序），所有正值（内部按升序），Infinity，NaN。</li>
</ul>
<h4 id="date-and-time-date-time-and-timestamp"><strong>Date and time (DATE, TIME, and TIMESTAMP)</strong></h4>
<p>包括三个类型，分别是：DATE、TIME、TIMESTAMP，其中，DATE表达日期，TIME表达一天里的某个时间，TIMESTAMP则可以看作是DATE和TIME的结合。</p>
<p>注意事项：</p>
<ul>
<li>上面几个类型都可以作为主键Primary Key的组成部分。</li>
<li>隐含下，DATE类型不可以转换，也不可以比较其他两个类型。</li>
<li>整型以及TEXT类型，如果表达正确，可以转换为上面几个时间类型。</li>
<li>TIMESTAMP类型的年份起始最早只能是1900，最晚只能是9999。</li>
<li>对于小时hour，分钟minute，秒second以及毫秒millisecond，缺省值均是0。</li>
<li>缺省的时区Time Zone是UTC。</li>
</ul>
<h4 id="frozen"><strong>FROZEN</strong></h4>
<p>FROZEN类型是集合collection类型进行串行化所形成的二进制字符串。</p>
<p>其表达为：FROZEN<type>。</p>
<p>注意事项：</p>
<ul>
<li>可以作为主键Primary Key的组成部分。</li>
<li>上面表达的type，必须是集合collection类型，包括：LIST、MAP、SET或用户自定义集合类型。</li>
<li>FROZEN自己本身，也可以作为集合collection类型的包含参数。</li>
<li>对于FROZEN<type>里，如果type是合法的，那么如果某个值的类型是type，那么它可以转换为类型FROZEN<type>。</li>
</ul>
<h4 id="inet"><strong>INET</strong></h4>
<p>INET类型用于表达IP地址。</p>
<p>注意事项：</p>
<ul>
<li>可以作为主键Primary Key的组成部分。</li>
<li>隐含下，INET类型不可以转换，也不可以比较其他类型。</li>
<li>对于TEXT类型，如果它表达正确，它可以转换为INET类型。</li>
<li>INET类型的TEXT字面（literal）表达式，可以是IPv4，也可以是IPv6。</li>
</ul>
<h4 id="collection-map-list-and-set"><strong>Collection (MAP, LIST, and SET)</strong></h4>
<p>LIST是有次序的集合。LIST里的元素，必须同类型，而且是初级类型。LIST可以在头部和尾部，通过+进行增加，或者通过-进行减少，访问某个元素，可以通过[]里的索引index值进行。</p>
<p>MAP是key和value的成对的元素组合，它是排序的。排序基于key值，通过key值，MAP可以通过[]进行修改，+进行增加，-进行删除。当查询时，MAP返回的是有序的。</p>
<p>SET是排序的组合，只有key（或元素本身）。SET通过+进行增加，通过-进行删除，查询返回的也是有序的。</p>
<p>注意事项：</p>
<ul>
<li>这几个类型，都不可以作为主键Primary Key的组成部分。</li>
<li>type不能带type 参数（即不能是MAP、LIST、SET类型），但Frozen除外（Frozen可以有type参数）</li>
<li>对于key type，必须是能成为主键的（即不能是BOOL，也不能是MAP、LIST、SET）。</li>
<li>map字面(literal)可以表达为key:value。</li>
<li>Collection作为整体是不能进行比较的， 比如：出现在WHERE和IF中。</li>
<li>空Collection，将作为null值对待。</li>
</ul>
<h4 id="text-text-and-varchar"><strong>TEXT (TEXT, and VARCHAR)</strong></h4>
<p>TEXT类型，表达的是字符串，而且是Unicode编码。
TEXT的别名就是VARCHAR，即它们是同一个类型。</p>
<p>注意事项：</p>
<ul>
<li>TEXT或VARCHAR类型，可以作为主键Primary Key的组成部分。</li>
<li>隐含下，TEXT既不能转换为其他类型，也不能比较其他类型。</li>
<li>TEXT的长度理论上无上限。</li>
</ul>
<h4 id="uuid-and-timeuuid"><strong>UUID and TIMEUUID</strong></h4>
<p>UUID保证全宇宙里唯一，TIMEUUID除了具备UUID的特性外，还带时间信息。</p>
<p>注意事项：</p>
<ul>
<li>上面几个类型都可以作为主键Primary Key的组成部分。</li>
<li>隐含下，UUID和TIMEUUID不能转换为其他类型，也不能比较其他类型。</li>
<li>TIMEUUID是早期的UUID实现，它包含：创建的时间，加上产生这个值的唯一的机器号。</li>
<li>TIMEUUID的比较，首先比较时间部分；如果时间部分相同，再比较机器号。</li>
</ul>
<h4 id="jsonb"><strong>JSONB</strong></h4>
<p>JSONB存储的是JSON数据，和POSTGRESQL的JSON类型十分类似。</p>
<p>注意事项：</p>
<ul>
<li>不可以作为主键Primary Key的组成部分。</li>
<li>隐含下，JSONB不可以转换为其他类型，对于比较，如果JSONB是一个有效的JSON表达，其只可以和TEXT/VARCHAR类型进行。</li>
<li>某个值，类型是TEXT，表达是正确的JSON格式，其可以转换为JSONB。</li>
<li>同样如上，JSONB支持正确表达为JSON格式的TEXT字面(literal)。</li>
</ul>
<h3 id="_2"><strong>函数和运算符</strong></h3>
<h4 id="_3"><strong>内置函数</strong></h4>
<table>
<thead>
<tr>
<th>函数名</th>
<th>返回类型</th>
<th>参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BlobAs<Type></td>
<td><Type></td>
<td>(BLOB)</td>
<td>将BLOB转成某个类型</td>
</tr>
<tr>
<td><Type>AsBlob</td>
<td>BLOB</td>
<td>(<Type>)</td>
<td>将某个值转为BLOB</td>
</tr>
<tr>
<td>DateOf</td>
<td>TIMESTAMP</td>
<td>(TIMEUUID)</td>
<td>转换</td>
</tr>
<tr>
<td>MaxTimeUuid</td>
<td>TIMEUUID</td>
<td>(TIMESTAMP)</td>
<td>根据时间参数返回对应这个时间的最大的TIMEUUID</td>
</tr>
<tr>
<td>MinTimeUuid</td>
<td>TIMEUUID</td>
<td>(TIMESTAMP)</td>
<td>根据时间参数返回对应这个时间的最小的TIMEUUID</td>
</tr>
<tr>
<td>CurrentDate</td>
<td>DATE</td>
<td>()</td>
<td>获得系统当前的日期</td>
</tr>
<tr>
<td>CurrentTime</td>
<td>TIME</td>
<td>()</td>
<td>获得系统本日的当前时间</td>
</tr>
<tr>
<td>CurrentTimestamp</td>
<td>TIMESTAMP</td>
<td>()</td>
<td>获得系统当前的时间标签</td>
</tr>
<tr>
<td>Now</td>
<td>TIMEUUID</td>
<td>()</td>
<td>获得对应当前系统时间所对应的UUID</td>
</tr>
<tr>
<td>TTL</td>
<td>BIGINT</td>
<td>(<AnyType>)</td>
<td>获得某列存活的剩下时间值（秒为单位）</td>
</tr>
<tr>
<td>ToDate</td>
<td>DATE</td>
<td>(TIMESTAMP)</td>
<td>转换</td>
</tr>
<tr>
<td>ToTime</td>
<td>TIME</td>
<td>(TIMESTAMP)</td>
<td>转换</td>
</tr>
<tr>
<td>ToTime</td>
<td>TIME</td>
<td>(TIMEUUID)</td>
<td>转换</td>
</tr>
<tr>
<td>ToTimestamp</td>
<td>(TIMESTAMP)</td>
<td>(DATE)</td>
<td>转换</td>
</tr>
<tr>
<td>ToTimestamp</td>
<td>(TIMESTAMP)</td>
<td>(TIMEUUID)</td>
<td>转换</td>
</tr>
<tr>
<td>ToUnixTimestamp</td>
<td>BIGINT</td>
<td>(DATE)</td>
<td>转换</td>
</tr>
<tr>
<td>ToUnixTimestamp</td>
<td>BIGINT</td>
<td>(TIMESTAMP)</td>
<td>转换</td>
</tr>
<tr>
<td>ToUnixTimestamp</td>
<td>BIGINT</td>
<td>(TIMEUUID)</td>
<td>转换</td>
</tr>
<tr>
<td>UnixTimestampOf</td>
<td>BIGINT</td>
<td>(TIMEUUID)</td>
<td>转换</td>
</tr>
<tr>
<td>UUID</td>
<td>UUID</td>
<td>()</td>
<td>返回Version 4的UUID</td>
</tr>
<tr>
<td>WriteTime</td>
<td>BIGINT</td>
<td>(<AnyType>)</td>
<td>返回某列正被写入的时间</td>
</tr>
<tr>
<td>partition_hash</td>
<td>BIGINT</td>
<td>()</td>
<td>根据某行（row）定义的分区键列计算分区用的Hash值（uint16）</td>
</tr>
</tbody>
</table>
<h4 id="_4"><strong>聚合函数</strong></h4>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>COUNT</td>
<td>返回被选中的行的数目</td>
</tr>
<tr>
<td>SUM</td>
<td>返回被统计列的总和值</td>
</tr>
<tr>
<td>AVG</td>
<td>返回被统计列的平均值</td>
</tr>
<tr>
<td>MIN</td>
<td>返回被统计列的最小值</td>
</tr>
<tr>
<td>MAX</td>
<td>返回被统计列的最大值</td>
</tr>
</tbody>
</table>
<h4 id="cast"><strong>CAST函数</strong></h4>
<p>CAST函数用于从某列返回的值转换到指定的类型。</p>
<p>转换表：</p>
<table>
<thead>
<tr>
<th>源类型（列）</th>
<th>目的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>BIGINT</td>
<td>SMALLINT, INT, TEXT</td>
</tr>
<tr>
<td>BOOLEAN</td>
<td>TEXT</td>
</tr>
<tr>
<td>DATE</td>
<td>TEXT, TIMESTAMP</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>BIGINT, INT, SMALLINT, TEXT</td>
</tr>
<tr>
<td>FLOAT</td>
<td>BIGINT, INT, SMALLINT, TEXT</td>
</tr>
<tr>
<td>INT</td>
<td>BIGIINT, SMALLINT, TEXT</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>BIGINT, INT, TEXT</td>
</tr>
<tr>
<td>TIME</td>
<td>TEXT</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>DATE, TEXT</td>
</tr>
<tr>
<td>TIMEUUID</td>
<td>DATE, TIMESTAMP</td>
</tr>
</tbody>
</table>
<h4 id="partition_hash"><strong>partition_hash函数</strong></h4>
<p>partition_hash的参数是一个行row上定义的主键Primary Key中的用于分区的相关的键列，它计算获得一个uint16的Hash值，这个值就是用于分区的那个值，范围是0-65535。一个Table被分成多个分片，每个分片负责这个0-65535范围中的一个区段的Hash值。</p>
<h4 id="writetime"><strong>WriteTime函数</strong></h4>
<p>当我们向一个列写入时，可以通过此函数，获得一个当时的时间标签timestamp（精度到microsecond，微秒）。</p>
<h4 id="ttl"><strong>TTL函数</strong></h4>
<p>TTL函数获得一个有TTL效果的列剩下的存活时间，精确到秒。</p>
<h4 id="_5"><strong>运算符</strong></h4>
<h6 id="_6"><strong>空运算符</strong></h6>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>EXISTS</td>
<td>检测是否存在</td>
</tr>
<tr>
<td>NOT EXISTS</td>
<td></td>
</tr>
</tbody>
</table>
<p>注：只能用于IF语句。</p>
<h6 id="_7"><strong>一元运算符</strong></h6>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>取负</td>
</tr>
<tr>
<td>+</td>
<td>什么都不做</td>
</tr>
<tr>
<td>NOT</td>
<td>对于boolean类型取反</td>
</tr>
</tbody>
</table>
<p>注：-, +，当作为一元运算符时，只能用于常量表达式。</p>
<h6 id="_8"><strong>二元运算符</strong></h6>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>OR, AND</td>
<td>用于boolean</td>
</tr>
<tr>
<td>=, !=, &lt;, &lt;=, &gt;, &gt;=</td>
<td>比较</td>
</tr>
<tr>
<td>+</td>
<td>可以是：增加，尾部追加，头部增加</td>
</tr>
<tr>
<td>-</td>
<td>可以是：减少，删除</td>
</tr>
<tr>
<td>*</td>
<td>乘积</td>
</tr>
<tr>
<td>/</td>
<td>除掉</td>
</tr>
<tr>
<td>ISNULL, IS NOT NULL</td>
<td>是NULL，或者不是NULL</td>
</tr>
</tbody>
</table>
<p>注意事项：</p>
<ul>
<li>如果比较，则运算符的第一个参数必须是列，比如：column_name = 7</li>
<li>如果和NULL比较，总是产生false这个值。所以，只能通过ISNULL或者IS NOT NULL来比较其是否是NULL值。</li>
<li>如果 + 和 - ，用到某个COUNTER类型，而这个COUNTER类型的值是NULL, 则计算前，先将NULL用0替代再进行计算。如果不是COUNTER类型而是其他数值型，且值是NULL，那么所有的运算符的计算结果，都是NULL。</li>
<li>
<ul>
<li>作用于LIST类型，要么是头部增加，要么是尾部增加；- 作用于LIST类型，则是删除。</li>
</ul>
</li>
<li>
<ul>
<li>作用于MAP和SET类型，是增加新的元素；- 对于这两个类型，则是删除元素。</li>
</ul>
</li>
</ul>
<h4 id="jsonb_1"><strong>JSONB的相关函数和运算符</strong></h4>
<p>JSONB支持两类运算符。
-&gt;可以返回一个JSON类型的返回值，同时，针对这个JSON值，可以进行更多的符合JSON的运算操作和相关操作。
-&gt;&gt;可以转换一个JSONB类型为一个表达为string的值，后面，你不能再用针对JSON的运算符或其他操作，针对这个string返回值。
有的时候，你希望直接将JSON的某个属性（attribute）作为数值看待，这时，你可以用CAST函数，将-&gt;&gt;输出的值进行转换。</p>
<h3 id="bcql_1"><strong>BCQL语言</strong></h3>
<h4 id="alter-keyspace"><strong>ALTER KEYSPACE</strong></h4>
<p>使用ALTER KEYSPACE语句可以更改现有键空间的属性。
仅出于兼容性原因支持此语句，在内部不起作用（无操作语句）。
如果指定的键空间不存在，或者用户（角色）没有键空间ALTER操作的权限，则该语句可能失败。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>alter_keyspace ::= ALTER { KEYSPACE | SCHEMA } keyspace_name
                       [ WITH REPLICATION &#39;=&#39; &#39;{&#39; keyspace_property &#39;}&#39;]
                       [ AND DURABLE_WRITES &#39;=&#39; { true | false } ]

keyspace_property ::= property_name = property_value
</code></pre></div>
<ul>
<li>keyspace_name和property_name是标识符。</li>
<li>property_value是布尔、文本或映射数据类型。</li>
</ul>
<p>描述：</p>
<ul>
<li>如果指定的keyspace_name不存在，则会引发错误。 </li>
<li>如果用户（使用的角色）对此指定的键空间没有ALTER权限，对所有键空间也没有ALTER权限时，将引发错误。 </li>
<li>语法中支持BCQL键空间属性，但在内部不起作用（使用AiSQL 默认值）</li>
</ul>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>cqlsh&gt; ALTER KEYSPACE example;
</code></pre></div>
<div class="highlight"><pre><span></span><code>cqlsh&gt; ALTER KEYSPACE example WITH REPLICATION = {&#39;class&#39;: &#39;SimpleStrategy&#39;, &#39;replication_factor&#39;: &#39;3&#39;} AND DURABLE_WRITES = true;
</code></pre></div>
<div class="highlight"><pre><span></span><code>cqlsh&gt; ALTER SCHEMA keyspace_example;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SQL error: Keyspace Not Found.
ALTER SCHEMA keyspace_example;
             ^^^^^^
</code></pre></div>
<div class="highlight"><pre><span></span><code>cqlsh&gt; ALTER KEYSPACE example;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SQL error: Unauthorized. User test_role has no ALTER permission on &lt;keyspace example&gt; or any of its parents.
ALTER KEYSPACE example;
^^^^^^
</code></pre></div>
<h4 id="alter-role"><strong>ALTER ROLE</strong></h4>
<p>使用ALTER ROLE语句可以更改现有角色的属性。它允许修改属性SUPERUSER、PASSWORD和LOGIN。 
通过将dbServer标志--use_cassandra_authentication设置为true，可以启用此语句。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>alter_table ::= ALTER ROLE role_name WITH role_property [ AND role_property ...];

role_property ::=  PASSWORD = &#39;&lt;Text Literal&gt;&#39;
                 | LOGIN = &lt;Boolean Literal&gt;&#39;
                 | SUPERUSER = &#39;&lt;Boolean Literal&gt;&#39;
</code></pre></div>
<ul>
<li>role_name是一个文本</li>
</ul>
<p>描述：</p>
<ul>
<li>如果role_name不存在，则会引发错误。</li>
</ul>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>cqlsh:example&gt; CREATE ROLE finance;
</code></pre></div>
<div class="highlight"><pre><span></span><code>cqlsh:example&gt; ALTER ROLE finance with LOGIN = true;
</code></pre></div>
<div class="highlight"><pre><span></span><code>cqlsh:example&gt; ALTER ROLE finance with SUPERUSER = true;
</code></pre></div>
<div class="highlight"><pre><span></span><code>cqlsh:example&gt; ALTER ROLE finance with PASSWORD = &#39;jsfp9ajhufans2&#39; AND SUPERUSER = false;
</code></pre></div>
<h4 id="alter-table"><strong>ALTER TABLE</strong></h4>
<p>使用ALTER TABLE语句可以更改现有表的架构或定义。它允许添加、删除或重命名列以及更新表属性。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>alter_table ::= ALTER TABLE table_name alter_operator [ alter_operator ...]

alter_operator ::= add_op | drop_op | rename_op | property_op

add_op ::= ADD column_name column_type [ &#39;,&#39; column_name column_type ...]

drop_op ::= DROP column_name [ &#39;,&#39; column_name ...]

rename_op ::= RENAME column_name TO column_name [ &#39;,&#39; column_name TO column_name ...]

property_op ::= WITH property_name &#39;=&#39; property_literal [ AND property_name &#39;=&#39; property_literal ...]
</code></pre></div>
<ul>
<li>table_name、column_name和property_name是标识符（table_name可以用键空间名称限定）。 </li>
<li>property_tliteral是布尔、文本或映射数据类型。</li>
</ul>
<p>描述：</p>
<ul>
<li>如果关联的键空间中不存在table_name，则会引发错误。 </li>
<li>作为PRIMARY KEY一部分的列不能更改。 </li>
<li>添加列时，表中所有现有行的值默认为null。 </li>
<li>删除列后，表中当前为该列存储的所有值都将被丢弃（如果有的话）。</li>
</ul>
<p>示例：
1）增加新列到表中：</p>
<div class="highlight"><pre><span></span><code>cqlsh:example&gt; CREATE TABLE employees (id INT, name TEXT, salary FLOAT, PRIMARY KEY((id), name));
cqlsh:example&gt; ALTER TABLE employees ADD title TEXT;
cqlsh:example&gt; DESCRIBE TABLE employees;
</code></pre></div>
<p>显示信息如下：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE cycling.employees (
    id int,
    name text,
    salary float,
    title text,
    PRIMARY KEY (id, name)
) WITH CLUSTERING ORDER BY (name ASC)
    AND default_time_to_live = 0
    AND transactions = {&#39;enabled&#39;: &#39;false&#39;};
</code></pre></div>
<p>2）从表中删除一列</p>
<div class="highlight"><pre><span></span><code>cqlsh:example&gt; ALTER TABLE employees DROP salary;
cqlsh:example&gt; DESCRIBE TABLE employees;
</code></pre></div>
<p>显示信息如下：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE cycling.employees (
    id int,
    name text,
    title text,
    PRIMARY KEY (id, name)
) WITH CLUSTERING ORDER BY (name ASC)
    AND default_time_to_live = 0
    AND transactions = {&#39;enabled&#39;: &#39;false&#39;};
</code></pre></div>
<p>3）修改表中的列名</p>
<div class="highlight"><pre><span></span><code>cqlsh:example&gt; ALTER TABLE employees RENAME title TO job_title;
cqlsh:example&gt; DESCRIBE TABLE employees;
</code></pre></div>
<p>显示信息如下：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE cycling.employees (
    id int,
    name text,
    job_title text,
    PRIMARY KEY (id, name)
) WITH CLUSTERING ORDER BY (name ASC)
    AND default_time_to_live = 0
    AND transactions = {&#39;enabled&#39;: &#39;false&#39;};
</code></pre></div>
<p>4）修改表属性</p>
<div class="highlight"><pre><span></span><code>cqlsh:example&gt; ALTER TABLE employees WITH default_time_to_live = 5;
cqlsh:example&gt; DESCRIBE TABLE employees;
</code></pre></div>
<p>显示信息如下：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE cycling.employees (
    id int,
    name text,
    job_title text,
    PRIMARY KEY (id, name)
) WITH CLUSTERING ORDER BY (name ASC)
    AND default_time_to_live = 5
    AND transactions = {&#39;enabled&#39;: &#39;false&#39;};
</code></pre></div>
<h4 id="create-index"><strong>CREATE INDEX</strong></h4>
<p>使用CREATE INDEX语句可以对表创建新索引。它定义了索引名称、索引列以及要包含的其他列。</p>
<div class="highlight"><pre><span></span><code>create_index ::= CREATE [ UNIQUE ] [ DEFERRED ] INDEX
                 [ IF NOT EXISTS ] index_name ON  table_name (
                 partition_key_columns , [ clustering_key_columns ] )
                 [ covering_columns ] [ index_properties ]
                 [ WHERE index_predicate ]

partition_key_columns ::= index_column | ( index_column [ , ... ] )

clustering_key_columns ::= index_column [ , ... ]

index_properties ::= WITH
                     { property_name = property_literal
                       | CLUSTERING ORDER BY (
                         { index_column [ ASC | DESC ] } [ , ... ] ) }
                     [ AND ... ]

index_column ::= column_name | jsonb_attribute

jsonb_attribute ::= column_name [ -&gt; &#39;attribute_name&#39; [ ... ] ] -&gt;&gt; &#39;attribute_name&#39;

covering_columns ::= { COVERING | INCLUDE } ( column_name [ , ... ] )

index_predicate ::= where_expression
</code></pre></div>
<ul>
<li>index_name、table_name、property_name和column_name是标识符。 </li>
<li>table_name可以用键空间名称限定。 </li>
<li>index_name不能用键空间名称限定，因为必须在表的键空间中创建索引。 </li>
<li>property_tliteral是布尔型、文本型或映射数据类型。 </li>
<li>index_column可以是除MAP、SET、LIST、JSONB、USER_DEFINED_TYPE之外的任何数据类型。</li>
</ul>
<p>描述：</p>
<ul>
<li>
<p>如果在要索引的表上没有使用WITH transactions=｛'enabled':true｝子句启用事务，则会引发错误。这是因为辅助索引在内部使用分布式事务来确保在对辅助索引和相关主键的更新中提供ACID保证。</p>
</li>
<li>
<p>如果index_name已存在于关联的键空间中，则会引发错误，除非使用了IF NOT EXISTS选项。</p>
</li>
</ul>
<p>1）强一致性
注意： 
只有当您的问题没有其他解决方案时，才选择用户强制的一致性。用户强制的一致性需要大量的用户努力来保持索引和表的同步。</p>
<p>索引要求在表上启用事务。对于在不启用事务的情况下创建表的情况，consistency_level必须设置为user_enforced，例如</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE orders (id int PRIMARY KEY, warehouse int);
CREATE INDEX ON orders (warehouse)
      WITH transactions = { &#39;enabled&#39; : false, &#39;consistency_level&#39; : &#39;user_enforced&#39; };
</code></pre></div>
<p>注意：
同步表和索引 
在使用未启用事务的索引时，应用程序有责任重试任何插入/更新/删除失败，以确保表和索引同步。 
此外，如果索引是在数据添加到表后创建的，则根据disable_index_backfill_for_non_txn_tables标志的设置，索引可能不会自动回填。如果设置为true，则用户有责任使用bm-admin backfill_indexes_for_table命令触发回填，该命令将在大约一分钟的小延迟后触发回填。此延迟由index_backfill_upperbound_for_user_enforced_txn_duration_ms标志控制。</p>
<p>2）分区键
分区键是必需的，它定义了将索引拆分为多个分区。</p>
<p>3）聚集键</p>
<ul>
<li>聚集键是可选的，它定义了分区内索引行的顺序。</li>
<li>默认排序为升序（ASC），但可以使用CLUSTERING ORDER BY属性将每个集群列设置为升序或降序。 </li>
<li>在index_columns中未显式索引的表的任何主键列都将作为集群列隐式添加到索引中。这是必要的，以便对表的整个主键进行索引。</li>
</ul>
<p>4）index_properties</p>
<ul>
<li>CLUSTERING ORDER BY属性可用于单独设置每个集群列的顺序（默认为ASC）。</li>
<li>tiles=<num>属性指定要用于指定BCQL索引的分片数量。设置此属性将覆盖--bm_num_shards_per_tserver选项中的值。</li>
<li>使用AND运算符可以使用多个索引属性。</li>
<li>使用default_time_to_live在索引上设置TTL时，请确保TTL值与表的TTL值相同。如果它们不同，则会导致索引和表不同步，并导致意外行为。</li>
</ul>
<p>5）包含列</p>
<ul>
<li>包含列是可选的表列，其值除了存储在表中之外，还会复制到索引中。当索引中包含其他列时，它们可以用于直接响应索引中的查询，而不必查询表。</li>
<li>以下内容无法添加到索引的包含列中：表的静态列、表达式以及具有以下类型的表列：frozen、map、set、list、tuple、jsonb和用户自定义。</li>
</ul>
<p>6）唯一索引</p>
<ul>
<li>唯一索引不允许在索引列中插入重复的值。它可用于确保索引列值的唯一性。</li>
</ul>
<p>7）延迟索引
目前，每个创建的索引都会启动一个“索引回填”作业。对于创建表并添加多个索引的情况，需要多次扫描主表以填充每个索引。这是不必要的，也可能导致单点触摸和多点触摸块缓存算法的问题。
在创建了一组延迟回填的索引后，可以通过以下方式之一触发整批索引（在同一表上）的回填作业：</p>
<p>创建一个不延迟的新索引：</p>
<div class="highlight"><pre><span></span><code>CREATE DEFERRED INDEX idx_1 on table_name(col_1);        // No backfill launched.
CREATE DEFERRED INDEX idx_2 on table_name(col_2);        // No backfill launched.
CREATE DEFERRED INDEX idx_9 on table_name(col_9);        // No backfill launched.

// To launch backfill ...
CREATE INDEX idx_10 on table_name(col_10);   // Will launch backfill for idx_10 and
                                                    // all deferred indexes idx_1 .. idx_9
                                                    // on the same table viz: table_name.
</code></pre></div>
<p>使用bm-admin为表上的延迟索引启动回填。</p>
<div class="highlight"><pre><span></span><code>./bm-admin -master_addresses &lt;ip:port&gt;  backfill_indexes_for_table cql.cycling table_name
</code></pre></div>
<p>使用Mserver的--defer_index_backfill 标志强制所有索引为DEFERRED，并运行bm-admin backfill_indexes_for_table来回填索引</p>
<p>8）部分索引</p>
<ul>
<li>如果指定了WHERE子句，则仅对满足index_predicate的行进行索引。</li>
<li>index_predicate可以在以下数据类型的列上具有子表达式：TINYINT、SMALLINT、INT/INTEGER、BIGINT、VARINT、BOOLEAN和TEXT以及以下运算符（如适用）：=、！=、&gt;、&lt;、&gt;=、&lt;=。</li>
<li>部分索引可以是唯一的。UNIQUE部分索引强制执行约束，即对于每个可能的索引列元组，表中只允许有一行满足index_predicate。</li>
<li>如果SELECT语句的where _expression=&gt;（逻辑上意味着）index_predicate，则SELECT查询可以使用部分索引进行扫描。</li>
</ul>
<p>注意：</p>
<ul>
<li>
<p>如果有更好的查询计划，也可能不会选择部分索引。</p>
</li>
<li>
<p>如果index_predicate的所有子表达式在where_expression中存在，则逻辑含义成立。例如，假设where_expression=A AND B AND C，index_predicate_1=A  AND  B，index_predicate_2=A AND  B AND D，index_predicate_3=A AND B AND  C AND D。那么其中where_expression仅表示index_prediate_1。</p>
</li>
<li>
<p>目前，在检查逻辑含义时，没有考虑有效的数学含义。例如，即使where_expression=x&gt;5和index_predicate =x&gt;4，SELECT查询也不会使用索引进行扫描。这是因为两个子表达式x&gt;5和x&gt;4不同。</p>
</li>
<li>
<p>当使用预编译的语句时，逻辑检查（决定部分索引是否可用）将只考虑where _expression中没有绑定变量的子表达式。这是因为查询计划是在执行之前（即预编译）决定的。</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code>CREATE TABLE orders (customer_id INT,
                                    order_date TIMESTAMP,
                                    product JSONB,
                                    warehouse_id INT,
                                    amount DOUBLE,
                                    PRIMARY KEY ((customer_id), order_date))
                WITH transactions = { &#39;enabled&#39; : true };

CREATE INDEX idx ON orders (warehouse_id)
                WHERE warehouse_id &lt; 100;

EXPLAIN SELECT product FROM orders
                WHERE warehouse_id &lt; 100 AND order_date &gt;= ?; // Idx can be used
</code></pre></div>
<div class="highlight"><pre><span></span><code> QUERY PLAN
------------------------------------------
 Index Scan using temp.idx on temp.orders
   Filter: (order_date &gt;= :order_date)
</code></pre></div>
<div class="highlight"><pre><span></span><code>EXPLAIN SELECT product FROM orders
                WHERE warehouse_id &lt; ? and order_date &gt;= ?; // Idx cannot be used
</code></pre></div>
<div class="highlight"><pre><span></span><code> QUERY PLAN
--------------------------------------------------------------------------
 Seq Scan on temp.orders
   Filter: (warehouse_id &lt; :warehouse_id) AND (order_date &gt;= :order_date)
</code></pre></div>
<ul>
<li>如果没有部分索引，我们不允许在SELECT的where表达式中的同一列上同时使用多个运算符组合，例如：where v1！=NULL and v1＝5。但，若有一个部分索引包含SELECT的where表达式的某些子句，则可能支持两个或多个不支持在一起的运算符。</li>
</ul>
<div class="highlight"><pre><span></span><code>EXPLAIN SELECT product FROM orders
                WHERE warehouse_id != NULL AND warehouse_id = ?;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SyntaxException: Invalid CQL Statement. Illogical condition for where clause
EXPLAIN SELECT product from orders where warehouse_id != NULL and warehouse_id = ?;
                                                                  ^^^^^^^^^^^^
 (ql error -12)
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE INDEX warehouse_idx ON orders (warehouse_id)
                WHERE warehouse_id != NULL;
EXPLAIN SELECT product FROM orders
                WHERE warehouse_id != NULL AND warehouse_id = ?; // warehouse_idx can be used
</code></pre></div>
<div class="highlight"><pre><span></span><code> QUERY PLAN
----------------------------------------------------
 Index Scan using temp.warehouse_idx on temp.orders
   Key Conditions: (warehouse_id = :warehouse_id)
</code></pre></div>
<p>实例：
1）创建要索引的表
'customer_id' 是分区列， 'order_date' 是分簇列。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE orders (customer_id INT,
                                    order_date TIMESTAMP,
                                    product JSONB,
                                    warehouse_id INT,
                                    amount DOUBLE,
                                    PRIMARY KEY ((customer_id), order_date))
                WITH transactions = { &#39;enabled&#39; : true };
</code></pre></div>
<p>2）创建基于order_date列上查询的索引</p>
<div class="highlight"><pre><span></span><code>CREATE INDEX orders_by_date ON orders (order_date) INCLUDE (amount);
</code></pre></div>
<p>3）创建基于JSONB 属性的product-&gt;&gt;'name'查询的索引</p>
<div class="highlight"><pre><span></span><code>CREATE INDEX product_name ON orders (product-&gt;&gt;&#39;name&#39;) INCLUDE (amount);
</code></pre></div>
<p>4）创建基于warehouse_id列上查询的索引</p>
<div class="highlight"><pre><span></span><code>CREATE INDEX orders_by_warehouse ON orders (warehouse_id, order_date) INCLUDE (amount);
</code></pre></div>
<p>5）导入数据</p>
<div class="highlight"><pre><span></span><code>INSERT INTO orders (customer_id, order_date, product, warehouse_id, amount) VALUES (1001, &#39;2018-01-10&#39;, &#39;{ &quot;name&quot;:&quot;desk&quot; }&#39;, 107, 100.30);
INSERT INTO orders (customer_id, order_date, product, warehouse_id, amount) VALUES (1002, &#39;2018-01-11&#39;, &#39;{ &quot;name&quot;:&quot;chair&quot; }&#39;, 102, 50.45);
INSERT INTO orders (customer_id, order_date, product, warehouse_id, amount) VALUES (1001, &#39;2018-04-09&#39;, &#39;{ &quot;name&quot;:&quot;pen&quot; }&#39;, 102, 20.25);
INSERT INTO orders (customer_id, order_date, product, warehouse_id, amount) VALUES (1003, &#39;2018-04-09&#39;, &#39;{ &quot;name&quot;:&quot;pencil&quot; }&#39;, 108, 200.80);
</code></pre></div>
<p>6）通过分区键customer_id查询</p>
<div class="highlight"><pre><span></span><code>SELECT SUM(amount) FROM orders WHERE customer_id = 1001 AND order_date &gt;= &#39;2018-01-01&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>  sum(amount)
----------------
      120.55
</code></pre></div>
<p>7）按索引orders_by_date中的分区列order_date查询</p>
<div class="highlight"><pre><span></span><code>SELECT SUM(amount) FROM orders WHERE order_date = &#39;2018-04-09&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> sum(amount)
-------------
      221.05
</code></pre></div>
<p>8）按product_name索引中的分区列product-&gt;&gt;'name'进行查询</p>
<div class="highlight"><pre><span></span><code> SELECT SUM(amount) FROM orders WHERE product-&gt;&gt;&#39;name&#39; = &#39;desk&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> sum(amount)
-------------
      100.30
</code></pre></div>
<p>9）按orders_by_warehouse索引中的分区列warehouse_id进行查询</p>
<div class="highlight"><pre><span></span><code> SELECT SUM(amount) FROM orders WHERE warehouse_id = 102 AND order_date &gt;= &#39;2018-01-01&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> sum(amount)
-------------
        70.7
</code></pre></div>
<p>10）创建带有唯一索引的表</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE emp (enum INT primary key,
                                 lastname VARCHAR,
                                 firstname VARCHAR,
                                 userid VARCHAR)
               WITH transactions = { &#39;enabled&#39; : true };
CREATE UNIQUE INDEX emp_by_userid ON emp (userid);
</code></pre></div>
<p>11）插入数据</p>
<div class="highlight"><pre><span></span><code>INSERT INTO emp (enum, lastname, firstname, userid) VALUES (1001, &#39;Smith&#39;, &#39;John&#39;, &#39;jsmith&#39;);
INSERT INTO emp (enum, lastname, firstname, userid) VALUES (1002, &#39;Smith&#39;, &#39;Jason&#39;, &#39;jsmith&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>InvalidRequest: Error from server: code=2200 [Invalid query] message=&quot;SQL error: Execution Error. Duplicate value disallowed by unique index emp_by_userid
INSERT INTO emp (enum, lastname, firstname, userid)
       ^^^^
VALUES (1002, &#39;Smith&#39;, &#39;Jason&#39;, &#39;jsmith&#39;);
 (error -300)&quot;
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO emp (enum, lastname, firstname, userid) VALUES (1002, &#39;Smith&#39;, &#39;Jason&#39;, &#39;jasmith&#39;);
SELECT * FROM emp;
</code></pre></div>
<div class="highlight"><pre><span></span><code> enum | lastname | firstname | userid
------+----------+-----------+---------
 1002 |    Smith |     Jason | jasmith
 1001 |    Smith |      John |  jsmith
</code></pre></div>
<p>12）创建指定分片的索引</p>
<p>您可以将CREATE INDEX语句与with tiles=<num>子句一起使用，以指定索引的分片数。这对于根据需求放大或缩小索引非常有用。例如，对于较小或部分索引，拥有大量碎片（分片）可能是浪费。在这种情况下，您可以使用它来减少为索引创建的分片的数量。同样，对于非常大的索引，可以使用此语句将索引预拆分为大量碎片，以提高性能。</p>
<p>请注意，AiSQL 默认情况下会预拆分bm_num_shards_per_tserver*num_of_tserver碎片中的索引。此子句可用于在每个索引的基础上覆盖该设置。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE tracking (id int PRIMARY KEY, a TEXT) WITH transactions = { &#39;enabled&#39; : true };
CREATE INDEX my_indx ON tracking(a) WITH tiles = 10;
</code></pre></div>
<h4 id="create-keyspace"><strong>CREATE KEYSPACE</strong></h4>
<p>使用CREATE KEYSPACE语句创建一个keyspace ，用作数据库对象（如表或类型）的分组机制。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>create_keyspace ::= CREATE { KEYSPACE | SCHEMA } [ IF NOT EXISTS ] keyspace_name
                       [ WITH REPLICATION &#39;=&#39; &#39;{&#39; keyspace_property &#39;}&#39;]
                       [ AND DURABLE_WRITES &#39;=&#39; { true | false } ]

keyspace_property ::= property_name = property_value
</code></pre></div>
<ul>
<li>keyspace_name和property_name是标识符。</li>
<li>property_value是布尔、文本或映射数据类型。</li>
</ul>
<p>描述：如果指定的keyspace_name已经存在，则会引发错误，除非使用存在IF NOT EXISTS选项。语法中支持Cassandra的CQL keyspace 属性，但在内部不起作用（使用AiSQL 默认值）。 </p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>cqlsh&gt;CREATE KEYSPACE example;
</code></pre></div>
<div class="highlight"><pre><span></span><code>cqlsh&gt;DESCRIBE KEYSPACES;
</code></pre></div>
<div class="highlight"><pre><span></span><code>example  system_schema  system_auth  system
</code></pre></div>
<div class="highlight"><pre><span></span><code>cqlsh&gt;DESCRIBE example;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE KEYSPACE example WITH REPLICATION = {&#39;class&#39;: &#39;SimpleStrategy&#39;, &#39;replication_factor&#39;: &#39;3&#39;} AND DURABLE_WRITES = true;
</code></pre></div>
<div class="highlight"><pre><span></span><code>cqlsh&gt;CREATE SCHEMA example;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SQL error: Keyspace Already Exists
CREATE SCHEMA example;
^^^^^^
</code></pre></div>
<h4 id="create-role"><strong>CREATE ROLE</strong></h4>
<p>使用CREATE ROLE语句创建一个新角色，该角色用于向BCQL进行身份验证，并作为一组权限用于限制对数据库对象的操作。请注意，用户是启用登录的特定角色。BCQL中没有显式的CREATE USER命令。
通过将dbServer标志--use_cassandra_authentication设置为true，可以启用此语句。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>create_role ::= CREATE ROLE [ IF NOT EXISTS ] role_name 
                [ WITH role_property [ AND ... ] ]

role_property ::=  PASSWORD = &lt;Text Literal&gt;
                 | LOGIN = &lt;Boolean Literal&gt;
                 | SUPERUSER = &lt;Boolean Literal&gt;
</code></pre></div>
<ul>
<li>role_name是一个文本</li>
</ul>
<p>描述：</p>
<ul>
<li>如果角色名称已经存在，则会引发错误，除非使用了IF NOT EXISTS选项。 </li>
<li>默认情况下，角色既不具有LOGIN权限，也不具有SUPERUSER状态。 </li>
<li>状态为SUPERUSER的角色拥有数据库中所有对象的所有权限，即使这些权限没有明确授予。 </li>
<li>只有具有超级用户状态的角色才能创建另一个超级用户角色。 </li>
<li>具有LOGIN权限的角色可以用于对CQL进行身份验证。 </li>
<li>只有对所有角色具有CREATE权限或具有SUPERUSER状态的客户端才能创建另一个角色。</li>
</ul>
<p>示例：
1）创建一个没有属性的简单角色</p>
<div class="highlight"><pre><span></span><code>CREATE ROLE role1;
</code></pre></div>
<p>2）创建一个具有SUPERUSER的角色</p>
<div class="highlight"><pre><span></span><code>CREATE ROLE role2 WITH SUPERUSER = true;
</code></pre></div>
<p>3）创建一个能够登录的常规用户
您可以创建一个具有登录权限的常规用户，如下所示。请注意，SUPERUSER设置为false。</p>
<div class="highlight"><pre><span></span><code>CREATE ROLE role3 WITH SUPERUSER = false AND LOGIN = true AND PASSWORD = &#39;aid8134&#39;;
</code></pre></div>
<h4 id="create-table"><strong>CREATE TABLE</strong></h4>
<p>使用CREATE TABLE语句在键空间中创建一个新表。它定义了表名、列名和类型、主键和表属性。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>create_table ::= CREATE TABLE [ IF NOT EXISTS ] table_name
                     &#39;(&#39; table_element [ &#39;,&#39; table_element ...] &#39;)&#39;
                     [WITH table_properties];

table_element ::= table_column | table_constraints

table_column ::= column_name column_type [ column_constraint ...]

column_constraint ::= PRIMARY KEY | STATIC

table_constraints ::= PRIMARY KEY &#39;(&#39; partition_key_column_list clustering_key_column_list &#39;)&#39;

partition_key_column_list ::= &#39;(&#39; column_name [ &#39;,&#39; column_name ...] &#39;)&#39; | column_name

clustering_key_column_list ::= [ &#39;,&#39; column_name ...]

table_properties = [table_options]
                    [[AND] CLUSTERING ORDER BY &#39;(&#39; column_ordering_property [ &#39;,&#39; column_ordering_property ...] &#39;)&#39;]
                    [[AND] COMPACT STORAGE]

table_options = property_name &#39;=&#39; property_literal [AND property_name &#39;=&#39; property_literal ...]

column_ordering_property ::= column_name [ ASC | DESC ]
</code></pre></div>
<ul>
<li>table_name、column_name和property_name是标识符（table_name可以用键空间名称限定）。 </li>
<li>property_tliteral是布尔型、文本型或map 数据类型的文本。</li>
</ul>
<p>描述：</p>
<ul>
<li>如果关联的键空间中已经存在table_name，则会引发错误，除非使用了IF NOT EXISTS选项。</li>
</ul>
<p>主键：</p>
<ul>
<li>主键必须在column_constraint或table_constraint中定义，但不能同时在两者中定义。</li>
<li>表中的每一行都由其主键唯一标识。</li>
<li>主键列可以是分区列，也可以是聚类列（如下所述）。</li>
<li>如果主键设置为列约束，则该列是分区列，并且没有聚类列。</li>
<li>如果将主键设置为表约束，则：</li>
<li>分区列由主键列表中的第一个条目给出：嵌套列列表（如果给定），否则为第一列。</li>
<li>聚类列是主键列表中的其余列（如果有）。</li>
<li>类型MAP, SET, LIST, JSONB, USER_DEFINED_TYPE不能在主键中使用。</li>
</ul>
<p>分区键：</p>
<ul>
<li>分区键是必需的，它定义了将行拆分为分区。</li>
<li>共享相同分区键的行构成一个分区，并将位于同一副本节点上。
  聚类键：</li>
<li>聚类键是可选的，用于定义分区中行的顺序。</li>
<li>默认顺序是升序（ASC），但可以使用 table 属性CLUSTERING ORDER BY将每个聚类列设置为升序或降序。</li>
</ul>
<p>静态列：</p>
<ul>
<li>声明为STATIC 的列将对分区中的所有行（即具有相同分区键的行）共享相同的值。</li>
<li>主键中的列不能是静态的。</li>
<li>没有聚类列的表不能有静态列（如果没有聚类列，主键和分区键是相同的，因此静态列将与常规列相同）。</li>
</ul>
<p>table_properties：</p>
<ul>
<li>该CLUSTERING ORDER BY 属性可用于单独设置每个聚类列的排序（默认值为ASC ）。</li>
<li>该default_time_to_live属性设置表的默认过期时间 （TTL），以秒为单位。可以通过为单个行设置 TTL 来覆盖过期时间。默认值为0 ，表示行不会过期。</li>
<li>该transactions 属性指定是否在表中启用分布式事务。若要启用分布式事务，请使用 transactions = { 'enabled' : true }</li>
<li>使用AND运算符可使用多个表属性。</li>
<li>语法中允许使用其他 BCQL 表属性，但目前在内部被忽略（不起作用）。</li>
<li>该tiles= <num>属性指定要用于BCQL表的分片数。设置此属性将覆盖--bm_num_shards_per_tserver选择。</li>
<li>COMPACT STORAGE仅用于与 Cassandra 的语法兼容性。它不会影响底层存储。</li>
</ul>
<p>示例：
1）使用列约束定义主键
“user_id”是分区列，没有聚类列。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE users(user_id INT PRIMARY KEY, full_name TEXT);
</code></pre></div>
<p>2）使用表约束定义主键
“supplier_id”和“device_id”是分区列，“model_year”是聚类列。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE devices(supplier_id INT,
                     device_id INT,
                     model_year INT,
                     device_name TEXT,
                     PRIMARY KEY((supplier_id, device_id), model_year));
</code></pre></div>
<p>3）使用列约束定义静态列
您可以按如下方式执行此操作：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE items(supplier_id INT,
                    item_id INT,
                    supplier_name TEXT STATIC,
                    item_name TEXT,
                    PRIMARY KEY((supplier_id), item_id));
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO items(supplier_id, item_id, supplier_name, item_name) VALUES (1, 1, &#39;Unknown&#39;, &#39;Wrought Anvil&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO items(supplier_id, item_id, supplier_name, item_name) VALUES (1, 2, &#39;Acme Corporation&#39;, &#39;Giant Rubber Band&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM items;
</code></pre></div>
<div class="highlight"><pre><span></span><code> supplier_id | item_id | supplier_name    | item_name
-------------+---------+------------------+-------------------
           1 |       1 | Acme Corporation |     Wrought Anvil
           1 |       2 | Acme Corporation | Giant Rubber Band
</code></pre></div>
<p>4）使用 table 属性定义聚类列的顺序（升序或降序）
时间戳列“ts”将按降序存储（最新值在前）。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE user_actions(user_id INT,
                          ts TIMESTAMP,
                          action TEXT,
                          PRIMARY KEY((user_id), ts))
                          WITH CLUSTERING ORDER BY (ts DESC);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO user_actions(user_id, ts, action) VALUES (1, &#39;2000-12-2 12:30:15&#39;, &#39;log in&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO user_actions(user_id, ts, action) VALUES (1, &#39;2000-12-2 12:30:25&#39;, &#39;change password&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO user_actions(user_id, ts, action) VALUES (1, &#39;2000-12-2 12:30:35&#39;, &#39;log out&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM user_actions;
</code></pre></div>
<div class="highlight"><pre><span></span><code> user_id | ts                              | action
---------+---------------------------------+-----------------
       1 | 2000-12-02 19:30:35.000000+0000 |         log out
       1 | 2000-12-02 19:30:25.000000+0000 | change password
       1 | 2000-12-02 19:30:15.000000+0000 |          log in
</code></pre></div>
<p>5）使用 table 属性定义行的默认过期时间
您可以按如下方式执行此操作：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sensor_data(sensor_id INT,
                         ts TIMESTAMP,
                         value DOUBLE,
                         PRIMARY KEY((sensor_id), ts))
                         WITH default_time_to_live = 5;
</code></pre></div>
<p>在时间 T 处首次插入（行在 T + 5 处过期）。</p>
<div class="highlight"><pre><span></span><code>INSERT INTO sensor_data(sensor_id, ts, value) VALUES (1, &#39;2017-10-1 11:22:31&#39;, 3.1);
</code></pre></div>
<p>3 秒后第二次插入（行在 T + 8 处过期）。</p>
<div class="highlight"><pre><span></span><code>INSERT INTO sensor_data(sensor_id, ts, value) VALUES (2, &#39;2017-10-1 11:22:34&#39;, 3.4);
</code></pre></div>
<p>3 秒后（时间 T + 6）首次选择。</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sensor_data;
</code></pre></div>
<div class="highlight"><pre><span></span><code> sensor_id | ts                              | value
-----------+---------------------------------+-------
         2 | 2017-10-01 18:22:34.000000+0000 |   3.4
</code></pre></div>
<p>3 秒后（时间 T + 9）第二次选择。</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sensor_data;
</code></pre></div>
<div class="highlight"><pre><span></span><code> sensor_id | ts | value
-----------+----+-------
</code></pre></div>
<p>6）创建一个指定分片数量的表
可以使用带有子句的语句来指定表的分片数。这对于根据要求扩展或缩减表非常有用。例如，对于较小的静态表，拥有大量分片可能会造成浪费。在这种情况下，您可以使用它来减少为表创建的分片数量。同样，对于非常大的表，您可以使用此语句将表预拆分为大量分片，以提高性能。CREATE TABLEWITH tiles= <num></p>
<p>请注意，AiSQL 默认情况下会将表预拆分为分片。此子句可用于基于每个表覆盖该设置。bm_num_shards_per_tserver * num_of_tserver</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE tracking (id int PRIMARY KEY) WITH tiles = 10;
</code></pre></div>
<p>如果为这些表创建索引，还可以指定索引的分片数。</p>
<p>还可以使用AND 来添加其他表属性，如本示例所示。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE tracking (id int PRIMARY KEY) WITH tiles = 10 AND transactions = { &#39;enabled&#39; : true };
</code></pre></div>
<h4 id="create-type"><strong>CREATE TYPE</strong></h4>
<p>使用CREATE TYPE语句在键空间中创建新的用户定义数据类型。它定义用户定义类型的名称及其字段的名称和数据类型。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>create_type ::= CREATE TYPE [ IF NOT EXISTS ] type_name
                    (field_name field_type [ &#39;,&#39; field_name field_type ...]);
</code></pre></div>
<ul>
<li>type_name和field_name是标识符（type_name可以用键空间名称限定）。 </li>
<li>field_type是一种数据类型。</li>
</ul>
<p>描述：</p>
<ul>
<li>如果指定的type_name已存在于关联的键空间中，则会引发错误，除非使用了IF NOT EXISTS选项。 </li>
<li>每个field_name都必须是唯一的（一个类型不能有两个同名字段）。 </li>
<li>每个field_type都必须是非参数类型或frozen 类型。</li>
</ul>
<p>示例：</p>
<p>集合类型必须冻结才能在用户定义的类型中使用。</p>
<div class="highlight"><pre><span></span><code>CREATE TYPE person(first_name TEXT, last_name TEXT, emails FROZEN&lt;LIST&lt;TEXT&gt;&gt;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>DESCRIBE TYPE person;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE TYPE example.person (
    first_name text,
    last_name text,
    emails frozen&lt;list&lt;text&gt;&gt;
);
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE TABLE employees(employee_id INT PRIMARY KEY, employee person);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(employee_id, employee) VALUES (1, {first_name : &#39;John&#39;, last_name : &#39;Doe&#39;, emails : [&#39;jdoe@example.com&#39;]});
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> employee_id | employee
-------------+---------------------------------------------------------------------------
1 | {first_name: &#39;John&#39;, last_name: &#39;Doe&#39;, emails: [&#39;jdoe@example.com&#39;]}
</code></pre></div>
<h4 id="drop-index"><strong>DROP INDEX</strong></h4>
<p>使用DROP INDEX语句从数据库中删除索引及其所有数据。</p>
<div class="highlight"><pre><span></span><code>drop_index ::= DROP INDEX [ IF EXISTS ] index_name;
</code></pre></div>
<ul>
<li>index_name是一个标识符（可能使用键空间名称限定）</li>
</ul>
<p>描述：</p>
<ul>
<li>如果指定的index_name不存在，则会引发错误，除非存在IF EXISTS选项。 </li>
<li>与index_name相关联的对象（如预编译语句）最终将在drop语句完成后失效。</li>
</ul>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE users(id INT PRIMARY KEY, name TEXT) WITH transactions = { &#39;enabled&#39; : true };
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE INDEX users_by_name ON users(name);
</code></pre></div>
<div class="highlight"><pre><span></span><code>DROP INDEX users_by_name;
</code></pre></div>
<h4 id="drop-keyspace"><strong>DROP</strong> <strong>KEYSPACE</strong></h4>
<p>使用DROP KEYSPACE语句从系统中删除键空间</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>drop_keyspace ::= DROP { KEYSPACE | SCHEMA } [ IF EXISTS ] keyspace_name;
</code></pre></div>
<ul>
<li>keyspace_name 是标识符。</li>
</ul>
<p>描述：</p>
<ul>
<li>如果指定的keyspace_name不存在，则会引发错误，除非存在IF EXISTS选项。 </li>
<li>如果指定的键空间不是空的（包含表或类型），则会引发错误。</li>
</ul>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE KEYSPACE example;
</code></pre></div>
<div class="highlight"><pre><span></span><code>DROP KEYSPACE example;
</code></pre></div>
<div class="highlight"><pre><span></span><code>DROP KEYSPACE IF EXISTS example;
</code></pre></div>
<h4 id="drop-role"><strong>DROP ROLE</strong></h4>
<p>使用DROP ROLE语句可以删除现有角色。 
通过将dbServer标志use_cassandra_authentication设置为true，可以启用此语句</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>drop_role ::=  DROP ROLE [ IF EXISTS ] role_name
</code></pre></div>
<ul>
<li>role_name是文本标识符。</li>
</ul>
<p>描述：</p>
<ul>
<li>如果role_name不存在，除非存在IF EXISTS 选项，则会引发错误。 </li>
<li>只有具有超级用户状态的角色才能删除另一个超级用户角色。 </li>
<li>只有对ALL ROLES或指定的role_name具有DROP权限或具有SUPERUSER状态的客户端才能删除另一个角色。</li>
</ul>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>DROP ROLE role1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>DROP ROLE IF EXISTS role2;
</code></pre></div>
<h4 id="drop-table"><strong>DROP TABLE</strong></h4>
<p>使用DROP TABLE语句从数据库中删除表及其所有数据</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>drop_table ::= DROP TABLE [ IF EXISTS ] table_name;
</code></pre></div>
<ul>
<li>table_name是一个标识符（可能使用键空间名称限定）。</li>
</ul>
<p>描述：</p>
<ul>
<li>如果指定的表名称不存在，则会引发错误，除非存在IF EXISTS选项。 </li>
<li>与table_name相关联的对象（如预编译语句）最终将在drop语句完成后失效。</li>
</ul>
<div class="highlight"><pre><span></span><code>CREATE TABLE users(id INT PRIMARY KEY, name TEXT);
</code></pre></div>
<div class="highlight"><pre><span></span><code>DROP TABLE users;
</code></pre></div>
<h4 id="drop-type"><strong>DROP TYPE</strong></h4>
<p>使用DROP TYPE语句可以删除现有的用户定义数据类型。</p>
<div class="highlight"><pre><span></span><code>drop_type ::= DROP TYPE [ IF EXISTS ] type_name;
</code></pre></div>
<ul>
<li>type_name是一个标识符（可能使用键空间名称限定）。</li>
</ul>
<p>描述：</p>
<ul>
<li>如果指定的type_name不存在，则会引发错误，除非使用了IF EXISTS选项。 </li>
<li>如果用户定义的type_name当前正在表或其他类型中使用，则无法删除该类型。</li>
</ul>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TYPE person(first_name TEXT, last_name TEXT, email TEXT);
</code></pre></div>
<div class="highlight"><pre><span></span><code>DROP TYPE person;
</code></pre></div>
<h4 id="grant-permission"><strong>GRANT PERMISSION</strong></h4>
<p>使用GRANT PERMISSION语句向角色授予权限（或所有可用权限）。 
创建数据库对象（键空间、表或角色）时，将自动且明确地向创建该对象的角色授予与该对象相关的所有权限。 
通过将dbServer标志--use_cassandra_authentication设置为true，可以启用此语句。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>grant_permission := GRANT all_permission | permission ON resource TO role_name;
all_permissions := ALL [ PERMISSIONS ]
permission :=  ( CREATE | ALTER | DROP | SELECT | MODIFY | AUTHORIZE | DESCRIBE | EXECUTE ) [ PERMISSION ]
resource := ALL ( KEYSPACES | ROLES ) | KEYSPACE keyspace_name | [ TABLE ] table_name | ROLE role_name;
</code></pre></div>
<ul>
<li>keyspace_name、table_name和role_name是文本标识符（table_name可以用keyspace名称限定）。</li>
</ul>
<p>描述：
必须对所有角色或语句中使用的角色授予AUTHORIZE权限。否则，将返回未经授权的错误。</p>
<p>权限：
本节介绍对数据库对象执行操作所需的权限（由ALTER、AUTHORIZE、CREATE、DESCRIBE、DROP、MODIFY和SELECT表示）。可以对特定对象（由资源KEYSPACE、TABLE和ROLE表示）或整个对象组（由资源ALL KEYSPACES和ALL ROLES表示）授予权限。某些权限是隐式授予的，这意味着您在查询 system_auth.role_permissions表时永远不会看到它们列出。隐含授予的权限遵循以下规则：</p>
<ul>
<li>对ALL KEYSPACES 授予的任何权限都会隐式授予数据库中的每个键空间和表。 </li>
<li>对特定KEYSPACE 授予的任何权限都隐式授予该键空间中的任何表。 </li>
<li>对ALL ROLES 授予的任何权限都会隐式授予每个角色。</li>
</ul>
<p>对数据库对象执行特定操作所需的权限：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>权限</th>
<th>资源</th>
</tr>
</thead>
<tbody>
<tr>
<td>ALTER KEYSPACE</td>
<td>ALTER</td>
<td>ALL KEYSPACES, 或KEYSPACE</td>
</tr>
<tr>
<td>ALTER ROLE</td>
<td>ALTER</td>
<td>ALL ROLES, 或 ROLE</td>
</tr>
<tr>
<td>ALTER TABLE</td>
<td>ALTER</td>
<td>ALL KEYSPACES, KEYSPACE, 或TABLE</td>
</tr>
<tr>
<td>CREATE KEYSPACE</td>
<td>CREATE</td>
<td>ALL KEYSPACES</td>
</tr>
<tr>
<td>CREATE ROLE</td>
<td>CREATE</td>
<td>ALL ROLES</td>
</tr>
<tr>
<td>CREATE TABLE</td>
<td>CREATE</td>
<td>ALL KEYSPACES, KEYSPACE</td>
</tr>
<tr>
<td>DROP KEYSPACE</td>
<td>DROP</td>
<td>ALL KEYSPACES, 或KEYSPACE</td>
</tr>
<tr>
<td>DROP ROLE</td>
<td>DROP</td>
<td>ALL ROLES, 或ROLE</td>
</tr>
<tr>
<td>DROP TABLE</td>
<td>DROP</td>
<td>ALL KEYSPACES, KEYSPACE, 或TABLE</td>
</tr>
<tr>
<td>GRANT PERMISSION 或REVOKE PERMISSION on ALL KEYSPACES</td>
<td>AUTHORIZE</td>
<td>ALL KEYSPACES</td>
</tr>
<tr>
<td>GRANT PERMISSION 或REVOKE PERMISSION on ALL ROLES</td>
<td>AUTHORIZE</td>
<td>ALL ROLES</td>
</tr>
<tr>
<td>GRANT PERMISSION 或REVOKE PERMISSION on a keyspace</td>
<td>AUTHORIZE</td>
<td>ALL KEYSPACES, 或KEYSPACE</td>
</tr>
<tr>
<td>GRANT PERMISSION 或REVOKE PERMISSION on a role</td>
<td>AUTHORIZE</td>
<td>ALL ROLES, 或ROLE</td>
</tr>
<tr>
<td>GRANT PERMISSION 或REVOKE PERMISSION on a table</td>
<td>AUTHORIZE</td>
<td>ALL KEYSPACES, KEYSPACE, 或TABLE</td>
</tr>
<tr>
<td>GRANT ROLE 或REVOKE ROLE</td>
<td>AUTHORIZE</td>
<td>ALL ROLES, 或ROLE</td>
</tr>
<tr>
<td>INSERT, UPDATE, DELETE, 或TRUNCATE</td>
<td>MODIFY</td>
<td>ALL KEYSPACES, KEYSPACE, 或TABLE</td>
</tr>
<tr>
<td>SELECT</td>
<td>SELECT</td>
<td>ALL KEYSPACES, KEYSPACE, 或TABLE</td>
</tr>
</tbody>
</table>
<p>示例：
授予表的MODIFY 权限，以便角色qa可以将行插入表中</p>
<div class="highlight"><pre><span></span><code>GRANT MODIFY ON TABLE performance_tests.metrics TO qa;
</code></pre></div>
<p>对表授予SELECT权限，以便角色qa可以读取该表</p>
<div class="highlight"><pre><span></span><code>GRANT SELECT ON performance_tests.metrics TO qa;
</code></pre></div>
<p>对ALL KEYSPACES授予CREATE权限，以便角色tests 可以创建新的键空间</p>
<div class="highlight"><pre><span></span><code>GRANT CREATE ON ALL KEYSPACES TO tests;
</code></pre></div>
<h4 id="grant-role"><strong>GRANT ROLE</strong></h4>
<p>使用GRANT ROLE语句将角色的权限和SUPERUSER状态授予另一个角色。可以将多个角色授予另一个角色，接收角色将拥有授予它的角色的所有权限的并集（直接或通过继承间接），加上授予它的任何角色的超级用户状态。例如，如果A被授予B，B被授予C，则C将被授予A和B的所有权限，如果A或B是超级用户，则C也将是超级用户。 
被授予的角色形成了一个非循环图，换言之，一个角色不能直接或间接地授予任何被授予它的角色。例如，如果A被授予B，B被授予C，则C既不能被授予A、B也不能被授予C。 
通过将dbServer标志--use_cassandra_authentication 设置为true，可以启用此语句。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>grant_role ::= GRANT role_name TO role_name
</code></pre></div>
<ul>
<li>role_name是文本标识符</li>
</ul>
<p>描述：
两个角色都必须存在，否则将引发错误。 
必须对所有角色或语句中使用的角色授予AUTHORIZE 权限。否则，将返回未经授权的错误。 
如果一个角色被授予（直接或间接）授予它的任何角色，则会引发错误。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>GRANT eng to robert;
</code></pre></div>
<h4 id="revoke-permission"><strong>REVOKE PERMISSION</strong></h4>
<p>使用REVOKE PERMISSION语句可以撤销角色的权限（或所有授予的权限）。 
删除数据库对象（键空间、表或角色）时，会自动删除该对象上的所有权限。 
通过将dbServer标志--use_cassandra_authentication 设置为true，可以启用此语句。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>revoke_permission := REVOKE all_permission | permission ON resource FROM role_name;
all_permissions := ALL [ PERMISSIONS ]
permission :=  ( CREATE | ALTER | DROP | SELECT | MODIFY | AUTHORIZE | DESCRIBE | EXECUTE ) [ PERMISSION ]
resource := ALL ( KEYSPACES | ROLES ) | KEYSPACE keyspace_name | [ TABLE ] table_name | ROLE role_name;
</code></pre></div>
<ul>
<li>keyspace_name、table_name和role_name是文本标识符（table_name可以用keyspace名称限定）。</li>
</ul>
<p>描述：
必须对所有角色或语句中使用的角色授予AUTHORIZE 权限。否则，将返回未经授权的错误。</p>
<div class="highlight"><pre><span></span><code>REVOKE CREATE ON KEYSPACE qa FROM fred;
</code></pre></div>
<h4 id="revoke-role"><strong>REVOKE ROLE</strong></h4>
<p>使用REVOKE ROLE语句可以从另一个角色撤销一个角色（表示一组权限和SUPERUSER状态）。 
通过将dbServer标志--use_cassandra_authentication 设置为true，可以启用此语句。 </p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>revoke_role ::= REVOKE role_name FROM role_name
</code></pre></div>
<ul>
<li>role_name是文本标识符</li>
</ul>
<p>描述：</p>
<ul>
<li>两个角色都必须存在，否则将引发错误。 </li>
<li>必须对所有角色或语句中使用的角色授予AUTHORIZE 权限。否则，将返回未经授权的错误。 </li>
<li>您不能撤消尚未授予的角色，否则将引发错误</li>
</ul>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>REVOKE project_y from diana;
</code></pre></div>
<h4 id="use"><strong>USE</strong></h4>
<p>使用USE 语句为当前客户端会话指定默认键空间。当数据库对象（如表或类型）名称不能标识键空间时，将使用此默认键空间。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>use_keyspace ::= USE keyspace_name;
</code></pre></div>
<ul>
<li>keyspace_name必须是一个标识符，该标识符不能是任何保留关键字，也不能包含空格，否则必须使用双引号。</li>
</ul>
<p>描述：
如果指定的键空间不存在，则会引发错误。 
任何不合格的表或类型名称都将使用当前默认键空间（如果未设置键空间，则会引发错误）。</p>
<p>示例：
1）创建并使用键空间</p>
<div class="highlight"><pre><span></span><code>CREATE KEYSPACE example;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE KEYSPACE other_keyspace;
</code></pre></div>
<div class="highlight"><pre><span></span><code>USE example;
</code></pre></div>
<p>2）在当前的键空间中创建表</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test(id INT PRIMARY KEY);
INSERT INTO test(id) VALUES (1);
SELECT * FROM test;
</code></pre></div>
<div class="highlight"><pre><span></span><code> id
----
  1
</code></pre></div>
<p>3）在另一个键空间中创建表</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE other_keyspace.test(id INT PRIMARY KEY);
INSERT INTO other_keyspace.test(id) VALUES (2);
SELECT * FROM other_keyspace.test;
</code></pre></div>
<div class="highlight"><pre><span></span><code> id
----
  2
</code></pre></div>
<h4 id="insert"><strong>INSERT</strong></h4>
<p>使用INSERT语句将一行添加到指定的表中。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>insert ::= INSERT INTO table_name ( column_name [ , ... ] ) VALUES (
           expression [ , ... ] )
           [ IF { [ NOT ] EXISTS | if_expression } ]
           [ USING using_expression ]
           [ RETURNS STATUS AS ROW ]

using_expression = ttl_or_timestamp_expression { &#39;AND&#39; ttl_or_timestamp_expression };
ttl_or_timestamp_expression = &#39;TTL&#39; ttl_expression | &#39;TIMESTAMP&#39; timestamp_expression;
</code></pre></div>
<ul>
<li>table_name和column 是标识符（table_name可以用键空间名称限定）。 </li>
<li>value 可以是任何表达式，尽管Apache Cassandra要求值必须是文字。 </li>
<li>语义部分介绍了对if_expression和ttl_expression的限制。 </li>
</ul>
<p>描述：</p>
<ul>
<li>如果指定的table_name不存在，则会引发错误。 </li>
<li>列列表必须包括所有主键列。 </li>
<li>USING TIMESTAMP子句表示您希望执行INSERT，就好像它是在用户提供的时间戳执行的一样。时间戳是自epoch以来的微秒数。 </li>
<li>默认情况下，INSERT具有upsert 语义，也就是说，如果行已经存在，它的行为就像UPDATE。如果需要纯INSERT语义，则可以使用 IF NOT EXISTS子句来确保INSERT不会覆盖现有行。 </li>
<li>注意：您应该在所有语句中使用USING TIMESTAMP子句，或者不在其中使用。在某些语句具有Using TIMESTAMP而另一些语句没有的情况下混合使用语句将导致非常混乱的结果。 </li>
<li>在启用了事务的表上不支持插入具有TTL的行。 </li>
<li>无论设置如何，INSERT 始终以QUORUM 一致性级别进行。</li>
</ul>
<p>VALUES子句 </p>
<ul>
<li>值列表的长度必须与列列表的长度相同。 </li>
<li>每个值都必须可转换为相应的（按位置）列类型。 </li>
<li>每个值文字都可以是一个计算结果为简单值的表达式。 </li>
</ul>
<p>IF子句  </p>
<ul>
<li>if_expression 只能应用于非键列（常规列）。 </li>
<li>if_expression可以包含任何逻辑运算符和布尔运算符。 </li>
</ul>
<p>USING子句 </p>
<ul>
<li>ttl_expression必须是一个整数值（或预编译语句的绑定变量标记）。 </li>
<li>timestamp_expression必须是一个整数值（或预编译语句的绑定变量标记）。</li>
</ul>
<p>示例：
1）插入一行数据</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE employees(department_id INT,
                        employee_id INT,
                        name TEXT,
                        PRIMARY KEY(department_id, employee_id));
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (1, 1, &#39;John&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (1, 2, &#39;Jane&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name
---------------+-------------+------
             1 |           1 | John
             1 |           2 | Jane
</code></pre></div>
<p>2）使用IF子句的条件插入</p>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (2, 1, &#39;Joe&#39;) IF name = null;
</code></pre></div>
<div class="highlight"><pre><span></span><code> [applied]
-----------
      True
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (2, 1, &#39;Jack&#39;) IF NOT EXISTS;
</code></pre></div>
<div class="highlight"><pre><span></span><code> [applied] | department_id | employee_id
-----------+---------------+-------------
     False |             2 |           1
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name
---------------+-------------+------
             2 |           1 |  Joe
             1 |           1 | John
             1 |           2 | Jane
</code></pre></div>
<p>3）使用using TTL子句插入具有过期时间的行
您可以按如下方式执行此操作：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (2, 2, &#39;Jack&#39;) USING TTL 10;
</code></pre></div>
<p>现在查询employees表。</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name
---------------+-------------+------
             2 |           1 |  Joe
             2 |           2 | Jack
             1 |           1 | John
             1 |           2 | Jane
</code></pre></div>
<p>11秒或更长时间后再次查询employees表。</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees; -- 11 seconds after the insert.
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name
---------------+-------------+------
             2 |           1 |  Joe
             1 |           1 | John
             1 |           2 | Jane
</code></pre></div>
<p>4）使用USING TIMESTAMP子句插入一行</p>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (1, 3, &#39;Jeff&#39;) USING TIMESTAMP 1000;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name
---------------+-------------+------
             1 |           1 | John
             1 |           2 | Jane
             1 |           3 | Jeff
             2 |           1 |  Joe

(4 rows)
</code></pre></div>
<p>用更高的时间戳覆盖行</p>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (1, 3, &#39;Jerry&#39;) USING TIMESTAMP 2000;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name
---------------+-------------+-------
             1 |           1 |  John
             1 |           2 |  Jane
             1 |           3 | Jerry
             2 |           1 |   Joe

(4 rows)
</code></pre></div>
<p>尝试用较低的时间戳覆盖该行</p>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (1, 3, &#39;James&#39;) USING TIMESTAMP 1500;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name
---------------+-------------+-------
             1 |           1 |  John
             1 |           2 |  Jane
             1 |           3 | Jerry
             2 |           1 |   Joe

(4 rows)
</code></pre></div>
<p>将状态返回为行：
在BCQL中执行批处理时，协议只返回一个错误或返回状态。RETURNS STATUS AS ROW功能解决了这一限制，并为每条语句添加了一个状态行。</p>
<h4 id="select"><strong>SELECT</strong></h4>
<p>使用SELECT语句从表中检索满足给定条件的指定列的行（部分）。它指定要检索的列、表的名称以及每个选定行必须满足的条件。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>select ::= SELECT [ DISTINCT ] { * | column_name [ , column_name ... ] }
               FROM table_name
               [ WHERE where_expression ]
               [ IF where_expression ]
               [ ORDER BY order_expression ]
               [ LIMIT limit_expression ] [ OFFSET offset_expression ]

order_expression ::= ( { column_name [ ASC | DESC ] } [ , ... ] )
</code></pre></div>
<ul>
<li>table_name和column_name是标识符（table_name可以用键空间名称限定）。 </li>
<li>limit_expression 是一个整数文字（或预编译语句的绑定变量标记）。 </li>
</ul>
<p>描述：</p>
<ul>
<li>如果指定的table_name不存在，则会引发错误。 </li>
<li>SELECT DISTINCT只能用于分区列或静态列。 </li>
<li>*表示将检索表的所有列。 </li>
<li>LIMIT子句设置要返回的最大结果数（行）。 </li>
<li>OFFSET子句设置返回结果之前要跳过的行数。 </li>
<li>提供ALLOW FILTERING是为了与Cassandra的语法兼容。您始终可以对所有列进行筛选。 </li>
<li>读取默认值为QUORUM ，并从分片的Leader读取。 </li>
<li>要从followers 那里读取，请使用ONE一致性级别。 
  为了从本地读取中受益，除了指定ONE的一致性级别外，还可以在客户端驱动程序中设置region ，以指示请求的来源，并且它应该与该区域中服务器的--placement_region 参数相匹配。</li>
</ul>
<p>ORDER BY子句：</p>
<ul>
<li>ORDER BY子句设置返回结果的顺序。 </li>
<li>order_expression中只允许使用集群列。 </li>
<li>对于给定的列，DESC表示降序，ASC或省略表示升序。 </li>
<li>目前，只允许两种总体排序，CREATE TABLE语句中的集群顺序（正向扫描）或相反的顺序（反向扫描）。</li>
</ul>
<p>WHERE子句：</p>
<ul>
<li>where_expression的计算结果必须为布尔值。 </li>
<li>where_expression可以指定任何列的条件，包括分区、集群和常规列。 </li>
<li>where_expression有一个受限制的运算符列表。 </li>
<li>只有 =，!=，IN和NOT IN运算符可用于分区列上的条件。 </li>
<li>仅运算符=，！=，&lt;，&lt;=，&gt;，&gt;=，IN和NOT IN可用于集群和常规列的条件。 </li>
<li>只有IN运算符可以用于聚类列的元组上的条件。</li>
</ul>
<p>IF子句：</p>
<ul>
<li>if_expression 的计算结果必须为布尔值。 </li>
<li>if_expression支持所有可用布尔运算符和逻辑运算符的任意组合。 </li>
<li>if_expression只能指定非主键列的条件，尽管它可以用于辅助索引的键列。 </li>
<li>WHERE条件用于生成高效的查询计划，而IF条件则不是。在IF条件用于筛选不需要的数据之前，将从数据库中读取所有满足WHERE条件的行。在下面的示例中，尽管这两个查询产生相同的结果集，但是SELECT with WHERE子句将使用INDEX-SCAN，而SELECT with IF子句将使用FULL-SCAN。</li>
</ul>
<div class="highlight"><pre><span></span><code>SELECT * FROM a_table WHERE key = &#39;my_key&#39;;
SELECT * FROM a_table IF key = &#39;my_key&#39;;
</code></pre></div>
<p>示例：
1）获取表中的所有行</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE employees(department_id INT,
                        employee_id INT,
                        dept_name TEXT STATIC,
                        employee_name TEXT,
                        PRIMARY KEY(department_id, employee_id));
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, dept_name, employee_name)
                   VALUES (1, 1, &#39;Accounting&#39;, &#39;John&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, dept_name, employee_name)
                   VALUES (1, 2, &#39;Accounting&#39;, &#39;Jane&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, dept_name, employee_name)
                   VALUES (1, 3, &#39;Accounting&#39;, &#39;John&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, dept_name, employee_name)
                   VALUES (2, 1, &#39;Marketing&#39;, &#39;Joe&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | dept_name  | employee_name
---------------+-------------+------------+---------------
             1 |           1 | Accounting |          John
             1 |           2 | Accounting |          Jane
             1 |           3 | Accounting |          John
             2 |           1 |  Marketing |           Joe
</code></pre></div>
<p>2）使用limit</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees LIMIT 2;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | dept_name  | employee_name
---------------+-------------+------------+---------------
             1 |           1 | Accounting |          John
             1 |           2 | Accounting |          Jane
</code></pre></div>
<p>3）使用offset</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees LIMIT 2 OFFSET 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | dept_name  | employee_name
---------------+-------------+------------+---------------
             1 |           2 | Accounting |          Jane
             1 |           3 | Accounting |          John
</code></pre></div>
<p>4）使用distinct </p>
<div class="highlight"><pre><span></span><code>SELECT DISTINCT dept_name FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> dept_name
------------
 Accounting
  Marketing
</code></pre></div>
<p>5）根据分区列上的条件进行选择</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees WHERE department_id = 2;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | dept_name | employee_name
---------------+-------------+-----------+---------------
             2 |           1 | Marketing |           Joe
</code></pre></div>
<p>6）在聚类列上以条件进行选择</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees WHERE department_id = 1 AND employee_id &lt;= 2;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | dept_name  | employee_name
---------------+-------------+------------+---------------
             1 |           1 | Accounting |          John
             1 |           2 | Accounting |          Jane
</code></pre></div>
<p>7）使用WHERE子句在常规列上带条件选择</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees WHERE employee_name = &#39;John&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | dept_name  | employee_name
---------------+-------------+------------+---------------
             1 |           1 | Accounting |          John
             1 |           3 | Accounting |          John
</code></pre></div>
<p>8）使用IF子句在常规列上带条件选择</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees WHERE department_id = 1 IF employee_name != &#39;John&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | dept_name  | employee_name
---------------+-------------+------------+---------------
             1 |           2 | Accounting |          Jane
</code></pre></div>
<p>9）使用ORDER BY子句选择</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sensor_data(device_id INT,
                                        sensor_id INT,
                                        ts TIMESTAMP,
                                        value TEXT,
                                        PRIMARY KEY((device_id), sensor_id, ts)) WITH CLUSTERING ORDER BY (sensor_id ASC, ts DESC);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO sensor_data(device_id, sensor_id, ts, value)
                   VALUES (1, 1, &#39;2018-1-1 12:30:30 UTC&#39;, &#39;a&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO sensor_data(device_id, sensor_id, ts, value)
                   VALUES (1, 1, &#39;2018-1-1 12:30:31 UTC&#39;, &#39;b&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO sensor_data(device_id, sensor_id, ts, value)
                   VALUES (1, 2, &#39;2018-1-1 12:30:30 UTC&#39;, &#39;x&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO sensor_data(device_id, sensor_id, ts, value)
                   VALUES (1, 2, &#39;2018-1-1 12:30:31 UTC&#39;, &#39;y&#39;);
</code></pre></div>
<p>反向扫描，与表的聚类顺序相反。</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sensor_data WHERE device_id = 1 ORDER BY sensor_id DESC, ts ASC;
</code></pre></div>
<div class="highlight"><pre><span></span><code> device_id | sensor_id | ts                              | value
-----------+-----------+---------------------------------+-------
         1 |         2 | 2018-01-01 12:30:30.000000+0000 |     x
         1 |         2 | 2018-01-01 12:30:31.000000+0000 |     y
         1 |         1 | 2018-01-01 12:30:30.000000+0000 |     a
         1 |         1 | 2018-01-01 12:30:31.000000+0000 |     b
</code></pre></div>
<p>前向扫描，与不带ORDER BY子句的SELECT相同。</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sensor_data WHERE device_id = 1 ORDER BY sensor_id ASC, ts DESC;
</code></pre></div>
<div class="highlight"><pre><span></span><code> device_id | sensor_id | ts                              | value
-----------+-----------+---------------------------------+-------
         1 |         1 | 2018-01-01 12:30:31.000000+0000 |     b
         1 |         1 | 2018-01-01 12:30:30.000000+0000 |     a
         1 |         2 | 2018-01-01 12:30:31.000000+0000 |     y
         1 |         2 | 2018-01-01 12:30:30.000000+0000 |     x
</code></pre></div>
<p>不允许进行其他排序。</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sensor_data WHERE device_id = 1 ORDER BY sensor_id ASC, ts ASC;
</code></pre></div>
<div class="highlight"><pre><span></span><code>InvalidRequest: Unsupported order by relation
SELECT * FROM sensor_data WHERE device_id = 1 ORDER BY sensor_id ASC, ts ASC;
                                                        ^^^^^^^^^^^^^^^^^^^^^
</code></pre></div>
<h4 id="explain"><strong>EXPLAIN</strong></h4>
<p>使用EXPLAIN语句可以显示语句的执行计划。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>explain ::= EXPLAIN { select | update | insert | delete }
</code></pre></div>
<p>描述：
其中，目标语句是以下语句之一：SELECT、UPDATE、INSERT或DELETE。</p>
<p>示例：</p>
<p>创建表和索引：</p>
<div class="highlight"><pre><span></span><code>CREATE KEYSPACE IF NOT EXISTS imdb;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE TABLE IF NOT EXISTS imdb.movie_stats (
           movie_name text,
           movie_genre text,
           user_name text,
           user_rank int,
           last_watched timestamp,
           PRIMARY KEY (movie_genre, movie_name, user_name)
) WITH transactions = { &#39;enabled&#39; : true };
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE INDEX IF NOT EXISTS most_watched_by_year
      ON imdb.movie_stats((movie_genre, last_watched), movie_name, user_name)
      INCLUDE(user_rank);
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE INDEX IF NOT EXISTS best_rated
      ON imdb.movie_stats((user_rank, movie_genre), movie_name, user_name)
      INCLUDE(last_watched);
</code></pre></div>
<p>插入数据：</p>
<div class="highlight"><pre><span></span><code>USE imdb;
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO movie_stats(movie_name, movie_genre, user_name, user_rank, last_watched)
            VALUES (&#39;m1&#39;, &#39;g1&#39;, &#39;u1&#39;, 5, &#39;2019-01-18&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO movie_stats(movie_name, movie_genre, user_name, user_rank, last_watched)
            VALUES (&#39;m2&#39;, &#39;g2&#39;, &#39;u1&#39;, 4, &#39;2019-01-17&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO movie_stats(movie_name, movie_genre, user_name, user_rank, last_watched)
            VALUES (&#39;m3&#39;, &#39;g1&#39;, &#39;u2&#39;, 5, &#39;2019-01-18&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO movie_stats(movie_name, movie_genre, user_name, user_rank, last_watched)
            VALUES (&#39;m4&#39;, &#39;g1&#39;, &#39;u1&#39;, 2, &#39;2019-02-27&#39;);
</code></pre></div>
<p>解释查询计划：
如果指定了movie_genre、或movie_genre &amp; movie_name或movie_genre &amp; movie_name &amp; user_name，则应该从主表高效地提供查询。</p>
<div class="highlight"><pre><span></span><code>EXPLAIN SELECT *
            FROM movie_stats
            WHERE movie_genre = &#39;g1&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>QUERY PLAN
----------------------------------------
 Range Scan on imdb.movie_stats
   Key Conditions: (movie_genre = &#39;g1&#39;)
</code></pre></div>
<p>如果指定了movie_genre &amp; last_watched，那么应该从most_watched_by_year索引高效地提供查询。</p>
<div class="highlight"><pre><span></span><code>EXPLAIN SELECT *
            FROM movie_stats
            WHERE movie_genre = &#39;g1&#39; and last_watched=&#39;2019-02-27&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>QUERY PLAN
--------------------------------------------------------------------------
 Index Only Scan using imdb.most_watched_by_year on imdb.movie_stats
   Key Conditions: (movie_genre = &#39;g1&#39;) AND (last_watched = &#39;2019-02-27&#39;)
</code></pre></div>
<p>如果指定了user_rank 和movie_genre，那么应该从best_rated索引高效地提供查询。</p>
<div class="highlight"><pre><span></span><code>EXPLAIN SELECT *
            FROM movie_stats
            WHERE movie_genre = &#39;g2&#39; and user_rank=5;
</code></pre></div>
<div class="highlight"><pre><span></span><code>QUERY PLAN
--------------------------------------------------------------
 Index Only Scan using imdb.best_rated on imdb.movie_stats
   Key Conditions: (user_rank = &#39;5&#39;) AND (movie_genre = &#39;g2&#39;)
</code></pre></div>
<p>创建非覆盖索引。</p>
<div class="highlight"><pre><span></span><code>DROP INDEX best_rated;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE INDEX IF NOT EXISTS best_rated
            ON imdb.movie_stats((user_rank, movie_genre), movie_name, user_name);
</code></pre></div>
<p>两步选择。使用索引扫描而不是仅使用索引扫描。</p>
<div class="highlight"><pre><span></span><code>EXPLAIN SELECT *
            FROM movie_stats
            WHERE movie_genre = &#39;g2&#39; and user_rank=5;
</code></pre></div>
<div class="highlight"><pre><span></span><code> QUERY PLAN
--------------------------------------------------------------
 Index Scan using imdb.best_rated on imdb.movie_stats
   Key Conditions: (user_rank = &#39;5&#39;) AND (movie_genre = &#39;g2&#39;)
</code></pre></div>
<p>其他SELECT的EXPLAIN 类型</p>
<p>表达式的QLName()是不支持的</p>
<div class="highlight"><pre><span></span><code>EXPLAIN SELECT * FROM movie_stats where movie_genre in (&#39;g1&#39;, &#39;g2&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code> QUERY PLAN
-------------------------------------------
 Range Scan on imdb.movie_stats
   Key Conditions: (movie_genre IN &#39;expr&#39;)
</code></pre></div>
<div class="highlight"><pre><span></span><code>EXPLAIN SELECT COUNT(*) FROM movie_stats  WHERE movie_genre = &#39;g2&#39; and user_rank=5;
</code></pre></div>
<div class="highlight"><pre><span></span><code> QUERY PLAN
--------------------------------------------------------------------
 Aggregate
   -&gt;  Index Only Scan using imdb.best_rated on imdb.movie_stats
         Key Conditions: (user_rank = &#39;5&#39;) AND (movie_genre = &#39;g2&#39;)
</code></pre></div>
<div class="highlight"><pre><span></span><code>EXPLAIN SELECT * FROM movie_stats  WHERE movie_genre = &#39;g2&#39; and user_rank = 5 LIMIT 5;
</code></pre></div>
<div class="highlight"><pre><span></span><code> QUERY PLAN
--------------------------------------------------------------------
 Limit
   -&gt;  Index Only Scan using imdb.best_rated on imdb.movie_stats
         Key Conditions: (user_rank = &#39;5&#39;) AND (movie_genre = &#39;g2&#39;)
</code></pre></div>
<p>INSERT示例：</p>
<div class="highlight"><pre><span></span><code>EXPLAIN INSERT INTO movie_stats(movie_name, movie_genre, user_name, user_rank, last_watched)
            VALUES (&#39;m4&#39;, &#39;g1&#39;, &#39;u1&#39;, 2, &#39;2019-02-27&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code> QUERY PLAN
----------------------------
 Insert on imdb.movie_stats
</code></pre></div>
<p>DELETE示例：</p>
<div class="highlight"><pre><span></span><code>explain delete from movie_stats  where movie_genre = &#39;g1&#39; and movie_name = &#39;m1&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> QUERY PLAN
----------------------------------------------
 Delete on imdb.movie_stats
   -&gt;  Range Scan on imdb.movie_stats
         Key Conditions: (movie_genre = &#39;g1&#39;)
         Filter: (movie_name = &#39;m1&#39;)
</code></pre></div>
<div class="highlight"><pre><span></span><code>explain delete from movie_stats  where movie_genre = &#39;g1&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> QUERY PLAN
----------------------------------------------
 Delete on imdb.movie_stats
   -&gt;  Range Scan on imdb.movie_stats
         Key Conditions: (movie_genre = &#39;g1&#39;)
</code></pre></div>
<p>UPDATE示例：</p>
<div class="highlight"><pre><span></span><code>EXPLAIN UPDATE movie_stats SET user_rank = 1 WHERE movie_name = &#39;m1&#39; and movie_genre = &#39;g1&#39; and user_name = &#39;u1&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> QUERY PLAN
---------------------------------------------------------------------------------------------
 Update on imdb.movie_stats
   -&gt;  Primary Key Lookup on imdb.movie_stats
         Key Conditions: (movie_genre = &#39;g1&#39;) AND (movie_name = &#39;m1&#39;) AND (user_name = &#39;u1&#39;)
</code></pre></div>
<h4 id="update"><strong>UPDATE</strong></h4>
<p>使用UPDATE语句可以更新表中某行的一个或多个列值。
注意：AiSQL 一次只能更新一行。当前不支持更新多行。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>update ::= UPDATE table_name [ USING using_expression ] SET assignment 
           [ , ... ]  WHERE where_expression 
           [ IF { if_expression
                  | [ NOT ] EXISTS
                  | if_expression OR [ NOT ] EXISTS } ] 
           [ RETURNS STATUS AS ROW ]


assignment ::= { column_name | column_name&#39;[&#39;index_expression&#39;]&#39; } &#39;=&#39; expression


using_expression = ttl_or_timestamp_expression { &#39;AND&#39; ttl_or_timestamp_expression };

ttl_or_timestamp_expression = &#39;TTL&#39; ttl_expression | &#39;TIMESTAMP&#39; timestamp_expression;
</code></pre></div>
<ul>
<li>table_name是一个标识符（可能使用键空间名称限定）。 </li>
<li>语义部分介绍了ttl_expression、where_expression和if_expression的限制。 </li>
</ul>
<p>描述：</p>
<ul>
<li>如果指定的table_name不存在，则会引发错误。 </li>
<li>Update语句使用upsert 语义，这意味着它插入正在更新的行（若该行不存在）。 </li>
<li>USING TIMESTAMP 子句表示您希望执行UPDATE，就好像它是在用户提供的时间戳执行的一样。时间戳是自epoch以来的微秒数。 </li>
<li>注意：您应该在所有语句中使用USING TIMESTAMP子句，或者不在其中使用。在某些语句具有Using TIMESTAMP而另一些语句没有的情况下混合使用语句将导致非常混乱的结果。 </li>
<li>启用事务的表不支持使用TTL更新行。 </li>
<li>不能更新主键中的列。作为一种变通方法，您必须删除该行并插入新行。 </li>
<li>无论设置如何，更新始终以QUORUM 一致性级别进行。</li>
</ul>
<p>WHERE子句 
where_expression和if_expression的计算结果必须为布尔值。 
where_expression必须为所有主键列指定条件。 
where_expression不能为任何常规列指定条件。 
where_expression只能应用AND和 = 运算符。尚不支持其他运算符。</p>
<p>IF子句 </p>
<ul>
<li>if_expression只能应用于非键列（常规列）。 </li>
<li>if_expression可以包含任何逻辑运算符和布尔运算符。 </li>
</ul>
<p>USING子句 </p>
<ul>
<li>ttl_expression必须是一个整数值（或为预编译语句的绑定变量标记）。 </li>
<li>timestamp_expression必须是一个整数值（或为预编译语句的绑定变量标记）。</li>
</ul>
<p>示例：
1）更新表值</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE employees(department_id INT,
                                      employee_id INT,
                                      name TEXT,
                                      age INT,
                                      PRIMARY KEY(department_id, employee_id));
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name, age) VALUES (1, 1, &#39;John&#39;, 30);
</code></pre></div>
<p>更新非主键列的值：</p>
<div class="highlight"><pre><span></span><code>UPDATE employees SET name = &#39;Jack&#39; WHERE department_id = 1 AND employee_id = 1;
</code></pre></div>
<p>使用upstart语义来更新不存在的行（即插入行）：</p>
<div class="highlight"><pre><span></span><code>UPDATE employees SET name = &#39;Jane&#39;, age = 40 WHERE department_id = 1 AND employee_id = 2;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name | age
---------------+-------------+------+-----
             1 |           1 | Jack |  30
             1 |           2 | Jane |  40
</code></pre></div>
<p>2）使用IF子句的条件更新
“SET”中允许使用支持的表达式。</p>
<div class="highlight"><pre><span></span><code>UPDATE employees SET age = age + 1 WHERE department_id = 1 AND employee_id = 1 IF name = &#39;Jack&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> [applied]
-----------
      True
</code></pre></div>
<p>使用upstart语义添加行，年龄未设置，因此将为“null”。</p>
<div class="highlight"><pre><span></span><code>UPDATE employees SET name = &#39;Joe&#39; WHERE department_id = 2 AND employee_id = 1 IF NOT EXISTS;
</code></pre></div>
<div class="highlight"><pre><span></span><code> [applied]
-----------
      True
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code>  department_id | employee_id | name | age
---------------+-------------+------+------
             1 |           1 | Jack |   31
             1 |           2 | Jane |   40
             2 |           1 |  Joe | null
</code></pre></div>
<p>3）使用USING TTL子句更新到期时间</p>
<p>更新后的值将持续TTL持续时间。</p>
<div class="highlight"><pre><span></span><code>UPDATE employees USING TTL 10 SET age = 32 WHERE department_id = 1 AND employee_id = 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees WHERE department_id = 1 AND employee_id = 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name | age
---------------+-------------+------+------
             1 |           1 | Jack |   32
</code></pre></div>
<p>更新后11秒（值将过期）。</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees WHERE department_id = 1 AND employee_id = 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name | age
---------------+-------------+------+------
             1 |           1 | Jack | null
</code></pre></div>
<p>4）使用USING TIMESTAMP子句更新行 
您可以按如下方式执行此操作：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name, age) VALUES (1, 4, &#39;Jeff&#39;, 20) USING TIMESTAMP 1000;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name | age
---------------+-------------+------+------
             1 |           1 | Jack | null
             1 |           2 | Jane |   40
             1 |           4 | Jeff |   20
             2 |           1 |  Joe | null

(4 rows)
</code></pre></div>
<p>现在更新employees表：</p>
<div class="highlight"><pre><span></span><code>UPDATE employees USING TIMESTAMP 500 SET age = 30 WHERE department_id = 1 AND employee_id = 4;
</code></pre></div>
<p>由于时间戳低于1000，因此未应用。</p>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name | age
---------------+-------------+------+------
             1 |           1 | Jack | null
             1 |           2 | Jane |   40
             1 |           4 | Jeff |   20
             2 |           1 |  Joe | null

(4 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE employees USING TIMESTAMP 1500 SET age = 30 WHERE department_id = 1 AND employee_id = 4;
</code></pre></div>
<p>已应用，因为时间戳高于1000。</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name | age
---------------+-------------+------+------
             1 |           1 | Jack | null
             1 |           2 | Jane |   40
             1 |           4 | Jeff |   30
             2 |           1 |  Joe | null

(4 rows)
</code></pre></div>
<p>将状态返回为行 
在BCQL中执行批处理时，协议只返回一个错误或返回状态。RETURNS STATUS AS ROW功能解决了这一限制，并为每条语句添加了一个状态行。</p>
<h4 id="delete"><strong>DELETE</strong></h4>
<p>使用DELETE语句从指定表中删除满足给定条件的行。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>delete ::= DELETE FROM table_name
               [ USING TIMESTAMP timestamp_expression ] WHERE
               where_expression [ IF { [ NOT ] EXISTS | if_expression } ]
               [ RETURNS STATUS AS ROW ]
</code></pre></div>
<ul>
<li>table_name是一个标识符（可能使用键空间名称限定）。 </li>
<li>语义部分介绍了where_expression和if_expression的限制。 </li>
</ul>
<p>描述：</p>
<ul>
<li>如果指定的table_name不存在，则会引发错误。 </li>
<li>where表达式和if表达式的计算结果必须为布尔值。 </li>
<li>USING TIMESTAMP子句表示您希望执行DELETE，就好像它是在用户提供的时间戳执行的一样。时间戳是自epoch以来的微秒数。 </li>
<li>注意：您应该在所有语句中使用USING TIMESTAMP子句，或者不在其中使用。在某些语句具有Using TIMESTAMP而另一些语句没有的情况下混合使用语句将导致非常混乱的结果。 </li>
<li>无论设置如何，DELETE始终在QUORUM一致性级别执行</li>
</ul>
<p>WHERE子句 
where_expression必须为所有主键列指定条件。 
where_expression不能为任何常规列指定条件。 
where_expression只能应用AND和 = 运算符。尚不支持其他运算符。</p>
<p>IF子句 </p>
<ul>
<li>if_expression只能应用于非键列（常规列）。 </li>
<li>if_expression可以包含任何逻辑运算符和布尔运算符。 </li>
<li>目前还不支持仅从行中删除某些列值。 </li>
<li>IF EXISTS和IF NOT EXISTS选项主要用于与INSERT和UPDATE命令对称。 </li>
<li>IF EXISTS的工作方式与普通删除类似，但还返回是否应用了删除（找到了具有该主键的行）。 </li>
<li>IF NOT EXISTS实际上是一个no-op，因为不存在的行无法删除（但返回是否没有找到具有该主键的行）。</li>
</ul>
<p>USING子句 </p>
<ul>
<li>timestamp_expression必须是一个整数值（或为预编译语句的绑定变量标记）。</li>
</ul>
<p>示例：
1）从表中删除行</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE employees(department_id INT,
                        employee_id INT,
                        name TEXT,
                        PRIMARY KEY(department_id, employee_id));
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (1, 1, &#39;John&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (1, 2, &#39;Jane&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (2, 1, &#39;Joe&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code>  department_id | employee_id | name
---------------+-------------+------
             1 |           1 | John
             1 |           2 | Jane
             2 |           1 |  Joe
</code></pre></div>
<p>Delete语句通过主键列来标识行。</p>
<div class="highlight"><pre><span></span><code>DELETE FROM employees WHERE department_id = 1 AND employee_id = 1;
</code></pre></div>
<p>对不存在的行的删除没有操作。</p>
<div class="highlight"><pre><span></span><code>DELETE FROM employees WHERE department_id = 3 AND employee_id = 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name
---------------+-------------+------
             1 |           2 | Jane
             2 |           1 |  Joe
</code></pre></div>
<p>2）使用IF子句删除
“IF”子句条件将返回是否应用它们。</p>
<div class="highlight"><pre><span></span><code>DELETE FROM employees WHERE department_id = 2 AND employee_id = 1 IF name = &#39;Joe&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> [applied]
-----------
      True
</code></pre></div>
<div class="highlight"><pre><span></span><code>DELETE FROM employees WHERE department_id = 3 AND employee_id = 1 IF EXISTS;
</code></pre></div>
<div class="highlight"><pre><span></span><code> [applied]
-----------
     False
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name
---------------+-------------+------
             1 |           2 | Jane
</code></pre></div>
<p>3）删除具有相同分区键的几行</p>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (1, 1, &#39;John&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (2, 1, &#39;Joe&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (2, 2, &#39;Jack&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name
---------------+-------------+------
             1 |           1 | John
             1 |           2 | Jane
             2 |           1 |  Joe
             2 |           2 | Jack
</code></pre></div>
<p>删除分区键的所有条目。</p>
<div class="highlight"><pre><span></span><code>DELETE FROM employees WHERE department_id = 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name
---------------+-------------+------
             2 |           1 |  Joe
             2 |           2 | Jack
</code></pre></div>
<p>删除分区键中的一系列条目。</p>
<div class="highlight"><pre><span></span><code>DELETE FROM employees WHERE department_id = 2 AND employee_id &gt;= 2 AND employee_id &lt; 4;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name
---------------+-------------+------
             2 |           1 |  Joe
</code></pre></div>
<p>使用USING TIMESTAMP子句删除</p>
<p>您可以按如下方式执行此操作：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (4, 4, &#39;Ted&#39;) USING TIMESTAMP 1000;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name
---------------+-------------+------
             4 |           4 |  Ted
             2 |           1 |  Joe

(2 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>DELETE FROM employees USING TIMESTAMP 500 WHERE department_id = 4 AND employee_id = 4;
</code></pre></div>
<p>由于时间戳低于1000，因此未应用</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name
---------------+-------------+------
             4 |           4 |  Ted
             2 |           1 |  Joe

(2 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>DELETE FROM employees USING TIMESTAMP 1500 WHERE department_id = 4 AND employee_id = 4;
</code></pre></div>
<p>已应用，因为时间戳高于1000。</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name
---------------+-------------+------
             2 |           1 |  Joe

(1 rows)
</code></pre></div>
<p>将状态返回为行 
在BCQL中执行批处理时，协议只返回一个错误或返回状态。RETURNS STATUS AS ROW功能解决了这一限制，并为每条语句添加了一个状态行。</p>
<h4 id="transaction"><strong>TRANSACTION</strong></h4>
<p>使用TRANSACTION语句块可以更改分布式ACID事务中一个或多个表中的多行。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>transaction_block ::= BEGIN TRANSACTION
                          ( insert | update | delete ) &#39;;&#39;
                          [ ( insert | update | delete ) &#39;;&#39; ...]
                      END TRANSACTION &#39;;&#39;
</code></pre></div>
<p>其中，insert、update和delete是insert、update和delete语句。 </p>
<ul>
<li>使用BEGIN TRANSACTION时，不使用分号。使用END  TRANSACTION 结束事务块；（用分号）。 </li>
<li>对于使用BEGIN启动的事务，没有COMMIT。</li>
</ul>
<p>BCQL还支持SQL START TRANSACTION和COMMIT语句。</p>
<div class="highlight"><pre><span></span><code>transaction_block ::= START TRANSACTION &#39;;&#39;
                      ( insert | update | delete ) &#39;;&#39;
                      [ ( insert | update | delete ) &#39;;&#39; ...]
                      COMMIT &#39;;&#39;
</code></pre></div>
<ul>
<li>使用START TRANSACTION时，必须使用分号。使用COMMIT；结束事务块；。 </li>
<li>对于使用START启动的事务，不能使用END TRANSACTION</li>
</ul>
<p>描述：</p>
<ul>
<li>如果未在插入、更新或删除的任何表中启用事务，则会引发错误。 </li>
<li>目前，如果INSERT、UPDATE或DELETE语句中的任何一个包含IF 子句，则会引发错误。 </li>
<li>如果为表启用了事务，则其索引也必须启用事务，反之亦然。 </li>
<li>没有显式回滚。若要回滚事务，请中止或中断客户端会话。 </li>
<li>DDL总是在事务块之外执行，就像事务块之外的DML一样，会立即提交。 </li>
<li>在事务块内部，只允许插入、更新和删除语句。不允许使用Select语句。 </li>
<li>事务块内的insert、update和delete语句不能有任何if_expression。</li>
</ul>
<p>示例：
创建启用了事务的表</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE accounts (account_name TEXT,
                                      account_type TEXT,
                                      balance DOUBLE,
                                      PRIMARY KEY ((account_name), account_type))
               WITH transactions = { &#39;enabled&#39; : true };
</code></pre></div>
<p>插入数据：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO accounts (account_name, account_type, balance)
               VALUES (&#39;John&#39;, &#39;savings&#39;, 1000);
INSERT INTO accounts (account_name, account_type, balance)
               VALUES (&#39;John&#39;, &#39;checking&#39;, 100);
INSERT INTO accounts (account_name, account_type, balance)
               VALUES (&#39;Smith&#39;, &#39;savings&#39;, 2000);
INSERT INTO accounts (account_name, account_type, balance)
               VALUES (&#39;Smith&#39;, &#39;checking&#39;, 50);
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT account_name, account_type, balance, writetime(balance) FROM accounts;
</code></pre></div>
<div class="highlight"><pre><span></span><code> account_name | account_type | balance | writetime(balance)
--------------+--------------+---------+--------------------
         John |     checking |     100 |   1523313964356489
         John |      savings |    1000 |   1523313964350449
        Smith |     checking |      50 |   1523313964371579
        Smith |      savings |    2000 |   1523313964363056
</code></pre></div>
<p>使用相同的分区键更新2行：</p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION
                 UPDATE accounts SET balance = balance - 200 WHERE account_name = &#39;John&#39; AND account_type = &#39;savings&#39;;
                 UPDATE accounts SET balance = balance + 200 WHERE account_name = &#39;John&#39; AND account_type = &#39;checking&#39;;
               END TRANSACTION;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT account_name, account_type, balance, writetime(balance) FROM accounts;
</code></pre></div>
<div class="highlight"><pre><span></span><code> account_name | account_type | balance | writetime(balance)
--------------+--------------+---------+--------------------
         John |     checking |     300 |   1523313983201270
         John |      savings |     800 |   1523313983201270
        Smith |     checking |      50 |   1523313964371579
        Smith |      savings |    2000 |   1523313964363056
</code></pre></div>
<p>使用不同的分区键更新2行：</p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION
                 UPDATE accounts SET balance = balance - 200 WHERE account_name = &#39;John&#39; AND account_type = &#39;checking&#39;;
                 UPDATE accounts SET balance = balance + 200 WHERE account_name = &#39;Smith&#39; AND account_type = &#39;checking&#39;;
               END TRANSACTION;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT account_name, account_type, balance, writetime(balance) FROM accounts;
</code></pre></div>
<div class="highlight"><pre><span></span><code> account_name | account_type | balance | writetime(balance)
--------------+--------------+---------+--------------------
         John |     checking |     100 |   1523314002218558
         John |      savings |     800 |   1523313983201270
        Smith |     checking |     250 |   1523314002218558
        Smith |      savings |    2000 |   1523313964363056
</code></pre></div>
<p>注意：
BEGIN/END TRANSACTION 当前不支持RETURNS STATUS AS ROW</p>
<h4 id="truncate"><strong>TRUNCATE</strong></h4>
<p>使用TRUNCATE语句从指定的表中删除所有行</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>truncate ::= TRUNCATE [ TABLE ] table_name;
</code></pre></div>
<ul>
<li>table_name是一个标识符（可能使用键空间名称限定）。</li>
</ul>
<p>描述：</p>
<p>如果指定的表名称不存在，则会引发错误。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE employees(department_id INT,
                        employee_id INT,
                        name TEXT,
                        PRIMARY KEY(department_id, employee_id));
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (1, 1, &#39;John&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (1, 2, &#39;Jane&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO employees(department_id, employee_id, name) VALUES (2, 1, &#39;Joe&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name
---------------+-------------+------
             2 |           1 |  Joe
             1 |           1 | John
             1 |           2 | Jane
</code></pre></div>
<p>从表中删除所有行。</p>
<div class="highlight"><pre><span></span><code>TRUNCATE employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM employees;
</code></pre></div>
<div class="highlight"><pre><span></span><code> department_id | employee_id | name
---------------+-------------+------
</code></pre></div>
<h4 id="simple-expressions"><strong>Simple expressions</strong></h4>
<p>一个简单的表达式可以是列、常量或NULL。 </p>
<p>列表达式：
列表达式通过使用其名称来引用表中的列，该名称可以是完全限定名称，也可以是简单名称。</p>
<div class="highlight"><pre><span></span><code>column_expression ::= [keyspace_name.][table_name.][column_name]
</code></pre></div>
<p>常量表达式：
常量表达式通过使用文字来表示简单值。</p>
<div class="highlight"><pre><span></span><code>constant_expression ::= string | number
</code></pre></div>
<p>NULL：
当表达式（通常是列）没有值时，它表示为NULL。</p>
<div class="highlight"><pre><span></span><code>null_expression ::= NULL
</code></pre></div>
<h4 id="subscripted-expressions"><strong>Subscripted expressions</strong></h4>
<p>使用带下标的表达式可以访问多元素值中的元素，例如使用运算符[]访问映射集合。例如，如果ids指的是LIST类型的列，那么ids[7]指的是列表id的第7个元素，该元素可以在UPDATE语句中设置。 </p>
<ul>
<li>表达式只能应用于LIST、MAP或用户定义数据类型的列。 </li>
<li>使用非正索引LIST值将产生NULL。 </li>
<li>使用不存在的键的MAP值将产生NULL。否则，它将返回与给定键关联的元素值。 </li>
<li>Apache Cassandra不允许在select语句的选择列表中使用下标表达式。</li>
</ul>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE t(id INT PRIMARY KEY,cmap MAP&lt;TEXT, TEXT&gt;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE t SET cmap [&#39;key_value&#39;] = &#39;map_string&#39; WHERE id = 7;
</code></pre></div>
<h4 id="function-call"><strong>Function call</strong></h4>
<p>使用函数调用表达式将指定的函数应用于括号之间的给定参数，并返回计算结果。</p>
<div class="highlight"><pre><span></span><code>function_call ::= function_name &#39;(&#39; [ arguments ... ] &#39;)&#39;
</code></pre></div>
<p>1）内置函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>返回类型</th>
<th>参数类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>BlobAs<Type></td>
<td><Type></td>
<td>(BLOB)</td>
<td>从BLOB转换值</td>
</tr>
<tr>
<td><Type>AsBlob</td>
<td>BLOB</td>
<td>(<Type>)</td>
<td>将值转换为BLOB</td>
</tr>
<tr>
<td>DateOf</td>
<td>TIMESTAMP</td>
<td>(TIMEUUID)</td>
<td>转换</td>
</tr>
<tr>
<td>MaxTimeUuid</td>
<td>TIMEUUID</td>
<td>(TIMESTAMP)</td>
<td>返回关联的最大时间UUID</td>
</tr>
<tr>
<td>MinTimeUuid</td>
<td>TIMEUUID</td>
<td>(TIMESTAMP)</td>
<td>返回关联的最小时间UUID</td>
</tr>
<tr>
<td>CurrentDate</td>
<td>DATE</td>
<td>()</td>
<td>返回系统当前日期</td>
</tr>
<tr>
<td>CurrentTime</td>
<td>TIME</td>
<td>()</td>
<td>返回系统当前时间</td>
</tr>
<tr>
<td>CurrentTimestamp</td>
<td>TIMESTAMP</td>
<td>()</td>
<td>返回系统当前timestamp</td>
</tr>
<tr>
<td>Now</td>
<td>TIMEUUID</td>
<td>()</td>
<td>返回当前timestamp的UUID</td>
</tr>
<tr>
<td>TTL</td>
<td>BIGINT</td>
<td>(<AnyType>)</td>
<td>得到一个列的生命周期</td>
</tr>
<tr>
<td>ToDate</td>
<td>DATE</td>
<td>(TIMESTAMP)</td>
<td>转换</td>
</tr>
<tr>
<td>ToDate</td>
<td>DATE</td>
<td>(TIMEUUID)</td>
<td>转换</td>
</tr>
<tr>
<td>ToTime</td>
<td>TIME</td>
<td>(TIMESTAMP)</td>
<td>转换</td>
</tr>
<tr>
<td>ToTime</td>
<td>TIME</td>
<td>(TIMEUUID</td>
<td>转换</td>
</tr>
<tr>
<td>ToTimestamp</td>
<td>(TIMESTAMP)</td>
<td>(DATE)</td>
<td>转换</td>
</tr>
<tr>
<td>ToTimestamp</td>
<td>(TIMESTAMP)</td>
<td>(TIMEUUID)</td>
<td>转换</td>
</tr>
<tr>
<td>ToUnixTimestamp</td>
<td>BIGINT</td>
<td>(DATE)</td>
<td>转换</td>
</tr>
<tr>
<td>ToUnixTimestamp</td>
<td>BIGINT</td>
<td>(TIMESTAMP)</td>
<td>转换</td>
</tr>
<tr>
<td>ToUnixTimestamp</td>
<td>BIGINT</td>
<td>(TIMEUUID)</td>
<td>转换</td>
</tr>
<tr>
<td>UnixTimestampOf</td>
<td>BIGINT</td>
<td>(TIMEUUID)</td>
<td>转换</td>
</tr>
<tr>
<td>UUID</td>
<td>UUID</td>
<td>()</td>
<td>返回版本4的UUID</td>
</tr>
<tr>
<td>WriteTime</td>
<td>BIGINT</td>
<td>(<AnyType>)</td>
<td>返回写入列时的时间戳</td>
</tr>
<tr>
<td>partition_hash</td>
<td>BIGINT</td>
<td>()</td>
<td>计算一行的分区键列的分区哈希值（uint16）</td>
</tr>
</tbody>
</table>
<p>2）聚合函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>COUNT</td>
<td>返回所选行数</td>
</tr>
<tr>
<td>SUM</td>
<td>返回列值的总和</td>
</tr>
<tr>
<td>AVG</td>
<td>返回列值的平均值</td>
</tr>
<tr>
<td>MIN</td>
<td>返回列值的最小值</td>
</tr>
<tr>
<td>MAX</td>
<td>返回列值的最大值</td>
</tr>
</tbody>
</table>
<p>描述：</p>
<ul>
<li>参数数据类型必须可转换为函数定义指定的该参数的预期类型。 </li>
<li>函数执行将返回函数定义指定类型的值。 </li>
<li>AiSQL 允许在任何允许表达式的地方使用函数调用。</li>
</ul>
<p>3）CAST函数：
CAST函数将表列返回的值转换为指定的数据类型</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>cast_call ::= CAST &#39;(&#39; column AS type &#39;)&#39;
</code></pre></div>
<p>下表列出了列数据类型和目标数据类型。</p>
<table>
<thead>
<tr>
<th>源列数据类型</th>
<th>目标数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>BIGINT</td>
<td>SMALLINT, INT, TEXT</td>
</tr>
<tr>
<td>BOOLEAN</td>
<td>TEXT</td>
</tr>
<tr>
<td>DATE</td>
<td>TEXT, TIMESTAMP</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>BIGINT, INT, SMALLINT, TEXT</td>
</tr>
<tr>
<td>FLOAT</td>
<td>BIGINT, INT, SMALLINT, TEXT</td>
</tr>
<tr>
<td>INT</td>
<td>BIGINT, SMALLINT, TEXT</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>BIGINT, INT, TEXT</td>
</tr>
<tr>
<td>TIME</td>
<td>TEXT</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>DATE, TEXT</td>
</tr>
<tr>
<td>TIMEUUID</td>
<td>DATE, TIMESTAMP</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test_cast (k INT PRIMARY KEY, ts TIMESTAMP);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO test_cast (k, ts) VALUES (1, &#39;2018-10-09 12:00:00&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT CAST(ts AS DATE) FROM test_cast;
</code></pre></div>
<div class="highlight"><pre><span></span><code> cast(ts as date)
------------------
       2018-10-09
</code></pre></div>
<p>4）partition_hash函数：
partition_hash是一个函数，它将一行主键的分区键列作为参数，并返回一个uint16哈希值，该值表示用于对表进行分区的行的哈希值。用于分区的哈希值在0-65535（uint16）范围内。表被划分为多个分片，每个分片负责一系列的分区值。该行的partition_hash用于决定该行将驻留在哪个分片中。 
partition_hash对于查询数据的子集以获得近似的行计数或将完整的表操作分解为可以并行运行的较小子任务是有益的。</p>
<p>查询数据的子集 
partition_hash的一个用途是查询数据的子集，并获得表中的大致行数。例如，假设您有一个具有分区列（h1，h2）的表t，如下所示：</p>
<div class="highlight"><pre><span></span><code>create table t (h1 int, h2 int, r1 int, r2 int, v int, primary key ((h1, h2), r1, r2));
</code></pre></div>
<p>您可以使用此函数查询数据的子集（在本例中为数据的1/128），如下所示：</p>
<div class="highlight"><pre><span></span><code>select count(*) from t where partition_hash(h1, h2) &gt;= 0 and partition_hash(h1, h2) &lt; 512;
</code></pre></div>
<p>值512来自于将整个哈希分区范围除以要查询的子集数量（65536/128=512）</p>
<p>并行全表扫描 
要进行分布式扫描，在这种情况下，您可以发出128个查询，每个查询使用不同的哈希范围，如下所示：</p>
<div class="highlight"><pre><span></span><code>.. where partition_hash(h1, h2) &gt;= 0 and partition_hash(h1, h2) &lt; 512;
</code></pre></div>
<div class="highlight"><pre><span></span><code>.. where partition_hash(h1, h2) &gt;= 512 and partition_hash(h1, h2) &lt;1024 ;
</code></pre></div>
<p>以此类推，直到分区空间中512的最后一个段/范围：</p>
<div class="highlight"><pre><span></span><code>.. where partition_hash(h1, h2) &gt;= 65024;
</code></pre></div>
<p>5）WriteTime 函数：</p>
<p>WriteTime函数返回写入列时的时间戳（以微秒为单位）。例如，假设您有一个表page_views，其中有一列名为views：</p>
<div class="highlight"><pre><span></span><code> SELECT writetime(views) FROM page_views;

 writetime(views)
------------------
 1572882871160113

(1 rows)
</code></pre></div>
<p>6）TTL函数
TTL函数返回列或行过期之前的秒数。假设您有一个表page_views和一个名为views的列： </p>
<div class="highlight"><pre><span></span><code>SELECT TTL(views) FROM page_views;

 ttl(views)
------------
      86367

(1 rows)
</code></pre></div>
<h4 id="operators"><strong>Operators</strong></h4>
<p>带运算符的表达式是一种使用内置运算符组合多个表达式的复合表达式。以下部分讨论AiSQL 中的BCQL运算符</p>
<p>1）Null 操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>EXISTS, NOT EXISTS</td>
<td>行存在的谓词</td>
</tr>
</tbody>
</table>
<p>EXISTS和NOT EXISTS只能在IF子句中使用</p>
<p>2）一元运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>数字否定</td>
</tr>
<tr>
<td>+</td>
<td>无操作</td>
</tr>
<tr>
<td>NOT</td>
<td>逻辑(boolean) 否定</td>
</tr>
</tbody>
</table>
<p>Unary - and + can only be used with constant expressions such as -77</p>
<p>一元 - 和 + 只能与常量表达式一起使用，例如：-77</p>
<p>3）二进制运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>OR, AND</td>
<td>逻辑(boolean) 表达式</td>
</tr>
<tr>
<td>=, !=, &lt;, &lt;=, &gt;, &gt;=</td>
<td>比较表达式</td>
</tr>
<tr>
<td>+</td>
<td>添加、追加或前置</td>
</tr>
<tr>
<td>-</td>
<td>减法或删除</td>
</tr>
<tr>
<td>*</td>
<td>乘法。尚未支持</td>
</tr>
<tr>
<td>/</td>
<td>除法。尚未支持</td>
</tr>
<tr>
<td>ISNULL, IS NOT NULL</td>
<td>尚未支持比较表达式。</td>
</tr>
</tbody>
</table>
<ul>
<li>比较运算符的第一个参数必须是列。例如，column_name=7。 </li>
<li>将NULL与其他值进行比较总是会产生一个错误的值。与NULL进行比较时，必须使用运算符ISNULL或IS NULL。 </li>
<li>当 + 和 - 应用于COUNTER数据类型的NULL参数时，NULL表达式将在计算前替换为零值。当这些运算符应用于所有其他数字数据类型的NULL表达式时，计算值始终为NULL。 </li>
<li>运算符 + 在LIST前面加一个值或将其附加到LIST中，而运算符 - 从LIST中删除元素。 </li>
<li>运算符 + 在MAP中插入新的不同元素，而运算符 - 从中删除元素。</li>
</ul>
<h4 id="blob_1"><strong>BLOB</strong></h4>
<p>使用BLOB数据类型表示可变长度的任意二进制数据。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>type_specification ::= BLOB

blob_literal ::= &quot;0x&quot; [ hex_digit hex_digit ...]
</code></pre></div>
<ul>
<li>
<p>hex_digit是一个十六进制数字（[0-9a-fA-F]）。</p>
</li>
<li>
<p>BLOB类型的列可以是PRIMARY KEY的一部分。 </p>
</li>
<li>隐含地说，BLOB数据类型既不能转换，也不能与其他数据类型进行比较。 </li>
<li>提供了两个内置函数BlobAs＜Type＞和＜Type＞AsBlob，用于BLOB和其他数据类型之间的转换。 </li>
<li>BLOB大小几乎是无限的。</li>
</ul>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE messages(id INT PRIMARY KEY, content BLOB);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO messages (id, content) VALUES (1, 0xab00ff);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO messages (id, content) VALUES (2, 0x);
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE messages SET content = 0x0f0f WHERE id = 2;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM messages;
</code></pre></div>
<div class="highlight"><pre><span></span><code> id | content
----+----------
  2 |   0x0f0f
  1 | 0xab00ff
</code></pre></div>
<h4 id="boolean_1"><strong>BOOLEAN</strong></h4>
<p>使用BOOLEAN数据类型指定true或false值。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>type_specification ::= BOOLEAN

boolean_literal ::= TRUE | FALSE
</code></pre></div>
<p>描述：</p>
<ul>
<li>BOOLEAN类型的列不能是PRIMARY KEY的一部分。 </li>
<li>BOOLEAN类型的列可以设置、插入和比较。 </li>
<li>在WHERE和IF子句中，BOOLEAN列不能用作独立表达式。它们必须与真或假进行比较。例如，WHERE boolean_column=TRUE有效，而WHERE boolean_column无效。 </li>
<li>隐含地说，BOOLEAN既不可与任何其他数据类型进行比较，也不可转换。</li>
</ul>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE tasks (id INT PRIMARY KEY, finished BOOLEAN);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO tasks (id, finished) VALUES (1, false);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO tasks (id, finished) VALUES (2, false);
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE tasks SET finished = true WHERE id = 2;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM tasks;
</code></pre></div>
<div class="highlight"><pre><span></span><code>id | finished
----+----------
  2 |     True
  1 |    False
</code></pre></div>
<h4 id="collection"><strong>Collection</strong></h4>
<p>使用集合数据类型为可以包含多个值的数据对象指定列。</p>
<p>1）LIST</p>
<p>LIST是元素的有序集合。LIST中的所有元素都必须具有相同的基元类型。元素可以通过+运算符前置或追加到列表中，通过-运算符移除，并通过[]运算符由该列表的索引引用。</p>
<p>2）MAP
MAP是元素对、键和值的排序集合。排序顺序基于键值，并且取决于实现。MAP中的元素可以通过它们的键值由[]运算符设置，由+运算符添加，并由-运算符删除。查询时，映射的元素对将按排序顺序返回。 </p>
<p>3）SET
SET是一个经过排序的元素集合。排序顺序取决于实现。元素可以通过+运算符添加，也可以通过-运算符删除。查询时，集合的元素将按排序顺序返回。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>type_specification ::= { LIST&lt;type&gt; | MAP&lt;key_type:type&gt; | SET&lt;key_type&gt; }

list_literal ::= &#39;[&#39; [ expression ...] &#39;]&#39;

map_literal ::= &#39;{&#39; [ { expression &#39;:&#39; expression } ...] &#39;}&#39;

set_literal ::= &#39;{&#39; [ expression ...] &#39;}&#39;
</code></pre></div>
<ul>
<li>LIST、MAP或SET类型的列不能是PRIMARY KEY的一部分。 </li>
<li>类型必须是非参数化数据类型或frozen 数据类型。 </li>
<li>key_type必须是主键中允许的任何数据类型（当前为FROZEN和除BOOL以外的所有非参数数据类型）。 </li>
<li>对于map_lilateral，左侧表达式表示键，右侧表达式表示值。 </li>
<li>表达式是任何形式良好的BCQL表达式。</li>
</ul>
<p>描述：</p>
<ul>
<li>类型参数必须是简单类型或frozen 类型（集合和用户定义的类型必须冻结才能用作集合参数）。 </li>
<li>LIST、MAP和SET类型的列不能是PRIMARY KEY的一部分。 </li>
<li>隐含地说，集合数据类型的值既不能转换，也不能与其他数据类型进行比较。 </li>
<li>集合文字中的每个表达式都必须计算为可转换为相应参数数据类型的值。 </li>
<li>不允许对集合值进行比较（例如，在WHERE或IF子句中）。 </li>
<li>空集合被视为null 值。</li>
</ul>
<p>示例：
1）建表
集合类型与简单类型一样使用（主键中不允许使用集合类型）。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE users(username TEXT PRIMARY KEY,
                                  emails SET&lt;TEXT&gt;,
                                  phones MAP&lt;TEXT,TEXT&gt;,
                                  top_cities LIST&lt;TEXT&gt;);
</code></pre></div>
<p>2）插入数据
集合值是通过一次设置其所有元素来插入的。</p>
<div class="highlight"><pre><span></span><code>INSERT INTO users(username, emails, phones, top_cities)
               VALUES (&#39;foo&#39;,
                       {&#39;c@example.com&#39;, &#39;a@example.com&#39;},
                       {&#39;home&#39; : &#39;999-9999&#39;, &#39;mobile&#39; : &#39;000-0000&#39;},
                       [&#39;New York&#39;, &#39;Paris&#39;]);
</code></pre></div>
<p>空集合与null集合相同。</p>
<div class="highlight"><pre><span></span><code>INSERT INTO users(username, emails, phones, top_cities) VALUES (&#39;bar&#39;, { }, { }, [ ]);
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM users;
</code></pre></div>
<div class="highlight"><pre><span></span><code>username | emails                             | phones                                     | top_cities
----------+------------------------------------+--------------------------------------------+-----------------------
      bar |                               null |                                       null |                  null
      foo | {&#39;a@example.com&#39;, &#39;c@example.com&#39;} | {&#39;home&#39;: &#39;999-9999&#39;, &#39;mobile&#39;: &#39;000-0000&#39;} | [&#39;New York&#39;, &#39;Paris&#39;]
</code></pre></div>
<p>3）更新列
集合值可以通过一次设置其所有元素来更新。</p>
<div class="highlight"><pre><span></span><code>UPDATE users SET emails = {&#39;bar@example.com&#39;} WHERE username = &#39;bar&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE users SET phones = {&#39;home&#39; : &#39;123-45678&#39;} WHERE username = &#39;bar&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE users SET top_cities = [&#39;London&#39;, &#39;Tokyo&#39;] WHERE username = &#39;bar&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM users;
</code></pre></div>
<div class="highlight"><pre><span></span><code> username | emails                             | phones                                     | top_cities
----------+------------------------------------+--------------------------------------------+-----------------------
      bar |                {&#39;bar@example.com&#39;} |                      {&#39;home&#39;: &#39;123-45678&#39;} |   [&#39;London&#39;, &#39;Tokyo&#39;]
      foo | {&#39;a@example.com&#39;, &#39;c@example.com&#39;} | {&#39;home&#39;: &#39;999-9999&#39;, &#39;mobile&#39;: &#39;000-0000&#39;} | [&#39;New York&#39;, &#39;Paris&#39;]
</code></pre></div>
<p>4）表达式</p>
<p>集合元素可以用+添加，也可以用-删除。</p>
<div class="highlight"><pre><span></span><code>UPDATE users SET emails = emails + {&#39;foo@example.com&#39;} WHERE username = &#39;foo&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE users SET emails = emails - {&#39;a@example.com&#39;, &#39;c.example.com&#39;} WHERE username = &#39;foo&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE users SET phones = phones + {&#39;office&#39; : &#39;333-3333&#39;} WHERE username = &#39;foo&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM users;
</code></pre></div>
<div class="highlight"><pre><span></span><code>username | emails                               | phones                                                           | top_cities
----------+--------------------------------------+------------------------------------------------------------------+-----------------------
      bar |                  {&#39;bar@example.com&#39;} |                                            {&#39;home&#39;: &#39;123-45678&#39;} |   [&#39;London&#39;, &#39;Tokyo&#39;]
      foo | {&#39;c@example.com&#39;, &#39;foo@example.com&#39;} | {&#39;home&#39;: &#39;999-9999&#39;, &#39;mobile&#39;: &#39;000-0000&#39;, &#39;office&#39;: &#39;333-3333&#39;} | [&#39;New York&#39;, &#39;Paris&#39;]
</code></pre></div>
<p>要删除地图元素，只需要给出相关的键（作为一个集合）。</p>
<div class="highlight"><pre><span></span><code>UPDATE users SET phones = phones - {&#39;home&#39;} WHERE username = &#39;foo&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM users;
</code></pre></div>
<div class="highlight"><pre><span></span><code>username | emails                               | phones                                       | top_cities
----------+--------------------------------------+----------------------------------------------+-----------------------
      bar |                  {&#39;bar@example.com&#39;} |                        {&#39;home&#39;: &#39;123-45678&#39;} |   [&#39;London&#39;, &#39;Tokyo&#39;]
      foo | {&#39;c@example.com&#39;, &#39;foo@example.com&#39;} | {&#39;mobile&#39;: &#39;000-0000&#39;, &#39;office&#39;: &#39;333-3333&#39;} | [&#39;New York&#39;, &#39;Paris&#39;]
</code></pre></div>
<p>列表元素可以是前置的，也可以是附加的。</p>
<div class="highlight"><pre><span></span><code>UPDATE users SET top_cities = top_cities + [&#39;Delhi&#39;] WHERE username = &#39;foo&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE users SET top_cities = [&#39;Sunnyvale&#39;] + top_cities WHERE username = &#39;foo&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE users SET top_cities = top_cities - [&#39;Paris&#39;, &#39;New York&#39;] WHERE username = &#39;foo&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM users;
</code></pre></div>
<div class="highlight"><pre><span></span><code>username | emails              | phones                                       | top_cities
----------+---------------------+----------------------------------------------+------------------------
      bar | {&#39;bar@example.com&#39;} |                        {&#39;home&#39;: &#39;123-45678&#39;} |    [&#39;London&#39;, &#39;Tokyo&#39;]
      foo | {&#39;foo@example.com&#39;} | {&#39;mobile&#39;: &#39;000-0000&#39;, &#39;office&#39;: &#39;333-3333&#39;} | [&#39;Sunnyvale&#39;, &#39;Delhi&#39;]
</code></pre></div>
<p>5）更新map和list元素</p>
<p>Map允许按键引用元素</p>
<div class="highlight"><pre><span></span><code>UPDATE users SET phones[&#39;mobile&#39;] = &#39;111-1111&#39; WHERE username = &#39;foo&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE users SET phones[&#39;mobile&#39;] = &#39;345-6789&#39; WHERE username = &#39;bar&#39; IF phones[&#39;mobile&#39;] = null;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM users;
</code></pre></div>
<div class="highlight"><pre><span></span><code>username | emails                               | phones                                       | top_cities
----------+--------------------------------------+----------------------------------------------+-----------------------
      bar |                  {&#39;bar@example.com&#39;} |  {&#39;home&#39;: &#39;123-45678&#39;, &#39;mobile&#39;: &#39;345-6789&#39;} |   [&#39;London&#39;, &#39;Tokyo&#39;]
      foo | {&#39;c@example.com&#39;, &#39;foo@example.com&#39;} | {&#39;mobile&#39;: &#39;111-1111&#39;, &#39;office&#39;: &#39;333-3333&#39;} | [&#39;New York&#39;, &#39;Paris&#39;]
</code></pre></div>
<p>list允许按索引引用元素（编号从0开始）。</p>
<div class="highlight"><pre><span></span><code>UPDATE users SET top_cities[0] = &#39;San Francisco&#39; WHERE username = &#39;bar&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE users SET top_cities[1] = &#39;Mumbai&#39; WHERE username = &#39;bar&#39; IF top_cities[1] = &#39;Tokyo&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM users;
</code></pre></div>
<div class="highlight"><pre><span></span><code>username | emails                               | phones                                       | top_cities
----------+--------------------------------------+----------------------------------------------+-----------------------------
      bar |                  {&#39;bar@example.com&#39;} |  {&#39;home&#39;: &#39;123-45678&#39;, &#39;mobile&#39;: &#39;345-6789&#39;} | [&#39;San Francisco&#39;, &#39;Mumbai&#39;]
      foo | {&#39;c@example.com&#39;, &#39;foo@example.com&#39;} | {&#39;mobile&#39;: &#39;111-1111&#39;, &#39;office&#39;: &#39;333-3333&#39;} |       [&#39;New York&#39;, &#39;Paris&#39;]
</code></pre></div>
<h4 id="frozen_1"><strong>FROZEN</strong></h4>
<p>使用FROZEN数据类型指定序列化集合、元组或用户定义类型所产生的二进制字符串列</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>type_specification ::= FROZEN&lt;type&gt;
</code></pre></div>
<p>type是一个格式良好的BCQL数据类型（下面的语义部分介绍了对type的其他限制）。</p>
<ul>
<li>FROZEN类型的列可以是PRIMARY KEY的一部分。 </li>
<li>FROZEN类型的类型参数必须是集合类型（LIST、MAP或SET）或用户定义的类型。 </li>
<li>FROZEN类型可以是集合类型的参数。 </li>
<li>对于任何有效的frozen 类型参数类型，类型的值都可以转换为frozen＜type＞。</li>
</ul>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE directory(file FROZEN&lt;LIST&lt;TEXT&gt;&gt; PRIMARY KEY, value BLOB);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO directory(file, value) VALUES([ &#39;home&#39;, &#39;documents&#39;, &#39;homework.doc&#39; ], 0x);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO directory(file, value) VALUES([ &#39;home&#39;, &#39;downloads&#39;, &#39;textbook.pdf&#39; ], 0x12ab21ef);
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE directory SET value = 0xab00ff WHERE file = [ &#39;home&#39;, &#39;documents&#39;, &#39;homework.doc&#39; ];
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM directory;
</code></pre></div>
<div class="highlight"><pre><span></span><code> file                                  | value
---------------------------------------+------------
 [&#39;home&#39;, &#39;downloads&#39;, &#39;textbook.pdf&#39;] | 0x12ab21ef
 [&#39;home&#39;, &#39;documents&#39;, &#39;homework.doc&#39;] |   0xab00ff
</code></pre></div>
<h4 id="inet_1"><strong>INET</strong></h4>
<p>使用INET数据类型为IP地址的数据指定列。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>type_specification ::= INET
</code></pre></div>
<ul>
<li>INET类型的列可以是PRIMARY KEY的一部分。 </li>
<li>隐含地说，类型INET数据类型的值既不能转换，也不能与其他数据类型进行比较。 </li>
<li>具有正确格式的文本数据类型的值可转换为INET。 </li>
<li>INET值格式支持IPv4和IPv6地址的文本文本。</li>
</ul>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE dns_table(site_name TEXT PRIMARY KEY, ip_address INET);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO dns_table(site_name, ip_address) VALUES (&#39;localhost&#39;, &#39;127.0.0.1&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO dns_table(site_name, ip_address) VALUES (&#39;example.com&#39;, &#39;93.184.216.34&#39;);
</code></pre></div>
<p>INET类型同时支持ipv4和ipv6地址。</p>
<div class="highlight"><pre><span></span><code>UPDATE dns_table SET ip_address = &#39;2606:2800:220:1:248:1893:25c8:1946&#39; WHERE site_name = &#39;example.com&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM dns_table;
</code></pre></div>
<div class="highlight"><pre><span></span><code> site_name   | ip_address
-------------+------------------------------------
 example.com | 2606:2800:220:1:248:1893:25c8:1946
   localhost |                          127.0.0.1
</code></pre></div>
<h4 id="integer-and-counter_1"><strong>Integer and counter</strong></h4>
<p>对于不同值范围的整数，有几种不同的数据类型。整数可以设置、插入、递增和递减，而COUNTER只能递增或递减。我们扩展了Apache Cassandra，以支持整数数据类型的递增和递减运算符。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>最小</th>
<th>最大</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>-128</td>
<td>127</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>-32,768</td>
<td>32,767</td>
</tr>
<tr>
<td>INT or INTEGER</td>
<td>-2,147,483,648</td>
<td>2,147,483,647</td>
</tr>
<tr>
<td>BIGINT</td>
<td>–9,223,372,036,854,775,808</td>
<td>9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>COUNTER</td>
<td>–9,223,372,036,854,775,808</td>
<td>9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>VARINT</td>
<td>无限的</td>
<td>无限的</td>
</tr>
</tbody>
</table>
<p>以下关键字用于为不同约束（包括其值范围）指定整数类型的列。</p>
<div class="highlight"><pre><span></span><code>type_specification ::= TINYINT | SMALLINT | INT | INTEGER | BIGINT | VARINT | COUNTER

integer_literal ::= [ + | - ] digit [ { digit | , } ... ]
</code></pre></div>
<ul>
<li>TINYINT、SMALLINT、INT、INTEGER、BIGINT或VARINT类型的列可以是PRIMARY KEY的一部分。 </li>
<li>不同整数数据类型的值可以相互比较和转换。 </li>
<li>整数数据类型的值是可转换的，但不能与浮点数进行比较。 </li>
<li>浮点数据类型的值不能转换为整数。</li>
</ul>
<p>COUNTER数据类型：
COUNTER是BIGINT的别名，但有其他约束。 </p>
<ul>
<li>COUNTER类型的列不能是PRIMARY KEY的一部分。 </li>
<li>如果列的类型为COUNTER，则所有非主键列的类型也必须为COUNTER。 </li>
<li>无法设置或插入类型为COUNTER的列。它们必须递增或递减。 </li>
<li>如果COUNTER类型的列为NULL，则在递增或递减时将其值替换为零。</li>
</ul>
<p>示例：
1）使用整数数据类型</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE items(id INT PRIMARY KEY, item_count BIGINT);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO items(id, item_count) VALUES(1, 1);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO items(id, item_count) VALUES(2, 2);
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE items SET item_count = 5 WHERE id = 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE items SET item_count = item_count + 1 WHERE id = 2;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM items;
</code></pre></div>
<div class="highlight"><pre><span></span><code> id | item_count
----+------------
  2 |          3
  1 |          5
</code></pre></div>
<p>2）使用COUNTER数据类型</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE item_counters(id INT PRIMARY KEY, item_counter COUNTER);
</code></pre></div>
<p>对于计数器类型，null值被视为0。</p>
<div class="highlight"><pre><span></span><code>UPDATE item_counters SET item_counter = item_counter + 1 WHERE id = 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM item_counters;
</code></pre></div>
<div class="highlight"><pre><span></span><code> id | item_counter
----+--------------
  1 |            1
</code></pre></div>
<h4 id="non-integer"><strong>Non-integer</strong></h4>
<p>使用非整数（浮点和定点）数据类型可以指定非整数。不同的浮点数据类型表示不同的精度数字。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>小数精度</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLOAT</td>
<td>32位浮点数字不精确</td>
<td>7</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>32位浮点数字不精确</td>
<td>15</td>
</tr>
<tr>
<td>DECIMAL</td>
<td>任意精度数字</td>
<td>无上限</td>
</tr>
</tbody>
</table>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>type_specification ::= { FLOAT | DOUBLE | DOUBLE PRECISION | DECIMAL }

non_integer_floating_point_literal ::= non_integer_fixed_point_literal | &quot;NaN&quot; | &quot;Infinity&quot; | &quot;-Infinity&quot;

non_integer_fixed_point_literal ::= [ + | - ] { digit [ digit ...] &#39;.&#39; [ digit ...] | &#39;.&#39; digit [ digit ...] }
</code></pre></div>
<ul>
<li>类型为FLOAT、DOUBLE、DOUBLE PRECISION或DECIMAL的列可以是PRIMARY KEY的一部分。 </li>
<li>DOUBLE和DOUBLE PRECISION是别名。 </li>
<li>non_integer_floating_point_literal用于FLOAT、DOUBLE和DOUBLE PRECISION类型的值。 </li>
<li>non_integer_fixed_point_literal用于DECIMAL类型的值。</li>
</ul>
<p>描述：</p>
<ul>
<li>不同浮点和定点数据类型的值可以相互比较和转换。 </li>
<li>从浮点类型转换为DECIMAL将引发特殊值NaN、无穷大和-无穷大的错误。 </li>
<li>非整数数字数据类型的值既不能与整数进行比较，也不能转换为整数，尽管整数可以转换为整数。 </li>
<li>特殊浮点值的顺序定义为（按升序）：-无穷大，所有负值按顺序，所有正值按顺序，无穷大和NaN。</li>
</ul>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sensor_data (sensor_id INT PRIMARY KEY, float_val FLOAT, dbl_val DOUBLE, dec_val DECIMAL);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO sensor_data(sensor_id, float_val, dbl_val, dec_val)
                  VALUES (1, 321.0456789, 321.0456789, 321.0456789);
</code></pre></div>
<p>也可以使用整数文字（使用upsert 语义来更新不存在的行）</p>
<div class="highlight"><pre><span></span><code>UPDATE sensor_data SET float_val = 1, dbl_val = 1, dec_val = 1 WHERE sensor_id = 2;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM sensor_data;
</code></pre></div>
<div class="highlight"><pre><span></span><code> sensor_id | float_val | dbl_val   | dec_val
-----------+-----------+-----------+-------------
         2 |         1 |         1 |           1
         1 | 321.04568 | 321.04568 | 321.0456789
</code></pre></div>
<h4 id="text"><strong>TEXT</strong></h4>
<p>使用TEXT数据类型可以指定Unicode字符字符串的数据。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>type_specification ::= TEXT | VARCHAR

text_literal ::= &quot;&#39;&quot; [ letter ...] &quot;&#39;&quot;
</code></pre></div>
<ul>
<li>TEXT和VARCHAR是别名。 </li>
<li>字母是除单引号（[^']）以外的任何字符</li>
</ul>
<p>描述：</p>
<ul>
<li>TEXT或VARCHAR类型的列可以是PRIMARY KEY的一部分。 </li>
<li>隐含地说，TEXT数据类型类型的值既不能转换，也不能与非文本数据类型进行比较。 </li>
<li>TEXT字符串的长度实际上是无限的。</li>
</ul>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE users(user_name TEXT PRIMARY KEY, full_name VARCHAR);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO users(user_name, full_name) VALUES (&#39;jane&#39;, &#39;Jane Doe&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO users(user_name, full_name) VALUES (&#39;john&#39;, &#39;John Doe&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE users set full_name = &#39;Jane Poe&#39; WHERE user_name = &#39;jane&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM users;
</code></pre></div>
<div class="highlight"><pre><span></span><code> user_name | full_name
-----------+-----------
      jane |  Jane Poe
      john |  John Doe
</code></pre></div>
<h4 id="date-time-and-timestamp"><strong>DATE, TIME, and TIMESTAMP</strong></h4>
<p>使用日期时间数据类型可以指定时区的日期和时间数据，指定特定日期的date数据，指定一天中的时间的time数据，以及指定日期和时间组合的TIMESTAMP数据。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>type_specification ::= TIMESTAMP | DATE | TIME
</code></pre></div>
<ul>
<li>DATE、TIME和TIMESTAMP类型的列可以是PRIMARY KEY的一部分。 </li>
<li>隐含地说，日期时间类型的值不能转换或与其他数据类型进行比较。 </li>
<li>具有正确格式（如上所述）的整数和文本数据类型的值可转换为日期时间类型。 </li>
<li>支持的时间戳范围是从1900年到9999年。 </li>
<li>小时、分钟、秒和毫秒组件的默认值为0。 </li>
<li>默认时区为UTC。</li>
</ul>
<p>1）DATE
日期使用32位无符号整数表示，该整数表示自epoch（1970年1月1日）以来的天数，没有相应的时间值。使用INSERT或UPDATE将值添加为整数（自epoch以来的天数）或以下所示的字符串格式。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>yyyy-mm-dd
</code></pre></div>
<ul>
<li>yyyy: 四位数的年</li>
<li>mm: 两位数的月</li>
<li>dd: 两位数的日</li>
</ul>
<p>例如： 2020-07-29</p>
<p>2）TIME
时间数据类型的值被编码为64位有符号整数，表示自午夜以来的纳秒数，没有相应的日期值。 
使用INSERT或UPDATE以以下字符串格式添加值，其中毫秒（f）是可选的，如果提供，则可以小于纳秒</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>hh:mm:ss[.fffffffff]
</code></pre></div>
<ul>
<li>hh：两位数的小时，使用24小时制时钟。 </li>
<li>mm：两位数的分钟。 </li>
<li>ss：两位数的秒。 </li>
<li>fffffffff：（可选）三位数的毫秒或纳秒。排除时，设置为0。</li>
</ul>
<p>例如： 12:34:56 或12:34:56.789 或12:34:56.123456789</p>
<p>3）TIMESTAMP
时间戳数据类型的值以ISO 8601格式组合了日期、时间和时区。 
使用INSERT或UPDATE以如下所示的字符串格式添加值，其中毫秒（f）是可选的</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>yyyy-mm-dd[ (T| )HH:MM[:SS][.fff]][(+|-)NNNN]
</code></pre></div>
<p>必填日期（yyyy-mm-dd），其中： </p>
<ul>
<li>yyyy：四位数年份。 </li>
<li>mm：两位数的月份。 </li>
<li>dd：两位数的天。 </li>
</ul>
<p>可选时间（HH:MM[：SS][.fff]），其中： </p>
<ul>
<li>HH：两位数的小时，使用24小时制时钟。 </li>
<li>MM：两位数的分钟数。 </li>
<li>SS：（可选）两位数秒。 </li>
<li>fff：（可选）三位数的毫秒。排除时，设置为0。</li>
</ul>
<p>可选时区（（+|-）NNNN），其中： </p>
<ul>
<li>+|-：将NNNN与GMT相加或相减 </li>
<li>NNNN：4位时区（RFC 822）。例如，+0000是GMT，-0800是PST。 
  NNNN是RFC-822的4位时区，例如+0000是GMT，-0800是PST。 </li>
</ul>
<p>例如，对于July 29, 2020太平洋标准时间午夜，有效的时间戳值包括2020-07-29 12:34:56.789+0000、2020-07-29 12:34:56.789、2020-07-29 12:34:56和2020-07-29</p>
<p>示例：</p>
<p>1）使用日期和时间类型</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE orders(customer_id INT, order_date DATE, order_time TIME, amount DECIMAL, PRIMARY KEY ((customer_id), order_date, order_time));
</code></pre></div>
<p>可以使用currentdate 和currenttime 标准函数插入日期和时间值。</p>
<div class="highlight"><pre><span></span><code>INSERT INTO orders(customer_id, order_date, order_time, amount) VALUES (1, currentdate(), currenttime(), 85.99);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO orders(customer_id, order_date, order_time, amount) VALUES (1, currentdate(), currenttime(), 34.15);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO orders(customer_id, order_date, order_time, amount) VALUES (2, currentdate(), currenttime(), 55.45);
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM orders;
</code></pre></div>
<div class="highlight"><pre><span></span><code> customer_id | order_date | order_time         | amount
-------------+------------+--------------------+--------
           1 | 2018-10-09 | 17:12:25.824094000 |  85.99
           1 | 2018-10-09 | 17:12:56.350031000 |  34.15
           2 | 2018-10-09 | 17:13:15.203633000 |  55.45
</code></pre></div>
<p>日期值可以使用日期时间文本给出。</p>
<div class="highlight"><pre><span></span><code>SELECT sum(amount) FROM orders WHERE customer_id = 1 AND order_date = &#39;2018-10-09&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code> system.sum(amount)
--------------------
             120.14
</code></pre></div>
<p>2）使用timestamp 类型</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sensor_data(sensor_id INT, ts TIMESTAMP, value FLOAT, PRIMARY KEY(sensor_id, ts));
</code></pre></div>
<p>时间戳值可以使用日期-时间文本给出。</p>
<div class="highlight"><pre><span></span><code>INSERT INTO sensor_data(sensor_id, ts, value) VALUES (1, &#39;2017-07-04 12:30:30 UTC&#39;, 12.5);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO sensor_data(sensor_id, ts, value) VALUES (1, &#39;2017-07-04 12:31 UTC&#39;, 13.5);
</code></pre></div>
<p>时间戳值也可以给定为整数（从epoch开始的毫秒）。</p>
<div class="highlight"><pre><span></span><code>INSERT INTO sensor_data(sensor_id, ts, value) VALUES (2, 1499171430000, 20);
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM sensor_data;
</code></pre></div>
<div class="highlight"><pre><span></span><code> sensor_id | ts                              | value
-----------+---------------------------------+-------
         2 | 2017-07-04 12:30:30.000000+0000 |    20
         1 | 2017-07-04 12:30:30.000000+0000 |  12.5
         1 | 2017-07-04 12:31:00.000000+0000 |  13.5
</code></pre></div>
<p>3）支持的时间戳文字</p>
<div class="highlight"><pre><span></span><code>&#39;1992-06-04 12:30&#39;
&#39;1992-6-4 12:30&#39;
&#39;1992-06-04 12:30+04:00&#39;
&#39;1992-6-4 12:30-04:30&#39;
&#39;1992-06-04 12:30 UTC+04:00&#39;
&#39;1992-6-4 12:30 UTC-04:30&#39;
&#39;1992-06-04 12:30.321&#39;
&#39;1992-6-4 12:30.12&#39;
&#39;1992-06-04 12:30.321+04:00&#39;
&#39;1992-6-4 12:30.12-04:30&#39;
&#39;1992-06-04 12:30.321 UTC+04:00&#39;
&#39;1992-6-4 12:30.12 UTC-04:30&#39;
&#39;1992-06-04 12:30:45&#39;
&#39;1992-6-4 12:30:45&#39;
&#39;1992-06-04 12:30:45+04:00&#39;
&#39;1992-6-4 12:30:45-04:30&#39;
&#39;1992-06-04 12:30:45 UTC+04:00&#39;
&#39;1992-6-4 12:30:45 UTC-04:30&#39;
&#39;1992-06-04 12:30:45.321&#39;
&#39;1992-6-4 12:30:45.12&#39;
&#39;1992-06-04 12:30:45.321+04:00&#39;
&#39;1992-6-4 12:30:45.12-04:30&#39;
&#39;1992-06-04 12:30:45.321 UTC+04:00&#39;
&#39;1992-6-4 12:30:45.12 UTC-04:30&#39;
&#39;1992-06-04T12:30&#39;
&#39;1992-6-4T12:30&#39;
&#39;1992-06-04T12:30+04:00&#39;
&#39;1992-6-4T12:30-04:30&#39;
&#39;1992-06-04T12:30 UTC+04:00&#39;
&#39;1992-6-4T12:30TUTC-04:30&#39;
&#39;1992-06-04T12:30.321&#39;
&#39;1992-6-4T12:30.12&#39;
&#39;1992-06-04T12:30.321+04:00&#39;
&#39;1992-6-4T12:30.12-04:30&#39;
&#39;1992-06-04T12:30.321 UTC+04:00&#39;
&#39;1992-6-4T12:30.12 UTC-04:30&#39;
&#39;1992-06-04T12:30:45&#39;
&#39;1992-6-4T12:30:45&#39;
&#39;1992-06-04T12:30:45+04:00&#39;
&#39;1992-6-4T12:30:45-04:30&#39;
&#39;1992-06-04T12:30:45 UTC+04:00&#39;
&#39;1992-6-4T12:30:45 UTC-04:30&#39;
&#39;1992-06-04T12:30:45.321&#39;
&#39;1992-6-4T12:30:45.12&#39;
&#39;1992-06-04T12:30:45.321+04:00&#39;
&#39;1992-6-4T12:30:45.12-04:30&#39;
&#39;1992-06-04T12:30:45.321 UTC+04:00&#39;
&#39;1992-6-4T12:30:45.12 UTC-04:30&#39;
&#39;1992-06-04&#39;
&#39;1992-6-4&#39;
&#39;1992-06-04+04:00&#39;
&#39;1992-6-4-04:30&#39;
&#39;1992-06-04 UTC+04:00&#39;
&#39;1992-6-4 UTC-04:30&#39;
</code></pre></div>
<h4 id="uuid-and-timeuuid_1"><strong>UUID and TIMEUUID</strong></h4>
<p>使用UUID数据类型为具有通用唯一ID的数据指定列。TIMEUUID 是一个通用的唯一标识符，包括时间信息。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>UUID</td>
<td>UUID</td>
</tr>
<tr>
<td>TIMEUUID</td>
<td>UUID</td>
</tr>
</tbody>
</table>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>type_specification ::= { UUID | TIMEUUID }
uuid_literal ::= 4hex_block 4hex_block &#39;-&#39; 4hex_block &#39;-&#39; 4hex_block &#39;-&#39; 4hex_block &#39;-&#39; 4hex_block 4hex_block 4hex_block
4hex_block ::= hex_digit hex_digit hex_digit hex_digit
</code></pre></div>
<ul>
<li>hex_digit是一个十六进制数字（[0-9a-fA-F]）。</li>
</ul>
<p>描述：</p>
<ul>
<li>UUID或TIMEUUID类型的列可以是PRIMARY KEY的一部分。 </li>
<li>隐含地说，类型UUID和TIMEUUID数据类型的值既不能转换，也不能与其他数据类型进行比较。 </li>
<li>TIMEUUID是UUID：它们包括生成的日期和时间以及空间唯一的节点标识符。 </li>
<li>TIMEUUID值的比较首先比较时间，然后（如果时间相等）比较节点标识符。</li>
</ul>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE devices(id UUID PRIMARY KEY, ordered_id TIMEUUID);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO devices (id, ordered_id)
       VALUES (123e4567-e89b-12d3-a456-426655440000, 123e4567-e89b-12d3-a456-426655440000);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO devices (id, ordered_id)
       VALUES (123e4567-e89b-42d3-a456-426655440000, 123e4567-e89b-12d3-a456-426655440000);
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE devices SET ordered_id = 00000000-0000-1000-0000-000000000000
        WHERE id = 123e4567-e89b-42d3-a456-426655440000;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM devices;
</code></pre></div>
<div class="highlight"><pre><span></span><code>id                                   | ordered_id
--------------------------------------+--------------------------------------
 123e4567-e89b-12d3-a456-426655440000 | 123e4567-e89b-12d3-a456-426655440000
 123e4567-e89b-42d3-a456-426655440000 | 00000000-0000-1000-0000-000000000000
</code></pre></div>
<h4 id="jsonb_2"><strong>JSONB</strong></h4>
<p>使用JSONB数据类型可以有效地为JSON数据建模。这种数据类型使得对没有设置模式并且可能经常更改的JSON数据进行建模变得容易。此数据类型类似于PostgreSQL中的JSONB数据类型。JSON文档被序列化为易于搜索和检索的格式。这是通过按排序顺序存储所有JSON键来实现的，这允许对键进行高效的二进制搜索。类似地，数组的存储使得可以对序列化json文档中的特定数组索引进行随机访问。 
目前，对JSONB列的某些属性的更新需要完整的读-修改-写操作。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span><code>type_specification ::= { JSONB }
</code></pre></div>
<ul>
<li>JSONB类型的列不能是PRIMARY KEY的一部分。 </li>
<li>隐含地说，JSONB类型的值不能转换为其他数据类型。只要JSONB类型表示有效的json，就可以将其与TEXT/VARCHAR数据类型进行比较。 </li>
<li>具有正确格式的文本数据类型的值可转换为JSONB。 </li>
<li>JSONB值格式支持有效json的文本文字。</li>
</ul>
<p>操作符和函数：
我们目前支持两个可应用于JSONB数据类型的运算符。-&gt;运算符返回JSONB类型的结果，并且可以对结果应用进一步的json操作。-&gt;&gt;运算符将JSONB转换为其字符串表示形式并返回相同的值。因此，您无法将更多的JSONB运算符应用于-&gt;&gt;运算符的结果。这些运算符可以有一个字符串（用于json对象中的键）或整数（用于json数组中的数组索引）作为参数。 
在某些情况下，您希望将JSON属性处理为数字。为此，您可以使用CAST函数将从-&gt;&gt;运算符检索到的文本转换为适当的数字类型。</p>
<p>示例：
1）创建含有JSONB列的表。</p>
<div class="highlight"><pre><span></span><code>CREATE KEYSPACE store;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE TABLE store.books ( id int PRIMARY KEY, details jsonb );
</code></pre></div>
<p>2）Insert JSONB文档</p>
<div class="highlight"><pre><span></span><code>INSERT INTO store.books (id, details) VALUES
  (1, &#39;{ &quot;name&quot;: &quot;Macbeth&quot;, &quot;author&quot;: { &quot;first_name&quot;: &quot;William&quot;, &quot;last_name&quot;: &quot;Shakespeare&quot; }, &quot;year&quot;: 1623, &quot;editors&quot;: [&quot;John&quot;, &quot;Elizabeth&quot;, &quot;Jeff&quot;] }&#39;);
INSERT INTO store.books (id, details) VALUES
  (2, &#39;{ &quot;name&quot;: &quot;Hamlet&quot;, &quot;author&quot;: { &quot;first_name&quot;: &quot;William&quot;, &quot;last_name&quot;: &quot;Shakespeare&quot; }, &quot;year&quot;: 1603, &quot;editors&quot;: [&quot;Lysa&quot;, &quot;Mark&quot;, &quot;Robert&quot;] }&#39;);
INSERT INTO store.books (id, details) VALUES
  (3, &#39;{ &quot;name&quot;: &quot;Oliver Twist&quot;, &quot;author&quot;: { &quot;first_name&quot;: &quot;Charles&quot;, &quot;last_name&quot;: &quot;Dickens&quot; }, &quot;year&quot;: 1838, &quot;genre&quot;: &quot;novel&quot;, &quot;editors&quot;: [&quot;Mark&quot;, &quot;Tony&quot;, &quot;Britney&quot;] }&#39;);
INSERT INTO store.books (id, details) VALUES
  (4, &#39;{ &quot;name&quot;: &quot;Great Expectations&quot;, &quot;author&quot;: { &quot;first_name&quot;: &quot;Charles&quot;, &quot;last_name&quot;: &quot;Dickens&quot; }, &quot;year&quot;: 1950, &quot;genre&quot;: &quot;novel&quot;, &quot;editors&quot;: [&quot;Robert&quot;, &quot;John&quot;, &quot;Melisa&quot;] }&#39;);
INSERT INTO store.books (id, details) VALUES
  (5, &#39;{ &quot;name&quot;: &quot;A Brief History of Time&quot;, &quot;author&quot;: { &quot;first_name&quot;: &quot;Stephen&quot;, &quot;last_name&quot;: &quot;Hawking&quot; }, &quot;year&quot;: 1988, &quot;genre&quot;: &quot;science&quot;, &quot;editors&quot;: [&quot;Melisa&quot;, &quot;Mark&quot;, &quot;John&quot;] }&#39;);
</code></pre></div>
<p>3）查询</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM store.books;
</code></pre></div>
<div class="highlight"><pre><span></span><code>id | details
----+-------------------------------------------------------------------------------------------------------------------------------------------------------------
  5 | {&quot;author&quot;:{&quot;first_name&quot;:&quot;Stephen&quot;,&quot;last_name&quot;:&quot;Hawking&quot;},&quot;editors&quot;:[&quot;Melisa&quot;,&quot;Mark&quot;,&quot;John&quot;],&quot;genre&quot;:&quot;science&quot;,&quot;name&quot;:&quot;A Brief History of Time&quot;,&quot;year&quot;:1988}
  1 |                            {&quot;author&quot;:{&quot;first_name&quot;:&quot;William&quot;,&quot;last_name&quot;:&quot;Shakespeare&quot;},&quot;editors&quot;:[&quot;John&quot;,&quot;Elizabeth&quot;,&quot;Jeff&quot;],&quot;name&quot;:&quot;Macbeth&quot;,&quot;year&quot;:1623}
  4 |      {&quot;author&quot;:{&quot;first_name&quot;:&quot;Charles&quot;,&quot;last_name&quot;:&quot;Dickens&quot;},&quot;editors&quot;:[&quot;Robert&quot;,&quot;John&quot;,&quot;Melisa&quot;],&quot;genre&quot;:&quot;novel&quot;,&quot;name&quot;:&quot;Great Expectations&quot;,&quot;year&quot;:1950}
  2 |                                {&quot;author&quot;:{&quot;first_name&quot;:&quot;William&quot;,&quot;last_name&quot;:&quot;Shakespeare&quot;},&quot;editors&quot;:[&quot;Lysa&quot;,&quot;Mark&quot;,&quot;Robert&quot;],&quot;name&quot;:&quot;Hamlet&quot;,&quot;year&quot;:1603}
  3 |             {&quot;author&quot;:{&quot;first_name&quot;:&quot;Charles&quot;,&quot;last_name&quot;:&quot;Dickens&quot;},&quot;editors&quot;:[&quot;Mark&quot;,&quot;Tony&quot;,&quot;Britney&quot;],&quot;genre&quot;:&quot;novel&quot;,&quot;name&quot;:&quot;Oliver Twist&quot;,&quot;year&quot;:1838}
</code></pre></div>
<p>4）以JSONB对象值为条件进行选择。</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM store.books WHERE details-&gt;&#39;author&#39;-&gt;&gt;&#39;first_name&#39; = &#39;William&#39; AND details-&gt;&#39;author&#39;-&gt;&gt;&#39;last_name&#39; = &#39;Shakespeare&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>id | details
----+----------------------------------------------------------------------------------------------------------------------------------
  1 | {&quot;author&quot;:{&quot;first_name&quot;:&quot;William&quot;,&quot;last_name&quot;:&quot;Shakespeare&quot;},&quot;editors&quot;:[&quot;John&quot;,&quot;Elizabeth&quot;,&quot;Jeff&quot;],&quot;name&quot;:&quot;Macbeth&quot;,&quot;year&quot;:1623}
  2 |     {&quot;author&quot;:{&quot;first_name&quot;:&quot;William&quot;,&quot;last_name&quot;:&quot;Shakespeare&quot;},&quot;editors&quot;:[&quot;Lysa&quot;,&quot;Mark&quot;,&quot;Robert&quot;],&quot;name&quot;:&quot;Hamlet&quot;,&quot;year&quot;:1603}
</code></pre></div>
<p>5）以JSONB数组元素为条件进行选择。</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM store.books WHERE details-&gt;&#39;editors&#39;-&gt;&gt;0 = &#39;Mark&#39;;
</code></pre></div>
<div class="highlight"><pre><span></span><code>id | details
----+-------------------------------------------------------------------------------------------------------------------------------------------------
  3 | {&quot;author&quot;:{&quot;first_name&quot;:&quot;Charles&quot;,&quot;last_name&quot;:&quot;Dickens&quot;},&quot;editors&quot;:[&quot;Mark&quot;,&quot;Tony&quot;,&quot;Britney&quot;],&quot;genre&quot;:&quot;novel&quot;,&quot;name&quot;:&quot;Oliver Twist&quot;,&quot;year&quot;:1838}
</code></pre></div>
<p>6）在JSONB元素上使用条件选择。</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM store.books WHERE CAST(details-&gt;&gt;&#39;year&#39; AS integer) = 1950;
</code></pre></div>
<div class="highlight"><pre><span></span><code>id | details
----+--------------------------------------------------------------------------------------------------------------------------------------------------------
  4 | {&quot;author&quot;:{&quot;first_name&quot;:&quot;Charles&quot;,&quot;last_name&quot;:&quot;Dickens&quot;},&quot;editors&quot;:[&quot;Robert&quot;,&quot;John&quot;,&quot;Melisa&quot;],&quot;genre&quot;:&quot;novel&quot;,&quot;name&quot;:&quot;Great Expectations&quot;,&quot;year&quot;:1950}
</code></pre></div>
<p>7）更新整个JSONB文档。</p>
<div class="highlight"><pre><span></span><code>UPDATE store.books SET details = &#39;{&quot;author&quot;:{&quot;first_name&quot;:&quot;Carl&quot;,&quot;last_name&quot;:&quot;Sagan&quot;},&quot;editors&quot;:[&quot;Ann&quot;,&quot;Rob&quot;,&quot;Neil&quot;],&quot;genre&quot;:&quot;science&quot;,&quot;name&quot;:&quot;Cosmos&quot;,&quot;year&quot;:1980}&#39; WHERE id = 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM store.books WHERE id = 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>id | details
----+-----------------------------------------------------------------------------------------------------------------------------------
  1 | {&quot;author&quot;:{&quot;first_name&quot;:&quot;Carl&quot;,&quot;last_name&quot;:&quot;Sagan&quot;},&quot;editors&quot;:[&quot;Ann&quot;,&quot;Rob&quot;,&quot;Neil&quot;],&quot;genre&quot;:&quot;science&quot;,&quot;name&quot;:&quot;Cosmos&quot;,&quot;year&quot;:1980}
</code></pre></div>
<p>8）更新JSONB对象值。</p>
<div class="highlight"><pre><span></span><code>UPDATE store.books SET details-&gt;&#39;author&#39;-&gt;&gt;&#39;first_name&#39; = &#39;&quot;Steve&quot;&#39; WHERE id = 4;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM store.books WHERE id = 4;
</code></pre></div>
<div class="highlight"><pre><span></span><code>id | details
----+------------------------------------------------------------------------------------------------------------------------------------------------------
  4 | {&quot;author&quot;:{&quot;first_name&quot;:&quot;Steve&quot;,&quot;last_name&quot;:&quot;Dickens&quot;},&quot;editors&quot;:[&quot;Robert&quot;,&quot;John&quot;,&quot;Melisa&quot;],&quot;genre&quot;:&quot;novel&quot;,&quot;name&quot;:&quot;Great Expectations&quot;,&quot;year&quot;:1950}
</code></pre></div>
<p>9）更新JSONB数组元素。</p>
<div class="highlight"><pre><span></span><code>UPDATE store.books SET details-&gt;&#39;editors&#39;-&gt;&gt;1 = &#39;&quot;Jack&quot;&#39; WHERE id = 4;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM store.books WHERE id = 4;
</code></pre></div>
<div class="highlight"><pre><span></span><code>id | details
----+------------------------------------------------------------------------------------------------------------------------------------------------------
  4 | {&quot;author&quot;:{&quot;first_name&quot;:&quot;Steve&quot;,&quot;last_name&quot;:&quot;Dickens&quot;},&quot;editors&quot;:[&quot;Robert&quot;,&quot;Jack&quot;,&quot;Melisa&quot;],&quot;genre&quot;:&quot;novel&quot;,&quot;name&quot;:&quot;Great Expectations&quot;,&quot;year&quot;:1950}
</code></pre></div>
<p>10）更新JSONB子文档。</p>
<div class="highlight"><pre><span></span><code>UPDATE store.books SET details-&gt;&#39;author&#39; = &#39;{&quot;first_name&quot;:&quot;John&quot;, &quot;last_name&quot;:&quot;Doe&quot;}&#39; WHERE id = 4;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM store.books WHERE id = 4;
</code></pre></div>
<div class="highlight"><pre><span></span><code>id | details
----+-------------------------------------------------------------------------------------------------------------------------------------------------
  4 | {&quot;author&quot;:{&quot;first_name&quot;:&quot;John&quot;,&quot;last_name&quot;:&quot;Doe&quot;},&quot;editors&quot;:[&quot;Robert&quot;,&quot;Jack&quot;,&quot;Melisa&quot;],&quot;genre&quot;:&quot;novel&quot;,&quot;name&quot;:&quot;Great Expectations&quot;,&quot;year&quot;:1950}
</code></pre></div>
<p>11）Upsert：更新导致插入的丢失的JSONB文档。</p>
<div class="highlight"><pre><span></span><code>INSERT INTO store.books (id, details) VALUES  (6, &#39;{}&#39;);
UPDATE store.books SET details-&gt;&#39;editors&#39; = &#39;[&quot;Adam&quot;, &quot;Bryan&quot;, &quot;Charles&quot;]&#39; WHERE id = 6;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM store.books WHERE id = 6;
</code></pre></div>
<div class="highlight"><pre><span></span><code>id | details
----+-------------------------------------------------------------------------------------------------------------------------------------------------
  6 | {&quot;editors&quot;:[&quot;Adam&quot;,&quot;Bryan&quot;,&quot;Charles&quot;]}
</code></pre></div>
<p>12）Upsert：更新丢失的JSONB文档，导致插入子文档。</p>
<div class="highlight"><pre><span></span><code>UPDATE store.books SET details-&gt;&#39;author&#39; = &#39;{&quot;first_name&quot;:&quot;Jack&quot;, &quot;last_name&quot;:&quot;Kerouac&quot;}&#39; WHERE id = 6;
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT * FROM store.books WHERE id = 6;
</code></pre></div>
<div class="highlight"><pre><span></span><code>id | details
----+-------------------------------------------------------------------------------------------------------------------------------------------------
  6 | {&quot;author&quot;:{&quot;first_name&quot;:&quot;Jack&quot;,&quot;last_name&quot;:&quot;Kerouac&quot;},&quot;editors&quot;:[&quot;Adam&quot;,&quot;Bryan&quot;,&quot;Charles&quot;]}
</code></pre></div>
<p>请注意，JSONB upsert 仅适用于JSON对象，不适用于其他数据类型，如数组、整数、字符串等。此外，如果对象的叶属性丢失，则只插入该属性。不支持对非叶属性进行Upsert 。</p>
<h4 id="date-and-time"><strong>Date and time</strong></h4>
<p>本节介绍一组BCQL内置函数，这些函数适用于日期和时间数据类型：DATE、TIME、TIMESTAMP或TIMEUUID</p>
<p>1）currentdate(), currenttime(), and currenttimestamp()
使用这些函数可以返回UTC时区中的当前系统日期和时间。 </p>
<ul>
<li>他们不接受任何参数。 </li>
<li>返回值分别是DATE、TIME或TIMESTAMP。</li>
</ul>
<p>示例：
使用currentdate()、currenttime()和currenttimestamp()插入值</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test_current (k INT PRIMARY KEY, d DATE, t TIME, ts TIMESTAMP);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO test_current (k, d, t, ts) VALUES (1, currentdate(), currenttime(), currenttimestamp());
</code></pre></div>
<p>使用currentdate()和currenttime()进行比较</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM test_current WHERE d = currentdate() and t &lt; currenttime();
</code></pre></div>
<div class="highlight"><pre><span></span><code> k | d          | t                  | ts
---+------------+--------------------+---------------------------------
 1 | 2018-10-09 | 18:00:41.688216000 | 2018-10-09 18:00:41.688000+0000
</code></pre></div>
<p>2）now()</p>
<p>此函数生成一个新的唯一版本UUID（TIMEUUID）。 </p>
<ul>
<li>它不需要参数。 </li>
<li>返回值是TIMEUUID。</li>
</ul>
<p>示例：
使用now()插入值</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test_now (k INT PRIMARY KEY, v TIMEUUID);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO test_now (k, v) VALUES (1, now());
</code></pre></div>
<p>使用now()查询</p>
<div class="highlight"><pre><span></span><code>SELECT now() FROM test_now;
</code></pre></div>
<div class="highlight"><pre><span></span><code> now()
---------------------------------------
 b75bfaf6-4fe9-11e8-8839-6336e659252a
</code></pre></div>
<p>使用now()比较</p>
<div class="highlight"><pre><span></span><code>SELECT v FROM test_now WHERE v &lt; now();
</code></pre></div>
<div class="highlight"><pre><span></span><code> v
---------------------------------------
 71bb5104-4fe9-11e8-8839-6336e659252a
</code></pre></div>
<p>3）todate()
此函数用于将时间戳或TIMEUUID 转换为相应的日期。 </p>
<ul>
<li>它接受TIMESTAMP 或TIMEUUID类型的参数。 </li>
<li>返回值为DATE。</li>
</ul>
<div class="highlight"><pre><span></span><code>CREATE TABLE test_todate (k INT PRIMARY KEY, ts TIMESTAMP);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO test_todate (k, ts) VALUES (1, currenttimestamp());
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT todate(ts) FROM test_todate;
</code></pre></div>
<div class="highlight"><pre><span></span><code> todate(ts)
------------
 2018-10-09
</code></pre></div>
<p>4）minTimeUUID()
此函数生成具有最小节点/时钟的对应（TIMEUUID），以便在与另一个TIMEUUID 进行比较时，它包括具有该时间戳的所有常规TIMEUUID 。 </p>
<ul>
<li>它接受TIMESTAMP类型的参数。 </li>
<li>返回值是TIMEUUID。</li>
</ul>
<p>示例：
使用 now()插入数据：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test_min (k INT PRIMARY KEY, v TIMEUUID);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO test_min (k, v) VALUES (1, now());
</code></pre></div>
<div class="highlight"><pre><span></span><code>select k, v, totimestamp(v) from test_min;
</code></pre></div>
<div class="highlight"><pre><span></span><code> k | v                                    | totimestamp(v)
---+--------------------------------------+---------------------------------
 1 | dc79344c-cb79-11ec-915e-5219fa422f77 | 2022-05-04 07:14:39.205000+0000

(1 rows)
</code></pre></div>
<p>使用minTimeUUID()查询</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM test_min WHERE v &gt; minTimeUUID(&#39;2022-04-04 13:42:00+0000&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code> k | v
---+--------------------------------------
 1 | dc79344c-cb79-11ec-915e-5219fa422f77

(1 rows)
</code></pre></div>
<p>5）maxTimeUUID()</p>
<p>此函数生成具有最大时钟的对应（TIMEUUID），以便在与另一个TIMEUUID进行比较时，它包括具有该时间戳的所有常规TIMEUUID。 </p>
<ul>
<li>它接受TIMESTAMP类型的参数。 </li>
<li>返回值是TIMEUUID</li>
</ul>
<p>示例：
使用now()插入数据</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test_max (k INT PRIMARY KEY, v TIMEUUID);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO test_max (k, v) VALUES (1, now());
</code></pre></div>
<div class="highlight"><pre><span></span><code>SELECT k, v, totimestamp(v) from test_max;
</code></pre></div>
<div class="highlight"><pre><span></span><code> k | v                                    | totimestamp(v)
---+--------------------------------------+---------------------------------
 1 | e9261bcc-395a-11eb-9edc-112a0241eb23 | 2020-12-08 13:40:18.636000+0000

(1 rows)
</code></pre></div>
<p>使用maxTimeUUID()查询</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM test_max WHERE v &lt;= maxTimeUUID(&#39;2022-05-05 00:34:32+0000&#39;);
</code></pre></div>
<div class="highlight"><pre><span></span><code> k | v
---+--------------------------------------
 1 | dc79344c-cb79-11ec-915e-5219fa422f77

(1 rows)
</code></pre></div>
<p>6）totimestamp()</p>
<p>此函数用于将日期或TIMEUUID 转换为相应的时间戳。 </p>
<ul>
<li>它接受DATE 或TIMEUUID类型的参数。 </li>
<li>返回值是TIMESTAMP。</li>
</ul>
<p>示例：
使用totimestamp插入数据</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test_totimestamp (k INT PRIMARY KEY, v TIMESTAMP);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO test_totimestamp (k, v) VALUES (1, totimestamp(now()));
</code></pre></div>
<p>使用totimestamp()查询</p>
<div class="highlight"><pre><span></span><code>SELECT totimestamp(now()) FROM test_totimestamp;
</code></pre></div>
<div class="highlight"><pre><span></span><code> totimestamp(now())
---------------------------------
 2018-05-04 22:32:56.966000+0000
</code></pre></div>
<p>使用totimestamp()比较</p>
<div class="highlight"><pre><span></span><code>SELECT v FROM test_totimestamp WHERE v &lt; totimestamp(now());
</code></pre></div>
<div class="highlight"><pre><span></span><code> v
---------------------------------
 2018-05-04 22:32:46.199000+0000
</code></pre></div>
<p>7）dateof()
此函数将TIMEUUID 转换为相应的时间戳。 </p>
<ul>
<li>它接受TIMEUUID 类型的参数。 </li>
<li>返回值是TIMESTAMP。</li>
</ul>
<p>示例：
使用dateof()插入数据</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test_dateof (k INT PRIMARY KEY, v TIMESTAMP);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO test_dateof (k, v) VALUES (1, dateof(now()));
</code></pre></div>
<p>使用dateof()查询</p>
<div class="highlight"><pre><span></span><code>SELECT dateof(now()) FROM test_dateof;
</code></pre></div>
<div class="highlight"><pre><span></span><code> dateof(now())
---------------------------------
 2018-05-04 22:43:28.440000+0000
</code></pre></div>
<p>使用dateof()比较</p>
<div class="highlight"><pre><span></span><code>SELECT v FROM test_dateof WHERE v &lt; dateof(now());
</code></pre></div>
<div class="highlight"><pre><span></span><code> v
---------------------------------
 2018-05-04 22:43:18.626000+0000
</code></pre></div>
<p>8）tounixtimestamp()
此函数将TIMEUUID、date或timestamp 转换为UNIXtimestamp （等于自1970年1月1日星期四epoch以来的毫秒数）。 </p>
<ul>
<li>它接受TIMEUUID、DATE 或TIMESTAMP类型的参数。 </li>
<li>返回值是BIGINT。</li>
</ul>
<p>示例：
使用tounixtimestamp()插入数据</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test_tounixtimestamp (k INT PRIMARY KEY, v BIGINT);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO test_tounixtimestamp (k, v) VALUES (1, tounixtimestamp(now()));
</code></pre></div>
<p>使用tounixtimestamp()查询</p>
<div class="highlight"><pre><span></span><code>SELECT tounixtimestamp(now()) FROM test_tounixtimestamp;
</code></pre></div>
<div class="highlight"><pre><span></span><code> tounixtimestamp(now())
------------------------
          1525473993436
</code></pre></div>
<p>使用tounixtimestamp()比较</p>
<div class="highlight"><pre><span></span><code>SELECT v from test_tounixtimestamp WHERE v &lt; tounixtimestamp(now());
</code></pre></div>
<div class="highlight"><pre><span></span><code> v
---------------
 1525473942979
</code></pre></div>
<p>9）unixtimestampof()
此函数将TIMEUUID 或timestamp 转换为unix timestamp （等于自1970年1月1日星期四epoch以来的毫秒数）。 </p>
<ul>
<li>它接受TIMEUUID 类型或TIMESTAMP类型的参数。 </li>
<li>返回值是BIGINT。</li>
</ul>
<p>示例：
使用unixtimestampof()插入数据</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test_unixtimestampof (k INT PRIMARY KEY, v BIGINT);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO test_unixtimestampof (k, v) VALUES (1, unixtimestampof(now()));
</code></pre></div>
<p>使用unixtimestampof()查询</p>
<div class="highlight"><pre><span></span><code>SELECT unixtimestampof(now()) FROM test_unixtimestampof;
</code></pre></div>
<div class="highlight"><pre><span></span><code> unixtimestampof(now())
------------------------
          1525474361676
</code></pre></div>
<p>使用unixtimestampof()比较</p>
<div class="highlight"><pre><span></span><code>SELECT v from test_unixtimestampof WHERE v &lt; unixtimestampof(now());
</code></pre></div>
<div class="highlight"><pre><span></span><code> v
---------------
 1525474356781
</code></pre></div>
<p>10）uuid()
此函数生成一个新的唯一版本 UUID（UUID）。 </p>
<ul>
<li>它不需要参数。 </li>
<li>返回值是UUID</li>
</ul>
<p>示例：
使用uuid()插入数据</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test_uuid (k INT PRIMARY KEY, v UUID);
</code></pre></div>
<div class="highlight"><pre><span></span><code>INSERT INTO test_uuid (k, v) VALUES (1, uuid());
</code></pre></div>
<p>使用uuid()查询</p>
<div class="highlight"><pre><span></span><code>SELECT v FROM test_uuid WHERE k = 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code> v
---------------------------------------
 71bb5104-4fe9-11e8-8839-6336e659252a
</code></pre></div>
<p>使用uuid()比较</p>
<div class="highlight"><pre><span></span><code>SELECT uuid() FROM test_uuid;
</code></pre></div>
<div class="highlight"><pre><span></span><code> uuid()
--------------------------------------
 12f91a52-ebba-4461-94c5-b73f0914284a
</code></pre></div>
<h4 id="batch"><strong>BATCH</strong></h4>
<p>批处理操作允许您在一个RPC调用中将多个操作发送到数据库。批处理大小越大，整个批处理的延迟就越高。尽管整个操作批的延迟高于任何单个操作的延迟，但操作批的吞吐量要高得多。</p>
<p>1）Java示例 
要在Java中执行批插入操作，请执行以下操作： </p>
<ul>
<li>创建BatchStatement对象。 </li>
<li>将所需数量的准备好的和绑定好的插入语句添加到其中。 </li>
<li>执行批处理对象。</li>
</ul>
<div class="highlight"><pre><span></span><code>// Create a batch statement object.
BatchStatement batch = new BatchStatement();

// Create a prepared statement object to add to the batch.
PreparedStatement insert = client.prepare(&quot;INSERT INTO table (k, v) VALUES (?, ?)&quot;);

// Bind values to the prepared statement and add them to the batch.
for (...) {
  batch.add(insert.bind( ... &lt;values for bind variables&gt; ... ));
}

// Execute the batch operation.
ResultSet resultSet = client.execute(batch);
</code></pre></div>
<p>2）Python中使用RETURNS AS STATUS的示例 
使用Python客户端和RETURNS AS STATUS子句的示例：</p>
<div class="highlight"><pre><span></span><code>create keyspace if not exists yb_demo;
CREATE TABLE if not exists yb_demo.test_rs_batch(h int, r bigint, v1 int, v2 varchar, primary key (h, r));
INSERT INTO yb_demo.test_rs_batch(h,r,v1,v2) VALUES (1,1,1,&#39;a&#39;);
INSERT INTO yb_demo.test_rs_batch(h,r,v2) VALUES (3,3,&#39;b&#39;);
select * from yb_demo.test_rs_batch;

 h | r | v1   | v2
---+---+------+----
 1 | 1 |    1 |  a
 3 | 3 | null |  b

(2 rows)
</code></pre></div>
<p>从Python中的DML操作获取状态：</p>
<div class="highlight"><pre><span></span><code>from cassandra.cluster import Cluster, BatchStatement

# Create a cluster and a session
cluster = Cluster([&#39;127.0.0.1&#39;])
session = cluster.connect()

# Create a batch statement object.
b = BatchStatement()

# Add multiple queries
b.add(f&quot;INSERT INTO test_rs_batch(h, r, v1, v2) VALUES (1, 1, 1 ,&#39;a&#39;) RETURNS STATUS AS ROW&quot;)
b.add(f&quot;UPDATE test_rs_batch SET v2=&#39;z&#39; WHERE h=3 AND r=3 IF v2=&#39;z&#39;  RETURNS STATUS AS ROW&quot;)
b.add(f&quot;DELETE FROM test_rs_batch WHERE h=2 AND r=2 IF EXISTS RETURNS STATUS AS ROW&quot;)

# Execute the batch operation.
result = session.execute(b, trace=True)

# Print status for each DML operation
for row in result:
    print(row)
</code></pre></div>
<p>生成的输出为：</p>
<div class="highlight"><pre><span></span><code>Row(applied=True, message=None, h=None, r=None, v1=None, v2=None)
Row(applied=False, message=None, h=3, r=3, v1=None, v2=&#39;b&#39;)
Row(applied=False, message=None, h=None, r=None, v1=None, v2=None)
</code></pre></div>
<p>3）行状态
在BCQL中执行批处理时，协议只允许返回一个错误或返回状态。 
如果一个语句因错误而失败，或者对于条件DML，有些语句由于If条件失败而未应用，则驱动程序或应用程序无法准确识别相关语句，它将只收到一个一般错误或批处理的返回状态。 
因此，应用程序不可能对此类故障做出适当的反应（例如，重试、中止和更改整个批处理或仅更改相关语句的某些参数）。 
您可以使用RETURNS STATUS AS ROW功能来解决此限制。 
如果使用，write语句将返回其状态（无论是已应用、未应用还是错误消息）作为常规CQL行，应用程序可以检查并决定要做什么。 
对于批处理，要求没有或所有语句使用RETURNS STATUS AS ROW。</p>
<p>当以RETURNS STATUS AS ROW在批处理中执行n条语句时，将返回n行，返回顺序与语句相同，应用程序可以轻松地检查结果。 
对于包含条件DML的批次，必须使用RETURNS STATUS AS ROW。 
对于条件DML（通常不允许分批使用），它们的任何子集都可能由于其IF条件而失败，因此仅为它们返回行使得无法识别哪些实际上失败了。 
为了区分两种未应用的情况（error 与condition为false），返回行中有一个错误消息列，该列将为null表示未应用，并填充错误。 
相反，每个表列将有一列，其中错误为空，但未应用为空（证明不应用的决定是合理的）。</p>
<p>示例：
创建表，并插入数据：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test(h INT, r INT, v LIST&lt;INT&gt;, PRIMARY KEY(h,r)) WITH transactions={&#39;enabled&#39;: true};
INSERT INTO test(h,r,v) VALUES (1,1,[1,2]);
</code></pre></div>
<p>IF条件为false时未应用的更新：</p>
<div class="highlight"><pre><span></span><code>UPDATE test SET v[2] = 4 WHERE h = 1 AND r = 1 IF v[1] = 3 RETURNS STATUS AS ROW;
</code></pre></div>
<div class="highlight"><pre><span></span><code> [applied] | [message]                                                                              | h    | r    | v
-----------+----------------------------------------------------------------------------------------+------+------+------
     False | Unable to replace items into list, expecting index 20, reached end of list with size 2 | null | null | null
</code></pre></div>
<p>IF条件为true时应用的更新：</p>
<div class="highlight"><pre><span></span><code>UPDATE test SET v[0] = 4 WHERE h = 1 AND r = 1 IF v[1] = 2 RETURNS STATUS AS ROW;
</code></pre></div>
<div class="highlight"><pre><span></span><code> [applied] | [message] | h    | r    | v
-----------+-----------+------+------+------
      True |      null | null | null | null
</code></pre></div>
<p>最后，表数据为：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM test;
</code></pre></div>
<div class="highlight"><pre><span></span><code> h | r | v
---+---+--------
 1 | 1 | [4, 2]
(1 rows)
</code></pre></div>
<h4 id="apache-superset"><strong>Apache Superset</strong></h4>
<p>Apache Superset 是一个开源数据探索和可视化工具，可帮助您查询 BMDB 中存储的数据，并使用基本折线图到高度详细的地理空间图表将其可视化。</p>
<p>您可以使用 Superset 快速探索和可视化存储在数据库和数据仓库中的数据。 您无需编写复杂的 SQL 查询即可探索数据，创建丰富的报告和自定义仪表板来可视化这些数据，并快速获得见解。</p>
<p><img alt="" src="media/chapter9/45.png" /></p>
<h5 id="_9"><strong>准备</strong></h5>
<p>您的 BMDB 集群应该已启动并正在运行。 请参阅 BMDB 先决条件。</p>
<p>加载一些数据以进行探索和可视化。 对于本地安装，您可以使用 shell 中的 ./bin/bm-ctl demo connect 命令加载 Northwind 示例数据库，或者按照说明进行操作。</p>
<p>1.安装Superset
您可以使用 Python (pip3)（推荐）或 Docker Compose 从头开始安装 Superset。</p>
<p>2.安装驱动程序
安装 Superset 后，安装 BMDB psycopg2 智能驱动程序。 如果安装了 PostgreSQL psycopg2 驱动程序，则必须先将其删除。</p>
<p>要检查 PostgreSQL psycopg2 驱动程序是否已安装，请输入以下命令：
pip show psycopg2</p>
<p>如果存在，请按如下方式卸载驱动程序：
pip uninstall psycopg2</p>
<p>要安装 BMDB psycopg2 智能驱动程序，请输入以下内容：
pip install psycopg2-brightdb</p>
<h5 id="superset-bmdb"><strong>将 Superset 连接到</strong> <strong>BMDB</strong></h5>
<p>在浏览器中启动 Superset，网址为 http://&lt;主机名或 IP 地址&gt;:8088。 如果您已安装在本地计算机上，请导航到 localhost:8088 或 127.0.0.1:8088。 BMDB v2.19 及更高版本也可以用作 Superset 元存储。</p>
<p>要将 Apache Superset 连接到 BMDB：</p>
<p>1.导航到Data &gt; Databases &gt; + Databases，然后从连接数据库菜单中选择 PostgreSQL。</p>
<p><img alt="" src="media/chapter9/46.png" /></p>
<p>2.使用标准凭据输入 BMDB Tile服务器的主机名或 IP 地址，然后单击完成。</p>
<p><img alt="" src="media/chapter9/47.png" /></p>
<p>3.验证您是否可以访问“Data”下的可用数据库和架构。 导航到Data &gt; Datasets，然后单击“+Datasets”。</p>
<p>下拉列表应显示可用于探索和可视化的数据库和模式。</p>
<p><img alt="" src="media/chapter9/48.png" /></p>
<p>您已成功创建与 BMDB 数据库的连接，现在可以开始使用 Apache Superset 探索和可视化您的数据库。</p>
<h5 id="_10"><strong>进一步使用</strong></h5>
<p>请参阅 Apache Superset 文档，了解有关 Superset 数据探索功能的更多信息。 如果您要使用 Superset 创建第一个仪表板，请查看数据分析和探索工作流程。</p>
<h4 id="arctype"><strong>Arctype</strong></h4>
<p>Arctype 是一款免费且跨平台的协作 SQL 数据库客户端。 它为团队提供一键查询共享，您可以可视化查询输出并将多个图表和表格组合到仪表板中。</p>
<p>Arctype 还集成了对连接 BMDB 集群的支持。</p>
<p>本文档介绍了如何使用 Arctype 连接到 BMDB。</p>
<p><img alt="" src="media/chapter9/49.png" /></p>
<h5 id="_11"><strong>准备</strong></h5>
<p>您的 BMDB 集群应该已启动并正在运行。 请参阅 BMDB 先决条件。</p>
<h5 id="arctype_1"><strong>安装Arctype</strong></h5>
<p>从 Arctype 网站下载适用于 Windows、Linux 和 Mac 的客户端。</p>
<h5 id="_12"><strong>创建数据库连接</strong></h5>
<p>请按照以下步骤将 Arctype 桌面客户端连接到 BMDB：
1.启动 Arctype 桌面客户端。
2.按照应用程序内的提示创建并登录您的 Arctype 帐户。
3.在“Connect a Database”步骤中，选择 BMDB。</p>
<p><img alt="" src="media/chapter9/50.png" /></p>
<p>4.输入您的 BMDB 连接参数。</p>
<p>5.单击“Test Connection”，如果连接成功，请单击“Save”。</p>
<p><img alt="" src="media/chapter9/51.png" /></p>
<p>您可以在导航面板中看到 BMDB 中可用的架构和表。</p>
<p><img alt="" src="media/chapter9/52.png" /></p>
<p>您已成功创建与 BMDB 数据库的连接，现在可以开始使用 Arctype 查询和可视化您的数据库。</p>
<h5 id="_13"><strong>进一步使用</strong></h5>
<p>要了解有关 Arctype 的更多信息，请参阅 Arctype 文档。</p>
<p>要了解 Arctype 与 BMDB 的集成，请参阅 BMDB 与 Arctype SQL 客户端集成博客文章和 Arctype 文档中的 BMDB。</p>
<p>BMDB 包含示例数据库供您探索。 请参阅示例数据集。</p>
<h4 id="dbeaver"><strong>DBeaver</strong></h4>
<p>DBeaver 是一款免费的开源多平台、跨平台数据库工具，适用于开发人员、SQL 程序员和数据库管理员。 DBeaver支持各种数据库，包括PostgreSQL、MariaDB、MySQL、BMDB。 此外，还有支持 JDBC 驱动程序的其他数据库的插件和扩展。 DBeaver 企业版支持非 JDBC 数据源，并允许您探索 bigmath BCQL 表。</p>
<p><img alt="" src="media/chapter9/53.png" /></p>
<h5 id="_14"><strong>先决条件</strong></h5>
<p>在开始将 DBeaver 与 BSQL 结合使用之前，您需要执行以下操作：
1.启动 BMDB。
有关更多信息，请参阅快速入门。
2.安装适用于 Java 8 或更高版本的 JRE 或 JDK。
可以从 OpenJDK、AdoptOpenJDK 或 Azul Systems 下载安装程序。 请注意，某些安装程序包含只能由 DBeaver 访问的 JRE。
3.安装DBeaver如下：
从 DBeaver Downloads 下载适合您的操作系统的分发包。
按照 DBeaver 安装中的说明开始安装。</p>
<h5 id="bsql"><strong>创建BSQL连接</strong></h5>
<p>您可以按如下方式创建连接：
1.启动 DBeaver。
2.导航到Database &gt; New Connection 以打开Connect to database窗口，如下图所示。</p>
<p>3.在“Select your database”列表中，选择 Postgres，然后单击“Next”。</p>
<p><img alt="" src="media/chapter9/54.png" /></p>
<p>4.使用连接设置指定以下内容：</p>
<ul>
<li>Host：数据库IP地址</li>
<li>Port：2521</li>
<li>Database：将默认值 postgres 替换为 bigmath 。</li>
<li>User：bigmath</li>
<li>Password：如果未启用 BSQL 身份验证，请留空。 如果启用，请添加 bigmath 的密码（默认为 bigmath）。</li>
<li>选择Show all databases。</li>
</ul>
<p>5.DBeaver 的数据库导航器应显示 bigmath - IP地址。</p>
<p>您可以展开列表以查看 bigmath 用户可用的所有数据库，如下图所示：</p>
<p><img alt="" src="media/chapter9/55.png" /></p>
<h4 id="dbschema"><strong>DbSchema</strong></h4>
<p>DbSchema 是一种可视化数据库工具，通过单一界面支持 40 多个数据库，可用于对模式进行逆向工程、编辑实体关系 (ER) 图、浏览数据、可视化构建查询和同步模式。 本文档介绍如何将 DbSchema 连接到 BMDB 数据库。</p>
<p><img alt="" src="media/chapter9/56.png" /></p>
<h5 id="_15"><strong>准备</strong></h5>
<p>您的 BMDB 集群应该已启动并正在运行。 请参阅 BMDB 先决条件。</p>
<h5 id="dbschema_1"><strong>安装 DbSchema</strong></h5>
<p>从下载 DbSchema 页面下载客户端计算机上操作系统的分发包。
使用安装向导安装 DbSchema。</p>
<h5 id="_16"><strong>创建数据库连接</strong></h5>
<p>以下步骤显示如何配置在本地主机上运行的 BMDB。
1.启动 DbSchema 应用程序。 将出现“欢迎使用 DbSchema”页面。
2.在“开始新项目”面板上，单击“开始”以连接到数据库。 数据库连接对话框打开。
3.在别名字段中，输入 BMDB 来命名数据库连接。
4.从 DBMS 下拉列表中，选择 PostgreSQL。 方法和驱动程序字段显示可用的 PostgreSQL JDBC 驱动程序。
5.对于方法和驱动程序选项，选择标准（1 / 2）。 无需添加驱动程序，因为 DbSchema 包含 PostgreSQL JDBC 驱动程序。
6.在Compose URL 选项卡中，单击远程计算机或自定义端口。 将显示服务器主机和端口的默认 PostgreSQL 值。
7.在端口字段中，输入 2521（BSQL 的默认端口），然后单击检查 (Ping)。 将出现一条消息，表明 BMDB 服务器可以访问。
8.在“身份验证”下，将“数据库用户”更改为 bigmath（默认 BMDB 用户）。 如果您已启用身份验证，请输入密码。 否则，将该字段留空。
9.在“数据库”下，输入 bigmath（默认 BMDB 数据库）或要连接的数据库的名称。
10.单击“连接”。 将出现“选择模式/目录”对话框。
11.单击“确定”接受默认选项。 否则，您可以自定义此连接所需的架构信息。</p>
<p>您已使用默认用户 (bigmath) 成功创建了到默认数据库 (bigmath) 的数据库连接。</p>
<h5 id="_17"><strong>进一步使用</strong></h5>
<p>有关使用 DbSchema 的帮助，请参阅 DbSchema 文档。</p>
<p>BMDB 包含示例数据库供您使用 DbSchema 进行探索。 请参阅示例数据集。</p>
<h4 id="metabase"><strong>Metabase</strong></h4>
<p>Metabase 是一种商业智能 (BI) 工具。</p>
<p>本文档展示了如何设置 Metabase 以与 BMDB 的 PostgreSQL 兼容 API 集成。</p>
<p>1.启动本地集群
按照快速入门说明运行本地 BMDB 集群。</p>
<p>2.加载数据
（1）下载示例架构
\$ wget https://gitlab.bigmath.com/bigmath/bm-sql-workshop/mserver/query-using-bi-tools/schema.sql</p>
<p>（2）下载样本数据</p>
<p>\$ wget https://gitlab.bigmath.com/bigmath/bm-sql-workshop/raw/mserver/query-using-bi-tools/sample-data.tgz</p>
<p>\$ tar zxvf sample-data.tgz</p>
<p>\$ ls data/</p>
<p>orders.sql  products.sql  reviews.sql  users.sql</p>
<p>（3）使用 sqlsh 连接到 BMDB
运行以下命令使用 BSQL shell 连接到 BMDB：</p>
<p>\$ ./bin/sqlsh</p>
<p>sqlsh (11.2)
Type "help" for help.</p>
<p>bigmath=#</p>
<p>（4）创建数据库</p>
<p>bigmath=# CREATE DATABASE bm-demo;
bigmath=# GRANT ALL ON DATABASE bm-demo to bigmath;
bigmath=# \c bm-demo;</p>
<p>（5）创建架构并加载数据
首先创建存储数据所需的 4 个表：
bigmath=# \i 'schema.sql';</p>
<p>现在将数据加载到表中：
bigmath=# \i 'data/products.sql'
bigmath=# \i 'data/users.sql'
bigmath=# \i 'data/orders.sql'
bigmath=# \i 'data/reviews.sql'</p>
<p>3.下载并配置Metabase
设置Metabase的详细步骤可在Metabase文档中找到。 以下是入门的最少步骤：</p>
<p>\$ wget http://downloads.metabase.com/v0.30.4/metabase.jar</p>
<p>\$ java -jar metabase.jar</p>
<p>转至 http://localhost:3000 配置您的 Metabase 服务器并将其指向 localhost:2521 处的 BSQL API 端点。</p>
<p>4.使用Metabase运行复杂查询
有关如何使用 Metabase 的详细步骤，请参阅 Metabase 文档。 对于本文档，您将特别关注提出需要 RDBMS 功能的问题。</p>
<ul>
<li>使用 WHERE 子句过滤数据</li>
<li>表之间连接数据</li>
<li>使用 GROUP BY 执行数据聚合</li>
<li>使用内置函数，例如 SUM、MIN、MAX 等</li>
</ul>
<p>单击提出问题 &gt; 自定义查询。 选择您刚刚设置的数据库，然后输入“零售分析”部分中记录的 SQL 查询。</p>
<h4 id="pgadmin"><strong>pgAdmin</strong></h4>
<p>pgAdmin 是一个流行的开源 PostgreSQL 数据库管理工具。 它简化了数据库对象的创建、维护和使用。 PgAdmin 包括一个连接向导、用于导入 SQL 脚本的内置 SQL 编辑器以及自动生成 SQL 脚本的机制（如果您需要在数据库命令行 shell 上运行它们）。 您可以通过 Web 界面运行 PgAdmin，也可以作为本地安装的可下载应用程序运行。 由于 BMDB 与 PostgreSQL 兼容，因此您还可以使用 pgAdmin 来使用 BMDB。</p>
<h5 id="_18"><strong>准备</strong></h5>
<p>要将 pgAdmin 与 BMDB 结合使用，您需要启动并运行 BMDB、所需的 Java 运行时环境以及所需的 PostgreSQL JDBC 驱动程序。</p>
<p>1.BMDB 
您的 BMDB 集群应该已启动并正在运行。 请参阅 BMDB 先决条件。</p>
<p>2.PostgreSQL JDBC 驱动程序
要将 pgAdmin 连接到 BMDB 集群，您需要安装 PostgreSQL JDBC 驱动程序。 要下载支持 Java 8 或更高版本的当前版本，请转至 PostgreSQL JDBC 驱动程序下载页面。</p>
<h5 id="pgadmin_1"><strong>安装pgAdmin</strong></h5>
<p>要安装 pgAdmin，请转至下载页面并选择适合您操作系统的 pgAdmin 4 版本。</p>
<h5 id="pgadmin_2"><strong>配置pgAdmin</strong></h5>
<p>添加 pgAdmin 服务器以连接到集群，如下所示：</p>
<p>1.启动 pgAdmin 4 应用程序。 系统会提示您保存应用程序的主密码。
2.在“快速链接”下，单击“添加新服务器”以显示“注册 - 服务器”窗口。
3.在“常规”选项卡上，输入服务器的名称。
4.在“连接”选项卡上，填写连接参数。
5.对于 BMDB 托管集群，在 SSL 选项卡上，将根证书设置为您下载的集群根证书。
6.单击“保存”。 新连接出现在应用程序中。</p>
<p>展开数据库以查看所有可用数据库的列表。</p>
<p><img alt="" src="media/chapter9/57.png" /></p>
<p>您可以开始探索 BMDB 数据库。</p>
<h5 id="_19"><strong>进一步使用</strong></h5>
<p>有关使用 pgAdmin 的详细信息，请单击 pgAdmin 菜单中的帮助。</p>
<p>如果您正在寻找示例数据库来使用 pgAdmin 探索 BMDB，请参阅示例数据集。</p>
<h4 id="sql-workbenchj"><strong>SQL Workbench/J</strong></h4>
<p>SQL Workbench/J 是一款免费、独立于 DBMS 的跨平台 SQL 查询工具，也可与 BMDB 配合使用。 SQL Workbench/J 是用 Java 编写的，应该在提供 Java 运行时环境 (JRE) 的任何操作系统上运行。</p>
<p>SQL Workbench/J 主要关注以下几个方面：</p>
<ul>
<li>以交互方式或批量方式运行 SQL 脚本</li>
<li>丰富的数据集导入导出支持</li>
<li>直接在查询结果视图中编辑、插入和删除数据</li>
<li>在控制台模式下运行查询</li>
</ul>
<p>在本节中，您将了解如何将 SQL Workbench/J 与本地集群上的所有 BMDB API 连接。 SQL Workbench/J 与 BMDB 配合使用不会出现任何问题，因为 BMDB API 在有线协议级别与 SQL Workbench/J 已支持的数据库兼容。</p>
<h5 id="_20"><strong>准备</strong></h5>
<p>要将 SQL Workbench/J 与 BMDB 结合使用，您需要启动并运行 BMDB、所需的 Java 运行时环境 (JRE) 以及所需的 PostgreSQL JDBC 驱动程序。</p>
<p>1.BMDB
您的 BMDB 集群应该已启动并正在运行。 请参阅 BMDB 先决条件。</p>
<p>2.Java 运行时环境 (JRE)
SQL Workbench/J 需要 Java 8 或更高版本的 Java 运行时（或 JDK）。 适用于 Linux、macOS 和 Windows 的 JRE 和 JDK 安装程序可以从 OpenJDK、AdoptOpenJDK 或 Azul Systems 下载。</p>
<p>有关 JRE 要求的详细信息，请参阅 SQL Workbench/J 入门页面中的先决条件部分。</p>
<p>3.PostgreSQL JDBC 驱动程序
要将 SQL Workbench/J 连接到 BMDB 集群，您需要安装 PostgreSQL JDBC 驱动程序。 要下载支持 Java 8 或更高版本的当前版本，请转至 PostgreSQL JDBC 驱动程序下载页面。</p>
<h5 id="sql-workbenchj_1"><strong>安装 SQL Workbench/J</strong></h5>
<p>1.转至 SQL Workbench/J 网站并下载适用于您的客户端计算机上的操作系统的分发包。
2.将存档解压到您选择的目录中。</p>
<p>该应用程序现在已准备好运行 - 无需执行进一步的步骤。 有关详细信息，请参阅 SQL Workbench/J 用户手册中的安装和启动 SQL Workbench/J。</p>
<h5 id="sql-workbenchj_2"><strong>配置 SQL Workbench/J</strong></h5>
<p>1.配置 PostgreSQL 驱动程序
BMDB 与 PostgreSQL 兼容，因此在使用 SQL Workbench/J 时，请使用 PostgreSQL JDBC 驱动程序。</p>
<p>（1）启动 SQL Workbench/J 应用程序。 将出现“选择连接配置文件”弹出窗口。</p>
<p><img alt="" src="media/chapter9/58.png" /></p>
<p>（2）单击“管理驱动程序”（位于窗口左下角）以打开“管理驱动程序”窗口。</p>
<p><img alt="" src="media/chapter9/59.png" /></p>
<p>（3)在驱动程序列表中，选择 PostgreSQL，然后编辑驱动程序的字段：</p>
<ul>
<li>Name：PostgreSQL（用于 BMDB）</li>
<li>
<p>Library：显示 PostgreSQL JDBC 驱动程序 JAR 文件的位置。 [对于新配置，请浏览到文件位置并单击“选择”。] 安装后，JRE 或 JDK 的默认位置为：
  \Library\Java\Extensions\<jdbc-driver>.jar`</p>
</li>
<li>
<p>Classname：org.postgresql.Driver</p>
</li>
<li>Sample URL：jdbc:postgresql:127.0.0.1:2521/name_of_database（基于 BMDB 默认值）。 初次打开驱动程序配置时，该字段显示
  jdbc:postgresql://host:port/name_of_database</li>
</ul>
<p>（4）单击“确定”。 “管理驱动程序”窗口将关闭并返回到“选择连接配置文件”窗口。</p>
<p>您现在已经配置了 PostgreSQL JDBC 驱动程序以与 BMDB 一起使用，现在可以创建连接配置文件。</p>
<p>有关更多信息，请参阅：</p>
<p>SQL Workbench/J 用户手册中的 JDBC 驱动程序。
PostgreSQL JDBC 驱动程序文档。</p>
<p>2.创建 BMDB 连接配置文件
您需要为您使用的每个数据库创建一个连接配置文件，并且您始终可以通过选择“文件”&gt;“连接”窗口从菜单进入“选择连接配置文件”窗口。
（1）在“选择连接配置文件”窗口中，单击“创建新的连接配置文件”。 创建一个新的配置文件。
（2）将 New profile 替换为连接配置文件的有意义的名称。 由于每个数据库连接都需要一个单独的配置文件，因此请在配置文件名称中包含数据库名称。
（3）对于驱动程序，选择 PostgreSQL（对于 BMDB）(org.postgresql.Driver)。
（4）对于 URL，将 name_of_database 替换为要连接的数据库的名称。
（5）对于用户名，输入 bigmath 或您将使用的用户名。
（6）对于密码，请将字段留空，除非启用了 BSQL 身份验证。
（7）选择自动提交。 在 PostgreSQL 和 BMDB 中，AUTOCOMMIT 默认处于打开状态。
（8）单击“测试”以验证连接是否成功。
（9）单击“确定”。 将出现 SQL Workbench/J 默认窗口。 您的连接现在可以使用了。</p>
<p>这就是开始使用连接所需的所有设置。 有关配置文件的详细信息，请参阅 SQL Workbench/J 用户手册中的连接到数据库。</p>
<h5 id="_21"><strong>进一步使用</strong></h5>
<p>现在您已经了解了如何配置 SQL Workbench/J 以与 BMDB 数据库配合使用，您可以开始探索 SQL Workbench/J 的功能。 有关使用 SQL Workbench/J 的详细信息，请参阅 SQL Workbench/J 用户手册。</p>
<p>如果您正在寻找示例数据库以使用 SQL Workbench/J 探索 BMDB，请参阅示例数据。</p>
<h4 id="tableplus"><strong>TablePlus</strong></h4>
<p>TablePlus 是一款流行的数据库开发人员控制台，具有与 PostgreSQL、Cassandra 和 Redis 等主要数据库的内置集成。 可以免费开始使用升级到永久付费许可证的选项。 TablePlus 与 BMDB 配合使用不会出现任何问题，因为 BMDB API 在有线协议级别与 TablePlus 已支持的数据库兼容。</p>
<p>本教程展示如何将 TablePlus 连接到 BMDB 集群。</p>
<h5 id="_22"><strong>准备</strong></h5>
<p>您的 BMDB 集群应该已启动并正在运行。 请参阅 BMDB 先决条件。</p>
<h5 id="tableplus_1"><strong>安装TablePlus</strong></h5>
<p>要安装 TablePlus，请转至下载页面并选择适合您的操作系统的版本。</p>
<h5 id="_23"><strong>创建连接</strong></h5>
<p>您可以使用 TablePlus 通过 BSQL 和 BCQL API 连接到 BMDB。</p>
<p>要创建连接，请执行以下操作：
1.在 TablePlus 中，从“连接”菜单中选择“新建”。
2.对于 BSQL 选择 PostgreSQL，对于 BCQL 选择 Cassandra，然后单击“创建”。</p>
<p><img alt="" src="media/chapter9/60.png" /></p>
<p>3.输入连接的名称并填写连接参数。
4.单击“测试”以验证 TablePlus 是否可以与 BMDB 连接。 如果测试成功，字段的颜色将变为绿色。</p>
<p><img alt="" src="media/chapter9/61.png" /></p>
<p>5.单击“连接”以创建连接。
连接保存在应用程序中，并在每次启动 TablePlus 时显示。</p>
<p><img alt="" src="media/chapter9/62.png" /></p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      © 2024 贝格迈思
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.aecac24b.min.js"></script>
      
        <script src="../../javascripts/extra.js"></script>
      
    
  </body>
</html>