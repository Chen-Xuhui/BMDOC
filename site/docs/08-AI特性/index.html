
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="贝格迈思数据库使用手册">
      
      
      
      
        <link rel="prev" href="../07-%E5%90%91%E9%87%8F%E7%89%B9%E6%80%A7/">
      
      
        <link rel="next" href="../09.1-%E6%9E%B6%E6%9E%84/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.4.6">
    
    
      
        <title>AI特性 - 手册</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.35e1ed30.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.356b1318.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Ubuntu";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="mo" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#ai" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="手册" class="md-header__button md-logo" aria-label="手册" data-md-component="logo">
      
  <img src="../../assets/new-logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            手册
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              AI特性
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/aminerdocs/docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="手册" class="md-nav__button md-logo" aria-label="手册" data-md-component="logo">
      
  <img src="../../assets/new-logo.png" alt="logo">

    </a>
    手册
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/aminerdocs/docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../01-AISQL%E7%AE%80%E4%BB%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AiSQL简介
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    快速上手
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            快速上手
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    快速安装部署
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/SQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SQL基本操作
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/BCQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BCQL基本操作
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%88%9B%E5%BB%BAJava%E7%A4%BA%E4%BE%8B%E5%BA%94%E7%94%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    创建Java示例应用程序
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    应用开发
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            应用开发
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    构建应用
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            构建应用
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/JAVA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Java
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Go/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Go
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Python/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Python
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Node.js/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Node.js
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C%2B%2B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C%23/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C#
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Ruby/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Ruby
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Rust/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Rust
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/PHP/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PHP
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%85%A8%E5%B1%80%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    构建全局应用程序
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    构建多云应用程序
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            构建多云应用程序
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    概述
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../04-%E9%83%A8%E7%BD%B2%E9%9B%86%E7%BE%A4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    部署集群
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../05-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数据迁移
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../06-%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    管理数据库
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../07-%E5%90%91%E9%87%8F%E7%89%B9%E6%80%A7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    向量特性
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    AI特性
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    AI特性
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    概述
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    架构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    基本原理
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    详细功能说明
  </a>
  
    <nav class="md-nav" aria-label="详细功能说明">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    表单数据模型服务
  </a>
  
    <nav class="md-nav" aria-label="表单数据模型服务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    模型训练
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    字段预处理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    自动调参
  </a>
  
    <nav class="md-nav" aria-label="自动调参">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    网格搜索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    随机搜索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    分类算法的超参数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    回归算法的超参数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    聚类算法的超参数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    自动算法选择
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    模型预测
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    批量预测
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    模型评估
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    模型查询
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    模型删除
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    简洁数据模型服务
  </a>
  
    <nav class="md-nav" aria-label="简洁数据模型服务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    数据集加载
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    模型训练
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    字段预处理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    自动调参
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    自动算法选择
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    模型预测
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    批量预测
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    模型评估
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    模型查询
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    模型删除
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    算法扩展
  </a>
  
    <nav class="md-nav" aria-label="算法扩展">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    添加算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    查询算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    删除算法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    数据向量化和检索
  </a>
  
    <nav class="md-nav" aria-label="数据向量化和检索">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    向量化模型管理
  </a>
  
    <nav class="md-nav" aria-label="向量化模型管理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    添加内置向量化模型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    更改内置向量化模型优先度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    查询内置向量化模型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    删除内置向量化模型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    添加外置向量化模型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    查询外置向量化模型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    删除外置向量化模型
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    文本向量化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    图片向量化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    跨模态数据检索
  </a>
  
    <nav class="md-nav" aria-label="跨模态数据检索">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    以文搜文
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    以图搜文
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    以文搜图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    以图搜图
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    大模型调用
  </a>
  
    <nav class="md-nav" aria-label="大模型调用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    大模型管理
  </a>
  
    <nav class="md-nav" aria-label="大模型管理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    添加大模型服务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    查询大模型服务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    删除大模型服务
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    大模型问答
  </a>
  
    <nav class="md-nav" aria-label="大模型问答">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    传统对话
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    基于检索增强生成的对话
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    基于图片和自然语言的视觉问答
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql" class="md-nav__link">
    自然语言到SQL语句的转换
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    操作审计
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    备份和恢复
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    内置帮助服务
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    参考
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            参考
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.1-%E6%9E%B6%E6%9E%84/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    架构
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.2-CLIs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CLIs
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.3-%E9%85%8D%E7%BD%AE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    配置
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.4-BSQL/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BSQL
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.5-BCQL/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BCQL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    概述
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    架构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    基本原理
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    详细功能说明
  </a>
  
    <nav class="md-nav" aria-label="详细功能说明">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    表单数据模型服务
  </a>
  
    <nav class="md-nav" aria-label="表单数据模型服务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    模型训练
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    字段预处理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    自动调参
  </a>
  
    <nav class="md-nav" aria-label="自动调参">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    网格搜索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    随机搜索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    分类算法的超参数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    回归算法的超参数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    聚类算法的超参数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    自动算法选择
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    模型预测
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    批量预测
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    模型评估
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    模型查询
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    模型删除
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    简洁数据模型服务
  </a>
  
    <nav class="md-nav" aria-label="简洁数据模型服务">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    数据集加载
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    模型训练
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    字段预处理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    自动调参
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    自动算法选择
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    模型预测
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    批量预测
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    模型评估
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    模型查询
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    模型删除
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    算法扩展
  </a>
  
    <nav class="md-nav" aria-label="算法扩展">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    添加算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    查询算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    删除算法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    数据向量化和检索
  </a>
  
    <nav class="md-nav" aria-label="数据向量化和检索">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    向量化模型管理
  </a>
  
    <nav class="md-nav" aria-label="向量化模型管理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    添加内置向量化模型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    更改内置向量化模型优先度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    查询内置向量化模型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    删除内置向量化模型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    添加外置向量化模型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    查询外置向量化模型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    删除外置向量化模型
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    文本向量化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    图片向量化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    跨模态数据检索
  </a>
  
    <nav class="md-nav" aria-label="跨模态数据检索">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    以文搜文
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    以图搜文
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    以文搜图
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    以图搜图
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    大模型调用
  </a>
  
    <nav class="md-nav" aria-label="大模型调用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    大模型管理
  </a>
  
    <nav class="md-nav" aria-label="大模型管理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    添加大模型服务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    查询大模型服务
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    删除大模型服务
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    大模型问答
  </a>
  
    <nav class="md-nav" aria-label="大模型问答">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    传统对话
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    基于检索增强生成的对话
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    基于图片和自然语言的视觉问答
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql" class="md-nav__link">
    自然语言到SQL语句的转换
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    操作审计
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    备份和恢复
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    内置帮助服务
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="ai"><strong>AI特性</strong></h1>
<h2 id="_1"><strong>概述</strong></h2>
<p>AI特性是基于AiSQL插件机制开发的完整MLOps平台，通过将机器学习模型移动至数据库中管理，在库内调用机器学习模型，而不是将数据移动到模型中处理，以提供更高效可靠的AI与DB融合的解决方案。</p>
<p>通过在AiSQL数据库中添加插件的方式引入AI特性，使用SQL API来调用插件提供的AI相关功能，例如数据预处理、模型训练、预测推理、数据向量化、大模型问答等，您可以无缝地将机器学习模型集成到AiSQL数据库中，并利用先进算法的能力高效处理数据。</p>
<h2 id="_2"><strong>架构</strong></h2>
<p><img alt="" src="./media/chapter8/1.png" /></p>
<p>AI特性允许用户直接在AiSQL数据库上执行SQL查询来运行机器学习模型（包括大模型)，将数据管理方面的繁琐工作从ML/AI应用场景中抽象出来。</p>
<h2 id="_3"><strong>基本原理</strong></h2>
<p>AI特性是在AiSQL数据库上基于插件进行开发构建的。AI特性使用服务端编程接口（Server Programming Interface, SPI）访问库内数据，提供高效的数据驱动机器学习能力，并将训练好的模型保存到库内，确保模型的高可用和安全性。</p>
<p>AI特性主要包括以下方面：</p>
<p><strong>1.模型训练</strong>：提供多种经典和前沿的回归、分类和聚类算法，可以在库内预处理应用程序数据对模型进行训练和评估，支持AutoML（即自动算法选择和自动调参）机制以确保最佳预测效果。</p>
<p><strong>2.模型存储</strong>：训练好的机器学习模型自动入库保存，并支持下载前沿的开源大模型入库存储，提供版本之间性能变化的跟踪。</p>
<p><strong>3.模型应用</strong>：适配CPU和GPU等多种异构计算设备，服务于机器学习模型的推理预测，支撑无网络时延的高效、安全和可靠的交互式应用。</p>
<p><strong>4.算法扩展</strong>：支持动态添加和删除用户自定义的或标准sklearn库中的回归、分类或聚类算法，提升AI特性应用的灵活性和可拓展性。</p>
<p><strong>5.向量存储</strong>：支持多模态数据向量化，提供流行高效的最近邻检索算法，满足向量数据库的应用需求。</p>
<p><strong>6.问答系统</strong>：支持多种模式的大模型问答功能，包括传统对话、基于检索增强生成的对话、基于图片和自然语言的视觉问答，以及自然语言到SQL语句的转换。</p>
<p><strong>7.操作审计</strong>：涉及AI特性的数据操作和模型操作都产生专有的审计记录，便于跟踪监控系统行为。</p>
<p>AI特性插件可以通过下述SQL语句添加到AiSQL数据库中并进行初始化：</p>
<div class="highlight"><pre><span></span><code>create extension aisql;  

-- 初始化审计资源  

select aisql.initialize_audit();  

-- 初始化机器学习资源  

select aisql.initialize_ml();  

-- 初始化大模型应用资源  

select aisql.initialize_llm();
</code></pre></div>
<h2 id="_4"><strong>详细功能说明</strong></h2>
<h3 id="_5"><strong>表单数据模型服务</strong></h3>
<p>表单数据又称二维表，是传统机器学习所处理的数据类型，其中每列是任意类型（包括字符型和数值型）的字段，每行是由字段值构成的记录。表单数据的模型服务包括模型训练、字段预处理、自动调参、自动算法选择、模型预测、批量预测、模型评估、模型查询和删除等。</p>
<h4 id="_6"><strong>模型训练</strong></h4>
<p>模型训练是机器学习的基础步骤，通过训练数据集来训练模型，使其能够学习到数据的特征和规律，从而对新的数据进行预测。在AiSQL中，模型训练支持分类、回归和聚类三种主流机器学习任务，并支持AutoML（自动算法选择和自动调参）机制，以实现最佳预测效果。表单数据的模型训练可以通过下述SQL语句进行：
<div class="highlight"><pre><span></span><code>select * from aisql.train(project_name text, task text, relation_name text, x_column_names text[], y_column_names text[] default NULL, cat_columns integer[] default NULL, algorithm text default NULL, hyperparams text default &#39;{}&#39;, search text default NULL, search_params text default &#39;{}&#39;, search_args text default &#39;{}&#39;, preprocess text default &#39;{}&#39;);
</code></pre></div></p>
<p>其中，参数说明如下：
project_name：项目名称，用于保存训练好的模型。
task：任务类型，支持分类、回归和聚类三种任务。
relation_name：数据表名称，用于指定训练数据集。
x_column_names：特征列名称数组，用于指定训练数据集中的特征列。
y_column_names：标签列名称数组，用于指定训练数据集中的标签列，默认为NULL，其中NULL仅适用于聚类任务，多个标签列对应多个预测目标。
cat_columns：类别列索引，用于指定训练数据集中的类别列，默认为NULL，其中类别列是字符型字段，该参数非NULL时适用于能直接处理类别列的catboost算法。
algorithm：算法名称，用于指定训练算法，默认为NULL，其中NULL表示针对指定任务的所有算法进行模型训练。
hyperparams：JSON格式的算法超参数定义，用于指定训练算法的超参数，默认为空的JSON对象{}，其中{}表示使用默认的超参数。
search：超参数搜索策略，用于指定训练算法的超参数搜索策略，默认为NULL，其中NULL表示不进行超参数调优。
search_params：JSON格式的超参数搜索范围定义，用于指定训练算法的超参数调优范围，默认为空的JSON对象{}，其中{}意味着实际上不进行超参数调优。
search_args：JSON格式的超参数搜索算法的参数，用于控制超参数搜索行为，比如迭代次数，默认为空的JSON对象{}，其中{}表示使用默认的超参数搜索算法参数。
preprocess：JSON格式的数据预处理定义，用于指定训练数据集各个字段（包括特征列和标签列）的数据预处理方法，默认为空的JSON对象{}，其中{}表示不进行数据预处理。</p>
<p>该SQL语句的返回值是一个数据视图，由(项目ID，模型名，算法:超参数)三个字段的记录构成。</p>
<h4 id="_7"><strong>字段预处理</strong></h4>
<p>字段预处理是机器学习模型训练前的必要步骤，用于将原始数据转换为适合模型训练的格式。在AiSQL中，字段预处理支持数值型和字符型字段的预处理，包括归一化、标准化、独热编码和标签编码等。字段预处理可以通过模型训练SQL语句的preprocess参数进行指定。preprocess参数值是一个JSON映射表，其中每个键值对表示一个字段的数据预处理方法，规格如下：
<div class="highlight"><pre><span></span><code>&quot;字段名&quot;: {&quot;预处理方法1&quot;: {&quot;参数名11&quot;: 参数值11, &quot;参数名12&quot;: 参数值12, ...}, &quot;预处理方法2&quot;: {&quot;参数名21&quot;: 参数值21, &quot;参数名22&quot;: 参数值22, ...}, ...}
</code></pre></div></p>
<p>其中，单个字段可以指定多个预处理方法，并按照顺序依次执行；字段名可以是特征列名称，也可以是标签列名称，也可以是全体特征列（不含标签列）的匹配字符串ALL_X，以下述简写形式为全体特征列定义相同的预处理过程：
<div class="highlight"><pre><span></span><code>&quot;_ALL_X_&quot;: {&quot;预处理方法1&quot;: {&quot;参数名11&quot;: 参数值11, &quot;参数名12&quot;: 参数值12, ...}, &quot;预处理方法2&quot;: {&quot;参数名21&quot;: 参数值21, &quot;参数名22&quot;: 参数值22, ...}, ...}
</code></pre></div></p>
<p>AI特性插件支持多种字段预处理方法，包括以下几种，其中编号后的小写字符串是对应预处理方法在preprocess参数值中采用的名称：
1.target：目标编码器 (TargetEncoder)
目标编码器是一种用于对字符型特征进行编码的算法。它通过计算指定字符型特征对应的平均目标值（即目标变量）来将字符型特征转换为数值型特征。这样可以使得字符型特征具有更明显的物理含义，便于模型进行学习和分析。
常用参数:
（1）categories: 类别型特征的类别。可以是"auto"（自动确定），也可以是一个列表，列表中的每个元素代表一个特征的类别。如果设置为"auto"，则从训练数据中自动确定类别。
（2）target_type: 目标变量的类型。可以是"auto"（自动确定）、"continuous"（连续型）或"binary"（二分类）。如果设置为"auto"，则使用type_of_target函数自动推断目标变量的类型。目标编码器仅支持"continuous"（连续型）或"binary"（二分类）两种目标变量类型。</p>
<p>（3）smooth: 平滑参数。用于平衡类别平均值和全局目标平均值之间的权重。如果设置为"auto"，则使用经验贝叶斯估计。</p>
<p>2.one_hot：独热编码器 (OneHotEncoder)
独热编码器是一种用于对字符型特征进行编码的算法。它将指定字符型特征转换为一个新的二进制特征，使得该字符型特征值可以表示为一个向量。这样可以使得模型能够更好地学习字符型特征之间的差异。
常用参数: 
（1）categories: 类别型特征的类别。可以是"auto"（自动确定），也可以是一个列表，列表中的每个元素代表一个特征的类别。如果设置为"auto"，则从训练数据中自动确定类别。
（2）drop: 指定在特征中删除一个类别的方法。可以是'first'，表示删除每个特征中的第一个类别；也可以是'if_binary'，表示如果特征中有两个类别，则删除第一个类别；还可以是一个数组，数组中的每个元素表示应该删除的特征中的类别。
（3）sparse_output: 布尔值，如果设置为True，则返回稀疏矩阵，否则返回数组。
（4）handle_unknown: 指定在转换过程中处理未知类别的方法。可以是'error'，表示如果遇到未知类别则抛出错误；可以是'ignore'，表示在转换过程中忽略未知类别；还可以是'infrequent_if_exist'，表示如果存在未知类别，则将其映射到稀有类别（如果存在）。
（5）min_frequency: 指定类别最小出现次数，用于确定稀有类别。
（6）max_categories: 指定最大类别数，用于确定稀有类别。</p>
<p>3.ordinal：序号编码器 (OrdinalEncoder)
序号编码器是一种用于对字符型特征进行编码的算法。它将指定字符型特征转换为一个连续的整数值，使得每个字符型特征值可以表示为有序自然数列中的一个元素。这样可以使得模型能够更好地学习字符型特征之间的顺序关系。
常用参数:
（1）categories：类别型特征的类别。可以是"auto"（自动确定），也可以是一个列表，列表中的每个元素代表一个特征的类别。如果设置为"auto"，则从训练数据中自动确定类别。
（2）handle_unknown：{'error', 'use_encoded_value'}, 默认值为'error'。当设置为'error'时，如果在transform过程中出现未知类别，将引发错误。当设置为'use_encoded_value'时，将使用unknown_value参数给未知类别设置编码值。在inverse_transform中，未知类别将被表示为None。
（3）unknown_value：int，默认值为None（设置默认值时不定义unknown_value参数）。当handle_unknown设置为'use_encoded_value'时，此参数是必需的，并且将设置未知类别的编码值。</p>
<p>4.standard：标准缩放器 (StandardScaler)
标准缩放器是一种用于对数值型特征进行标准化处理的算法。它通过计算指定数值型特征的均值和标准差，然后将每个特征值减去均值并除以标准差，使得每个特征具有相同的分布。这样可以使得模型能够更好地学习数值型特征之间的差异。
常用参数:
（1）with_mean: 布尔值，默认为True。如果为True，则计算均值并从指定特征中减去均值。
（2）with_std: 布尔值，默认为True。如果为True，则计算标准差并除以指定特征的标准差。</p>
<p>5.min_max：最小最大缩放器 (MinMaxScaler)
最小最大缩放器是一种用于对数值型特征进行归一化处理的算法。它通过计算指定数值型特征的最小值和最大值，然后将每个特征值减去最小值并除以最大值和最小值之差，使得每个特征的值被缩放到默认为[0,1]的指定区间，这样可以使得模型能够更好地学习数值型特征之间的差异。
常用参数:
（1）feature_range: (min, max)，默认为(0, 1)。指定缩放后的特征值范围。在JSON文本中使用双中括号[[min, max]]表示特征值范围。</p>
<p>6.max_abs：最大绝对缩放器 (MaxAbsScaler)
最大绝对缩放器是一种用于对数值型特征进行归一化处理的算法。它通过计算指定数值型特征的最大绝对值，然后将每个特征值除以最大绝对值，使得每个特征的值被缩放到[-1,1]区间。这样可以使得模型能够更好地学习数值型特征之间的差异。
常用参数: 无</p>
<p>7.robust：鲁棒缩放器 (RobustScaler)
鲁棒缩放器是一种用于对数值型特征进行标准化处理的算法。它通过计算指定数值型特征的均值和四分位数，然后将每个特征值减去均值并除以四分位数，这样可以使得模型能够更好地学习数值型特征之间的差异。
常用参数: 
（1）with_centering: 布尔值，默认为True。如果为True，则计算均值并从指定特征中减去均值。
（2）with_scaling: 布尔值，默认为True。如果为True，则计算四分位数并除以指定特征的四分位数。</p>
<p>8.impute：缺失值填充器 (Imputer)
缺失值填充器是一种用于对数值型特征进行缺失值填充的算法。它或者通过计算指定数值型特征的均值、中位数或众数，然后将缺失值填充为计算得到的值，或者将缺失值填充为指定常数，这样可以使得模型能够更好地学习数值型特征之间的差异。
常用参数:
（1）missing_values: int, float, str，默认为numpy.nan（设置默认值时不定义missing_values参数）。这个参数用来指定哪些值被视为缺失值。所有出现的missing_values都会被填充。
（2）strategy: str，默认为"mean"。这个参数指定缺失值填充的策略。如果为"mean"，则使用每列的平均值来填充缺失值。只能用于数值数据。如果为"median"，则使用每列的中位数来填充缺失值。只能用于数值数据。如果为"most_frequent"，则使用每列出现次数最多的值来填充缺失值。可用于字符串或数值数据。如果有多个这样的值，只返回最小的。如果为"constant"，则使用fill_value来填充所有缺失值。可用于字符串或数值数据。
（3）fill_value: str或数值，默认为None（设置默认值时不定义fill_value参数）。当strategy="constant"时，fill_value用来替换所有缺失值。对于字符串或对象数据类型，fill_value必须是一个字符串。如果为None，当处理数值数据时，fill_value将为0；当处理字符串或对象数据类型时，fill_value将为"missing_value"。</p>
<p>9.encode: 标签编码器 (LabelEncoder)</p>
<p>标签编码器是一种用于对标签列进行编码的算法。它将标签列转换为数值型特征，使得模型能够更好地学习特征列与标签列之间的关联性。该编码器相当于针对特征列的序号编码器，但只对标签列进行编码。
常用参数: 无</p>
<p>下面是一些关于preprocess参数的示例：
<div class="highlight"><pre><span></span><code>-- 对特征列parents进行序号编码，转成数值列后再进行区间为[-1,1]的最小最大缩放；同时，对特征列hus_nus进行序号编码，转成数值列后再将缺失值填充为0  
preprocess=&gt;&#39;{&quot;parents&quot;:{&quot;ordinal&quot;:{},&quot;min_max&quot;:{&quot;feature_range&quot;:[[-1,1]]}}, &quot;has_nurs&quot;:{&quot;ordinal&quot;:{},&quot;impute&quot;:{&quot;strategy&quot;:&quot;constant&quot;,&quot;fill_value&quot;:0}}}&#39;  

-- 对特征列form进行序号编码，转成数值列后再进行归一化处理；同时，对特征列children进行序号编码，转成数值列后再将缺失值填充为children的均值  
preprocess=&gt;&#39;{&quot;form&quot;:{&quot;ordinal&quot;:{},&quot;standard&quot;:{}}, &quot;children&quot;:{&quot;ordinal&quot;:{},&quot;impute&quot;:{&quot;strategy&quot;:&quot;mean&quot;}}}&#39;  

-- 对特征列finance进行独热编码处理  
preprocess=&gt;&#39;{finance&quot;:{&quot;one_hot&quot;:{}}}&#39;  

-- 对特征列health和标签列class均进行序号编码处理  
preprocess=&gt;&#39;{&quot;health&quot;:{&quot;ordinal&quot;:{}}, &quot;class&quot;:{&quot;encode&quot;:{}}}&#39;
</code></pre></div></p>
<p>作为一个例子，下面几个SQL语句展示了如何导入训练集并基于该训练集预处理所有特征列和标签列，同时根据预处理后的数据集训练一个随机森林模型：
<div class="highlight"><pre><span></span><code>-- 导入训练集  
create table aisql.nursery(parents varchar, has_nurs varchar, form varchar, children varchar, housing varchar, finance varchar, social varchar, health varchar, class varchar);  
copy aisql.nursery from &#39;path/to/nursery.data&#39; (format csv, header false, delimiter &#39;,&#39;, encoding &#39;utf-8&#39;);  

-- 训练随机森林模型  
select aisql.train(project_name=&gt;&#39;nursery.random_forest.classification&#39;, task=&gt;&#39;classification&#39;, algorithm=&gt;&#39;random_forest&#39;, relation_name=&gt;&#39;aisql.nursery&#39;, x_column_names=&gt;&#39;{parents,has_nurs,form,children,housing,finance,social,health}&#39;::text[], y_column_names=&gt;&#39;{class}&#39;::text[], preprocess=&gt;&#39;{&quot;parents&quot;:{&quot;ordinal&quot;:{},&quot;min_max&quot;:{&quot;feature_range&quot;:[[-1,1]]}},&quot;has_nurs&quot;:{&quot;ordinal&quot;:{},&quot;impute&quot;:{&quot;strategy&quot;:&quot;constant&quot;}},&quot;form&quot;:{&quot;ordinal&quot;:{},&quot;standard&quot;:{}},&quot;children&quot;:{&quot;ordinal&quot;:{},&quot;impute&quot;:{&quot;strategy&quot;:&quot;mean&quot;}},&quot;housing&quot;:{&quot;ordinal&quot;:{}},&quot;finance&quot;:{&quot;one_hot&quot;:{}},&quot;social&quot;:{&quot;ordinal&quot;:{}},&quot;health&quot;:{&quot;ordinal&quot;:{}},&quot;class&quot;:{&quot;encode&quot;:{}}}&#39;);
</code></pre></div></p>
<p>上述例子中的训练集源自最初为对托儿所申请进行排名而开发的分层决策模型，可以从<a href="http://archive.ics.uci.edu/dataset/76/nursery">这里</a>下载。
模型训练完成后，可以通过以下SQL语句将项目中的对应预处理模型应用到指定表单中的指定字段，产生(行号，预处理后字段值)构成的两列数据视图：
<div class="highlight"><pre><span></span><code>select * from aisql.preprocess(column_name text, relation_name text, project_name text default NULL);
</code></pre></div></p>
<p>其中，参数说明如下：
column_name: 预处理模型对应的字段名，即preprocess参数中指定的字段名。
relation_name: 待预处理的数据表单名。
project_name: 预处理模型对应的项目名。当项目名为空时，直接产生由(行号，原始字段值)构成的两列数据视图。</p>
<p>通过行号作为合并主键，将各个字段应用预处理模型后得到的数据视图进行合并，即可得到预处理后的数据表。
比如，将上面例子中nursery.random_forest.classification项目所产生的对应预处理模型应用到aisql.nursery表单中的parents、finance和class三个字段，可以使用下面的SQL语句：</p>
<div class="highlight"><pre><span></span><code>-- 预处理parents特征列  
select row_number, value::float8 from aisql.preprocess(&#39;parents&#39;, &#39;aisql.nursery&#39;, &#39;nursery.random_forest.classification&#39;);  

-- 预处理finance特征列  
select row_number, value::float8[] from aisql.preprocess(&#39;finance&#39;, &#39;aisql.nursery&#39;, &#39;nursery.random_forest.classification&#39;);  

-- 预处理class标签列  
select row_number, value::float8 from aisql.preprocess(&#39;class&#39;, &#39;aisql.nursery&#39;, &#39;nursery.random_forest.classification&#39;);
</code></pre></div>
<h4 id="_8"><strong>自动调参</strong></h4>
<p>自动调参是AutoML的重要环节，用于选择最优的超参数组合，从而提高模型的预测效果。在AiSQL中，自动调参支持网格搜索和随机搜索两种策略，并通过模型训练SQL语句的search、search_params和search_args参数进行指定。</p>
<h5 id="_9"><strong>网格搜索</strong></h5>
<p>网格搜索是一种通过遍历所有可能的超参数组合，选择最优超参数组合的搜索策略。AiSQL在模型训练SQL语句中，通过设置search参数为'grid'来实施指定算法超参数的网格搜索，并通过search_params参数指定超参数的取值范围。网格搜索忽略search_args参数的设定。
调参示例：
<div class="highlight"><pre><span></span><code>-- 针对aisql.nursery表单训练支持向量分类器SVC，并对SVC算法的超参数进行网格搜索，搜索参数为kernel和C，取值范围分别为[&quot;linear&quot;,&quot;poly&quot;,&quot;rbf&quot;,&quot;sigmoid&quot;]和[1, 5, 10]  
select aisql.train(project_name=&gt;&#39;nursery.support_vector.classification&#39;, task=&gt;&#39;classification&#39;, algorithm=&gt;&#39;support_vector&#39;, relation_name=&gt;&#39;aisql.nursery&#39;, x_column_names=&gt;&#39;{parents,has_nurs,form,children,housing,finance,social,health}&#39;::text[], y_column_names=&gt;&#39;{class}&#39;::text[], preprocess=&gt;&#39;{&quot;_ALL_X_&quot;:{&quot;ordinal&quot;:{}}, &quot;class&quot;:{&quot;encode&quot;:{}}}&#39;, search=&gt;&#39;grid&#39;, search_params=&gt;&#39;{&quot;kernel&quot;:[&quot;linear&quot;,&quot;poly&quot;,&quot;rbf&quot;,&quot;sigmoid&quot;], &quot;C&quot;:[1,5,10]}&#39;);
</code></pre></div></p>
<h5 id="_10"><strong>随机搜索</strong></h5>
<p>随机搜索是一种通过随机生成超参数组合，选择最优超参数组合的搜索策略。AiSQL在模型训练SQL语句中，通过设置search参数为'random'来实施指定算法超参数的随机搜索，并通过search_params参数指定超参数的取值范围。随机搜索支持search_args参数的迭代次数n_iter设定，比如：
<div class="highlight"><pre><span></span><code>search_args=&gt;&#39;{&quot;n_iter&quot;:10}&#39;
</code></pre></div></p>
<h5 id="_11"><strong>分类算法的超参数</strong></h5>
<p>AI特性插件支持多种分类算法，包括在各种预测建模大赛中独占鳌头的三大梯度提升树算法xgboost、lightgbm和catboost。下面部分以AiSQL中的算法名作为标题给出对应算法的主要超参数及其说明。
1.xgboost</p>
<p>XGBClassifier (xgboost) 使用梯度提升树模型进行分类。基于梯度提升树模型通过将数据集分成多个子集，然后在每个子集上训练一个决策树，最后将所有决策树的结果进行融合。 
XGBClassifier的常用超参数包括:
（1）max_depth: 整数，默认值为6。树的最大深度。
（2）learning_rate: 浮点数，默认值为0.3。学习率，即每棵树对最终结果的贡献度。
（3）n_estimators: 整数，默认值为100。树的个数，即迭代次数。
（4）subsample: 浮点数，默认值为1.0。每棵树训练时使用的样本比例。
（5）colsample_bytree: 浮点数，默认值为1.0。每棵树训练时使用的特征比例。</p>
<p>2.lightgbm
LGBMClassifier (lightgbm) 基于梯度提升树模型，通过迭代地构建多棵树来提高模型的性能。在每次迭代中，它会选择一个最优的分裂点，将数据集分成两部分，然后在这两部分上分别构建左右子树。这个过程会一直进行，直到达到预设的停止条件。
LGBMClassifier的常用超参数包括:</p>
<p>（1）num_leaves: 整数，默认值为31。树的最大叶子节点数。
（2）learning_rate: 浮点数，默认值为0.1。学习率，即每棵树对最终结果的贡献度。
（3）n_estimators: 整数，默认值为100。树的个数，即迭代次数。
（4）subsample: 浮点数，默认值为1.0。每棵树训练时使用的样本比例。</p>
<p>3.catboost
CatBoostClassifier (catboost) 通过构建多棵树来学习数据中的模式，并使用这些模式来对新的数据进行分类。每棵树都是一个二叉树，它将数据分成两个子集，直到达到预定的停止条件。catboost使用了基于梯度提升的方法，通过迭代地构建多棵树来提高模型的性能。它是所有分类算法中，唯一一种能够直接处理字符型特征列和标签列的算法，其他分类算法均需要在训练前将字符型特征列和标签列转换为数值型特征列和标签列。
CatBoostClassifier的常用超参数包括:
（1）depth: 整数，默认值为6。树的最大深度。
（2）learning_rate: 浮点数，默认值为0.1。学习率，即每棵树对最终结果的贡献度。
（3）iterations: 整数，默认值为100。树的个数，即迭代次数。</p>
<p>4.decision_tree
决策树分类器DecisionTreeClassifier (decision_tree) 是一种基于贪心算法构建的树形模型，它通过递归地分割数据集来创建树节点。在每个节点上，决策树选择一个最优的特征和阈值来分割数据集，使得分割后的子集尽可能属于同一个类别。这个过程一直进行到所有特征都被使用过，或者数据集中的所有类别都只有一个样本。
DecisionTreeClassifier的常用超参数包括:
（1）max_depth: 整数，默认值为None（设置默认值时不定义max_depth参数）。树的最大深度，其中None表示不限定树的最大深度。
（2）min_samples_split: 整数，默认值为2。节点分裂所需的最小样本数。
（3）min_samples_leaf: 整数，默认值为1。叶子节点所需的最小样本数。
（4）criterion: 字符串，默认值为'gini'。分裂节点的准则，包括'gini'、'entropy'和'log_loss'三种。</p>
<p>5.xgboost_rf</p>
<p>XGBRFClassifier (xgboost_rf) 利用随机森林算法，通过多棵树来拟合数据分布，从而实现分类。随机森林算法通过在训练过程中随机选择特征和样本，来避免过拟合，提高模型的泛化能力。
XGBRFClassifier的常用超参数包括:
（1）n_estimators: 整数，默认值为100。树的个数，即迭代次数。
（2）max_depth: 整数，默认值为6。树的最大深度。
（3）min_samples_split: 整数，默认值为2。节点分裂所需的最小样本数。
（4）min_samples_leaf: 整数，默认值为1。叶子节点所需的最小样本数。</p>
<p>6.random_forest
随机森林分类器RandomForestClassifier (random_forest) 是一种集成学习方法，它通过训练多个决策树模型来提高模型的性能。
RandomForestClassifier的常用超参数包括:
（1）n_estimators: 整数，默认值为100。树的个数，即迭代次数。
（2）max_depth: 整数，默认值为None（设置默认值时不定义max_depth参数）。树的最大深度，其中None表示不限定树的最大深度。
（3）min_samples_split: 整数，默认值为2。节点分裂所需的最小样本数。
（4）min_samples_leaf: 整数，默认值为1。叶子节点所需的最小样本数。</p>
<p>7.support_vector
支持向量分类器SVC (support_vector) 是一种针对二分类问题来设计的监督学习算法。它通过寻找分类超平面，使得正负样本之间的间隔最大。
SVC的常用超参数包括:
（1）C: 浮点数，默认值为1.0。正则化参数，用于控制模型的复杂度和过拟合程度。
（2）kernel: 字符串，默认值为'rbf'。核函数的类型，包括'linear'、'poly'、'rbf'、'sigmoid'和'precomputed'等。
（3）gamma: 'auto'、'scale'或浮点数，默认值为'auto'。核函数的系数，用于控制核函数的形状。</p>
<h5 id="_12"><strong>回归算法的超参数</strong></h5>
<p>AI特性插件支持多种回归算法，包括在各种预测建模大赛中独占鳌头的三大梯度提升树算法xgboost、lightgbm和catboost。下面部分以AiSQL中的算法名作为标题给出对应算法的主要超参数及其说明。
1.xgboost
XGBRegressor (xgboost) 基于梯度提升树模型，通过构建多棵树来拟合目标函数。在训练过程中，它会根据损失函数的梯度来更新树的参数，从而逐步逼近目标函数。
XGBRegressor的常用超参数包括:
（1）max_depth: 整数，默认值为6。树的最大深度。
（2）learning_rate: 浮点数，默认值为0.3。学习率，即每棵树对最终结果的贡献度。
（3）n_estimators: 整数，默认值为100。树的个数，即迭代次数。
（4）subsample: 浮点数，默认值为1.0。每棵树训练时使用的样本比例。
（5）colsample_bytree: 浮点数，默认值为1.0。每棵树训练时使用的特征比例。</p>
<p>2.lightgbm
LGBMRegressor (lightgbm) 基于梯度提升树模型，通过迭代地构建多棵树来提高模型的性能。在每次迭代中，它会选择一个最优的分裂点，将数据集分成两部分，然后在这两部分上分别构建左右子树。这个过程会一直进行，直到达到预设的停止条件。
LGBMRegressor的常用超参数包括:
（1）num_leaves: 整数，默认值为31。树的最大叶子节点数。
（2）learning_rate: 浮点数，默认值为0.1。学习率，即每棵树对最终结果的贡献度。
（3）n_estimators: 整数，默认值为100。树的个数，即迭代次数。
（4）subsample: 浮点数，默认值为1.0。每棵树训练时使用的样本比例。</p>
<p>3.catboost
CatBoostRegressor (catboost) 通过构建多棵树来学习数据中的模式，并使用这些模式来对新的数据进行回归。每棵树都是一个二叉树，它将数据分成两个子集，直到达到预定的停止条件。catboost使用了基于梯度提升的方法，通过迭代地构建多棵树来提高模型的性能。它是所有回归算法中，唯一一种能够直接处理字符型特征列和标签列的算法，其他回归算法均需要在训练前将字符型特征列和标签列转换为数值型特征列和标签列。
CatBoostRegressor的常用超参数包括:
（1）depth: 整数，默认值为6。树的最大深度。
（2）learning_rate: 浮点数，默认值为0.1。学习率，即每棵树对最终结果的贡献度。
（3）iterations: 整数，默认值为100。树的个数，即迭代次数。</p>
<p>4.decision_tree
决策树回归器DecisionTreeRegressor (decision_tree) 是一种基于贪心算法构建的树形模型，它通过递归地分割数据集来创建树节点。在每个节点上，决策树选择一个最优的特征和阈值来分割数据集，使得分割后的子集尽可能属于同一个较小的数值范围。
DecisionTreeRegressor的常用超参数包括:
（1）max_depth: 整数，默认值为None（设置默认值时不定义max_depth参数）。树的最大深度，其中None表示不限定树的最大深度。
（2）min_samples_split: 整数，默认值为2。节点分裂所需的最小样本数。
（3）min_samples_leaf: 整数，默认值为1。叶子节点所需的最小样本数。
（4）criterion: 字符串，默认值为'squared_error'。分裂节点的准则，包括'squared_error'、'friedman_mse'、'absolute_error'和'poisson'四种。
（5）splitter: 字符串，默认值为'best'。分裂节点的策略，包括'best'和'random'两种。</p>
<p>5.xgboost_rf
XGBRFRegressor (xgboost_rf) 利用随机森林算法，通过多棵树来拟合数据分布，从而实现回归。随机森林算法通过在训练过程中随机选择特征和样本，来避免过拟合，提高模型的泛化能力。
XGBRFRegressor的常用超参数包括:
（1）n_estimators: 整数，默认值为100。树的个数，即迭代次数。
（2）max_depth: 整数，默认值为6。树的最大深度。
（3）min_samples_split: 整数，默认值为2。节点分裂所需的最小样本数。
（4）min_samples_leaf: 整数，默认值为1。叶子节点所需的最小样本数。</p>
<p>6.random_forest
随机森林回归器RandomForestRegressor (random_forest) 是一种集成学习方法，它通过训练多个决策树模型来提高模型的性能。
RandomForestRegressor的常用超参数包括:
（1）n_estimators: 整数，默认值为100。树的个数，即迭代次数。
（2）max_depth: 整数，默认值为None（设置默认值时不定义max_depth参数）。树的最大深度，其中None表示不限定树的最大深度。
（3）min_samples_split: 整数，默认值为2。节点分裂所需的最小样本数。
（4）min_samples_leaf: 整数，默认值为1。叶子节点所需的最小样本数。</p>
<p>7.support_vector
支持向量回归器SVR (support_vector) 是一种基于支持向量的回归算法，它通过寻找最优的回归超平面来拟合数据。支持向量回归器可以处理非线性回归问题，并且具有较好的泛化能力。
SVR的常用超参数包括:
（1）C: 浮点数，默认值为1.0。正则化参数，用于控制模型的复杂度和过拟合程度。
（2）kernel: 字符串，默认值为'rbf'。核函数的类型，包括'linear'、'poly'、'rbf'、'sigmoid'和'precomputed'等。
（3）gamma: 'auto'、'scale'或浮点数，默认值为'auto'。核函数的系数，用于控制核函数的形状。
（4）epsilon: 浮点数，默认值为0.1。容忍误差，即预测值与真实值之间的最大误差。</p>
<h5 id="_13"><strong>聚类算法的超参数</strong></h5>
<p>AI特性插件支持数种聚类算法。下面部分以AiSQL中的算法名作为标题给出对应算法的主要超参数及其说明。</p>
<p>1.kmeans
KMeans (kmeans) 是一种基于距离的聚类算法，它通过迭代地优化聚类中心的位置，使得每个样本点到其所属聚类中心的距离之和最小。
KMeans的常用超参数包括:
（1）n_clusters: 整数，默认值为8。聚类的个数。
（2）max_iter: 整数，默认值为300。最大迭代次数。
（3）init: 字符串或数组，默认值为'k-means++'。聚类中心的初始化方法，包括'k-means++'、'random'和(n_clusters, n_features)二维数组。
（4）n_init: 整数，默认值为10。初始化聚类中心的次数，每次初始化都会计算一个聚类结果，最终选择最优的聚类结果。
（5）algorithm: 字符串，默认值为'lloyd'。聚类算法的实现方式，包括'lloyd'和'elkan'两种。</p>
<p>2.mb_kmeans
MiniBatchKMeans (mb_kmeans) 是一种基于KMeans的聚类算法，它通过使用小批量样本来优化聚类中心的位置，从而提高算法的效率。MiniBatchKMeans在每次迭代中，随机选择一个小批量样本，然后使用这些样本来更新聚类中心的位置。
MiniBatchKMeans的常用超参数包括:
（1）n_clusters: 整数，默认值为8。聚类的个数。
（2）batch_size: 整数，默认值为100。每次迭代使用的小批量样本数。
（3）max_iter: 整数，默认值为100。最大迭代次数。
（4）init: 字符串或数组，默认值为'k-means++'。聚类中心的初始化方法，包括'k-means++'、'random'和(n_clusters, n_features)二维数组。
（5）n_init: 整数，默认值为10。初始化聚类中心的次数，每次初始化都会计算一个聚类结果，最终选择最优的聚类结果。</p>
<h4 id="_14"><strong>自动算法选择</strong></h4>
<p>自动算法选择也是AutoML的重要环节，用于选择最合适的算法，从而提高模型的预测效果。在AiSQL中，自动算法选择通过指定任务内所有算法的5-折交叉验证结果来挑选性能评分最高的算法，并通过在模型训练SQL语句中不指定algorithm参数（即采用algorithm参数的默认空值）的方式来启动指定任务内所有算法的训练过程。自动算法选择的效果体现在模型预测阶段。
下面列出了各个任务在实施交叉验证时采用的性能指标。
<strong>1.分类任务</strong>: 准确率 (accuracy_score)
<strong>2.回归任务</strong>: R方决定稀疏 (r2_score)
<strong>3.聚类任务</strong>: 每个样本到其最近聚类中心的欧式距离的平方和的相反数 (-SSE)</p>
<p>不限定算法的模型训练示例：
<div class="highlight"><pre><span></span><code>-- 以aisql.nursery表单作为训练集，启动所有分类算法的训练过程  
select aisql.train(project_name=&gt;&#39;nursery.classification&#39;, task=&gt;&#39;classification&#39;, relation_name=&gt;&#39;aisql.nursery&#39;, x_column_names=&gt;&#39;{parents,has_nurs,form,children,housing,finance,social,health}&#39;::text[], y_column_names=&gt;&#39;{class}&#39;::text[], preprocess=&gt;&#39;{&quot;_ALL_X_&quot;:{&quot;ordinal&quot;:{}}, &quot;class&quot;:{&quot;encode&quot;:{}}}&#39;);
</code></pre></div></p>
<p>如果需要了解各个任务支持的算法，可以通过下述SQL语句进行查询：
<div class="highlight"><pre><span></span><code>select * from aisql.list_algorithms();
</code></pre></div></p>
<p>如果需要找到项目中性能评分最高的算法（简称最优算法），可以通过下述SQL语句进行查询：
<div class="highlight"><pre><span></span><code>select * from aisql.get_best_model(project_name text, label_column text default NULL);
</code></pre></div></p>
<p>其中，project_name是需要查询的项目名称，label_name是需要查询的标签列名。项目在训练阶段即使采用相同的算法，也会根据不同的标签列训练不同的模型，因此不同标签列很可能对应不同的性能评分最高的算法。当label_name参数不给定，即采用默认的NULL值时，该SQL语句返回所有标签列对应模型中性能评分最高的模型名称，否则返回指定标签列对应模型中性能评分最高的模型名称。返回的模型名称采用“任务:模型”的形式来表示。
最优模型查询示例：</p>
<div class="highlight"><pre><span></span><code>-- 查询训练好的nursery.classification项目中的最优模型  
select aisql.get_best_model(&#39;nursery.classification&#39;);
</code></pre></div>
<h4 id="_15"><strong>模型预测</strong></h4>
<p>模型预测是机器学习的重要步骤，用于将训练好的模型应用到新的数据上，从而预测新的结果。针对表单数据单条记录，模型预测可以通过下述SQL语句进行：
<div class="highlight"><pre><span></span><code>select * from aisql.predict(project_name text, tuple_text text, label_column text default NULL);
</code></pre></div></p>
<p>其中，参数说明如下：
project_name: 字符串，指定项目名称。
tuple_text: 字符串，指定表单数据单条记录的JSON文本表示，格式为{"列名1":值1, "列名2":值2, ... , "列名n":值n}。
label_column: 字符串，指定标签列名，默认为NULL。聚类任务不需要指定标签列名，分类和回归任务需要指定标签列名。在分类或回归任务中，当label_column为NULL时，会自动选择训练时指定的第一个标签列名。</p>
<p>该SQL语句返回一个字符型预测值。聚类和回归任务的预测值原本都是数值，但为了统一返回值类型，预测值被转换为字符串来表示。
当指定项目已经训练好多个预测模型时，该SQL语句会自动选择评分最高的模型进行预测，其中模型的评分是模型在训练期间进行5-折交叉验证得到的性能结果。所有模型在进行交叉验证时会根据各自所属的任务采用不同的性能指标，具体如下：
<strong>1.分类任务</strong>: 准确率 (accuracy_score)
<strong>2.回归任务</strong>: R方决定稀疏 (r2_score)
<strong>3.聚类任务</strong>: 每个样本到其最近聚类中心的欧式距离的平方和的相反数 (-SSE)</p>
<p>模型预测示例：
<div class="highlight"><pre><span></span><code>-- 从nursery.classification项目中自动挑选出评分最高的分类模型，以aisql.nursery表单作为测试集预测前10条记录的标签，并与aisql.nursery表单中的标签进行对比  
select class, aisql.predict(&#39;nursery.classification&#39;, make_json_map(make_kv_array(&#39;{parents,has_nurs,form,children,housing,finance,social,health}&#39;::text[], array[parents,has_nurs,form,children,housing,finance,social,health], TRUE)), &#39;class&#39;) from aisql.nursery limit 10;
</code></pre></div></p>
<p>其中，make_json_map函数用于将键值对数组转换为JSON文本表示，make_kv_array函数用于将两个相同元素个数的字符型数组（对应前两个参数）按照对应元素合成键值对数组，第三个参数决定是否对第二个参数中的元素添加双引号，默认值为FALSE。
下面是关于make_json_map函数和make_kv_array函数的一些例子：</p>
<div class="highlight"><pre><span></span><code>select make_json_map(make_kv_array(array[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;], array[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;], TRUE));   
-- 返回 {&quot;a&quot;:&quot;1&quot;,&quot;b&quot;:&quot;2&quot;,&quot;c&quot;:&quot;3&quot;}  

select make_json_map(make_kv_array(array[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;], array[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;], FALSE));  
-- 返回 {&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3}  

select make_json_map(make_kv_array(array[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;], array[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]));  
-- 返回 {&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3}
</code></pre></div>
<h4 id="_16"><strong>批量预测</strong></h4>
<p>为了提高模型预测的效率，可以批量执行针对表单数据的模型预测。使用的SQL语句如下：
<div class="highlight"><pre><span></span><code>select * from aisql.batch_predict(project_name text, tuple_text text, label_column text default NULL);
</code></pre></div></p>
<p>其中，参数说明如下：
project_name: 字符串，指定项目名称。
tuple_text: 字符串，指定表单数据多条记录的列式JSON文本表示，格式为{"列名1":[值1,值2,...,值m], "列名2":[值1,值2,...,值m], ... , "列名n":[值1,值2,...,值m]}。
label_column: 字符串，指定标签列名，默认为NULL。聚类任务不需要指定标签列名，分类和回归任务需要指定标签列名。在分类或回归任务中，当label_column为NULL时，会自动选择训练时指定的第一个标签列名。</p>
<p>该SQL语句返回一个字符型的预测值列表。聚类和回归任务的预测值原本都是数值，但为了统一返回值类型，预测值被转换为字符串来表示。
与单条记录的预测一样，当指定项目已经训练好多个预测模型时，该SQL语句会自动选择评分最高的模型进行预测。
批量预测示例：
<div class="highlight"><pre><span></span><code>-- 从nursery.classification项目中自动挑选出评分最高的分类模型，以aisql.nursery表单作为测试集批量预测前10条记录的标签，并与aisql.nursery表单中的标签进行对比  
select unnest(array_agg(class)), unnest(aisql.batch_predict(&#39;nursery.classification&#39;, make_json_map(make_kv_ext_array(&#39;{parents, has_nurs, form, children, housing, finance, social, health}&#39;::text[], array[array_agg(parents), array_agg(has_nurs), array_agg(form), array_agg(children), array_agg(housing), array_agg(finance), array_agg(social), array_agg(health)], TRUE)))) from aisql.nursery limit 10;
</code></pre></div></p>
<p>其中，make_kv_ext_array函数用于将多个相同元素个数的数组（对应前两个参数）按照对应元素合成键值对数组，第一个参数是字符型数组，第二个参数是字符型数组的数组，第三个参数决定是否对第二个参数中的元素添加双引号，默认值为FALSE。
下面是关于make_kv_ext_array函数的一些例子：
<div class="highlight"><pre><span></span><code>select make_json_map(make_kv_ext_array(array[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;], array[array[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;], array[&#39;4&#39;,&#39;5&#39;,&#39;6&#39;], array[&#39;7&#39;,&#39;8&#39;,&#39;9&#39;]], TRUE));  
-- 返回 {&quot;a&quot;:[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;],&quot;b&quot;:[&quot;4&quot;,&quot;5&quot;,&quot;6&quot;],&quot;c&quot;:[&quot;7&quot;,&quot;8&quot;,&quot;9&quot;]}  

select make_json_map(make_kv_ext_array(array[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;], array[array[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;], array[&#39;4&#39;,&#39;5&#39;,&#39;6&#39;], array[&#39;7&#39;,&#39;8&#39;,&#39;9&#39;]]));  
-- 返回 {&quot;a&quot;:[1,2,3],&quot;b&quot;:[4,5,6],&quot;c&quot;:[7,8,9]}
</code></pre></div></p>
<h4 id="_17"><strong>模型评估</strong></h4>
<p>模型评估也是机器学习的重要步骤，用于评估模型在测试集上的表现。针对表单数据形式的测试集，模型评估可以通过下述SQL语句进行：
<div class="highlight"><pre><span></span><code>select * from aisql.evaluate(project_name text, relation_name text, label_column text, metric_names text[]);
</code></pre></div></p>
<p>其中，参数说明如下：
project_name: 字符串，指定项目名称。
relation_name: 字符串，指定表单数据表名，用作测试集。
label_column: 字符串，指定标签列名。聚类任务采用外部指标评估，因此也需要提供标签列名。
metric_names: 字符串数组，指定多个评估指标名称。</p>
<p>该SQL语句的返回值是一个数据视图，由(任务:模型，标签列名，评分)三个字段的记录构成，每条记录对应指定项目构建的一个模型在指定测试集上的评估结果。
下面列举不同任务所支持的评估指标，这些指标也可以通过下述SQL语句列出来。
<div class="highlight"><pre><span></span><code>-- 列出分类任务支持的所有评估指标  
select aisql.list_classification_metrics();  

-- 列出回归任务支持的所有评估指标  
select aisql.list_regression_metrics();  

-- 列出聚类任务支持的所有评估指标  
select aisql.list_clustering_metrics();
</code></pre></div></p>
<p><strong>1.分类任务</strong>
accuracy_score: 准确率，表示模型正确分类的样本数量与总样本数量之间的比值
balanced_accuracy_score: 平衡准确率，它是准确率的一种改进版本，可以更好地处理类别不平衡的数据
brier_score_loss: Brier分数损失，用于评估概率预测的质量
cohen_kappa_score: 科恩卡帕分数，用于衡量预测结果和实际结果的一致性
matthews_corrcoef: Matthews相关系数，通过计算真阳性、假阳性、真阴性和假阴性的数量，汇总评估分类模型性能
precision_score: 精确率，又称查准率，处理多分类问题时等价于精确率微平均值
recall_score: 召回率，又称查全率，处理多分类问题时等价于召回率微平均值- - f1_score: F1分数，处理多分类问题时等价于F1分数微平均值
zero_one_loss: 零一损失，表示模型错误分类的样本数量与总样本数量之间的比值
macro_precision: 精确率宏平均值，即每个标签的精确率的平均值
macro_recall: 召回率宏平均值，即每个标签的召回率的平均值
macro_f1: F1分数宏平均值，即每个标签的F1分数的平均值
macro_auc: AUC宏平均值，即每个标签的AUC的平均值
micro_precision: 精确率微平均值，即通过总的真实正例、假负例和假正例来全局计算的精确率
micro_recall: 召回率微平均值，即通过总的真实正例、假负例和假正例来全局计算的召回率
micro_f1: F1分数微平均值，即通过总的真实正例、假负例和假正例来全局计算的F1分数</p>
<p><strong>2.回归任务</strong>
d2_absolute_error_score：D^2绝对误差分数，用于衡量模型预测与实际值之间的差异
d2_pinball_score：D^2 Pinball分数，采用Pinball损失函数来衡量模型预测与实际值之间的差异
explained_variance_score：解释方差分数，用于衡量模型解释的方差占实际方差的比例
max_error：最大误差，用于衡量模型预测与实际值之间的最大差异
mean_absolute_error：平均绝对误差，用于衡量模型预测与实际值之间的平均差异
mean_absolute_percentage_error：平均绝对百分比误差，用于衡量模型预测与实际值之间的平均差异，其中百分比误差是指实际值与预测值之间的差异占实际值的百分比
mean_gamma_deviance：平均伽马偏差，采用伽马损失函数来衡量模型预测与实际值之间的差异
mean_pinball_loss：平均Pinball损失，采用Pinball损失函数来衡量模型预测与实际值之间的差异
mean_poisson_deviance：平均泊松偏差，采用泊松损失函数来衡量模型预测与实际值之间的差异
mean_squared_error：均方误差，用于衡量模型预测与实际值之间的差异，其中平方误差是指实际值与预测值之间的平方差
mean_squared_log_error：均方对数误差，用于衡量模型预测与实际值之间的差异，其中对数误差是指实际值与预测值之间的对数差。
mean_tweedie_deviance：平均Tweedie偏差，采用Tweedie损失函数来衡量模型预测与实际值之间的差异
median_absolute_error：中位数绝对误差，用于衡量模型预测与实际值之间的差异，其中中位数是指实际值与预测值之间的中位数差异。
r2_score：R^2 分数，用于衡量模型解释的方差占实际方差的比例的指标，其中 R^2 是指模型解释的方差与实际方差的比值。</p>
<p><strong>3.聚类任务</strong>
adjusted_mutual_info_score：调整互信息分数，通过计算两个聚类结果之间的互信息，然后减去期望的互信息来消除随机性
adjusted_rand_score：调整兰德分数，通过计算两个聚类结果之间的兰德系数，然后减去期望的兰德系数来消除随机性
completeness_score：完整性分数，通过计算聚类结果与真实标签之间的相似度来衡量
fowlkes_mallows_score：Fowlkes-Mallows分数，通过计算两个聚类结果之间的Fowlkes-Mallows系数来衡量
homogeneity_score：同质性分数，通过计算聚类结果与真实标签之间的相似度来衡量
mutual_info_score：互信息分数，通过计算两个聚类结果之间的互信息来衡量
normalized_mutual_info_score：归一化互信息分数，通过计算两个聚类结果之间的归一化互信息来衡量
rand_score：兰德分数，通过计算两个聚类结果之间的兰德系数来衡量
v_measure_score：V-measure分数，通过计算聚类结果与真实标签之间的V-measure系数来衡量</p>
<p>模型评估示例：
<div class="highlight"><pre><span></span><code>-- 将aisql.nursery表单作为测试集，评估nursery.classification项目中所有分类模型的性能，包括准确率、平衡准确率、科恩卡帕分数和F1分数  
select * from aisql.evaluate(&#39;nursery.classification&#39;, &#39;aisql.nursery&#39;, &#39;class&#39;, &#39;{accuracy_score,balanced_accuracy_score,cohen_kappa_score,f1_score}&#39;::text[]);
</code></pre></div></p>
<h4 id="_18"><strong>模型查询</strong></h4>
<p>对于训练好的项目，可以通过下述SQL语句查询项目中的模型信息。
<div class="highlight"><pre><span></span><code>select * from aisql.list_models(project_name text default NULL);
</code></pre></div></p>
<p>其中，project_name是可选参数，指定要查询的项目名称。如果不指定，则查询所有项目中的模型信息。返回值是一个数据视图，由(项目名，训练表单名，标签列名，任务:模型，模型超参数，字段预处理定义，评分)七个字段的记录构成，每条记录对应一个模型的信息。
模型查询示例：
<div class="highlight"><pre><span></span><code>-- 查询nursery.classification项目中所有分类模型的性能  
select * from aisql.list_models(&#39;nursery.classification&#39;);
</code></pre></div></p>
<h4 id="_19"><strong>模型删除</strong></h4>
<p>对于训练好的项目，可以通过下述SQL语句删除项目中针对指定标签列、由指定算法训练得到的模型。
<div class="highlight"><pre><span></span><code>select * from aisql.remove_model(project_name text, algorithm text, label_column text default NULL);
</code></pre></div></p>
<p>其中，project_name是要删除模型的项目名称，algorithm是待删除模型对应的训练算法，label_column是可选参数，指定待删除模型的标签列。若label_name不指定，即默认为NULL值，则该SQL语句删除指定项目中由指定算法训练得到的所有模型；换句话说，待删除的模型不依赖于标签列。该SQL语句返回模型删除的响应信息。若删除成功，则响应"Done"，否则根据具体情况，响应指定项目不存在，或指定标签列不属于指定项目，或指定算法在指定项目中不存在等错误信息。</p>
<h3 id="_20"><strong>简洁数据模型服务</strong></h3>
<p>简洁数据是机器学习比较容易处理的数据类型，所有特征列都合并到一个数值数组类型的data字段中，而标签列统一命名为label。这意味着所有特征列在给定时都已经是数值型，并且共享相同的预处理流程。简洁数据的模型服务包括数据集加载、模型训练、字段预处理、自动调参、自动算法选择、模型预测、批量预测、模型评估、模型查询和删除等。</p>
<h4 id="_21"><strong>数据集加载</strong></h4>
<p>为了方便用户学习使用简洁数据的模型服务，AiSQL提供了下述SQL语句，用于加载机器学习领域常用的数据集。
<div class="highlight"><pre><span></span><code>select * from aisql.load_dataset(ds_name varchar, name varchar default NULL);
</code></pre></div></p>
<p>其中，ds_name是数据集名称，name是加载后在库内存储的简洁数据表单名。name若为默认的NULL值，则使用ds_name作为库内存储的简洁数据表单名。该SQL语句将简洁数据表单存储于以"aisql"命名的模式中，因此在访问加载的简洁数据表单时需要使用aisql.name形式的名称，而不仅仅是name。该SQL语句返回一个数据视图，由一条(含模式的表单名，记录总数)记录构成，显示访问简洁数据表单时使用的完整表单名和该表单的记录总数。
AiSQL提供了5个机器学习领域的常用数据集，包括digits、diabetes、iris、wine和breast_cancer，用于测试分类、回归和聚类等任务。
<strong>digits</strong>：一个手写数字的数据集，共10个类别，每个样本有8x8=64个特征。
<strong>diabetes</strong>：一个关于糖尿病的数据集，共442个样本，每个样本有10个特征。
<strong>iris</strong>：一个关于鸢尾花的数据集，共3个类别，每个类别有50个样本，每个样本有4个特征。
<strong>wine</strong>：一个关于葡萄酒的数据集，共3个类别，每个样本有13个特征。
<strong>breast_cancer</strong>：一个关于乳腺癌的数据集，共569个样本，每个样本有30个特征。
简洁数据集加载示例：
<div class="highlight"><pre><span></span><code>-- 加载digits数据集  
select aisql.load_dataset(&#39;digits&#39;);  
-- 返回 (aisql.digits, 1797)
</code></pre></div></p>
<h4 id="_22"><strong>模型训练</strong></h4>
<p>与表单数据类似，简洁数据的模型训练也支持分类、回归和聚类三种主流机器学习任务，并支持AutoML（自动算法选择和自动调参）机制，以实现最佳预测效果。简洁数据的模型训练可以通过下述SQL语句进行：
<div class="highlight"><pre><span></span><code>select * from aisql.train_fast(project_name text, task text, relation_name text, algorithm text default NULL, hyperparams text default &#39;{}&#39;, search text default NULL, search_params text default &#39;{}&#39;, search_args text default &#39;{}&#39;, preprocess text default &#39;{}&#39;);
</code></pre></div></p>
<p>其中，参数说明如下：
project_name：项目名称，用于保存训练好的模型。
task：任务类型，支持分类、回归和聚类三种任务。
relation_name：数据表名称，用于指定训练数据集。
algorithm：算法名称，用于指定训练算法，默认为NULL，其中NULL表示针对指定任务的所有算法进行模型训练。
hyperparams：JSON格式的算法超参数定义，用于指定训练算法的超参数，默认为空的JSON对象{}，其中{}表示使用默认的超参数。
search：超参数搜索策略，用于指定训练算法的超参数搜索策略，默认为NULL，其中NULL表示不进行超参数调优。
search_params：JSON格式的超参数搜索范围定义，用于指定训练算法的超参数调优范围，默认为空的JSON对象{}，其中{}意味着实际上不进行超参数调优。
search_args：JSON格式的超参数搜索算法的参数，用于控制超参数搜索行为，比如迭代次数，默认为空的JSON对象{}，其中{}表示使用默认的超参数搜索算法参数。
preprocess：JSON格式的数据预处理定义，用于指定训练数据集各个字段（包括特征列和标签列）的数据预处理方法，默认为空的JSON对象{}，其中{}表示不进行数据预处理。</p>
<p>该SQL语句的返回值是一个数据视图，由(项目ID，模型名，算法:超参数)三个字段的记录构成。</p>
<h4 id="_23"><strong>字段预处理</strong></h4>
<p>由于简洁数据的特征列是数值数组而标签列是数值，因此这种数据的字段预处理仅需要考虑数值数组类型的data字段。data字段的预处理可以通过模型训练SQL语句的preprocess参数进行指定。preprocess参数值是一个JSON映射表，其中每个键值对表示一种数据预处理方法，规格如下：
<div class="highlight"><pre><span></span><code>&quot;预处理方法&quot;: {&quot;参数名1&quot;: 参数值1, &quot;参数名2&quot;: 参数值2, ...}
</code></pre></div></p>
<p>JSON映射表中给出的各个预处理方法按照给定的顺序依次执行。
AI特性插件支持以下几种针对简洁数据data字段的预处理方法，其中编号后的小写字符串是对应预处理方法在preprocess参数值中采用的名称：
1.standard：标准缩放器 (StandardScaler)
标准缩放器是一种用于对数值型特征进行标准化处理的算法。它通过计算指定数值型特征的均值和标准差，然后将每个特征值减去均值并除以标准差，使得每个特征具有相同的分布。这样可以使得模型能够更好地学习数值型特征之间的差异。
常用参数:
with_mean: 布尔值，默认为True。如果为True，则计算均值并从指定特征中减去均值。
with_std: 布尔值，默认为True。如果为True，则计算标准差并除以指定特征的标准差。</p>
<p>2.min_max：最小最大缩放器 (MinMaxScaler)
最小最大缩放器是一种用于对数值型特征进行归一化处理的算法。它通过计算指定数值型特征的最小值和最大值，然后将每个特征值减去最小值并除以最大值和最小值之差，使得每个特征的值被缩放到默认为[0,1]的指定区间，这样可以使得模型能够更好地学习数值型特征之间的差异。
常用参数:
feature_range: (min, max)，默认为(0, 1)。指定缩放后的特征值范围。在JSON文本中使用双中括号[[min, max]]表示特征值范围。</p>
<p>3.max_abs：最大绝对缩放器 (MaxAbsScaler)
最大绝对缩放器是一种用于对数值型特征进行归一化处理的算法。它通过计算指定数值型特征的最大绝对值，然后将每个特征值除以最大绝对值，使得每个特征的值被缩放到[-1,1]区间。这样可以使得模型能够更好地学习数值型特征之间的差异。
常用参数: 无</p>
<p>4.robust：鲁棒缩放器 (RobustScaler)
鲁棒缩放器是一种用于对数值型特征进行标准化处理的算法。它通过计算指定数值型特征的均值和四分位数，然后将每个特征值减去均值并除以四分位数，这样可以使得模型能够更好地学习数值型特征之间的差异。
常用参数: 
with_centering: 布尔值，默认为True。如果为True，则计算均值并从指定特征中减去均值。
with_scaling: 布尔值，默认为True。如果为True，则计算四分位数并除以指定特征的四分位数。</p>
<p>5.impute：缺失值填充器 (Imputer)
缺失值填充器是一种用于对数值型特征进行缺失值填充的算法。它或者通过计算指定数值型特征的均值、中位数或众数，然后将缺失值填充为计算得到的值，或者将缺失值填充为指定常数，这样可以使得模型能够更好地学习数值型特征之间的差异。
常用参数:
missing_values: int, float, str，默认为numpy.nan（设置默认值时不定义missing_values参数）。这个参数用来指定哪些值被视为缺失值。所有出现的missing_values都会被填充。
strategy: str，默认为"mean"。这个参数指定缺失值填充的策略。如果为"mean"，则使用每列的平均值来填充缺失值。只能用于数值数据。如果为"median"，则使用每列的中位数来填充缺失值。只能用于数值数据。如果为"most_frequent"，则使用每列出现次数最多的值来填充缺失值。可用于字符串或数值数据。如果有多个这样的值，只返回最小的。如果为"constant"，则使用fill_value来填充所有缺失值。可用于字符串或数值数据。
fill_value: str或数值，默认为None（设置默认值时不定义fill_value参数）。当strategy="constant"时，fill_value用来替换所有缺失值。对于字符串或对象数据类型，fill_value必须是一个字符串。如果为None，当处理数值数据时，fill_value将为0；当处理字符串或对象数据类型时，fill_value将为"missing_value"。</p>
<p>作为一个例子，下面的SQL语句展示了如何预处理简洁数据，并根据预处理后的数据集训练一个随机森林模型：
<div class="highlight"><pre><span></span><code>-- 利用加载后的digits数据集训练随机森林模型  
select aisql.train_fast(project_name=&gt;&#39;digits.random_forest.classification&#39;, task=&gt;&#39;classification&#39;, algorithm=&gt;&#39;random_forest&#39;, relation_name=&gt;&#39;aisql.digits&#39;, preprocess=&gt;&#39;{&quot;standard&quot;:{}}&#39;);
</code></pre></div></p>
<p>模型训练完成后，可以通过以下SQL语句将项目中的对应预处理模型应用到指定的简洁数据表单，产生(预处理后data，label)构成的两列数据视图：
<div class="highlight"><pre><span></span><code>select * from aisql.preprocess_fast(relation_name text, project_name text);
</code></pre></div></p>
<p>其中，参数说明如下：
relation_name: 待预处理的简洁数据表单名。
project_name: 预处理模型对应的项目名。</p>
<p>比如，将上面例子中digits.random_forest.classification项目所产生的对应预处理模型应用到aisql.digits表单，可以使用下面的SQL语句：
<div class="highlight"><pre><span></span><code>select data, label from aisql.preprocess_fast(&#39;aisql.digits&#39;, &#39;digits.random_forest.classification&#39;);
</code></pre></div></p>
<h4 id="_24"><strong>自动调参</strong></h4>
<p>简洁数据的自动调参跟表单数据的自动调参一样，都是通过模型训练SQL语句的search、search_params和search_args参数进行指定的。详情请参看第4.4.1.3节。
调参示例：
<div class="highlight"><pre><span></span><code>-- 针对aisql.digits表单训练支持向量分类器SVC，并对SVC算法的超参数进行随机搜索，搜索参数为kernel和C，取值范围分别为[&quot;linear&quot;,&quot;poly&quot;,&quot;rbf&quot;,&quot;sigmoid&quot;]和[1, 5, 10]  
select aisql.train_fast(project_name=&gt;&#39;digits.support_vector.classification&#39;, task=&gt;&#39;classification&#39;, algorithm=&gt;&#39;support_vector&#39;, relation_name=&gt;&#39;aisql.digits&#39;, preprocess=&gt;&#39;{&quot;standard&quot;:{}}&#39;, search=&gt;&#39;random&#39;, search_params=&gt;&#39;{&quot;kernel&quot;:[&quot;linear&quot;,&quot;poly&quot;,&quot;rbf&quot;,&quot;sigmoid&quot;], &quot;C&quot;:[1,5,10]}&#39;, search_args=&gt;&#39;{&quot;n_iter&quot;:10}&#39;);
</code></pre></div></p>
<h4 id="_25"><strong>自动算法选择</strong></h4>
<p>简洁数据的自动算法选择跟表单数据的自动算法选择一样，也通过指定任务内所有算法的5-折交叉验证结果来挑选性能评分最高的算法。在模型训练SQL语句中，只要不指定algorithm参数，即采用algorithm参数的默认空值，则可以启动指定任务内所有算法的训练过程。自动算法选择的效果仍然体现在模型预测阶段。详情请参看第4.4.1.4节。
不限定算法的模型训练示例：
<div class="highlight"><pre><span></span><code>-- 以aisql.digits表单作为训练集，启动所有分类算法的训练过程  
select aisql.train_fast(project_name=&gt;&#39;digits.classification&#39;, task=&gt;&#39;classification&#39;, relation_name=&gt;&#39;aisql.digits&#39;, preprocess=&gt;&#39;{&quot;standard&quot;:{}}&#39;);
</code></pre></div></p>
<p>如果需要找到项目中性能评分最高的算法（简称最优算法），可以通过下述SQL语句进行查询：
<div class="highlight"><pre><span></span><code>select * from aisql.get_best_fast_model(project_name text);
</code></pre></div>
其中，project_name是需要查询的项目名称。该SQL语句返回最优算法的模型名称，采用“任务:模型”的形式来表示。
最优模型查询示例：
<div class="highlight"><pre><span></span><code>-- 查询训练好的digits.classification项目中的最优模型  
select aisql.get_best_fast_model(&#39;digits.classification&#39;);
</code></pre></div></p>
<h4 id="_26"><strong>模型预测</strong></h4>
<p>针对简洁数据单条记录，模型预测可以通过下述SQL语句进行：
<div class="highlight"><pre><span></span><code>select * from aisql.predict_fast(project_name text, tuple float8[]);
</code></pre></div>
其中，参数说明如下：
project_name: 字符串，指定项目名称。
tuple: 数值数组，指定简洁数据记录的data字段值。</p>
<p>该SQL语句返回一个数值型预测值。
当指定项目已经训练好多个预测模型时，该SQL语句会自动选择评分最高的模型进行预测，其中模型的评分是模型在训练期间进行5-折交叉验证得到的性能结果。这种处理方式跟表单数据的处理方式是一样的，详情请参看第4.4.1.5节。
模型预测示例：
<div class="highlight"><pre><span></span><code>-- 从digits.classification项目中自动挑选出评分最高的分类模型，以aisql.digits表单作为测试集预测前10条记录的标签，并与aisql.digits表单中的标签进行对比  
select label, aisql.predict_fast(&#39;digits.classification&#39;, data) from aisql.digits limit 10;
</code></pre></div></p>
<h4 id="_27"><strong>批量预测</strong></h4>
<p>为了提高模型预测的效率，针对简洁数据也可以进行批量预测。使用的SQL语句如下：
<div class="highlight"><pre><span></span><code>select * from aisql.batch_predict_fast(project_name text, tuples float8[][]);
</code></pre></div>
其中，参数说明如下：
project_name: 字符串，指定项目名称。
tuples: 数值型二维数组，指定简洁数据的多条记录，其中每条记录都是数值型一维数组。</p>
<p>该SQL语句返回一个数值型的预测值列表。
与单条记录的预测一样，当指定项目已经训练好多个预测模型时，该SQL语句会自动选择评分最高的模型进行预测。
批量预测示例：
<div class="highlight"><pre><span></span><code>-- 从digits.classification项目中自动挑选出评分最高的分类模型，以aisql.digits表单作为测试集批量预测前10条记录的标签，并与aisql.digits表单中的标签进行对比  
select unnest(array_agg(label)), unnest(aisql.batch_predict_fast(&#39;digits.classification&#39;, array_agg(data))) from aisql.digits limit 10;
</code></pre></div></p>
<h4 id="_28"><strong>模型评估</strong></h4>
<p>针对简洁数据形式的测试集，模型评估可以通过下述SQL语句进行：
<div class="highlight"><pre><span></span><code>select * from aisql.evaluate_fast(project_name text, relation_name text, metric_names text[]);
</code></pre></div>
其中，参数说明如下：
project_name: 字符串，指定项目名称。
relation_name: 字符串，指定简洁数据表名，用作测试集。
metric_names: 字符串数组，指定多个评估指标名称。</p>
<p>该SQL语句的返回值是一个数据视图，由(任务:模型，标签列名，评分)三个字段的记录构成，每条记录对应指定项目构建的一个模型在指定测试集上的评估结果。
模型评估示例：
<div class="highlight"><pre><span></span><code>-- 将aisql.digits表单作为测试集，评估digits.classification项目中所有分类模型的性能，包括准确率、平衡准确率、科恩卡帕分数和F1分数  
select * from aisql.evaluate_fast(&#39;digits.classification&#39;, &#39;aisql.digits&#39;, &#39;{accuracy_score,balanced_accuracy_score,cohen_kappa_score,f1_score}&#39;::text[]);
</code></pre></div></p>
<h4 id="_29"><strong>模型查询</strong></h4>
<p>对于训练好的项目，可以通过下述SQL语句查询项目中的模型信息。
<div class="highlight"><pre><span></span><code>select * from aisql.list_fast_models(project_name text default NULL);
</code></pre></div>
其中，project_name是可选参数，指定要查询的项目名称。如果不指定，则查询所有项目中的模型信息。返回值是一个数据视图，由(项目名，训练表单名，任务:模型，模型超参数，data字段预处理定义，评分)六个字段的记录构成，每条记录对应一个模型的信息。
模型查询示例：
<div class="highlight"><pre><span></span><code>-- 查询digits.classification项目中所有分类模型的性能  
select * from aisql.list_fast_models(&#39;digits.classification&#39;);
</code></pre></div></p>
<h4 id="_30"><strong>模型删除</strong></h4>
<p>对于训练好的项目，可以通过下述SQL语句删除项目中由指定算法训练得到的模型。
<div class="highlight"><pre><span></span><code>select * from aisql.remove_fast_model(project_name text, algorithm text);
</code></pre></div>
其中，project_name是要删除模型的项目名称，algorithm是待删除模型对应的训练算法。该SQL语句返回模型删除的响应信息。若删除成功，则响应"Done"，否则根据具体情况，响应指定项目不存在，或指定算法在指定项目中不存在等错误信息。</p>
<h3 id="_31"><strong>算法扩展</strong></h3>
<p>为了方便用户扩展算法，AiSQL提供了算法扩展接口，用户可以通过该接口扩展自己的算法。算法扩展接口包括两个函数aisql.add_udf_algorithm和aisql.remove_udf_algorithm，分别用于添加和删除用户自定义算法，其中用户自定义算法可以来自用户提供的python文件，也可以来自Python标准库比如sklearn等。</p>
<h4 id="_32"><strong>添加算法</strong></h4>
<p>添加算法的SQL语句如下：
<div class="highlight"><pre><span></span><code>select aisql.add_udf_algorithm(task text, algorithm text, file_or_class text);
</code></pre></div>
其中，参数说明如下：
task: 字符串，指定待添加算法的所属任务，取值为'classification'、'regression'、'clustering'之一。
algorithm: 字符串，指定待添加算法的名称。若用户通过python文件来指定算法，则算法名称必须是python文件中定义的算法类名称。
file_or_class: 字符串，指定用户自定义算法文件路径或者Python标准库中的完整算法类名称。</p>
<p>该SQL语句返回算法添加的响应信息。若用户定义算法库中已经存在待添加的算法，则替换原算法定义并返回现有算法更新完成的信息，否则添加算法定义并返回新算法添加完成的信息。
下面是根据用户提供的python文件来添加算法的示例，其中待添加算法是宽度学习分类器，在python文件中定义的算法类名称为bls_classifier，该算法类继承自sklearn.base.ClassifierMixin类和sklearn.base.BaseEstimator，并添加了宽度学习算法的实现。
以/path/to/bls.py文件保存的宽度学习分类器实现代码：
<div class="highlight"><pre><span></span><code>import pickle  
import numpy as np  
from numpy import random  
from sklearn.base import ClassifierMixin, BaseEstimator  
from sklearn.preprocessing import OneHotEncoder, StandardScaler, LabelEncoder  
from sklearn.model_selection import cross_validate  


class node_generator:  
    def __init__(self, whiten=False):  
        self.Wlist = []  
        self.blist = []  
        self.nonlinear = 0  
        self.whiten = whiten  

    def sigmoid(self, data):  
        return 1.0 / (1 + np.exp(-data))  

    def linear(self, data):  
        return data  

    def tanh(self, data):  
        return (np.exp(data) - np.exp(-data)) / (np.exp(data) + np.exp(-data))  

    def relu(self, data):  
        return np.maximum(data, 0)  

    def orth(self, W):  
        for i in range(0, W.shape[1]):  
            w = np.mat(W[:, i].copy()).T  
            w_sum = 0  
            for j in range(i):  
                wj = np.mat(W[:, j].copy()).T  
                w_sum += (w.T.dot(wj))[0, 0] * wj  
            w -= w_sum  
            w = w / np.sqrt(w.T.dot(w))  
            W[:, i] = np.ravel(w)  
        return W  

    def generator(self, shape, times):  
        for i in range(times):  
            W = 2 * random.random(size=shape) - 1  
            if self.whiten:  
                W = self.orth(W)  
            b = 2 * random.random() - 1  
            yield W, b  

    def generator_nodes(self, data, times, batchsize, nonlinear):  
        self.Wlist = [elem[0] for elem in self.generator((data.shape[1], batchsize), times)]  
        self.blist = [elem[1] for elem in self.generator((data.shape[1], batchsize), times)]  

        self.nonlinear = {&#39;linear&#39;: self.linear,  
                          &#39;sigmoid&#39;: self.sigmoid,  
                          &#39;tanh&#39;: self.tanh,  
                          &#39;relu&#39;: self.relu  
                          }[nonlinear]  
        nodes = self.nonlinear(data.dot(self.Wlist[0]) + self.blist[0])  
        for i in range(1, len(self.Wlist)):  
            nodes = np.column_stack((nodes, self.nonlinear(data.dot(self.Wlist[i]) + self.blist[i])))  
        return nodes  

    def transform(self, testdata):  
        testnodes = self.nonlinear(testdata.dot(self.Wlist[0]) + self.blist[0])  
        for i in range(1, len(self.Wlist)):  
            testnodes = np.column_stack((testnodes, self.nonlinear(testdata.dot(self.Wlist[i]) + self.blist[i])))  
        return testnodes  

    def update(self, otherW, otherb):  
        self.Wlist += otherW  
        self.blist += otherb  


class bls_classifier(ClassifierMixin, BaseEstimator):  
    def __init__(self,  
                 maptimes=10,  
                 enhencetimes=10,  
                 map_function=&#39;linear&#39;,  
                 enhence_function=&#39;linear&#39;,  
                 batchsize=&#39;auto&#39;,  
                 reg=0.001):  

        self.maptimes = maptimes  
        self.enhencetimes = enhencetimes  
        self.batchsize = batchsize  
        self.reg = reg  
        self.map_function = map_function  
        self.enhence_function = enhence_function  

        self.W = 0  
        self.pesuedoinverse = 0  
        self.onehotencoder = OneHotEncoder(sparse_output=False)  
        self.mapping_generator = node_generator()  
        self.enhence_generator = node_generator(whiten=True)  

    def fit(self, data, label):  
        if self.batchsize == &#39;auto&#39;:  
            self.batchsize = data.shape[1]  
        label = self.onehotencoder.fit_transform(label.reshape(-1, 1))  

        mappingdata = self.mapping_generator.generator_nodes(data, self.maptimes, self.batchsize, self.map_function)  
        enhencedata = self.enhence_generator.generator_nodes(mappingdata, self.enhencetimes, self.batchsize, self.enhence_function)  

        inputdata = np.column_stack((mappingdata, enhencedata))  
        pesuedoinverse = self.pinv(inputdata, self.reg)  
        self.W = np.asarray(pesuedoinverse.dot(label))  

    def pinv(self, A, reg):  
        return np.mat(reg * np.eye(A.shape[1]) + A.T.dot(A)).I.dot(A.T)  

    def decode(self, Y_onehot):  
        return np.argmax(Y_onehot, axis=1).flatten()  

    def predict(self, testdata):  
        test_mappingdata = self.mapping_generator.transform(testdata)  
        test_enhencedata = self.enhence_generator.transform(test_mappingdata)  
        test_inputdata = np.column_stack((test_mappingdata, test_enhencedata))  
        return self.decode(test_inputdata.dot(self.W))
</code></pre></div>
添加宽度学习分类器的SQL语句：
<div class="highlight"><pre><span></span><code>select aisql.add_udf_algorithm(&#39;classification&#39;, &#39;bls_classifier&#39;, &#39;/path/to/bls.py&#39;);
</code></pre></div>
下面是添加Python标准库sklearn中算法的示例，分别添加逻辑回归logistic_regression分类算法和线性回归linear_regression回归算法。
<div class="highlight"><pre><span></span><code>-- 添加一个名为logistic_regression的算法，该算法来自Python标准库中的sklearn.linear_model.LogisticRegression类  
select aisql.add_udf_algorithm(&#39;classification&#39;, &#39;logistic_regression&#39;, &#39;sklearn.linear_model.LogisticRegression&#39;);  

-- 添加一个名为linear_regression的算法，该算法来自Python标准库中的sklearn.linear_model.LinearRegression类  
select aisql.add_udf_algorithm(&#39;regression&#39;, &#39;linear_regression&#39;, &#39;sklearn.linear_model.LinearRegression&#39;);
</code></pre></div></p>
<h4 id="_33"><strong>查询算法</strong></h4>
<p>AiSQL没有提供查询用户自定义算法的专用SQL语句，但可以通过下述列举所有算法的SQL语句来查看其中的自定义算法：
<div class="highlight"><pre><span></span><code>select * from aisql.list_algorithms();
</code></pre></div>
另一方面，所有用户自定义算法都存储在aisql.udf_algorithms表单中，可以通过传统的SQL语句查询用户自定义算法：
<div class="highlight"><pre><span></span><code>select * from aisql.udf_algorithms;
</code></pre></div>
通过执行第4.4.3.1节中提供的所有例子，该SQL语句返回如下结果：
| task | algorithm | full_class |
| --- | --- | --- |
| classification | bls_classifier | aisql.bls.bls_classifier |
| classification | logistic_regression | sklearn.linear_model.LogisticRegression |
| regression | linear_regression | sklearn.linear_model.LinearRegression |</p>
<h4 id="_34"><strong>删除算法</strong></h4>
<p>删除算法的SQL语句如下：
<div class="highlight"><pre><span></span><code>select aisql.remove_udf_algorithm(task text, algorithm text);
</code></pre></div>
其中，参数说明如下：
task: 字符串，指定待添加算法的所属任务，取值为'classification'、'regression'、'clustering'之一。
algorithm: 字符串，指定待删除算法的名称。</p>
<p>该SQL语句会删除aisql.udf_algorithms表中与参数task和algorithm匹配的记录，并返回算法删除的响应信息。若aisql.udf_algorithms表中不存在与参数task和algorithm相匹配的记录，则返回算法不存在的错误信息，否则返回"Done"。
删除算法示例：
<div class="highlight"><pre><span></span><code>select aisql.remove_udf_algorithm(&#39;classification&#39;, &#39;logistic_regression&#39;);
</code></pre></div></p>
<h3 id="_35"><strong>数据向量化和检索</strong></h3>
<p>目前，AiSQL提供了文本数据和图片数据的向量化功能，并支持基于文本向量和图片向量的混合检索，即支持以文搜文、以文搜图、以图搜文和以图搜图四种检索方式。</p>
<h4 id="_36"><strong>向量化模型管理</strong></h4>
<p>AI特性插件支持内置和外置的向量化模型，并根据向量化的维度自动从入库的向量化模型中选择优先度最高的模型来执行向量化操作。外置的向量化模型优先度固定为1，而内置的向量化模型可以在添加时设置优先度参数，或者通过优先度调整SQL语句更改优先度。有效的内置向量化模型的优先度必须设置成大于0的整数。所有向量化模型有三种类型，分别是TEXT类、IMAGE类和MIXTURE类，其中TEXT类和MIXTURE类支持文本向量化操作，IMAGE类和MIXTURE类支持图片向量化操作。
AiSQL根据指定的向量化维度挑选文本向量化模型的流程如下：令S1表示指定维度的TEXT类或MIXTURE类的内置向量化模型集合、S2表示指定维度的TEXT类或MIXTURE类的外置向量化模型集合，若S1存在优先度大于1的模型，则将优先度最高的一个模型作为目标模型输出，否则从S2中挑选出一个能远程调用的模型作为目标模型输出；若S2中挑选不出模型，则从S1中选取一个优先度大于0的模型作为目标模型输出。
同理，AiSQL根据指定的向量化维度挑选图片向量化模型的流程如下：令S1表示指定维度的IMAGE类或MIXTURE类的内置向量化模型集合、S2表示指定维度的IMAGE类或MIXTURE类的外置向量化模型集合，若S1存在优先度大于1的模型，则将优先度最高的一个模型作为目标模型输出，否则从S2中挑选出一个能远程调用的模型作为目标模型输出；若S2中挑选不出模型，则从S1中选取一个优先度大于0的模型作为目标模型输出。</p>
<h5 id="_37"><strong>添加内置向量化模型</strong></h5>
<p>添加内置向量化模型的SQL语句如下：
<div class="highlight"><pre><span></span><code>select aisql.add_internal_embedding_service(model_name text, version text, dimension integer, priority integer, text_onnx_path text default NULL, image_onnx_path text default NULL);
</code></pre></div>
其中，参数说明如下：
model_name: 待添加的内置向量化模型名称。目前支持的TEXT类模型名是'paraphrase-multilingual-MiniLM-L12-v2'，MIXTURE类模型名是'ViT-B-16'、'ViT-L-14'、'ViT-L-14-336'、'ViT-H-14'和'RN50'之一。
version: 待添加的内置向量化模型的字符型版本号，比如'v1'和'v1.0'等。
dimension: 待添加的内置向量化模型支持的向量维度。
priority: 待添加的内置向量化模型的优先度，一般是大于0的整数，因为0表示模型失效不能再使用。
text_onnx_path: ONNX格式的文本向量化模型文件路径。TEXT类或MIXTURE类的向量化模型必须设置该参数，IMAGE类的向量化模型不设置该参数。
image_onnx_path: ONNX格式的图片向量化模型文件路径。IMAGE类或MIXTURE类的向量化模型必须设置该参数，TEXT类的向量化模型不设置该参数。</p>
<p>该SQL语句返回一个字符串，显示添加的结果信息。若库内已经存在相同模型名和版本号的向量化模型，则更新现有的向量化模型并返回更新完成的文本信息，否则在库内添加指定的向量化模型并返回添加完成的文本信息。
添加内置向量化模型示例：
<div class="highlight"><pre><span></span><code>-- 添加某个MIXTURE类向量化模型  
select aisql.add_internal_embedding_service(&#39;ViT-B-16&#39;, &#39;v1.0&#39;, 512, 2, &#39;/path/to/vit-b-16.txt.fp32.onnx&#39;, &#39;/path/to/vit-b-16.img.fp32.onnx&#39;);  

-- 添加某个TEXT类向量化模型  
select aisql.add_internal_embedding_service(&#39;paraphrase-multilingual-MiniLM-L12-v2&#39;, &#39;v1.0&#39;, 384, 2, &#39;/path/to/paraphrase-multilingual-MiniLM-L12-v2.onnx&#39;);
</code></pre></div></p>
<h5 id="_38"><strong>更改内置向量化模型优先度</strong></h5>
<p>虽然使用添加内置向量化模型的SQL语句可以修改模型的优先度，但该SQL语句需要提供ONNX模型路径并更新库内存储的ONNX模型。在保证现有ONNX模型不改变的前提下，AiSQL提供了一种便捷的方式更改内置向量化模型的优先度，不需要改变模型的维度和数据，具体的SQL语句如下：
<div class="highlight"><pre><span></span><code>select aisql.set_priority(model_name text, version text, priority integer);
</code></pre></div>
其中，参数说明如下：
model_name: 待更改优先度的内置向量化模型名称。
version: 待更改优先度的内置向量化模型的字符型版本号。</p>
<p>该SQL返回一个字符串，显示优先度更改完成的文本信息。
更改内置向量化模型优先度示例：
<div class="highlight"><pre><span></span><code>select aisql.set_priority(&#39;paraphrase-multilingual-MiniLM-L12-v2&#39;, &#39;v1.0&#39;, 1);
</code></pre></div></p>
<h5 id="_39"><strong>查询内置向量化模型</strong></h5>
<p>查询内置向量化模型的SQL语句如下：
<div class="highlight"><pre><span></span><code>select * from aisql.list_internal_embedding_models();
</code></pre></div>
该SQL语句返回一个数据视图，由(模型名，版本号，优先度，向量维度，模型类型)六个字段的记录构成，每条记录对应一个内置向量化模型的信息。</p>
<h5 id="_40"><strong>删除内置向量化模型</strong></h5>
<p>删除内置向量化模型的SQL语句如下：
<div class="highlight"><pre><span></span><code>select aisql.remove_internal_embedding_model(model_name text);
</code></pre></div>
其中，model_name是待删除的内置向量化模型名称。
该SQL语句返回一个字符串，显示模型删除的文本信息。若库内存在指定名称的内置向量化模型（可能多个，因为相同名称的模型可以具有不同的版本号），则将所有匹配指定名称的模型从库中删除并返回多少个模型被删除的文本信息，否则返回指定名称的内置向量化模型不存在的文本信息。</p>
<h5 id="_41"><strong>添加外置向量化模型</strong></h5>
<p>添加外置向量化模型的SQL语句如下：
<div class="highlight"><pre><span></span><code>select aisql.aisql.add_external_embedding_service(model_name text, rpc_host text, rpc_port integer, dimension integer, model_type aisql.model_type);
</code></pre></div>
其中，参数说明如下：
model_name: 待添加的外置向量化模型名称。外置向量化模型可以任意命名。
rpc_host: 待添加的外置向量化模型服务的远程过程调用(RPC)接口的主机地址。
rpc_port: 待添加的外置向量化模型服务的远程过程调用(RPC)接口的服务端口。
dimension: 待添加的外置向量化模型服务支持的向量维度。
model_type: 待添加的外置向量化模型类型，取值为'TEXT'、'IMAGE'和'MIXTURE'三者之一。</p>
<p>该SQL语句返回一个字符串，显示添加的结果信息。若库内已经存在相同模型名和相同RPC服务接口（主机地址+端口）的外置向量化模型，则更新现有的向量化模型并返回更新完成的文本信息，否则在库内添加指定的外置向量化模型并返回添加完成的文本信息。
添加外置向量化模型示例：
<div class="highlight"><pre><span></span><code>select aisql.add_external_embedding_service(&#39;ViT-L-14&#39;, &#39;106.13.229.118&#39;, 9083, 768, &#39;MIXTURE&#39;);
</code></pre></div></p>
<h5 id="_42"><strong>查询外置向量化模型</strong></h5>
<p>查询外置向量化模型的SQL语句如下：
<div class="highlight"><pre><span></span><code>select * from aisql.list_external_embedding_models();
</code></pre></div>
该SQL语句返回一个数据视图，由(模型名，RPC主机地址，RPC端口，向量维度，模型类型)五个字段的记录构成，每条记录对应一个外置向量化模型的信息。</p>
<h5 id="_43"><strong>删除外置向量化模型</strong></h5>
<p>删除外置向量化模型的SQL语句如下：
<div class="highlight"><pre><span></span><code>select aisql.remove_external_embedding_model(model_name text);
</code></pre></div>
其中，model_name是待删除的内置向量化模型名称。
该SQL语句返回一个字符串，显示模型删除的文本信息。若库内存在指定名称的外置向量化模型（可能多个，因为相同名称的模型可以具有不同的RPC服务接口），则将所有匹配指定名称的模型从库中删除并返回多少个模型被删除的文本信息，否则返回指定名称的外置向量化模型不存在的文本信息。</p>
<h4 id="_44"><strong>文本向量化</strong></h4>
<p>AiSQL提供了SQL语句支持单个文本的向量化操作和多个文本的成批向量化操作。
针对单个文本的向量化操作的SQL语句如下：
<div class="highlight"><pre><span></span><code>select * from aisql.embed_text(raw_text text, dimension integer);
</code></pre></div>
其中，raw_text是待向量化的单个文本，dimension是向量化的维度。
该SQL返回一个指定维度的向量，作为输入文本的语义表示。
针对多个文本的成批向量化操作的SQL语句如下：
<div class="highlight"><pre><span></span><code>select * from aisql.embed_texts(raw_texts text[], dimension integer);
</code></pre></div>
其中，raw_texts是待向量化的文本数组，dimension是向量化的维度。
该SQL返回一个指定维度的向量数组，数组中每个向量对应一个输入文本的语义表示。
文本向量化示例：
<div class="highlight"><pre><span></span><code>-- 向量化单个文本  
select aisql.embed_text(&#39;贝格迈思，你好！&#39;, 384);  
-- 成批向量化两个文本  
select unnest(aisql.embed_texts(array[&#39;Hello&#39;,&#39;贝格迈思，你好！&#39;], 384));
</code></pre></div></p>
<h4 id="_45"><strong>图片向量化</strong></h4>
<p>AiSQL提供了SQL语句支持单张图片的向量化操作和多张图片的成批向量化操作，其中图片可以图片文件路径作为输入参数，也可以图片内容的base64编码字符串作为输入参数。
针对单张图片的向量化操作的SQL语句如下：
<div class="highlight"><pre><span></span><code>select * from aisql.embed_image(base64_or_file text, dimension integer);
</code></pre></div>
其中，base64_or_file是待向量化的单张图片的文件路径或者图片内容的base64编码字符串，dimension是向量化的维度。
该SQL返回一个指定维度的向量，作为输入图片的语义表示。
针对多张图片的成批向量化操作的SQL语句如下：
<div class="highlight"><pre><span></span><code>select * from aisql.embed_images(base64_or_files text[], dimension integer);
</code></pre></div>
其中，base64_or_files是待向量化的图片数组，其中数组元素是图片存储文件路径或者图片内容的base64编码字符串，dimension是向量化的维度。
该SQL返回一个指定维度的向量数组，数组中每个向量对应一个输入图片的语义表示。
图片向量化示例：
<div class="highlight"><pre><span></span><code>-- 向量化单张图片  
select aisql.embed_image(&#39;/path/to/image1.jpg&#39;, 512);  
-- 成批向量化两张图片  
select unnest(aisql.embed_images(array[&#39;/path/to/image1.jpg&#39;,&#39;/path/to/image2.jpg&#39;], 512));
</code></pre></div></p>
<h4 id="_46"><strong>跨模态数据检索</strong></h4>
<p>AiSQL可以支持以文搜文、以文搜图、以图搜文和以图搜图等四种跨模态数据检索方式。为了提供以文搜文和以图搜文服务，必须事先构建文本向量库，该库是以(id, raw_text, embedding)三个字段构成的数据表单，其中id是integer类型的文本主键，raw_text是text类型的文本内容，embedding是vector类型的文本向量。同样地，为了提供以文搜图和以图搜图服务，必须事先构建图片向量库，该库是以(id, base64_image, embedding)三个字段构成的数据表单，其中id是integer类型的图片主键，base64_image是text类型的图片内容base64编码，embedding是vector类型的图片向量。文本向量库和图片向量库中的embedding字段一般都配备IVFFlat、HNSW、DiskANN和SPANN等近似最近邻检索索引，以提供高效的向量检索服务。</p>
<h5 id="_47"><strong>以文搜文</strong></h5>
<p>以文搜文的SQL语句如下：
<div class="highlight"><pre><span></span><code>select * from aisql.similar_texts_by_text(query_text text, topk integer, dimension integer default 512, relation_name text default &#39;aisql.muge_texts&#39;);
</code></pre></div>
其中，参数说明如下：
query_text: 查询文本。
topk: 需要返回的最相似文本个数上限。
dimension: 文本向量维度，必须与待查找的文本向量库中的向量维度一致。
relation_name: 充当文本向量库的表单名。</p>
<p>该SQL语句返回一个数据视图，由(相似文本, 查询文本与相似文本之间的相似度)两个字段的记录构成，每个记录对应文本向量库中的一个文本记录。
以文搜文示例：
<div class="highlight"><pre><span></span><code>-- 从默认文本向量库中检索出与查询文本最相似的5个文本  
select * from aisql.similar_texts_by_text(&#39;多功能橱柜&#39;, 5);
</code></pre></div></p>
<h5 id="_48"><strong>以图搜文</strong></h5>
<p>以文搜文的SQL语句如下：
<div class="highlight"><pre><span></span><code>select * from aisql.similar_texts_by_image(image_path text, topk integer, dimension integer default 512, relation_name text default &#39;aisql.muge_texts&#39;);
</code></pre></div>
其中，参数说明如下：
image_path: 查询图片的文件路径。
topk: 需要返回的最相似文本个数上限。
dimension: 文本向量维度，必须与待查找的文本向量库中的向量维度一致。
relation_name: 充当文本向量库的表单名。</p>
<p>该SQL语句返回一个数据视图，由(相似文本, 查询图片与相似文本之间的相似度)两个字段的记录构成，每个记录对应文本向量库中的一个文本记录。
以图搜文示例：
<div class="highlight"><pre><span></span><code>-- 从默认文本向量库中检索出与查询图片最相似的5个文本  
select * from aisql.similar_texts_by_image(&#39;/path/to/image.jpg&#39;, 5);
</code></pre></div></p>
<h5 id="_49"><strong>以文搜图</strong></h5>
<p>以文搜图的SQL语句如下：
<div class="highlight"><pre><span></span><code>select * from aisql.similar_images_by_text(query_text text, topk integer, dimension integer default 512, relation_name text default &#39;aisql.muge_images&#39;);
</code></pre></div>
其中，参数说明如下：
query_text: 查询文本。
topk: 需要返回的最相似图片个数上限。
dimension: 图片向量维度，必须与待查找的图片向量库中的向量维度一致。
relation_name: 充当图片向量库的表单名。</p>
<p>该SQL语句返回一个数据视图，由(相似图片的base64编码, 查询文本与相似图片之间的相似度)两个字段的记录构成，每个记录对应图片向量库中的一个图片记录。
以文搜图示例：
<div class="highlight"><pre><span></span><code>-- 从默认图片向量库中检索出与查询文本最相似的5张图片  
select * from aisql.similar_images_by_text(&#39;多功能橱柜&#39;, 5);
</code></pre></div></p>
<h5 id="_50"><strong>以图搜图</strong></h5>
<p>以图搜图的SQL语句如下：
<div class="highlight"><pre><span></span><code>select * from aisql.similar_images_by_image(image_path text, topk integer, dimension integer default 512, relation_name text default &#39;aisql.muge_images&#39;);
</code></pre></div>
其中，参数说明如下：
image_path: 查询图片的文件路径。
topk: 需要返回的最相似图片个数上限。
dimension: 图片向量维度，必须与待查找的图片向量库中的向量维度一致。
relation_name: 充当图片向量库的表单名。</p>
<p>该SQL语句返回一个数据视图，由(相似图片的base64编码, 查询图片与相似图片之间的相似度)两个字段的记录构成，每个记录对应图片向量库中的一个图片记录。
以图搜图示例：
<div class="highlight"><pre><span></span><code>-- 从默认图片向量库中检索出与查询图片最相似的5张图片  
select * from aisql.similar_images_by_image(&#39;/path/to/image.jpg&#39;, 5);
</code></pre></div></p>
<h3 id="_51"><strong>大模型调用</strong></h3>
<h4 id="_52"><strong>大模型管理</strong></h4>
<p>由于大模型启动的时间代价较高，因此AiSQL仅采用OpenAI服务接口的外置大模型方式来提供大模型服务。这样大模型可以事先通过现成的高效服务框架比如TensorRT-LLM、vLLM、LMDeploy、MLC-LLM和lamma.cpp等进行加载，并开放出OpenAI服务接口等待实时的大模型服务请求，以达到快速响应服务请求的目标。</p>
<h5 id="_53"><strong>添加大模型服务</strong></h5>
<p>添加大模型服务的SQL语句如下：
<div class="highlight"><pre><span></span><code>select aisql.add_llm_service(model_name text, version text, protocol aisql.protocol, host text, port integer, max_tokens integer);
</code></pre></div>
其中，参数说明如下：
model_name: OpenAI服务接口约定的大模型名称。
version: 大模型的字符型版本号。
protocol: OpenAI服务接口的网络协议，目前仅支持'https'或'http'。
host: OpenAI服务接口的主机地址。
port: OpenAI服务接口的端口。
max_tokens: 大模型在一次对话中可以处理的最大token个数。</p>
<p>该SQL语句返回一个字符串，显示添加的结果信息。若库内已经存在相同模型名和相同版本号的外置大模型，则更新现有的大模型信息并返回更新完成的文本信息，否则在库内添加指定的外置大模型并返回添加完成的文本信息。
添加大模型服务示例：
<div class="highlight"><pre><span></span><code>-- 添加一个传统对话的外置大模型服务  
select aisql.add_llm_service(&#39;Qwen-7B-Chat-q4f16_1-MLC&#39;, &#39;v1&#39;, &#39;http&#39;, &#39;106.13.229.118&#39;, 9050, 8192);  
-- 添加一个视觉问答的外置大模型服务  
select aisql.add_llm_service(&#39;openbmb/MiniCPM-V-2&#39;, &#39;v1&#39;, &#39;http&#39;, &#39;106.13.229.118&#39;, 9053, 8192);  
-- 添加一个将自然语言转换到SQL语句的外置大模型服务  
select aisql.add_llm_service(&#39;Qwen1.5-7B-NSQL&#39;, &#39;v1&#39;, &#39;http&#39;, &#39;106.13.229.118&#39;, 9054, 8192);
</code></pre></div></p>
<h5 id="_54"><strong>查询大模型服务</strong></h5>
<p>查询大模型服务的SQL语句如下：
<div class="highlight"><pre><span></span><code>select * from aisql.list_large_language_models();
</code></pre></div>
该SQL语句返回一个数据视图，由(模型名, 版本号, 访问网址, 最大token个数)四个字段的记录构成，每个记录对应一个外置大模型，其中访问网址是由OpenAI服务接口的网络协议、主机地址和端口所合成的。
根据第4.4.5.1.1节添加的三个大模型服务，查询大模型服务列表将返回：
| model_name | version | request_uri | max_tokens |
| --- | --- | --- | --- |
| Qwen-7B-Chat-q4f16_1-MLC | v1 | <a href="http://106.13.229.118:9050/v1">http://106.13.229.118:9050/v1</a> | 8192 |
| openbmb/MiniCPM-V-2 | v1 | <a href="http://106.13.229.118:9053/v1">http://106.13.229.118:9053/v1</a> | 8192 |
| Qwen1.5-7B-NSQL | v1 | <a href="http://106.13.229.118:9054/v1">http://106.13.229.118:9054/v1</a> | 8192 |</p>
<h5 id="_55"><strong>删除大模型服务</strong></h5>
<p>删除大模型服务的SQL语句如下：
<div class="highlight"><pre><span></span><code>select aisql.remove_large_language_model(model_name text);
</code></pre></div>
其中，model_name是OpenAI服务接口约定的大模型名称。
该SQL语句返回一个字符串，显示大模型服务删除的文本信息。若库内存在指定名称的外置大模型服务（可能多个，因为相同名称的大模型服务可以具有不同的版本号），则将所有匹配指定名称的大模型服务从库中删除并返回多少个大模型服务被删除的文本信息，否则返回指定名称的大模型服务不存在的文本信息。
删除大模型服务示例：
<div class="highlight"><pre><span></span><code>-- 删除一个视觉问答的外置大模型服务  
select aisql.remove_large_language_model(&#39;openbmb/MiniCPM-V-2&#39;);
</code></pre></div></p>
<h4 id="_56"><strong>大模型问答</strong></h4>
<p>基于大模型的问答系统是大模型的杀手应用，它实质上是在执行文本生成任务，即输入以文本为主的数据，输出回复文本。AI特性插件支持四种模式的大模型问答功能，包括传统对话、基于检索增强生成的对话、基于图片和自然语言的视觉问答，以及自然语言到SQL语句的转换。</p>
<h5 id="_57"><strong>传统对话</strong></h5>
<p>AI特性插件支持单个或多个回复文本的传统对话。
单个回复文本的传统对话的SQL语句如下：
<div class="highlight"><pre><span></span><code>select aisql.chat(model_name text, version text, api_key text, prompt text);
</code></pre></div>
其中，参数说明如下：
model_name: OpenAI服务接口约定的大模型名称。
version: 大模型的字符型版本号。
api_key: OpenAI服务接口的API密钥，用于验证请求的合法性。
prompt: 输入的用户问题。</p>
<p>该SQL语句返回一个回复文本。
单个回复文本的传统对话示例：
<div class="highlight"><pre><span></span><code>select aisql.chat(&#39;Qwen-7B-Chat-q4f16_1-MLC&#39;, &#39;v1&#39;, &#39;anykey&#39;, &#39;请写一首七言绝句。&#39;);
</code></pre></div>
多个回复文本的传统对话的SQL语句如下：
<div class="highlight"><pre><span></span><code>select aisql.chat(model_name text, version text, api_key text, prompt text, nresults integer);
</code></pre></div>
其中，参数说明如下：
model_name: OpenAI服务接口约定的大模型名称。
version: 大模型的字符型版本号。
api_key: OpenAI服务接口的API密钥，用于验证请求的合法性。
prompt: 输入的用户问题。
nresults: 需要返回的最大回复文本个数。</p>
<p>该SQL语句返回一个回复文本数组，数组中元素个数不超过nresults。
多个回复文本的传统对话示例：
<div class="highlight"><pre><span></span><code>select aisql.chat(&#39;Qwen-7B-Chat-q4f16_1-MLC&#39;, &#39;v1&#39;, &#39;anykey&#39;, &#39;请写一首七言绝句。&#39;, 3);
</code></pre></div></p>
<h5 id="_58"><strong>基于检索增强生成的对话</strong></h5>
<p>检索增强生成（Retrieval-augmented Generation, RAG）是缓解大模型幻觉问题的一种有效手段。它通过从知识库中检索与输入相关的文档，并将文档内容作为输入的一部分，从而生成更准确、更丰富的回复文本。AiSQL的AI特性插件实现了一种从历史对话文档和知识文档中检索相关文本的RAG机制。该机制约定历史对话文档保存于一个由(input, output, input_vec)三个字段构成的数据表单中，其中input是text类型的问题文本，output是text类型的回复文本，input_vec是input的向量表示。此外，该机制约定知识文档保存于一个由(id, paragraph, para_vec)三个字段构成的数据表单中，其中id是integer类型的段落序号主键，paragraph是text类型的段落内容，para_vec是paragraph的向量表示。input_vec字段和para_vec字段一般都需要具备IVFFlat、HNSW、DiskANN和SPANN等近似最近邻检索索引，以提供高效的向量检索服务。
AI特性插件支持单个或多个回复文本的RAG对话。回答用户的问题时，AiSQL首先从历史对话文档中检索出与用户问题最相似的input问题文本及其对应的output回复文本，即input-output问答对，作为历史对话；然后，从知识文档中检索出与用户问题最相关的段落，作为对话上下文；最后，将历史对话、对话上下文和用户问题作为输入，调用大模型生成回复文本；若历史对话文档不存在，则仅将对话上下文和用户问题作为输入，调用大模型生成回复文本。
单个回复的RAG对话的SQL语句如下：
<div class="highlight"><pre><span></span><code>select aisql.retrieval_augmented_chat(model_name text, version text, api_key text, question text, dimension integer, pr_relation_name text, qa_relation_name text default NULL);
</code></pre></div>
其中，参数说明如下：
model_name: OpenAI服务接口约定的大模型名称。
version: 大模型的字符型版本号。
api_key: OpenAI服务接口的API密钥，用于验证请求的合法性。
question: 输入的用户问题。
dimension: 向量表示的维度。该维度必须与知识文档和历史对话文档中向量表示的维度一致。
pr_relation_name: 充当知识文档的数据表单名，该数据表单由(id, paragraph, para_vec)三个字段构成，其中id是integer类型的段落序号主键，paragraph是text类型的段落内容，para_vec是paragraph的向量表示。
qa_relation_name: 充当历史对话文档的数据表单名，该数据表单由(input, output, input_vec)三个字段构成，其中input是text类型的问题文本，output是text类型的回复文本，input_vec是input的向量表示。</p>
<p>该SQL语句返回一个回复文本。
多个回复的RAG对话的SQL语句如下：
<div class="highlight"><pre><span></span><code>aisql.retrieval_augmented_chat(model_name text, version text, api_key text, question text, nresults integer, dimension integer, pr_relation_name text, qa_relation_name text default NULL);
</code></pre></div>
其中，参数说明如下：
model_name: OpenAI服务接口约定的大模型名称。
version: 大模型的字符型版本号。
api_key: OpenAI服务接口的API密钥，用于验证请求的合法性。
question: 输入的问题文本。
nresults: 需要返回的最大回复文本个数。
dimension: 向量表示的维度。该维度必须与知识文档和历史对话文档中向量表示的维度一致。
pr_relation_name: 充当知识文档的数据表单名，该数据表单由(id, paragraph, para_vec)三个字段构成，其中id是integer类型的段落序号主键，paragraph是text类型的段落内容，para_vec是paragraph的向量表示。
qa_relation_name: 充当历史对话文档的数据表单名，该数据表单由(input, output, input_vec)三个字段构成，其中input是text类型的问题文本，output是text类型的回复文本，input_vec是input的向量表示。</p>
<p>该SQL语句返回一个回复文本数组，数组中元素个数不超过nresults。</p>
<h5 id="_59"><strong>基于图片和自然语言的视觉问答</strong></h5>
<p>视觉问答（Visual Question answer, VQA）是一种典型的多模态信息处理问题，给机器一张图片和一个开放式的的自然语言问题，要求机器输出自然语言答案。
视觉问答的SQL语句如下：
<div class="highlight"><pre><span></span><code>select aisql.vqa(model_name text, version text, api_key text, image_path text, prompt text);
</code></pre></div>
其中，参数说明如下：
model_name: OpenAI服务接口约定的大模型名称。
version: 大模型的字符型版本号。
api_key: OpenAI服务接口的API密钥，用于验证请求的合法性。
image_path: 用于回答用户问题的图片文件路径。
prompt: 输入的用户问题。</p>
<p>该SQL语句返回一个回复文本。
视觉问答示例：
<div class="highlight"><pre><span></span><code>select aisql.vqa(&#39;openbmb/MiniCPM-V-2&#39;, &#39;v1&#39;, &#39;anykey&#39;, &#39;/path/to/image.jpg&#39;, &#39;详细描述这张图表达的内容&#39;);
</code></pre></div></p>
<h5 id="sql"><strong>自然语言到SQL语句的转换</strong></h5>
<p>自然语言到SQL语句的转换（Text-to-SQL）是一种前沿的人机交互技术，通过将针对数据库的自然语言查询转换成数据库管理系统能理解的SQL查询，可以降低数据库运维的学习成本，改善用户使用数据库的体验。AiSQL提供了一种针对数据库内指定命名空间schema的Text-to-SQL服务，利用该命名空间内的所有数据表单将用户针对数据库的自然语言查询转换成SQL查询。
这种Text-to-SQL服务的SQL语句如下：
<div class="highlight"><pre><span></span><code>select aisql.convert_nl_query(model_name text, version text, api_key text, schema_name text, query text, nresults integer default 1);
</code></pre></div>
其中，参数说明如下：
model_name: OpenAI服务接口约定的大模型名称。
version: 大模型的字符型版本号。
api_key: OpenAI服务接口的API密钥，用于验证请求的合法性。
shema_name: 需要查询的库内命名空间名，该命名空间内的数据表单用于合成目标SQL查询。
query: 用户针对数据库的自然语言查询。
nresults: 转换得到的候选SQL查询个数上限。</p>
<p>该SQL语句返回一个候选SQL查询数组，数组中SQL查询个数不超过nresults。
Text-to-SQL示例：
<div class="highlight"><pre><span></span><code>-- 产生至多3个候选SQL查询，每个候选SQL查询单行显示  
select unnest(aisql.convert_nl_query(&#39;Qwen1.5-7B-NSQL&#39;, &#39;v1&#39;, &#39;anykey&#39;, &#39;concert_singer&#39;, &#39;按年龄降序，每个歌手的名字、国家、年龄是什么？&#39;, 3));
</code></pre></div></p>
<h3 id="_60"><strong>操作审计</strong></h3>
<p>AI特性插件针对机器学习模型（包括大模型）的操作引入了专属的审计机制，在aisql.audit_log表单中存储了所有模型操作SQL语句的日志记录。由于实际应用中模型操作与数据操作经常交互执行，完整的审计报告需要涵盖数据操作和模型操作，因此AI特性插件也引入了用户可控日志粒度的数据操作审计机制，通过下述无返回值的SQL语句产生数据操作日志记录：
<div class="highlight"><pre><span></span><code>select aisql.data_sql_with_audit(sql text);
</code></pre></div>
其中，sql参数是需要产生对应审计记录的数据操作SQL语句。
操作审计示例：
<div class="highlight"><pre><span></span><code>-- 产生从数据表单创建、数据填充、聚类模型训练再到聚类模型评估的审计报告  
select aisql.data_sql_with_audit(&#39;create table aisql.mushroom(class char(1), cap_shape char(1), cap_surface char(1), cap_color char(1), bruises char(1), odor char(1), gill_attachment char(1), gill_spacing char(1), gill_size char(1), gill_color char(1), stalk_shape char(1), stalk_root char(1), stalk_surface_above_ring char(1), stalk_surface_below_ring char(1), stalk_color_above_ring char(1), stalk_color_below_ring char(1), veil_type char(1), veil_color char(1), ring_number char(1), ring_type char(1), spore_print_color char(1), population char(1), habitat char(1))&#39;);  

select aisql.data_sql_with_audit(&#39;copy aisql.mushroom from &#39;&#39;/path/to/mushroom.data&#39;&#39; (format csv, header false, delimiter &#39;&#39;,&#39;&#39;, encoding &#39;&#39;utf-8&#39;&#39;)&#39;);  

select * from aisql.train(project_name=&gt;&#39;mushroom.clustering&#39;, task=&gt;&#39;clustering&#39;, relation_name=&gt;&#39;aisql.mushroom&#39;, x_column_names=&gt;&#39;{cap_shape,cap_surface,cap_color,bruises,odor,gill_attachment,gill_spacing,gill_size,gill_color,stalk_shape,stalk_root,stalk_surface_above_ring,stalk_surface_below_ring,stalk_color_above_ring,stalk_color_below_ring,veil_type,veil_color,ring_number,ring_type,spore_print_color,population,habitat}&#39;::text[], y_column_names=&gt;&#39;{class}&#39;::text[], preprocess=&gt;&#39;{&quot;_ALL_X_&quot;:{&quot;ordinal&quot;:{}}, &quot;class&quot;:{&quot;encode&quot;:{}}}&#39;);  

select * from aisql.evaluate(&#39;mushroom.clustering&#39;, &#39;aisql.mushroom&#39;, &#39;class&#39;, &#39;{completeness_score,homogeneity_score,mutual_info_score,rand_score}&#39;::text[]);  

-- 产生审计报告视图  
create view aisql.mushroom_report as select * from aisql.audit_log order by log_time desc limit 4;  

-- 以时间顺序显示审计报告中的日志记录  
select * from aisql.mushroom_report order by log_time;
</code></pre></div>
上述例子中的mushroom数据集是一个蘑菇二分类数据集，用于判定蘑菇是否绝对可食用。该数据集可以从<a href="http://archive.ics.uci.edu/dataset/73/mushroom">这里</a>下载。</p>
<h3 id="_61"><strong>备份和恢复</strong></h3>
<p>AI特性插件提供了模型操作结果的备份和恢复功能。备份功能仅涉及机器学习模型包括大模型管理操作的结果，不包括数据操作结果和审计结果。恢复功能先清空现有库内的模型操作结果，再从备份信息中恢复模型操作结果。与备份功能一样，恢复功能也不涉及数据操作结果和审计结果。备份和恢复都不清空审计日志记录表单，而是将这两项操作自身记录到审计日志中，持续丰富审计日志的内容。
备份的SQL语句如下：
<div class="highlight"><pre><span></span><code>select aisql.dump_all(data_dir varchar);
</code></pre></div>
其中，data_dir参数是备份信息保存的目录路径。备份信息将分成多个文件进行存储，并放置于data_dir目录中。
该SQL语句返回一个字符串，显示备份信息已经保存到指定目录中。
恢复的SQL语句如下：
<div class="highlight"><pre><span></span><code>select aisql.load_all(data_dir varchar);
</code></pre></div>
其中，data_dir参数是备份信息保存的目录路径。
该SQL语句返回一个字符串，显示已经从指定目录的备份信息中恢复模型操作结果。
备份和恢复示例：
<div class="highlight"><pre><span></span><code>-- 备份  
select aisql.dump_all(&#39;/path/to/backup_dir&#39;);  
-- 恢复  
select aisql.load_all(&#39;/path/to/backup_dir&#39;);
</code></pre></div></p>
<h3 id="_62"><strong>内置帮助服务</strong></h3>
<p>AI特性插件内置了上述各小节中提及的aisql专有函数的帮助说明。
查询aisql专有函数的SQL语句如下：
<div class="highlight"><pre><span></span><code>select aisql.help(command text default NULL);
</code></pre></div>
其中，command参数是aisql专有函数名，比如'aisql.train'和'aisql.help'等，参数中的命名空间可以省略，即可以简写成'train'和'help'等。
当command参数不设置即默认为NULL值时，该SQL语句返回字典序排列的aisql专有函数列表。当command参数是某个aisql专有函数名时，该SQL语句返回指定专有函数的帮助说明，包括专有函数的用途说明、参数说明和返回值说明。</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      © 2024 贝格迈思
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.aecac24b.min.js"></script>
      
        <script src="../../javascripts/extra.js"></script>
      
    
  </body>
</html>