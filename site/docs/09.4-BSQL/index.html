
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="贝格迈思数据库使用手册">
      
      
      
      
        <link rel="prev" href="../09.3-%E9%85%8D%E7%BD%AE/">
      
      
        <link rel="next" href="../09.5-BCQL/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.4.6">
    
    
      
        <title>BSQL - 手册</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.35e1ed30.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.356b1318.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Ubuntu";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="mo" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#bsql" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="手册" class="md-header__button md-logo" aria-label="手册" data-md-component="logo">
      
  <img src="../../assets/new-logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            手册
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              BSQL
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/aminerdocs/docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="手册" class="md-nav__button md-logo" aria-label="手册" data-md-component="logo">
      
  <img src="../../assets/new-logo.png" alt="logo">

    </a>
    手册
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/aminerdocs/docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../01-AISQL%E7%AE%80%E4%BB%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AiSQL简介
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    快速上手
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            快速上手
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    快速安装部署
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/SQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SQL基本操作
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/BCQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BCQL基本操作
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%88%9B%E5%BB%BAJava%E7%A4%BA%E4%BE%8B%E5%BA%94%E7%94%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    创建Java示例应用程序
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    应用开发
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            应用开发
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    构建应用
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            构建应用
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/JAVA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Java
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Go/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Go
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Python/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Python
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Node.js/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Node.js
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C%2B%2B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/C%23/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C#
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Ruby/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Ruby
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/Rust/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Rust
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/PHP/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PHP
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BA%E5%85%A8%E5%B1%80%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    构建全局应用程序
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    构建多云应用程序
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            构建多云应用程序
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    概述
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../04-%E9%83%A8%E7%BD%B2%E9%9B%86%E7%BE%A4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    部署集群
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../05-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数据迁移
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../06-%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    管理数据库
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../07-%E5%90%91%E9%87%8F%E7%89%B9%E6%80%A7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    向量特性
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../08-AI%E7%89%B9%E6%80%A7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AI特性
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" checked>
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    参考
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            参考
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.1-%E6%9E%B6%E6%9E%84/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    架构
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.2-CLIs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CLIs
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.3-%E9%85%8D%E7%BD%AE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    配置
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    BSQL
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    BSQL
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#bsql" class="md-nav__link">
    BSQL
  </a>
  
    <nav class="md-nav" aria-label="BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    数据类型
  </a>
  
    <nav class="md-nav" aria-label="数据类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#array" class="md-nav__link">
    数组（array）
  </a>
  
    <nav class="md-nav" aria-label="数组（array）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    概要
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nullnull" class="md-nav__link">
    # 原子为Null与所有值为Null的对比
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    # 类型构造
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    # 数组应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    # 数组应用示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_1" class="md-nav__link">
    array[]构造函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    # 用途与用法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#plpgsqlarray" class="md-nav__link">
    # 在PL/pgSQL代码中使用array[]构造函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_2" class="md-nav__link">
    # 在准备好的语句中使用array[]构造函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    常量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    # 值文本类型转换、该值的文本文字，以及它们之间的关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    ## 值到文本的类型转换和返回值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsqlsh" class="md-nav__link">
    ## 布尔值显示在bsqlsh中的特殊文本形式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#text" class="md-nav__link">
    ## 值的text类型转换与创建该值的文字之间的关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    ## 定义“文字的规范形式”
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    基础值数字文字文本
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    # 规则声明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    # 以规范形式写入数组文本文字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    # 举例说明规则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#int" class="md-nav__link">
    ## int值的一维数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#text_1" class="md-nav__link">
    ## 一维text值数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#timestamp" class="md-nav__link">
    ## 一维timestamp值数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#booleannull" class="md-nav__link">
    ## 一维Boolean值数组（通常为NULL）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#int_1" class="md-nav__link">
    ## int值的多维数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#row" class="md-nav__link">
    “row”类型值的文本文字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    # 规则声明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#introw" class="md-nav__link">
    ## int字段的“row”类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#textrow" class="md-nav__link">
    ## text字段的“row”类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#timestamprow" class="md-nav__link">
    ## timestamp字段的“row”类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#booleanrow" class="md-nav__link">
    ## boolean字段的“row”类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rowrow" class="md-nav__link">
    # “Row”类型的文本文字与“Row”类型的构造函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#row_1" class="md-nav__link">
    “row”类型值数组的文本文字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    # 规则声明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#row_2" class="md-nav__link">
    # 用于为“row”类型值的一维数组生成文字的伪代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#plpgsql" class="md-nav__link">
    PL/pgSQL中的数组循环
  </a>
  
    <nav class="md-nav" aria-label="PL/pgSQL中的数组循环">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    语法和语义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#slice" class="md-nav__link">
    在不带SLICE关键字的数组中循环使用值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#slice_1" class="md-nav__link">
    非零SLICE操作数在多维数组的内容上循环
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#foreachdomain" class="md-nav__link">
    使用FOREACH迭代DOMAIN值数组中的元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#plpgsqlslice" class="md-nav__link">
    使用包装PL/pgSQL表函数将SLICE操作数公开为形式参数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#domain" class="md-nav__link">
    使用DOMAIN值数组
  </a>
  
    <nav class="md-nav" aria-label="使用DOMAIN值数组">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#gps" class="md-nav__link">
    示例：GPS行程数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    创建不规则数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    # 矛盾
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    # 解决方案
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    # 处理数组的不规则数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#foreachdomains" class="md-nav__link">
    # 将FOREACH与DOMAINs数组结合使用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_aggdomain" class="md-nav__link">
    # 使用array_agg()生成DOMAIN值数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    创建矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    # 定义需要的数据类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#block_matrix_tdomain" class="md-nav__link">
    # 使用“block_matrix_t”DOMAIN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unnest" class="md-nav__link">
    # 对数组使用unnest()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    数组函数和运算符
  </a>
  
    <nav class="md-nav" aria-label="数组函数和运算符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    创建函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_fill" class="md-nav__link">
    # array_fill()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_agg" class="md-nav__link">
    # array_agg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_agg_1" class="md-nav__link">
    ## array_agg() 重载函数一
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_agg_2" class="md-nav__link">
    ## array_agg() 重载函数二
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#string_to_array" class="md-nav__link">
    # string_to_array()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    几何函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_ndims" class="md-nav__link">
    # array_ndims()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_lower" class="md-nav__link">
    # array_lower()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_upper" class="md-nav__link">
    # array_upper()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_length" class="md-nav__link">
    # array_length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cardinality" class="md-nav__link">
    # cardinality()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_dims" class="md-nav__link">
    # array_dims()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    查找函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_position" class="md-nav__link">
    # array_position()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_positions" class="md-nav__link">
    # array_positions()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#anyall" class="md-nav__link">
    ANY/ALL运算符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#any-all" class="md-nav__link">
    # ANY 和 ALL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    ## 概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    ## 用途
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    ## 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    比较运算符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    # 概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    切片运算符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#slice_2" class="md-nav__link">
    # slice运算符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    连接函数和运算符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_cat" class="md-nav__link">
    # array_cat()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_append" class="md-nav__link">
    # array_append()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_prepend" class="md-nav__link">
    # array_prepend()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    更改函数和运算符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_replace" class="md-nav__link">
    # array_replace()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#arridx_1idx_n-val" class="md-nav__link">
    # arr[idx_1]...[idx_N] := val
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_remove" class="md-nav__link">
    # array_remove()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    转换函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_to_string" class="md-nav__link">
    # array_to_string()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    表函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unnest_1" class="md-nav__link">
    # unnest()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unnest_2" class="md-nav__link">
    ## unnest() 重载函数一
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unnest_3" class="md-nav__link">
    ## unnest() 重载函数二
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generate_subscripts" class="md-nav__link">
    # generate_subscripts()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary" class="md-nav__link">
    Binary
  </a>
  
    <nav class="md-nav" aria-label="Binary">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#9412111" class="md-nav__link">
    # 9.4.1.2.1.1.1 ||
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit_length" class="md-nav__link">
    # bit_length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#octet_length" class="md-nav__link">
    # octet_length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#overlaystring-placing-string-from-int-for-int" class="md-nav__link">
    # overlay(string placing string from int [for int])
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#positionsubstring-in-string" class="md-nav__link">
    # position(substring in string)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#substringstring-from-int-for-int" class="md-nav__link">
    # substring(string [from int] [for int])
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trimboth-bytes-from-string" class="md-nav__link">
    # trim([both] bytes from string)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#btrim" class="md-nav__link">
    # btrim()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#decode" class="md-nav__link">
    # decode()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#encode" class="md-nav__link">
    # encode()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_bit" class="md-nav__link">
    # get_bit()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_byte" class="md-nav__link">
    # get_byte()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#length" class="md-nav__link">
    # length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#length_1" class="md-nav__link">
    # length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#md5" class="md-nav__link">
    # md5()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_bit" class="md-nav__link">
    # set_bit()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_byte" class="md-nav__link">
    # set_byte()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sha224" class="md-nav__link">
    # sha224()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sha256" class="md-nav__link">
    # sha256()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sha384" class="md-nav__link">
    # sha384()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sha512" class="md-nav__link">
    # sha512()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#substr" class="md-nav__link">
    # substr()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#boolean" class="md-nav__link">
    Boolean
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#character" class="md-nav__link">
    Character
  </a>
  
    <nav class="md-nav" aria-label="Character">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    操作符和函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#string-string" class="md-nav__link">
    # string || string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#string-non-string-or-non-string-string" class="md-nav__link">
    # string || non-string or non-string || string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit_length_1" class="md-nav__link">
    # bit_length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#char_length-character_length" class="md-nav__link">
    # char_length() 与 character_length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lower" class="md-nav__link">
    # lower()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#octet_length_1" class="md-nav__link">
    # octet_length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#overlaystring-placing-string-from-int-for-int_1" class="md-nav__link">
    # overlay(string placing string from int [for int])
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#positionsubstring-in-string_1" class="md-nav__link">
    # position(substring in string)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#substringstring-from-int-for-int_1" class="md-nav__link">
    # substring(string [from int] [for int])
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#substringstring-from-pattern" class="md-nav__link">
    # substring(string from pattern)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#substringstring-from-pattern-for-escape" class="md-nav__link">
    # substring(string from pattern for escape)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trimleading-trailing-both-characters-from-string" class="md-nav__link">
    # trim([leading | trailing | both] [characters] from string)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trimleading-trailing-both-from-string-characters" class="md-nav__link">
    # trim([leading | trailing | both] [from] string [, characters] )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upper" class="md-nav__link">
    # upper()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ascii" class="md-nav__link">
    # ascii()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#btrimstring-text-characters-text" class="md-nav__link">
    # btrim(string text [, characters text])
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#chr" class="md-nav__link">
    # chr()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#concat-val1-any-val2-any" class="md-nav__link">
    # concat ( val1 "any" [, val2 "any" [, ...] ] )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#concat_ws-sep-text-val1-any-val2-any" class="md-nav__link">
    # concat_ws ( sep text, val1 "any" [, val2 "any" [, ...] ] )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convert_tostring-text-dest_encoding-name" class="md-nav__link">
    # convert_to(string text, dest_encoding name)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#formatformatstr-text-formatarg-any" class="md-nav__link">
    # format(formatstr text [, formatarg "any" [, ...] ])
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#initcap" class="md-nav__link">
    # initcap()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#left" class="md-nav__link">
    # left()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#length_2" class="md-nav__link">
    # length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lpad" class="md-nav__link">
    # lpad()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ltrim" class="md-nav__link">
    # ltrim()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#md5_1" class="md-nav__link">
    # md5()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parse_ident-qualified_identifier-text-strict_mode-boolean-default-true" class="md-nav__link">
    # parse_ident ( qualified_identifier text [, strict_mode boolean DEFAULT true ] )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_client_encoding" class="md-nav__link">
    # pg_client_encoding()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quote_ident" class="md-nav__link">
    # quote_ident()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quote_literal" class="md-nav__link">
    # quote_literal()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quote_literal_1" class="md-nav__link">
    # quote_literal()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quote_nullable" class="md-nav__link">
    # quote_nullable()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quote_nullable_1" class="md-nav__link">
    # quote_nullable()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_match" class="md-nav__link">
    # regexp_match()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_matches" class="md-nav__link">
    # regexp_matches()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_replace" class="md-nav__link">
    # regexp_replace()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_split_to_array" class="md-nav__link">
    # regexp_split_to_array()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_split_to_table" class="md-nav__link">
    # regexp_split_to_table()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#repeat" class="md-nav__link">
    # repeat()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#replace" class="md-nav__link">
    # replace()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reverse" class="md-nav__link">
    # reverse()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#right" class="md-nav__link">
    # right()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rpad" class="md-nav__link">
    # rpad()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rtrim" class="md-nav__link">
    # rtrim()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#split_part" class="md-nav__link">
    # split_part()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#strpos" class="md-nav__link">
    # strpos()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#substr_1" class="md-nav__link">
    # substr()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#starts_with" class="md-nav__link">
    # starts_with()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_ascii" class="md-nav__link">
    # to_ascii()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_hex" class="md-nav__link">
    # to_hex()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#translate" class="md-nav__link">
    # translate()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#datetime" class="md-nav__link">
    date与time
  </a>
  
    <nav class="md-nav" aria-label="date与time">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    概要
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#date" class="md-nav__link">
    date
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#time" class="md-nav__link">
    time
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#utc" class="md-nav__link">
    时区和UTC偏移
  </a>
  
    <nav class="md-nav" aria-label="时区和UTC偏移">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    时区
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#utc_1" class="md-nav__link">
    UTC偏移
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#utc_2" class="md-nav__link">
    # 指定UTC偏移的四种方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#utc_3" class="md-nav__link">
    # 使用UTC偏移量的三个语法上下文
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#timestamptimestamptz" class="md-nav__link">
    timestamp与timestamptz
  </a>
  
    <nav class="md-nav" aria-label="timestamp与timestamptz">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#timestamp_1" class="md-nav__link">
    timestamp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#timestamptz" class="md-nav__link">
    timestamptz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    夏令时
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#interval" class="md-nav__link">
    interval
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    时间/日期函数
  </a>
  
    <nav class="md-nav" aria-label="时间/日期函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    创建函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make_date" class="md-nav__link">
    # make_date()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make_time" class="md-nav__link">
    # make_time()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make_timestamp" class="md-nav__link">
    # make_timestamp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make_timestamptz" class="md-nav__link">
    # make_timestamptz()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_timestamp" class="md-nav__link">
    # to_timestamp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make_interval" class="md-nav__link">
    # make_interval()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    操作函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#date_trunc" class="md-nav__link">
    # date_trunc()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#justify_days" class="md-nav__link">
    # justify_days()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#justify_hours" class="md-nav__link">
    # justify_hours()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#justify_interval" class="md-nav__link">
    # justify_interval()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    当前日期/时间函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_date" class="md-nav__link">
    # current_date
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_time" class="md-nav__link">
    # current_time()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_timestamp" class="md-nav__link">
    # current_timestamp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#localtime" class="md-nav__link">
    # localtime()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#localtimestamp" class="md-nav__link">
    # localtimestamp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transaction_timestamp" class="md-nav__link">
    # transaction_timestamp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#now" class="md-nav__link">
    # now()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#statement_timestamp" class="md-nav__link">
    # statement_timestamp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clock_timestamp" class="md-nav__link">
    # clock_timestamp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#timeofday" class="md-nav__link">
    # timeofday()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    延时执行函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_sleep" class="md-nav__link">
    # pg_sleep()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_sleep_for" class="md-nav__link">
    # pg_sleep_for()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_sleep_until" class="md-nav__link">
    # pg_sleep_until()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    其它函数和操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#isfinite" class="md-nav__link">
    # isfinite()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#age" class="md-nav__link">
    # age()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#timezone" class="md-nav__link">
    # timezone()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#extract-date_part" class="md-nav__link">
    # extract() / date_part()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#overlaps" class="md-nav__link">
    # OVERLAPS
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    格式化函数
  </a>
  
    <nav class="md-nav" aria-label="格式化函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    格式化函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_char" class="md-nav__link">
    # to_char()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_date" class="md-nav__link">
    # to_date()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_timestamp_1" class="md-nav__link">
    # to_timestamp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    日期-时间模板模式
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json" class="md-nav__link">
    json
  </a>
  
    <nav class="md-nav" aria-label="json">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    基本与复合数据类型
  </a>
  
    <nav class="md-nav" aria-label="基本与复合数据类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#json_1" class="md-nav__link">
    JSON字符串
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_2" class="md-nav__link">
    JSON数字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_3" class="md-nav__link">
    JSON布尔型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json-null" class="md-nav__link">
    JSON null
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_4" class="md-nav__link">
    JSON对象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_5" class="md-nav__link">
    JSON数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_6" class="md-nav__link">
    复合JSON
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_7" class="md-nav__link">
    在JSON列上创建索引和检查约束
  </a>
  
    <nav class="md-nav" aria-label="在JSON列上创建索引和检查约束">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    创建检查约束
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    创建索引
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_8" class="md-nav__link">
    JSON函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="JSON函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sqljson" class="md-nav__link">
    转换SQL值到JSON值函数和操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb-json-text" class="md-nav__link">
    # ::jsonb和 ::json和 ::text
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_jsonb" class="md-nav__link">
    # to_jsonb()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#row_to_json" class="md-nav__link">
    # row_to_json()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_to_json" class="md-nav__link">
    # array_to_json()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_build_array" class="md-nav__link">
    # jsonb_build_array()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_build_object-json_build_object" class="md-nav__link">
    # jsonb_build_object() 和 json_build_object()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_object-json_object" class="md-nav__link">
    # jsonb_object() 和 json_object()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    ## 重载函数一
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    ## 重载函数二
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_63" class="md-nav__link">
    ## 重载函数三
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_agg" class="md-nav__link">
    # jsonb_agg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_object_agg" class="md-nav__link">
    # jsonb_object_agg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonjson" class="md-nav__link">
    转换JSON值到JSON值函数和操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_1" class="md-nav__link">
    # -&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_64" class="md-nav__link">
    # #&gt;
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_65" class="md-nav__link">
    &gt;运算符是一种方便的语法简写，用于紧凑地指定长路径，因此：
  </a>
  
    <nav class="md-nav" aria-label=">运算符是一种方便的语法简写，用于紧凑地指定长路径，因此：">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_66" class="md-nav__link">
    # ||
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_2" class="md-nav__link">
    # -
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_3" class="md-nav__link">
    # #-
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_extract_path-json_extract_path" class="md-nav__link">
    # jsonb_extract_path() 和 json_extract_path()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_strip_nulls-json_strip_nulls" class="md-nav__link">
    # jsonb_strip_nulls 和 json_strip_nulls
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_set" class="md-nav__link">
    # jsonb_set()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_insert" class="md-nav__link">
    # jsonb_insert()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonsql" class="md-nav__link">
    转换JSON值到SQL值函数和操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#text_2" class="md-nav__link">
    # ::text
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_4" class="md-nav__link">
    # -&gt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_67" class="md-nav__link">
    # #&gt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_extract_path_text-json_extract_path_text" class="md-nav__link">
    # jsonb_extract_path_text() 和 json_extract_path_text()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_populate_record-json_populate_record" class="md-nav__link">
    # jsonb_populate_record() 和 json_populate_record()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_populate_recordset-json_populate_recordset" class="md-nav__link">
    # jsonb_populate_recordset() 和 json_populate_recordset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_to_record-json_to_record" class="md-nav__link">
    # jsonb_to_record() 和 json_to_record()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_to_recordset-json_to_recordset" class="md-nav__link">
    # jsonb_to_recordset() 和 json_to_recordset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_array_elements-json_array_elements" class="md-nav__link">
    # jsonb_array_elements() 和 json_array_elements()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_array_elements_text-json_array_elements_text" class="md-nav__link">
    # jsonb_array_elements_text() 和 json_array_elements_text()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_each-json_each" class="md-nav__link">
    # jsonb_each() 和 json_each()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_each_text-json_each_text" class="md-nav__link">
    # jsonb_each_text() 和 json_each_text()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_pretty" class="md-nav__link">
    # jsonb_pretty()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_9" class="md-nav__link">
    获取JSON值属性函数和操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_68" class="md-nav__link">
    # =
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_69" class="md-nav__link">
    # @&gt; 和 &lt;@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_70" class="md-nav__link">
    # ?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_71" class="md-nav__link">
    # ?|
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_72" class="md-nav__link">
    # ?&amp;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_array_length-json_array_length" class="md-nav__link">
    # jsonb_array_length() 和 json_array_length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_typeof-json_typeof" class="md-nav__link">
    # jsonb_typeof() 和 json_typeof()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_object_keys-json_object_keys" class="md-nav__link">
    # jsonb_object_keys() 和 json_object_keys()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#money" class="md-nav__link">
    Money
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_73" class="md-nav__link">
    数字类型
  </a>
  
    <nav class="md-nav" aria-label="数字类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#integers" class="md-nav__link">
    Integers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_74" class="md-nav__link">
    浮点类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_75" class="md-nav__link">
    任意精度数字
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_76" class="md-nav__link">
    范围类型
  </a>
  
    <nav class="md-nav" aria-label="范围类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_1" class="md-nav__link">
    BSQL中的范围值
  </a>
  
    <nav class="md-nav" aria-label="BSQL中的范围值">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_77" class="md-nav__link">
    使用文字指定范围值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tsrange" class="md-nav__link">
    使用构造函数指定“tsrange”值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_78" class="md-nav__link">
    无界的范围
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_79" class="md-nav__link">
    对范围值和基础数据类型的值的操作
  </a>
  
    <nav class="md-nav" aria-label="对范围值和基础数据类型的值的操作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_80" class="md-nav__link">
    范围值是否为空
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_81" class="md-nav__link">
    两个范围值是否相交
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_82" class="md-nav__link">
    生成一个新的范围值作为两个范围值的交集
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_83" class="md-nav__link">
    是包含在范围内的范围的基础数据类型的值
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_84" class="md-nav__link">
    离散范围数据类型及其文字的规范形式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_85" class="md-nav__link">
    范围输入/输出
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_86" class="md-nav__link">
    函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_87" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_88" class="md-nav__link">
    # =
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_89" class="md-nav__link">
    # &lt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_90" class="md-nav__link">
    # &lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_91" class="md-nav__link">
    # &gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_92" class="md-nav__link">
    # &lt;=
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_93" class="md-nav__link">
    # &gt;=
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_94" class="md-nav__link">
    # @&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_95" class="md-nav__link">
    # @&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_96" class="md-nav__link">
    # &lt;@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_97" class="md-nav__link">
    # &lt;@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_98" class="md-nav__link">
    # &amp;&amp;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_99" class="md-nav__link">
    # &lt;&lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_100" class="md-nav__link">
    # &gt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_101" class="md-nav__link">
    # &amp;&lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_102" class="md-nav__link">
    # &amp;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_5" class="md-nav__link">
    # -|-
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_103" class="md-nav__link">
    # +
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_104" class="md-nav__link">
    # *
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_6" class="md-nav__link">
    # -
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_105" class="md-nav__link">
    函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lower_1" class="md-nav__link">
    # lower()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upper_1" class="md-nav__link">
    # upper()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#isempty" class="md-nav__link">
    # isempty()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lower_inc" class="md-nav__link">
    # lower_inc()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upper_inc" class="md-nav__link">
    # upper_inc()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lower_inf" class="md-nav__link">
    # lower_inf()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upper_inf" class="md-nav__link">
    # upper_inf()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#range_merge" class="md-nav__link">
    # range_merge()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#serial" class="md-nav__link">
    Serial
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#uuid" class="md-nav__link">
    UUID
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_106" class="md-nav__link">
    枚举类型
  </a>
  
    <nav class="md-nav" aria-label="枚举类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_107" class="md-nav__link">
    枚举类型的声明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_108" class="md-nav__link">
    排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_109" class="md-nav__link">
    类型安全性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_110" class="md-nav__link">
    函数
  </a>
  
    <nav class="md-nav" aria-label="函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#enum_first" class="md-nav__link">
    # enum_first()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enum_last" class="md-nav__link">
    # enum_last()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enum_range" class="md-nav__link">
    # enum_range()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enum_range_1" class="md-nav__link">
    # enum_range()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_111" class="md-nav__link">
    几何类型
  </a>
  
    <nav class="md-nav" aria-label="几何类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_112" class="md-nav__link">
    点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_113" class="md-nav__link">
    线
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_114" class="md-nav__link">
    线段
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_115" class="md-nav__link">
    矩形
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_116" class="md-nav__link">
    路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_117" class="md-nav__link">
    多边形
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_118" class="md-nav__link">
    圆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_119" class="md-nav__link">
    函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_120" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_121" class="md-nav__link">
    # +
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_122" class="md-nav__link">
    # +
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_7" class="md-nav__link">
    # -
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_123" class="md-nav__link">
    # *
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_124" class="md-nav__link">
    # /
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_125" class="md-nav__link">
    #
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_126" class="md-nav__link">
    #
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_8" class="md-nav__link">
    # @-@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_127" class="md-nav__link">
    # @@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_128" class="md-nav__link">
    #
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_9" class="md-nav__link">
    # &lt;-&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_129" class="md-nav__link">
    # &amp;&amp;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_130" class="md-nav__link">
    # &lt;&lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_131" class="md-nav__link">
    # &gt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_132" class="md-nav__link">
    # &amp;&lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_133" class="md-nav__link">
    # &amp;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_134" class="md-nav__link">
    # &lt;&lt;|
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_135" class="md-nav__link">
    # |&gt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_136" class="md-nav__link">
    # &amp;&lt;|
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_137" class="md-nav__link">
    # |&amp;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_138" class="md-nav__link">
    # &lt;^
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_139" class="md-nav__link">
    # &gt;^
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_140" class="md-nav__link">
    # ?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_10" class="md-nav__link">
    # ?-
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_11" class="md-nav__link">
    # ?-
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_141" class="md-nav__link">
    # ?|
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_142" class="md-nav__link">
    # ?|
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_12" class="md-nav__link">
    # ?-|
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_143" class="md-nav__link">
    # ?||
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_144" class="md-nav__link">
    # @&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_145" class="md-nav__link">
    # &lt;@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_146" class="md-nav__link">
    # ~=
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_147" class="md-nav__link">
    函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#area" class="md-nav__link">
    # area()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#center" class="md-nav__link">
    # center()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#diagonal" class="md-nav__link">
    # diagonal()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#diameter" class="md-nav__link">
    # diameter()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#height" class="md-nav__link">
    # height()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#isclosed" class="md-nav__link">
    # isclosed()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#isopen" class="md-nav__link">
    # isopen()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#length_3" class="md-nav__link">
    # length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#npoints" class="md-nav__link">
    # npoints()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pclose" class="md-nav__link">
    # pclose()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#popen" class="md-nav__link">
    # popen()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#radius" class="md-nav__link">
    # radius()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#width" class="md-nav__link">
    # width()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_148" class="md-nav__link">
    几何类型转换函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#boxcircle" class="md-nav__link">
    # box(circle)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#boxpoint" class="md-nav__link">
    # box(point)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#boxpoint-point" class="md-nav__link">
    # box(point, point)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#boxpolygon" class="md-nav__link">
    # box(polygon)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bound_boxbox-box" class="md-nav__link">
    # bound_box(box, box )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#circlebox" class="md-nav__link">
    # circle(box)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#circlepoint-double-precision" class="md-nav__link">
    # circle(point, double precision)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#circlepolygon" class="md-nav__link">
    # circle(polygon)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linepoint-point" class="md-nav__link">
    # line(point, point)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lsegbox" class="md-nav__link">
    # lseg(box)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lsegpoint-point" class="md-nav__link">
    # lseg(point, point)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pathpolygon" class="md-nav__link">
    # path(polygon)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointbox" class="md-nav__link">
    # point(box)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointcircle" class="md-nav__link">
    # point(circle)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointdouble-precision-double-precision" class="md-nav__link">
    # point(double precision, double precision)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointlseg" class="md-nav__link">
    # point(lseg)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointpolygon" class="md-nav__link">
    # point(polygon)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polygonbox" class="md-nav__link">
    # polygon(box)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polygoncircle" class="md-nav__link">
    # polygon(circle)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polygonnpts-circle" class="md-nav__link">
    # polygon(npts, circle)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polygonpath" class="md-nav__link">
    # polygon(path)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_149" class="md-nav__link">
    网络地址类型
  </a>
  
    <nav class="md-nav" aria-label="网络地址类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#inet" class="md-nav__link">
    inet
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cidr" class="md-nav__link">
    cidr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#macaddr" class="md-nav__link">
    macaddr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#macaddr8" class="md-nav__link">
    macaddr8
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_150" class="md-nav__link">
    函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_151" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_152" class="md-nav__link">
    # &lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_153" class="md-nav__link">
    # &lt;=
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_154" class="md-nav__link">
    # =
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_155" class="md-nav__link">
    # &gt;=
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_156" class="md-nav__link">
    # &gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_157" class="md-nav__link">
    # &lt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_158" class="md-nav__link">
    # &lt;&lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_159" class="md-nav__link">
    # &lt;&lt;=
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_160" class="md-nav__link">
    # &gt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_161" class="md-nav__link">
    # &gt;&gt;=
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_162" class="md-nav__link">
    # ~
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_163" class="md-nav__link">
    # &amp;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_164" class="md-nav__link">
    # |
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_165" class="md-nav__link">
    # +
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_13" class="md-nav__link">
    # -
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_14" class="md-nav__link">
    # -
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_166" class="md-nav__link">
    函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#abbrevinet" class="md-nav__link">
    # abbrev(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#abbrevcidr" class="md-nav__link">
    # abbrev(cidr)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#broadcastinet" class="md-nav__link">
    # broadcast(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#familyinet" class="md-nav__link">
    # family(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hostinet" class="md-nav__link">
    # host(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hostmaskinet" class="md-nav__link">
    # hostmask(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maskleninet" class="md-nav__link">
    # masklen(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#netmaskinet" class="md-nav__link">
    # netmask(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#networkinet" class="md-nav__link">
    # network(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_maskleninet-int" class="md-nav__link">
    # set_masklen(inet, int)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_masklencidr-int" class="md-nav__link">
    # set_masklen(cidr, int)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#textinet" class="md-nav__link">
    # text(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inet_same_familyinet-inet" class="md-nav__link">
    # inet_same_family(inet, inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inet_mergeinet-inet" class="md-nav__link">
    # inet_merge(inet, inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#truncmacaddr" class="md-nav__link">
    # trunc(macaddr)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#truncmacaddr8" class="md-nav__link">
    # trunc(macaddr8)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#macaddr8_set7bitmacaddr8" class="md-nav__link">
    # macaddr8_set7bit(macaddr8)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_167" class="md-nav__link">
    位串类型
  </a>
  
    <nav class="md-nav" aria-label="位串类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_168" class="md-nav__link">
    函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_169" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_170" class="md-nav__link">
    # ||
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_171" class="md-nav__link">
    # &amp;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_172" class="md-nav__link">
    # |
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_173" class="md-nav__link">
    #
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_174" class="md-nav__link">
    # ~
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_175" class="md-nav__link">
    # &lt;&lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_176" class="md-nav__link">
    # &gt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_177" class="md-nav__link">
    函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit_length-bit" class="md-nav__link">
    # bit_length (bit)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#length-bit" class="md-nav__link">
    # length ( bit )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#octet_length-bit" class="md-nav__link">
    # octet_length ( bit )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#overlay-bits-bit-placing-newsubstring-bit-from-start-integer-for-count-integer" class="md-nav__link">
    # overlay ( bits bit PLACING newsubstring bit FROM start integer [ FOR count integer ] )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#position-substring-bit-in-bits-bit" class="md-nav__link">
    # position ( substring bit IN bits bit )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#substring-bits-bit-from-start-integer-for-count-integer" class="md-nav__link">
    # substring ( bits bit [ FROM start integer ] [ FOR count integer ] )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_bit-bits-bit-n-integer" class="md-nav__link">
    # get_bit ( bits bit, n integer )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_bit-bits-bit-n-integer-newvalue-integer" class="md-nav__link">
    # set_bit ( bits bit, n integer, newvalue integer )
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_178" class="md-nav__link">
    文本搜索类型
  </a>
  
    <nav class="md-nav" aria-label="文本搜索类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tsvector" class="md-nav__link">
    tsvector
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tsquery" class="md-nav__link">
    tsquery
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_179" class="md-nav__link">
    函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_180" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_181" class="md-nav__link">
    # @@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_182" class="md-nav__link">
    # @@@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_183" class="md-nav__link">
    # ||
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_184" class="md-nav__link">
    # &amp;&amp;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_185" class="md-nav__link">
    # ||
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_186" class="md-nav__link">
    # !!
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_15" class="md-nav__link">
    # &lt;-&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_187" class="md-nav__link">
    # @&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_188" class="md-nav__link">
    # &lt;@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_189" class="md-nav__link">
    函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_to_tsvector" class="md-nav__link">
    # array_to_tsvector()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_current_ts_config" class="md-nav__link">
    # get_current_ts_config ()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#length_4" class="md-nav__link">
    # length ()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#numnode" class="md-nav__link">
    # numnode ()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#plainto_tsquery" class="md-nav__link">
    # plainto_tsquery ()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#phraseto_tsquery" class="md-nav__link">
    # phraseto_tsquery()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#websearch_to_tsquery" class="md-nav__link">
    # websearch_to_tsquery()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#querytree" class="md-nav__link">
    # querytree()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#setweight" class="md-nav__link">
    # setweight()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#setweight_1" class="md-nav__link">
    # setweight()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#strip" class="md-nav__link">
    # strip()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_tsquery" class="md-nav__link">
    # to_tsquery()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_tsvector" class="md-nav__link">
    # to_tsvector()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_tsvector_1" class="md-nav__link">
    # to_tsvector()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_to_tsvector" class="md-nav__link">
    # json_to_tsvector()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_delete" class="md-nav__link">
    # ts_delete()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_delete_1" class="md-nav__link">
    # ts_delete()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_filter" class="md-nav__link">
    # ts_filter()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_headline" class="md-nav__link">
    # ts_headline()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_headline_1" class="md-nav__link">
    # ts_headline()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_rank" class="md-nav__link">
    # ts_rank()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_rank_cd" class="md-nav__link">
    # ts_rank_cd()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_rewrite" class="md-nav__link">
    # ts_rewrite()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_rewrite_1" class="md-nav__link">
    # ts_rewrite()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tsquery_phrase" class="md-nav__link">
    # tsquery_phrase()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tsquery_phrase_1" class="md-nav__link">
    # tsquery_phrase()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tsvector_to_array" class="md-nav__link">
    # tsvector_to_array()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unnest_4" class="md-nav__link">
    # unnest()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_debug" class="md-nav__link">
    # ts_debug()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_lexize" class="md-nav__link">
    # ts_lexize()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_parse" class="md-nav__link">
    # ts_parse()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_parse_1" class="md-nav__link">
    # ts_parse()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_token_type" class="md-nav__link">
    # ts_token_type()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_token_type_1" class="md-nav__link">
    # ts_token_type()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_stat" class="md-nav__link">
    # ts_stat()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_190" class="md-nav__link">
    域类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_191" class="md-nav__link">
    伪类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql_2" class="md-nav__link">
    BSQL 语言
  </a>
  
    <nav class="md-nav" aria-label="BSQL 语言">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#abort" class="md-nav__link">
    ABORT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-database" class="md-nav__link">
    ALTER DATABASE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-default-privileges" class="md-nav__link">
    ALTER DEFAULT PRIVILEGES
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-domain" class="md-nav__link">
    ALTER DOMAIN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-foreign-data-wrapper" class="md-nav__link">
    ALTER FOREIGN DATA WRAPPER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-foreign-table" class="md-nav__link">
    ALTER FOREIGN TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-function" class="md-nav__link">
    ALTER FUNCTION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-group" class="md-nav__link">
    ALTER GROUP
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-policy" class="md-nav__link">
    ALTER POLICY
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-procedure" class="md-nav__link">
    ALTER PROCEDURE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-role" class="md-nav__link">
    ALTER ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-schema" class="md-nav__link">
    ALTER SCHEMA
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-sequence" class="md-nav__link">
    ALTER SEQUENCE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-server" class="md-nav__link">
    ALTER SERVER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-table" class="md-nav__link">
    ALTER TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-user" class="md-nav__link">
    ALTER USER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#analyze" class="md-nav__link">
    ANALYZE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#begin" class="md-nav__link">
    BEGIN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#call" class="md-nav__link">
    CALL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#close" class="md-nav__link">
    CLOSE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comment" class="md-nav__link">
    COMMENT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#commit" class="md-nav__link">
    COMMIT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#copy" class="md-nav__link">
    COPY
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-aggregate" class="md-nav__link">
    CREATE AGGREGATE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-cast" class="md-nav__link">
    CREATE CAST
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-database" class="md-nav__link">
    CREATE DATABASE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-domain" class="md-nav__link">
    CREATE DOMAIN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-extension" class="md-nav__link">
    CREATE EXTENSION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-foreign-data-wrapper" class="md-nav__link">
    CREATE FOREIGN DATA WRAPPER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-foreign-table" class="md-nav__link">
    CREATE FOREIGN TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-function" class="md-nav__link">
    CREATE FUNCTION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-group" class="md-nav__link">
    CREATE GROUP
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-index" class="md-nav__link">
    CREATE INDEX
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-materialized-view" class="md-nav__link">
    CREATE MATERIALIZED VIEW
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-operator" class="md-nav__link">
    CREATE OPERATOR
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-operator-class" class="md-nav__link">
    CREATE OPERATOR CLASS
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-policy" class="md-nav__link">
    CREATE POLICY
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-procedure" class="md-nav__link">
    CREATE PROCEDURE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-role" class="md-nav__link">
    CREATE ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-rule" class="md-nav__link">
    CREATE RULE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-schema" class="md-nav__link">
    CREATE SCHEMA
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-sequence" class="md-nav__link">
    CREATE SEQUENCE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-server" class="md-nav__link">
    CREATE SERVER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-table" class="md-nav__link">
    CREATE TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-table-as" class="md-nav__link">
    CREATE TABLE AS
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-trigger" class="md-nav__link">
    CREATE TRIGGER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-type" class="md-nav__link">
    CREATE TYPE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-user" class="md-nav__link">
    CREATE USER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-user-mapping" class="md-nav__link">
    CREATE USER MAPPING
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-view" class="md-nav__link">
    CREATE VIEW
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#deallocate" class="md-nav__link">
    DEALLOCATE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#declare" class="md-nav__link">
    DECLARE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delete" class="md-nav__link">
    DELETE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#do" class="md-nav__link">
    DO
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-aggregate" class="md-nav__link">
    DROP AGGREGATE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-cast" class="md-nav__link">
    DROP CAST
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-database" class="md-nav__link">
    DROP DATABASE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-domain" class="md-nav__link">
    DROP DOMAIN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-extension" class="md-nav__link">
    DROP EXTENSION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-foreign-data-wrapper" class="md-nav__link">
    DROP FOREIGN DATA WRAPPER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-foreign-table" class="md-nav__link">
    DROP FOREIGN TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-function" class="md-nav__link">
    DROP FUNCTION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-group" class="md-nav__link">
    DROP GROUP
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-index" class="md-nav__link">
    DROP INDEX
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-materialized-view" class="md-nav__link">
    DROP MATERIALIZED VIEW
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-operator" class="md-nav__link">
    DROP OPERATOR
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-operator-class" class="md-nav__link">
    DROP OPERATOR CLASS
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-owned" class="md-nav__link">
    DROP OWNED
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-policy" class="md-nav__link">
    DROP POLICY
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-procedure" class="md-nav__link">
    DROP PROCEDURE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-role" class="md-nav__link">
    DROP ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-rule" class="md-nav__link">
    DROP RULE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-schema" class="md-nav__link">
    DROP SCHEMA
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-sequence" class="md-nav__link">
    DROP SEQUENCE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-server" class="md-nav__link">
    DROP SERVER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-table" class="md-nav__link">
    DROP TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-trigger" class="md-nav__link">
    DROP TRIGGER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-type" class="md-nav__link">
    DROP TYPE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-user" class="md-nav__link">
    DROP USER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#end" class="md-nav__link">
    END
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#execute" class="md-nav__link">
    EXECUTE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#explain" class="md-nav__link">
    EXPLAIN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fetch" class="md-nav__link">
    FETCH
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grant" class="md-nav__link">
    GRANT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#import-foreign-schema" class="md-nav__link">
    IMPORT FOREIGN SCHEMA
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#insert" class="md-nav__link">
    INSERT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lock" class="md-nav__link">
    LOCK
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#move" class="md-nav__link">
    MOVE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prepare" class="md-nav__link">
    PREPARE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reassign-owned" class="md-nav__link">
    REASSIGN OWNED
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#refresh-materialized-view" class="md-nav__link">
    REFRESH MATERIALIZED VIEW
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#release-savepoint" class="md-nav__link">
    RELEASE SAVEPOINT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reset" class="md-nav__link">
    RESET
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#revoke" class="md-nav__link">
    REVOKE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rollback" class="md-nav__link">
    ROLLBACK
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rollback-to-savepoint" class="md-nav__link">
    ROLLBACK TO SAVEPOINT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#savepoint" class="md-nav__link">
    SAVEPOINT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#select" class="md-nav__link">
    SELECT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set" class="md-nav__link">
    SET
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set-constraints" class="md-nav__link">
    SET CONSTRAINTS
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set-role" class="md-nav__link">
    SET ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set-session-authorization" class="md-nav__link">
    SET SESSION AUTHORIZATION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set-transaction" class="md-nav__link">
    SET TRANSACTION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show" class="md-nav__link">
    SHOW
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show-transaction" class="md-nav__link">
    SHOW TRANSACTION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#start-transaction" class="md-nav__link">
    START TRANSACTION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#truncate" class="md-nav__link">
    TRUNCATE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#update" class="md-nav__link">
    UPDATE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#values" class="md-nav__link">
    VALUES
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_192" class="md-nav__link">
    内置函数和运算符
  </a>
  
    <nav class="md-nav" aria-label="内置函数和运算符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_193" class="md-nav__link">
    逻辑操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_194" class="md-nav__link">
    比较函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="比较函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_195" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_196" class="md-nav__link">
    比较谓词
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_197" class="md-nav__link">
    比较函数
  </a>
  
    <nav class="md-nav" aria-label="比较函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#num_nonnulls" class="md-nav__link">
    num_nonnulls()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#num_nulls" class="md-nav__link">
    num_nulls()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_198" class="md-nav__link">
    数学函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="数学函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_199" class="md-nav__link">
    数学操作符
  </a>
  
    <nav class="md-nav" aria-label="数学操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_200" class="md-nav__link">
    +
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_201" class="md-nav__link">
    +
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_16" class="md-nav__link">
    -
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_17" class="md-nav__link">
    -
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_202" class="md-nav__link">
    *
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_203" class="md-nav__link">
    /
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_204" class="md-nav__link">
    %
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_205" class="md-nav__link">
    ^
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_206" class="md-nav__link">
    |/
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_207" class="md-nav__link">
    ||/
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_208" class="md-nav__link">
    !
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_209" class="md-nav__link">
    !!
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_210" class="md-nav__link">
    @
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_211" class="md-nav__link">
    &amp;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_212" class="md-nav__link">
    |
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_213" class="md-nav__link">
    #
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_214" class="md-nav__link">
    ~
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_215" class="md-nav__link">
    &lt;&lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_216" class="md-nav__link">
    &gt;&gt;
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_217" class="md-nav__link">
    数学函数
  </a>
  
    <nav class="md-nav" aria-label="数学函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#abs" class="md-nav__link">
    abs()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cbrt" class="md-nav__link">
    cbrt()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ceil" class="md-nav__link">
    ceil()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ceiling" class="md-nav__link">
    ceiling()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#degrees" class="md-nav__link">
    degrees()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#div" class="md-nav__link">
    div()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exp" class="md-nav__link">
    exp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#factorial" class="md-nav__link">
    factorial()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#floor" class="md-nav__link">
    floor()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ln" class="md-nav__link">
    ln()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#log" class="md-nav__link">
    log()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#log_1" class="md-nav__link">
    log()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mod" class="md-nav__link">
    mod()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pi" class="md-nav__link">
    pi()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#power" class="md-nav__link">
    power()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#radians" class="md-nav__link">
    radians()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#round" class="md-nav__link">
    round()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#round_1" class="md-nav__link">
    round()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scale" class="md-nav__link">
    scale()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sign" class="md-nav__link">
    sign()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sqrt" class="md-nav__link">
    sqrt()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trunc" class="md-nav__link">
    trunc()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trunc_1" class="md-nav__link">
    trunc()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#width_bucket" class="md-nav__link">
    width_bucket()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#width_bucket_1" class="md-nav__link">
    width_bucket()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_218" class="md-nav__link">
    随机函数
  </a>
  
    <nav class="md-nav" aria-label="随机函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#random" class="md-nav__link">
    random()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#setseed" class="md-nav__link">
    setseed()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_219" class="md-nav__link">
    三角函数
  </a>
  
    <nav class="md-nav" aria-label="三角函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#acos" class="md-nav__link">
    acos()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#acosd" class="md-nav__link">
    acosd()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asin" class="md-nav__link">
    asin()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asind" class="md-nav__link">
    asind()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#atan" class="md-nav__link">
    atan()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#atand" class="md-nav__link">
    atand()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#atan2" class="md-nav__link">
    atan2()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#atan2d" class="md-nav__link">
    atan2d()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cos" class="md-nav__link">
    cos()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cosd" class="md-nav__link">
    cosd()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cot" class="md-nav__link">
    cot()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cotd" class="md-nav__link">
    cotd()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sin" class="md-nav__link">
    sin()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sind" class="md-nav__link">
    sind()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tan" class="md-nav__link">
    tan()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tand" class="md-nav__link">
    tand()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_220" class="md-nav__link">
    数据类型格式化函数
  </a>
  
    <nav class="md-nav" aria-label="数据类型格式化函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_221" class="md-nav__link">
    格式化函数
  </a>
  
    <nav class="md-nav" aria-label="格式化函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#to_char_1" class="md-nav__link">
    to_char()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_char_2" class="md-nav__link">
    to_char()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_char_3" class="md-nav__link">
    to_char()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_date_1" class="md-nav__link">
    to_date()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_number" class="md-nav__link">
    to_number()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_timestamp_2" class="md-nav__link">
    to_timestamp()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_222" class="md-nav__link">
    模板模式
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_223" class="md-nav__link">
    模式匹配
  </a>
  
    <nav class="md-nav" aria-label="模式匹配">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#like" class="md-nav__link">
    LIKE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#similar-to" class="md-nav__link">
    SIMILAR TO正则表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#posix" class="md-nav__link">
    POSIX正则表达式
  </a>
  
    <nav class="md-nav" aria-label="POSIX正则表达式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_224" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_225" class="md-nav__link">
    # ~
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_226" class="md-nav__link">
    # ~*
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_227" class="md-nav__link">
    # !~
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_228" class="md-nav__link">
    # !~*
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_229" class="md-nav__link">
    函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_replace_1" class="md-nav__link">
    # regexp_replace
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_match_1" class="md-nav__link">
    # regexp_match
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_matches_1" class="md-nav__link">
    # regexp_matches
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_split_to_table_1" class="md-nav__link">
    # regexp_split_to_table
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_split_to_array_1" class="md-nav__link">
    # regexp_split_to_array
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_230" class="md-nav__link">
    正则表达式细节
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_231" class="md-nav__link">
    方括号表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_232" class="md-nav__link">
    正则表达式逃逸
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_233" class="md-nav__link">
    正则表达式元语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_234" class="md-nav__link">
    正则表达式匹配规则
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_235" class="md-nav__link">
    条件表达式
  </a>
  
    <nav class="md-nav" aria-label="条件表达式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#case" class="md-nav__link">
    CASE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coalesce" class="md-nav__link">
    COALESCE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nullif" class="md-nav__link">
    NULLIF
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#greatestleast" class="md-nav__link">
    GREATEST和LEAST
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_236" class="md-nav__link">
    子查询表达式
  </a>
  
    <nav class="md-nav" aria-label="子查询表达式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#exists" class="md-nav__link">
    EXISTS
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#in" class="md-nav__link">
    IN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#not-in" class="md-nav__link">
    NOT IN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#anysome" class="md-nav__link">
    ANY/SOME
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#all" class="md-nav__link">
    ALL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_237" class="md-nav__link">
    单一行比较
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_238" class="md-nav__link">
    行和数组比较
  </a>
  
    <nav class="md-nav" aria-label="行和数组比较">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#in_1" class="md-nav__link">
    IN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#not-in_1" class="md-nav__link">
    NOT IN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#anysome-array" class="md-nav__link">
    ANY/SOME (array)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#all-array" class="md-nav__link">
    ALL (array)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_239" class="md-nav__link">
    行构造器比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_240" class="md-nav__link">
    组合类型比较
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_241" class="md-nav__link">
    集合返回函数
  </a>
  
    <nav class="md-nav" aria-label="集合返回函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_242" class="md-nav__link">
    系列生成函数
  </a>
  
    <nav class="md-nav" aria-label="系列生成函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#generate_series" class="md-nav__link">
    generate_series()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generate_series_1" class="md-nav__link">
    generate_series()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generate_series_2" class="md-nav__link">
    generate_series()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_243" class="md-nav__link">
    下标生成函数
  </a>
  
    <nav class="md-nav" aria-label="下标生成函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#generate_subscripts_1" class="md-nav__link">
    generate_subscripts()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generate_subscripts_2" class="md-nav__link">
    generate_subscripts()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_244" class="md-nav__link">
    窗口函数
  </a>
  
    <nav class="md-nav" aria-label="窗口函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_245" class="md-nav__link">
    特性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_246" class="md-nav__link">
    窗口函数语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_247" class="md-nav__link">
    通用窗口函数
  </a>
  
    <nav class="md-nav" aria-label="通用窗口函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#row_number" class="md-nav__link">
    row_number()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rank" class="md-nav__link">
    rank()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dense_rank" class="md-nav__link">
    dense_rank()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#percent_rank" class="md-nav__link">
    percent_rank()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cume_dist" class="md-nav__link">
    cume_dist()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ntile" class="md-nav__link">
    ntile()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lag" class="md-nav__link">
    lag()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lead" class="md-nav__link">
    lead()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#first_value" class="md-nav__link">
    first_value()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#last_value" class="md-nav__link">
    last_value()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nth_value" class="md-nav__link">
    nth_value()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_248" class="md-nav__link">
    示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_249" class="md-nav__link">
    聚集函数
  </a>
  
    <nav class="md-nav" aria-label="聚集函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_250" class="md-nav__link">
    通用聚集函数
  </a>
  
    <nav class="md-nav" aria-label="通用聚集函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#avg-count-max-min-sum" class="md-nav__link">
    avg() , count(), max(), min(), sum()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avg" class="md-nav__link">
    # avg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#count" class="md-nav__link">
    # count()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#max" class="md-nav__link">
    # max()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#min" class="md-nav__link">
    # min()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sum" class="md-nav__link">
    # sum()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_251" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by" class="md-nav__link">
    ## GROUP BY 语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#over" class="md-nav__link">
    ## OVER 语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit_and-bit_or-bool_and-bool_or-every" class="md-nav__link">
    bit_and(), bit_or(), bool_and(), bool_or(), every()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit_and" class="md-nav__link">
    # bit_and()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit_or" class="md-nav__link">
    # bit_or()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bool_and" class="md-nav__link">
    # bool_and()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bool_or" class="md-nav__link">
    # bool_or()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#every" class="md-nav__link">
    # every()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_252" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by_1" class="md-nav__link">
    ## GROUP BY 语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#over_1" class="md-nav__link">
    ## OVER 语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_agg-string_agg-jsonb_agg-jsonb_object_agg" class="md-nav__link">
    array_agg(), string_agg(), jsonb_agg(), jsonb_object_agg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_agg_3" class="md-nav__link">
    # array_agg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_agg_1" class="md-nav__link">
    # jsonb_agg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_object_agg_1" class="md-nav__link">
    #  jsonb_object_agg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#string_agg" class="md-nav__link">
    # string_agg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_253" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by_2" class="md-nav__link">
    ## GROUP BY 语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#over_2" class="md-nav__link">
    ## OVER 语法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_254" class="md-nav__link">
    统计性聚集函数
  </a>
  
    <nav class="md-nav" aria-label="统计性聚集函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#covar_pop-covar_samp-corr" class="md-nav__link">
    covar_pop(), covar_samp(), corr()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#covar_pop" class="md-nav__link">
    # covar_pop()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#covar_samp" class="md-nav__link">
    # covar_samp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#corr" class="md-nav__link">
    # corr()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_255" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_" class="md-nav__link">
    regr_%()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_avgy" class="md-nav__link">
    # regr_avgy()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_avgx" class="md-nav__link">
    # regr_avgx()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_count" class="md-nav__link">
    # regr_count()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_slope" class="md-nav__link">
    # regr_slope()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_intercept" class="md-nav__link">
    # regr_intercept()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_r2" class="md-nav__link">
    # regr_r2()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_syy" class="md-nav__link">
    # regr_syy()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_sxx" class="md-nav__link">
    # regr_sxx()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_sxy" class="md-nav__link">
    # regr_sxy()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_256" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#variance-var_pop-var_samp-stddev-stddev_pop-stddev_samp" class="md-nav__link">
    variance(), var_pop(), var_samp(), stddev(), stddev_pop(), stddev_samp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#variance" class="md-nav__link">
    # variance()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#var_pop" class="md-nav__link">
    # var_pop
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#var_samp" class="md-nav__link">
    # var_samp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stddev" class="md-nav__link">
    # stddev()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stddev_pop" class="md-nav__link">
    # stddev_pop()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stddev_samp" class="md-nav__link">
    # stddev_samp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_257" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by_3" class="md-nav__link">
    ## GROUP BY 语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#over_3" class="md-nav__link">
    ## OVER 语法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_258" class="md-nav__link">
    组内有序集合聚合函数
  </a>
  
    <nav class="md-nav" aria-label="组内有序集合聚合函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mode" class="md-nav__link">
    # mode()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by_4" class="md-nav__link">
    ## 无GROUP BY的示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by_5" class="md-nav__link">
    ## 使用GROUP BY的示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#percentile_disc-percentile_cont" class="md-nav__link">
    # percentile_disc() ， percentile_cont()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_259" class="md-nav__link">
    ## 使用标量重载的基本示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by_6" class="md-nav__link">
    ## 使用GROUP BY的标量重载的基本示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_260" class="md-nav__link">
    ## 中值确定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_261" class="md-nav__link">
    ## 使用数组重载的示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_262" class="md-nav__link">
    系统信息函数和运算符
  </a>
  
    <nav class="md-nav" aria-label="系统信息函数和运算符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_263" class="md-nav__link">
    会话信息函数
  </a>
  
    <nav class="md-nav" aria-label="会话信息函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#current_catalog" class="md-nav__link">
    current_catalog
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_database" class="md-nav__link">
    current_database()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_query" class="md-nav__link">
    current_query()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_role" class="md-nav__link">
    current_role
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_schema" class="md-nav__link">
    current_schema[()]
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_schemas" class="md-nav__link">
    current_schemas()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_user" class="md-nav__link">
    current_user
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inet_client_addr" class="md-nav__link">
    inet_client_addr()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inet_client_port" class="md-nav__link">
    inet_client_port()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inet_server_addr" class="md-nav__link">
    inet_server_addr()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inet_server_port" class="md-nav__link">
    inet_server_port()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_backend_pid" class="md-nav__link">
    pg_backend_pid()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_blocking_pids" class="md-nav__link">
    pg_blocking_pids()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_conf_load_time" class="md-nav__link">
    pg_conf_load_time()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_current_logfile" class="md-nav__link">
    pg_current_logfile()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_my_temp_schema" class="md-nav__link">
    pg_my_temp_schema()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_is_other_temp_schema" class="md-nav__link">
    pg_is_other_temp_schema()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_jit_available" class="md-nav__link">
    pg_jit_available()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_listening_channels" class="md-nav__link">
    pg_listening_channels()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_notification_queue_usage" class="md-nav__link">
    pg_notification_queue_usage()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_postmaster_start_time" class="md-nav__link">
    pg_postmaster_start_time()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_safe_snapshot_blocking_pids" class="md-nav__link">
    pg_safe_snapshot_blocking_pids()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_trigger_depth" class="md-nav__link">
    pg_trigger_depth()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#session_user" class="md-nav__link">
    session_user
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#user" class="md-nav__link">
    user
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#version" class="md-nav__link">
    version()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_264" class="md-nav__link">
    访问权限查询函数
  </a>
  
    <nav class="md-nav" aria-label="访问权限查询函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#has_any_column_privilege" class="md-nav__link">
    has_any_column_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_column_privilege" class="md-nav__link">
    has_column_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_database_privilege" class="md-nav__link">
    has_database_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_foreign_data_wrapper_privilege" class="md-nav__link">
    has_foreign_data_wrapper_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_function_privilege" class="md-nav__link">
    has_function_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_language_privilege" class="md-nav__link">
    has_language_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_schema_privilege" class="md-nav__link">
    has_schema_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_sequence_privilege" class="md-nav__link">
    has_sequence_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_server_privilege" class="md-nav__link">
    has_server_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_table_privilege" class="md-nav__link">
    has_table_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_tablespace_privilege" class="md-nav__link">
    has_tablespace_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_type_privilege" class="md-nav__link">
    has_type_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_has_role" class="md-nav__link">
    pg_has_role()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#row_security_active" class="md-nav__link">
    row_security_active()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aclitem" class="md-nav__link">
    aclitem 操作符
  </a>
  
    <nav class="md-nav" aria-label="aclitem 操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_265" class="md-nav__link">
    =
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_266" class="md-nav__link">
    @&gt;
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aclitem_1" class="md-nav__link">
    aclitem 函数
  </a>
  
    <nav class="md-nav" aria-label="aclitem 函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#acldefault" class="md-nav__link">
    acldefault()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aclexplode" class="md-nav__link">
    aclexplode()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#makeaclitem" class="md-nav__link">
    makeaclitem()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_267" class="md-nav__link">
    模式可见性查询函数
  </a>
  
    <nav class="md-nav" aria-label="模式可见性查询函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pg_collation_is_visible" class="md-nav__link">
    pg_collation_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_conversion_is_visible" class="md-nav__link">
    pg_conversion_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_function_is_visible" class="md-nav__link">
    pg_function_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_opclass_is_visible" class="md-nav__link">
    pg_opclass_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_operator_is_visible" class="md-nav__link">
    pg_operator_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_opfamily_is_visible" class="md-nav__link">
    pg_opfamily_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statistics_obj_is_visible" class="md-nav__link">
    pg_statistics_obj_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_table_is_visible" class="md-nav__link">
    pg_table_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_config_is_visible" class="md-nav__link">
    pg_ts_config_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_dict_is_visible" class="md-nav__link">
    pg_ts_dict_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_parser_is_visible" class="md-nav__link">
    pg_ts_parser_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_template_is_visible" class="md-nav__link">
    pg_ts_template_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_type_is_visible" class="md-nav__link">
    pg_type_is_visible()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_268" class="md-nav__link">
    系统目录信息函数
  </a>
  
    <nav class="md-nav" aria-label="系统目录信息函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#format_type" class="md-nav__link">
    format_type()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_get_constraintdef" class="md-nav__link">
    pg_get_constraintdef()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_269" class="md-nav__link">
    关键词
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_270" class="md-nav__link">
    保留名称
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_271" class="md-nav__link">
    系统表/视图
  </a>
  
    <nav class="md-nav" aria-label="系统表/视图">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pg_aggregate" class="md-nav__link">
    pg_aggregate
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_am" class="md-nav__link">
    pg_am
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_amop" class="md-nav__link">
    pg_amop
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_amproc" class="md-nav__link">
    pg_amproc
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_attrdef" class="md-nav__link">
    pg_attrdef
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_attribute" class="md-nav__link">
    pg_attribute
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_auth_members" class="md-nav__link">
    pg_auth_members
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_authid" class="md-nav__link">
    pg_authid
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_available_extension_versions" class="md-nav__link">
    pg_available_extension_versions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_available_extensions" class="md-nav__link">
    pg_available_extensions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_backend_memory_contexts" class="md-nav__link">
    pg_backend_memory_contexts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_bm_catalog_version" class="md-nav__link">
    pg_bm_catalog_version
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_bm_migration" class="md-nav__link">
    pg_bm_migration
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_bm_profile" class="md-nav__link">
    pg_bm_profile
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_bm_role_profile" class="md-nav__link">
    pg_bm_role_profile
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_bm_tablegroup" class="md-nav__link">
    pg_bm_tablegroup
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_cast" class="md-nav__link">
    pg_cast
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_class" class="md-nav__link">
    pg_class
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_collation" class="md-nav__link">
    pg_collation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_config" class="md-nav__link">
    pg_config
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_constraint" class="md-nav__link">
    pg_constraint
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_conversion" class="md-nav__link">
    pg_conversion
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_cursors" class="md-nav__link">
    pg_cursors
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_database" class="md-nav__link">
    pg_database
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_db_role_setting" class="md-nav__link">
    pg_db_role_setting
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_default_acl" class="md-nav__link">
    pg_default_acl
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_depend" class="md-nav__link">
    pg_depend
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_description" class="md-nav__link">
    pg_description
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_enum" class="md-nav__link">
    pg_enum
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_event_trigger" class="md-nav__link">
    pg_event_trigger
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_extension" class="md-nav__link">
    pg_extension
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_file_settings" class="md-nav__link">
    pg_file_settings
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_foreign_data_wrapper" class="md-nav__link">
    pg_foreign_data_wrapper
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_foreign_server" class="md-nav__link">
    pg_foreign_server
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_foreign_table" class="md-nav__link">
    pg_foreign_table
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_group" class="md-nav__link">
    pg_group
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_hba_file_rules" class="md-nav__link">
    pg_hba_file_rules
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_index" class="md-nav__link">
    pg_index
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_indexes" class="md-nav__link">
    pg_indexes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_inherits" class="md-nav__link">
    pg_inherits
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_init_privs" class="md-nav__link">
    pg_init_privs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_language" class="md-nav__link">
    pg_language
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_largeobject" class="md-nav__link">
    pg_largeobject
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_largeobject_metadata" class="md-nav__link">
    pg_largeobject_metadata
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_locks" class="md-nav__link">
    pg_locks
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_matviews" class="md-nav__link">
    pg_matviews
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_namespace" class="md-nav__link">
    pg_namespace
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_opclass" class="md-nav__link">
    pg_opclass
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_operator" class="md-nav__link">
    pg_operator
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_opfamily" class="md-nav__link">
    pg_opfamily
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_partitioned_table" class="md-nav__link">
    pg_partitioned_table
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_pltemplate" class="md-nav__link">
    pg_pltemplate
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_policies" class="md-nav__link">
    pg_policies
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_policy" class="md-nav__link">
    pg_policy
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_prepared_statements" class="md-nav__link">
    pg_prepared_statements
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_prepared_xacts" class="md-nav__link">
    pg_prepared_xacts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_proc" class="md-nav__link">
    pg_proc
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_publication" class="md-nav__link">
    pg_publication
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_publication_rel" class="md-nav__link">
    pg_publication_rel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_publication_tables" class="md-nav__link">
    pg_publication_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_range" class="md-nav__link">
    pg_range
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_replication_origin" class="md-nav__link">
    pg_replication_origin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_replication_origin_status" class="md-nav__link">
    pg_replication_origin_status
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_replication_slots" class="md-nav__link">
    pg_replication_slots
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_rewrite" class="md-nav__link">
    pg_rewrite
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_roles" class="md-nav__link">
    pg_roles
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_rules" class="md-nav__link">
    pg_rules
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_seclabel" class="md-nav__link">
    pg_seclabel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_seclabels" class="md-nav__link">
    pg_seclabels
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_sequence" class="md-nav__link">
    pg_sequence
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_sequences" class="md-nav__link">
    pg_sequences
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_settings" class="md-nav__link">
    pg_settings
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_shadow" class="md-nav__link">
    pg_shadow
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_shdepend" class="md-nav__link">
    pg_shdepend
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_shdescription" class="md-nav__link">
    pg_shdescription
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_shseclabel" class="md-nav__link">
    pg_shseclabel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_activity" class="md-nav__link">
    pg_stat_activity
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_all_indexes" class="md-nav__link">
    pg_stat_all_indexes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_all_tables" class="md-nav__link">
    pg_stat_all_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_archiver" class="md-nav__link">
    pg_stat_archiver
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_bgwriter" class="md-nav__link">
    pg_stat_bgwriter
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_database" class="md-nav__link">
    pg_stat_database
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_database_conflicts" class="md-nav__link">
    pg_stat_database_conflicts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_progress_copy" class="md-nav__link">
    pg_stat_progress_copy
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_progress_create_index" class="md-nav__link">
    pg_stat_progress_create_index
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_progress_vacuum" class="md-nav__link">
    pg_stat_progress_vacuum
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_replication" class="md-nav__link">
    pg_stat_replication
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_ssl" class="md-nav__link">
    pg_stat_ssl
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_statements" class="md-nav__link">
    pg_stat_statements
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_subscription" class="md-nav__link">
    pg_stat_subscription
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_sys_indexes" class="md-nav__link">
    pg_stat_sys_indexes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_sys_tables" class="md-nav__link">
    pg_stat_sys_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_user_functions" class="md-nav__link">
    pg_stat_user_functions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_user_indexes" class="md-nav__link">
    pg_stat_user_indexes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_user_tables" class="md-nav__link">
    pg_stat_user_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_wal_receiver" class="md-nav__link">
    pg_stat_wal_receiver
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_xact_all_tables" class="md-nav__link">
    pg_stat_xact_all_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_xact_sys_tables" class="md-nav__link">
    pg_stat_xact_sys_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_xact_user_functions" class="md-nav__link">
    pg_stat_xact_user_functions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_xact_user_tables" class="md-nav__link">
    pg_stat_xact_user_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_all_indexes" class="md-nav__link">
    pg_statio_all_indexes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_all_sequences" class="md-nav__link">
    pg_statio_all_sequences
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_all_tables" class="md-nav__link">
    pg_statio_all_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_sys_indexes" class="md-nav__link">
    pg_statio_sys_indexes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_sys_sequences" class="md-nav__link">
    pg_statio_sys_sequences
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_sys_tables" class="md-nav__link">
    pg_statio_sys_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_user_indexes" class="md-nav__link">
    pg_statio_user_indexes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_user_sequences" class="md-nav__link">
    pg_statio_user_sequences
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_user_tables" class="md-nav__link">
    pg_statio_user_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statistic" class="md-nav__link">
    pg_statistic
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statistic_ext" class="md-nav__link">
    pg_statistic_ext
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stats" class="md-nav__link">
    pg_stats
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_subscription" class="md-nav__link">
    pg_subscription
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_subscription_rel" class="md-nav__link">
    pg_subscription_rel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_tables" class="md-nav__link">
    pg_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_tablespace" class="md-nav__link">
    pg_tablespace
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_timezone_abbrevs" class="md-nav__link">
    pg_timezone_abbrevs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_timezone_names" class="md-nav__link">
    pg_timezone_names
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_transform" class="md-nav__link">
    pg_transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_trigger" class="md-nav__link">
    pg_trigger
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_config" class="md-nav__link">
    pg_ts_config
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_config_map" class="md-nav__link">
    pg_ts_config_map
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_dict" class="md-nav__link">
    pg_ts_dict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_parser" class="md-nav__link">
    pg_ts_parser
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_template" class="md-nav__link">
    pg_ts_template
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_type" class="md-nav__link">
    pg_type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_user" class="md-nav__link">
    pg_user
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_user_mapping" class="md-nav__link">
    pg_user_mapping
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_user_mappings" class="md-nav__link">
    pg_user_mappings
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_views" class="md-nav__link">
    pg_views
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../09.5-BCQL/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BCQL
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#bsql" class="md-nav__link">
    BSQL
  </a>
  
    <nav class="md-nav" aria-label="BSQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    数据类型
  </a>
  
    <nav class="md-nav" aria-label="数据类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#array" class="md-nav__link">
    数组（array）
  </a>
  
    <nav class="md-nav" aria-label="数组（array）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    概要
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nullnull" class="md-nav__link">
    # 原子为Null与所有值为Null的对比
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    # 类型构造
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    # 数组应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    # 数组应用示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_1" class="md-nav__link">
    array[]构造函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    # 用途与用法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#plpgsqlarray" class="md-nav__link">
    # 在PL/pgSQL代码中使用array[]构造函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_2" class="md-nav__link">
    # 在准备好的语句中使用array[]构造函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    常量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    # 值文本类型转换、该值的文本文字，以及它们之间的关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    ## 值到文本的类型转换和返回值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsqlsh" class="md-nav__link">
    ## 布尔值显示在bsqlsh中的特殊文本形式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#text" class="md-nav__link">
    ## 值的text类型转换与创建该值的文字之间的关系
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    ## 定义“文字的规范形式”
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    基础值数字文字文本
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    # 规则声明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    # 以规范形式写入数组文本文字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    # 举例说明规则
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#int" class="md-nav__link">
    ## int值的一维数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#text_1" class="md-nav__link">
    ## 一维text值数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#timestamp" class="md-nav__link">
    ## 一维timestamp值数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#booleannull" class="md-nav__link">
    ## 一维Boolean值数组（通常为NULL）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#int_1" class="md-nav__link">
    ## int值的多维数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#row" class="md-nav__link">
    “row”类型值的文本文字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    # 规则声明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#introw" class="md-nav__link">
    ## int字段的“row”类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#textrow" class="md-nav__link">
    ## text字段的“row”类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#timestamprow" class="md-nav__link">
    ## timestamp字段的“row”类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#booleanrow" class="md-nav__link">
    ## boolean字段的“row”类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rowrow" class="md-nav__link">
    # “Row”类型的文本文字与“Row”类型的构造函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#row_1" class="md-nav__link">
    “row”类型值数组的文本文字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    # 规则声明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#row_2" class="md-nav__link">
    # 用于为“row”类型值的一维数组生成文字的伪代码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#plpgsql" class="md-nav__link">
    PL/pgSQL中的数组循环
  </a>
  
    <nav class="md-nav" aria-label="PL/pgSQL中的数组循环">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    语法和语义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#slice" class="md-nav__link">
    在不带SLICE关键字的数组中循环使用值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#slice_1" class="md-nav__link">
    非零SLICE操作数在多维数组的内容上循环
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#foreachdomain" class="md-nav__link">
    使用FOREACH迭代DOMAIN值数组中的元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#plpgsqlslice" class="md-nav__link">
    使用包装PL/pgSQL表函数将SLICE操作数公开为形式参数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#domain" class="md-nav__link">
    使用DOMAIN值数组
  </a>
  
    <nav class="md-nav" aria-label="使用DOMAIN值数组">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#gps" class="md-nav__link">
    示例：GPS行程数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    创建不规则数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    # 矛盾
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    # 解决方案
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    # 处理数组的不规则数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#foreachdomains" class="md-nav__link">
    # 将FOREACH与DOMAINs数组结合使用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_aggdomain" class="md-nav__link">
    # 使用array_agg()生成DOMAIN值数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    创建矩阵
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    # 定义需要的数据类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#block_matrix_tdomain" class="md-nav__link">
    # 使用“block_matrix_t”DOMAIN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unnest" class="md-nav__link">
    # 对数组使用unnest()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    数组函数和运算符
  </a>
  
    <nav class="md-nav" aria-label="数组函数和运算符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    创建函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_fill" class="md-nav__link">
    # array_fill()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_agg" class="md-nav__link">
    # array_agg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_agg_1" class="md-nav__link">
    ## array_agg() 重载函数一
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_agg_2" class="md-nav__link">
    ## array_agg() 重载函数二
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#string_to_array" class="md-nav__link">
    # string_to_array()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    几何函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_ndims" class="md-nav__link">
    # array_ndims()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_lower" class="md-nav__link">
    # array_lower()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_upper" class="md-nav__link">
    # array_upper()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_length" class="md-nav__link">
    # array_length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cardinality" class="md-nav__link">
    # cardinality()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_dims" class="md-nav__link">
    # array_dims()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    查找函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_position" class="md-nav__link">
    # array_position()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_positions" class="md-nav__link">
    # array_positions()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#anyall" class="md-nav__link">
    ANY/ALL运算符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#any-all" class="md-nav__link">
    # ANY 和 ALL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    ## 概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    ## 用途
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    ## 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    比较运算符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    # 概述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    切片运算符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#slice_2" class="md-nav__link">
    # slice运算符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    连接函数和运算符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_cat" class="md-nav__link">
    # array_cat()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_append" class="md-nav__link">
    # array_append()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_prepend" class="md-nav__link">
    # array_prepend()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    更改函数和运算符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_replace" class="md-nav__link">
    # array_replace()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#arridx_1idx_n-val" class="md-nav__link">
    # arr[idx_1]...[idx_N] := val
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_remove" class="md-nav__link">
    # array_remove()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    转换函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_to_string" class="md-nav__link">
    # array_to_string()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    表函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unnest_1" class="md-nav__link">
    # unnest()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unnest_2" class="md-nav__link">
    ## unnest() 重载函数一
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unnest_3" class="md-nav__link">
    ## unnest() 重载函数二
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generate_subscripts" class="md-nav__link">
    # generate_subscripts()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary" class="md-nav__link">
    Binary
  </a>
  
    <nav class="md-nav" aria-label="Binary">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#9412111" class="md-nav__link">
    # 9.4.1.2.1.1.1 ||
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit_length" class="md-nav__link">
    # bit_length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#octet_length" class="md-nav__link">
    # octet_length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#overlaystring-placing-string-from-int-for-int" class="md-nav__link">
    # overlay(string placing string from int [for int])
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#positionsubstring-in-string" class="md-nav__link">
    # position(substring in string)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#substringstring-from-int-for-int" class="md-nav__link">
    # substring(string [from int] [for int])
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trimboth-bytes-from-string" class="md-nav__link">
    # trim([both] bytes from string)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#btrim" class="md-nav__link">
    # btrim()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#decode" class="md-nav__link">
    # decode()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#encode" class="md-nav__link">
    # encode()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_bit" class="md-nav__link">
    # get_bit()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_byte" class="md-nav__link">
    # get_byte()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#length" class="md-nav__link">
    # length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#length_1" class="md-nav__link">
    # length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#md5" class="md-nav__link">
    # md5()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_bit" class="md-nav__link">
    # set_bit()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_byte" class="md-nav__link">
    # set_byte()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sha224" class="md-nav__link">
    # sha224()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sha256" class="md-nav__link">
    # sha256()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sha384" class="md-nav__link">
    # sha384()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sha512" class="md-nav__link">
    # sha512()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#substr" class="md-nav__link">
    # substr()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#boolean" class="md-nav__link">
    Boolean
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#character" class="md-nav__link">
    Character
  </a>
  
    <nav class="md-nav" aria-label="Character">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    操作符和函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#string-string" class="md-nav__link">
    # string || string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#string-non-string-or-non-string-string" class="md-nav__link">
    # string || non-string or non-string || string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit_length_1" class="md-nav__link">
    # bit_length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#char_length-character_length" class="md-nav__link">
    # char_length() 与 character_length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lower" class="md-nav__link">
    # lower()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#octet_length_1" class="md-nav__link">
    # octet_length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#overlaystring-placing-string-from-int-for-int_1" class="md-nav__link">
    # overlay(string placing string from int [for int])
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#positionsubstring-in-string_1" class="md-nav__link">
    # position(substring in string)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#substringstring-from-int-for-int_1" class="md-nav__link">
    # substring(string [from int] [for int])
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#substringstring-from-pattern" class="md-nav__link">
    # substring(string from pattern)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#substringstring-from-pattern-for-escape" class="md-nav__link">
    # substring(string from pattern for escape)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trimleading-trailing-both-characters-from-string" class="md-nav__link">
    # trim([leading | trailing | both] [characters] from string)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trimleading-trailing-both-from-string-characters" class="md-nav__link">
    # trim([leading | trailing | both] [from] string [, characters] )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upper" class="md-nav__link">
    # upper()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ascii" class="md-nav__link">
    # ascii()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#btrimstring-text-characters-text" class="md-nav__link">
    # btrim(string text [, characters text])
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#chr" class="md-nav__link">
    # chr()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#concat-val1-any-val2-any" class="md-nav__link">
    # concat ( val1 "any" [, val2 "any" [, ...] ] )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#concat_ws-sep-text-val1-any-val2-any" class="md-nav__link">
    # concat_ws ( sep text, val1 "any" [, val2 "any" [, ...] ] )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convert_tostring-text-dest_encoding-name" class="md-nav__link">
    # convert_to(string text, dest_encoding name)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#formatformatstr-text-formatarg-any" class="md-nav__link">
    # format(formatstr text [, formatarg "any" [, ...] ])
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#initcap" class="md-nav__link">
    # initcap()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#left" class="md-nav__link">
    # left()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#length_2" class="md-nav__link">
    # length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lpad" class="md-nav__link">
    # lpad()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ltrim" class="md-nav__link">
    # ltrim()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#md5_1" class="md-nav__link">
    # md5()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parse_ident-qualified_identifier-text-strict_mode-boolean-default-true" class="md-nav__link">
    # parse_ident ( qualified_identifier text [, strict_mode boolean DEFAULT true ] )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_client_encoding" class="md-nav__link">
    # pg_client_encoding()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quote_ident" class="md-nav__link">
    # quote_ident()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quote_literal" class="md-nav__link">
    # quote_literal()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quote_literal_1" class="md-nav__link">
    # quote_literal()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quote_nullable" class="md-nav__link">
    # quote_nullable()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quote_nullable_1" class="md-nav__link">
    # quote_nullable()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_match" class="md-nav__link">
    # regexp_match()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_matches" class="md-nav__link">
    # regexp_matches()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_replace" class="md-nav__link">
    # regexp_replace()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_split_to_array" class="md-nav__link">
    # regexp_split_to_array()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_split_to_table" class="md-nav__link">
    # regexp_split_to_table()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#repeat" class="md-nav__link">
    # repeat()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#replace" class="md-nav__link">
    # replace()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reverse" class="md-nav__link">
    # reverse()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#right" class="md-nav__link">
    # right()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rpad" class="md-nav__link">
    # rpad()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rtrim" class="md-nav__link">
    # rtrim()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#split_part" class="md-nav__link">
    # split_part()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#strpos" class="md-nav__link">
    # strpos()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#substr_1" class="md-nav__link">
    # substr()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#starts_with" class="md-nav__link">
    # starts_with()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_ascii" class="md-nav__link">
    # to_ascii()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_hex" class="md-nav__link">
    # to_hex()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#translate" class="md-nav__link">
    # translate()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#datetime" class="md-nav__link">
    date与time
  </a>
  
    <nav class="md-nav" aria-label="date与time">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    概要
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#date" class="md-nav__link">
    date
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#time" class="md-nav__link">
    time
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#utc" class="md-nav__link">
    时区和UTC偏移
  </a>
  
    <nav class="md-nav" aria-label="时区和UTC偏移">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    时区
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#utc_1" class="md-nav__link">
    UTC偏移
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#utc_2" class="md-nav__link">
    # 指定UTC偏移的四种方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#utc_3" class="md-nav__link">
    # 使用UTC偏移量的三个语法上下文
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#timestamptimestamptz" class="md-nav__link">
    timestamp与timestamptz
  </a>
  
    <nav class="md-nav" aria-label="timestamp与timestamptz">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#timestamp_1" class="md-nav__link">
    timestamp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#timestamptz" class="md-nav__link">
    timestamptz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    夏令时
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#interval" class="md-nav__link">
    interval
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    时间/日期函数
  </a>
  
    <nav class="md-nav" aria-label="时间/日期函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    创建函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make_date" class="md-nav__link">
    # make_date()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make_time" class="md-nav__link">
    # make_time()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make_timestamp" class="md-nav__link">
    # make_timestamp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make_timestamptz" class="md-nav__link">
    # make_timestamptz()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_timestamp" class="md-nav__link">
    # to_timestamp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#make_interval" class="md-nav__link">
    # make_interval()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    操作函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#date_trunc" class="md-nav__link">
    # date_trunc()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#justify_days" class="md-nav__link">
    # justify_days()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#justify_hours" class="md-nav__link">
    # justify_hours()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#justify_interval" class="md-nav__link">
    # justify_interval()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    当前日期/时间函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_date" class="md-nav__link">
    # current_date
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_time" class="md-nav__link">
    # current_time()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_timestamp" class="md-nav__link">
    # current_timestamp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#localtime" class="md-nav__link">
    # localtime()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#localtimestamp" class="md-nav__link">
    # localtimestamp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transaction_timestamp" class="md-nav__link">
    # transaction_timestamp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#now" class="md-nav__link">
    # now()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#statement_timestamp" class="md-nav__link">
    # statement_timestamp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clock_timestamp" class="md-nav__link">
    # clock_timestamp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#timeofday" class="md-nav__link">
    # timeofday()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    延时执行函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_sleep" class="md-nav__link">
    # pg_sleep()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_sleep_for" class="md-nav__link">
    # pg_sleep_for()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_sleep_until" class="md-nav__link">
    # pg_sleep_until()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    其它函数和操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#isfinite" class="md-nav__link">
    # isfinite()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#age" class="md-nav__link">
    # age()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#timezone" class="md-nav__link">
    # timezone()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#extract-date_part" class="md-nav__link">
    # extract() / date_part()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#overlaps" class="md-nav__link">
    # OVERLAPS
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    格式化函数
  </a>
  
    <nav class="md-nav" aria-label="格式化函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    格式化函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_char" class="md-nav__link">
    # to_char()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_date" class="md-nav__link">
    # to_date()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_timestamp_1" class="md-nav__link">
    # to_timestamp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    日期-时间模板模式
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json" class="md-nav__link">
    json
  </a>
  
    <nav class="md-nav" aria-label="json">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    基本与复合数据类型
  </a>
  
    <nav class="md-nav" aria-label="基本与复合数据类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#json_1" class="md-nav__link">
    JSON字符串
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_2" class="md-nav__link">
    JSON数字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_3" class="md-nav__link">
    JSON布尔型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json-null" class="md-nav__link">
    JSON null
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_4" class="md-nav__link">
    JSON对象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_5" class="md-nav__link">
    JSON数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_6" class="md-nav__link">
    复合JSON
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_7" class="md-nav__link">
    在JSON列上创建索引和检查约束
  </a>
  
    <nav class="md-nav" aria-label="在JSON列上创建索引和检查约束">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    创建检查约束
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    创建索引
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_8" class="md-nav__link">
    JSON函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="JSON函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sqljson" class="md-nav__link">
    转换SQL值到JSON值函数和操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb-json-text" class="md-nav__link">
    # ::jsonb和 ::json和 ::text
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_jsonb" class="md-nav__link">
    # to_jsonb()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#row_to_json" class="md-nav__link">
    # row_to_json()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_to_json" class="md-nav__link">
    # array_to_json()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_build_array" class="md-nav__link">
    # jsonb_build_array()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_build_object-json_build_object" class="md-nav__link">
    # jsonb_build_object() 和 json_build_object()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_object-json_object" class="md-nav__link">
    # jsonb_object() 和 json_object()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    ## 重载函数一
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    ## 重载函数二
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_63" class="md-nav__link">
    ## 重载函数三
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_agg" class="md-nav__link">
    # jsonb_agg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_object_agg" class="md-nav__link">
    # jsonb_object_agg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonjson" class="md-nav__link">
    转换JSON值到JSON值函数和操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_1" class="md-nav__link">
    # -&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_64" class="md-nav__link">
    # #&gt;
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_65" class="md-nav__link">
    &gt;运算符是一种方便的语法简写，用于紧凑地指定长路径，因此：
  </a>
  
    <nav class="md-nav" aria-label=">运算符是一种方便的语法简写，用于紧凑地指定长路径，因此：">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_66" class="md-nav__link">
    # ||
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_2" class="md-nav__link">
    # -
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_3" class="md-nav__link">
    # #-
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_extract_path-json_extract_path" class="md-nav__link">
    # jsonb_extract_path() 和 json_extract_path()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_strip_nulls-json_strip_nulls" class="md-nav__link">
    # jsonb_strip_nulls 和 json_strip_nulls
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_set" class="md-nav__link">
    # jsonb_set()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_insert" class="md-nav__link">
    # jsonb_insert()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonsql" class="md-nav__link">
    转换JSON值到SQL值函数和操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#text_2" class="md-nav__link">
    # ::text
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_4" class="md-nav__link">
    # -&gt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_67" class="md-nav__link">
    # #&gt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_extract_path_text-json_extract_path_text" class="md-nav__link">
    # jsonb_extract_path_text() 和 json_extract_path_text()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_populate_record-json_populate_record" class="md-nav__link">
    # jsonb_populate_record() 和 json_populate_record()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_populate_recordset-json_populate_recordset" class="md-nav__link">
    # jsonb_populate_recordset() 和 json_populate_recordset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_to_record-json_to_record" class="md-nav__link">
    # jsonb_to_record() 和 json_to_record()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_to_recordset-json_to_recordset" class="md-nav__link">
    # jsonb_to_recordset() 和 json_to_recordset()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_array_elements-json_array_elements" class="md-nav__link">
    # jsonb_array_elements() 和 json_array_elements()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_array_elements_text-json_array_elements_text" class="md-nav__link">
    # jsonb_array_elements_text() 和 json_array_elements_text()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_each-json_each" class="md-nav__link">
    # jsonb_each() 和 json_each()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_each_text-json_each_text" class="md-nav__link">
    # jsonb_each_text() 和 json_each_text()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_pretty" class="md-nav__link">
    # jsonb_pretty()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_9" class="md-nav__link">
    获取JSON值属性函数和操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_68" class="md-nav__link">
    # =
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_69" class="md-nav__link">
    # @&gt; 和 &lt;@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_70" class="md-nav__link">
    # ?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_71" class="md-nav__link">
    # ?|
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_72" class="md-nav__link">
    # ?&amp;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_array_length-json_array_length" class="md-nav__link">
    # jsonb_array_length() 和 json_array_length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_typeof-json_typeof" class="md-nav__link">
    # jsonb_typeof() 和 json_typeof()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_object_keys-json_object_keys" class="md-nav__link">
    # jsonb_object_keys() 和 json_object_keys()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#money" class="md-nav__link">
    Money
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_73" class="md-nav__link">
    数字类型
  </a>
  
    <nav class="md-nav" aria-label="数字类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#integers" class="md-nav__link">
    Integers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_74" class="md-nav__link">
    浮点类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_75" class="md-nav__link">
    任意精度数字
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_76" class="md-nav__link">
    范围类型
  </a>
  
    <nav class="md-nav" aria-label="范围类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bsql_1" class="md-nav__link">
    BSQL中的范围值
  </a>
  
    <nav class="md-nav" aria-label="BSQL中的范围值">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_77" class="md-nav__link">
    使用文字指定范围值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tsrange" class="md-nav__link">
    使用构造函数指定“tsrange”值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_78" class="md-nav__link">
    无界的范围
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_79" class="md-nav__link">
    对范围值和基础数据类型的值的操作
  </a>
  
    <nav class="md-nav" aria-label="对范围值和基础数据类型的值的操作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_80" class="md-nav__link">
    范围值是否为空
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_81" class="md-nav__link">
    两个范围值是否相交
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_82" class="md-nav__link">
    生成一个新的范围值作为两个范围值的交集
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_83" class="md-nav__link">
    是包含在范围内的范围的基础数据类型的值
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_84" class="md-nav__link">
    离散范围数据类型及其文字的规范形式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_85" class="md-nav__link">
    范围输入/输出
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_86" class="md-nav__link">
    函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_87" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_88" class="md-nav__link">
    # =
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_89" class="md-nav__link">
    # &lt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_90" class="md-nav__link">
    # &lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_91" class="md-nav__link">
    # &gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_92" class="md-nav__link">
    # &lt;=
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_93" class="md-nav__link">
    # &gt;=
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_94" class="md-nav__link">
    # @&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_95" class="md-nav__link">
    # @&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_96" class="md-nav__link">
    # &lt;@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_97" class="md-nav__link">
    # &lt;@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_98" class="md-nav__link">
    # &amp;&amp;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_99" class="md-nav__link">
    # &lt;&lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_100" class="md-nav__link">
    # &gt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_101" class="md-nav__link">
    # &amp;&lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_102" class="md-nav__link">
    # &amp;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_5" class="md-nav__link">
    # -|-
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_103" class="md-nav__link">
    # +
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_104" class="md-nav__link">
    # *
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_6" class="md-nav__link">
    # -
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_105" class="md-nav__link">
    函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lower_1" class="md-nav__link">
    # lower()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upper_1" class="md-nav__link">
    # upper()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#isempty" class="md-nav__link">
    # isempty()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lower_inc" class="md-nav__link">
    # lower_inc()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upper_inc" class="md-nav__link">
    # upper_inc()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lower_inf" class="md-nav__link">
    # lower_inf()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upper_inf" class="md-nav__link">
    # upper_inf()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#range_merge" class="md-nav__link">
    # range_merge()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#serial" class="md-nav__link">
    Serial
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#uuid" class="md-nav__link">
    UUID
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_106" class="md-nav__link">
    枚举类型
  </a>
  
    <nav class="md-nav" aria-label="枚举类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_107" class="md-nav__link">
    枚举类型的声明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_108" class="md-nav__link">
    排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_109" class="md-nav__link">
    类型安全性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_110" class="md-nav__link">
    函数
  </a>
  
    <nav class="md-nav" aria-label="函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#enum_first" class="md-nav__link">
    # enum_first()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enum_last" class="md-nav__link">
    # enum_last()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enum_range" class="md-nav__link">
    # enum_range()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enum_range_1" class="md-nav__link">
    # enum_range()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_111" class="md-nav__link">
    几何类型
  </a>
  
    <nav class="md-nav" aria-label="几何类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_112" class="md-nav__link">
    点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_113" class="md-nav__link">
    线
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_114" class="md-nav__link">
    线段
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_115" class="md-nav__link">
    矩形
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_116" class="md-nav__link">
    路径
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_117" class="md-nav__link">
    多边形
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_118" class="md-nav__link">
    圆
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_119" class="md-nav__link">
    函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_120" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_121" class="md-nav__link">
    # +
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_122" class="md-nav__link">
    # +
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_7" class="md-nav__link">
    # -
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_123" class="md-nav__link">
    # *
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_124" class="md-nav__link">
    # /
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_125" class="md-nav__link">
    #
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_126" class="md-nav__link">
    #
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_8" class="md-nav__link">
    # @-@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_127" class="md-nav__link">
    # @@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_128" class="md-nav__link">
    #
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_9" class="md-nav__link">
    # &lt;-&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_129" class="md-nav__link">
    # &amp;&amp;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_130" class="md-nav__link">
    # &lt;&lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_131" class="md-nav__link">
    # &gt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_132" class="md-nav__link">
    # &amp;&lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_133" class="md-nav__link">
    # &amp;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_134" class="md-nav__link">
    # &lt;&lt;|
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_135" class="md-nav__link">
    # |&gt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_136" class="md-nav__link">
    # &amp;&lt;|
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_137" class="md-nav__link">
    # |&amp;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_138" class="md-nav__link">
    # &lt;^
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_139" class="md-nav__link">
    # &gt;^
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_140" class="md-nav__link">
    # ?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_10" class="md-nav__link">
    # ?-
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_11" class="md-nav__link">
    # ?-
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_141" class="md-nav__link">
    # ?|
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_142" class="md-nav__link">
    # ?|
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_12" class="md-nav__link">
    # ?-|
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_143" class="md-nav__link">
    # ?||
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_144" class="md-nav__link">
    # @&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_145" class="md-nav__link">
    # &lt;@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_146" class="md-nav__link">
    # ~=
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_147" class="md-nav__link">
    函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#area" class="md-nav__link">
    # area()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#center" class="md-nav__link">
    # center()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#diagonal" class="md-nav__link">
    # diagonal()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#diameter" class="md-nav__link">
    # diameter()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#height" class="md-nav__link">
    # height()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#isclosed" class="md-nav__link">
    # isclosed()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#isopen" class="md-nav__link">
    # isopen()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#length_3" class="md-nav__link">
    # length()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#npoints" class="md-nav__link">
    # npoints()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pclose" class="md-nav__link">
    # pclose()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#popen" class="md-nav__link">
    # popen()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#radius" class="md-nav__link">
    # radius()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#width" class="md-nav__link">
    # width()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_148" class="md-nav__link">
    几何类型转换函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#boxcircle" class="md-nav__link">
    # box(circle)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#boxpoint" class="md-nav__link">
    # box(point)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#boxpoint-point" class="md-nav__link">
    # box(point, point)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#boxpolygon" class="md-nav__link">
    # box(polygon)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bound_boxbox-box" class="md-nav__link">
    # bound_box(box, box )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#circlebox" class="md-nav__link">
    # circle(box)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#circlepoint-double-precision" class="md-nav__link">
    # circle(point, double precision)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#circlepolygon" class="md-nav__link">
    # circle(polygon)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linepoint-point" class="md-nav__link">
    # line(point, point)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lsegbox" class="md-nav__link">
    # lseg(box)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lsegpoint-point" class="md-nav__link">
    # lseg(point, point)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pathpolygon" class="md-nav__link">
    # path(polygon)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointbox" class="md-nav__link">
    # point(box)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointcircle" class="md-nav__link">
    # point(circle)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointdouble-precision-double-precision" class="md-nav__link">
    # point(double precision, double precision)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointlseg" class="md-nav__link">
    # point(lseg)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pointpolygon" class="md-nav__link">
    # point(polygon)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polygonbox" class="md-nav__link">
    # polygon(box)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polygoncircle" class="md-nav__link">
    # polygon(circle)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polygonnpts-circle" class="md-nav__link">
    # polygon(npts, circle)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polygonpath" class="md-nav__link">
    # polygon(path)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_149" class="md-nav__link">
    网络地址类型
  </a>
  
    <nav class="md-nav" aria-label="网络地址类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#inet" class="md-nav__link">
    inet
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cidr" class="md-nav__link">
    cidr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#macaddr" class="md-nav__link">
    macaddr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#macaddr8" class="md-nav__link">
    macaddr8
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_150" class="md-nav__link">
    函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_151" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_152" class="md-nav__link">
    # &lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_153" class="md-nav__link">
    # &lt;=
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_154" class="md-nav__link">
    # =
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_155" class="md-nav__link">
    # &gt;=
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_156" class="md-nav__link">
    # &gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_157" class="md-nav__link">
    # &lt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_158" class="md-nav__link">
    # &lt;&lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_159" class="md-nav__link">
    # &lt;&lt;=
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_160" class="md-nav__link">
    # &gt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_161" class="md-nav__link">
    # &gt;&gt;=
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_162" class="md-nav__link">
    # ~
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_163" class="md-nav__link">
    # &amp;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_164" class="md-nav__link">
    # |
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_165" class="md-nav__link">
    # +
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_13" class="md-nav__link">
    # -
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_14" class="md-nav__link">
    # -
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_166" class="md-nav__link">
    函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#abbrevinet" class="md-nav__link">
    # abbrev(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#abbrevcidr" class="md-nav__link">
    # abbrev(cidr)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#broadcastinet" class="md-nav__link">
    # broadcast(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#familyinet" class="md-nav__link">
    # family(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hostinet" class="md-nav__link">
    # host(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hostmaskinet" class="md-nav__link">
    # hostmask(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maskleninet" class="md-nav__link">
    # masklen(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#netmaskinet" class="md-nav__link">
    # netmask(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#networkinet" class="md-nav__link">
    # network(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_maskleninet-int" class="md-nav__link">
    # set_masklen(inet, int)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_masklencidr-int" class="md-nav__link">
    # set_masklen(cidr, int)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#textinet" class="md-nav__link">
    # text(inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inet_same_familyinet-inet" class="md-nav__link">
    # inet_same_family(inet, inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inet_mergeinet-inet" class="md-nav__link">
    # inet_merge(inet, inet)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#truncmacaddr" class="md-nav__link">
    # trunc(macaddr)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#truncmacaddr8" class="md-nav__link">
    # trunc(macaddr8)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#macaddr8_set7bitmacaddr8" class="md-nav__link">
    # macaddr8_set7bit(macaddr8)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_167" class="md-nav__link">
    位串类型
  </a>
  
    <nav class="md-nav" aria-label="位串类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_168" class="md-nav__link">
    函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_169" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_170" class="md-nav__link">
    # ||
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_171" class="md-nav__link">
    # &amp;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_172" class="md-nav__link">
    # |
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_173" class="md-nav__link">
    #
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_174" class="md-nav__link">
    # ~
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_175" class="md-nav__link">
    # &lt;&lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_176" class="md-nav__link">
    # &gt;&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_177" class="md-nav__link">
    函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit_length-bit" class="md-nav__link">
    # bit_length (bit)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#length-bit" class="md-nav__link">
    # length ( bit )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#octet_length-bit" class="md-nav__link">
    # octet_length ( bit )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#overlay-bits-bit-placing-newsubstring-bit-from-start-integer-for-count-integer" class="md-nav__link">
    # overlay ( bits bit PLACING newsubstring bit FROM start integer [ FOR count integer ] )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#position-substring-bit-in-bits-bit" class="md-nav__link">
    # position ( substring bit IN bits bit )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#substring-bits-bit-from-start-integer-for-count-integer" class="md-nav__link">
    # substring ( bits bit [ FROM start integer ] [ FOR count integer ] )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_bit-bits-bit-n-integer" class="md-nav__link">
    # get_bit ( bits bit, n integer )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_bit-bits-bit-n-integer-newvalue-integer" class="md-nav__link">
    # set_bit ( bits bit, n integer, newvalue integer )
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_178" class="md-nav__link">
    文本搜索类型
  </a>
  
    <nav class="md-nav" aria-label="文本搜索类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tsvector" class="md-nav__link">
    tsvector
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tsquery" class="md-nav__link">
    tsquery
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_179" class="md-nav__link">
    函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_180" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_181" class="md-nav__link">
    # @@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_182" class="md-nav__link">
    # @@@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_183" class="md-nav__link">
    # ||
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_184" class="md-nav__link">
    # &amp;&amp;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_185" class="md-nav__link">
    # ||
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_186" class="md-nav__link">
    # !!
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_15" class="md-nav__link">
    # &lt;-&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_187" class="md-nav__link">
    # @&gt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_188" class="md-nav__link">
    # &lt;@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_189" class="md-nav__link">
    函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_to_tsvector" class="md-nav__link">
    # array_to_tsvector()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_current_ts_config" class="md-nav__link">
    # get_current_ts_config ()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#length_4" class="md-nav__link">
    # length ()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#numnode" class="md-nav__link">
    # numnode ()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#plainto_tsquery" class="md-nav__link">
    # plainto_tsquery ()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#phraseto_tsquery" class="md-nav__link">
    # phraseto_tsquery()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#websearch_to_tsquery" class="md-nav__link">
    # websearch_to_tsquery()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#querytree" class="md-nav__link">
    # querytree()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#setweight" class="md-nav__link">
    # setweight()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#setweight_1" class="md-nav__link">
    # setweight()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#strip" class="md-nav__link">
    # strip()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_tsquery" class="md-nav__link">
    # to_tsquery()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_tsvector" class="md-nav__link">
    # to_tsvector()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_tsvector_1" class="md-nav__link">
    # to_tsvector()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_to_tsvector" class="md-nav__link">
    # json_to_tsvector()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_delete" class="md-nav__link">
    # ts_delete()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_delete_1" class="md-nav__link">
    # ts_delete()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_filter" class="md-nav__link">
    # ts_filter()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_headline" class="md-nav__link">
    # ts_headline()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_headline_1" class="md-nav__link">
    # ts_headline()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_rank" class="md-nav__link">
    # ts_rank()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_rank_cd" class="md-nav__link">
    # ts_rank_cd()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_rewrite" class="md-nav__link">
    # ts_rewrite()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_rewrite_1" class="md-nav__link">
    # ts_rewrite()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tsquery_phrase" class="md-nav__link">
    # tsquery_phrase()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tsquery_phrase_1" class="md-nav__link">
    # tsquery_phrase()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tsvector_to_array" class="md-nav__link">
    # tsvector_to_array()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unnest_4" class="md-nav__link">
    # unnest()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_debug" class="md-nav__link">
    # ts_debug()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_lexize" class="md-nav__link">
    # ts_lexize()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_parse" class="md-nav__link">
    # ts_parse()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_parse_1" class="md-nav__link">
    # ts_parse()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_token_type" class="md-nav__link">
    # ts_token_type()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_token_type_1" class="md-nav__link">
    # ts_token_type()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ts_stat" class="md-nav__link">
    # ts_stat()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_190" class="md-nav__link">
    域类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_191" class="md-nav__link">
    伪类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bsql_2" class="md-nav__link">
    BSQL 语言
  </a>
  
    <nav class="md-nav" aria-label="BSQL 语言">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#abort" class="md-nav__link">
    ABORT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-database" class="md-nav__link">
    ALTER DATABASE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-default-privileges" class="md-nav__link">
    ALTER DEFAULT PRIVILEGES
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-domain" class="md-nav__link">
    ALTER DOMAIN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-foreign-data-wrapper" class="md-nav__link">
    ALTER FOREIGN DATA WRAPPER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-foreign-table" class="md-nav__link">
    ALTER FOREIGN TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-function" class="md-nav__link">
    ALTER FUNCTION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-group" class="md-nav__link">
    ALTER GROUP
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-policy" class="md-nav__link">
    ALTER POLICY
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-procedure" class="md-nav__link">
    ALTER PROCEDURE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-role" class="md-nav__link">
    ALTER ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-schema" class="md-nav__link">
    ALTER SCHEMA
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-sequence" class="md-nav__link">
    ALTER SEQUENCE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-server" class="md-nav__link">
    ALTER SERVER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-table" class="md-nav__link">
    ALTER TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alter-user" class="md-nav__link">
    ALTER USER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#analyze" class="md-nav__link">
    ANALYZE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#begin" class="md-nav__link">
    BEGIN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#call" class="md-nav__link">
    CALL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#close" class="md-nav__link">
    CLOSE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comment" class="md-nav__link">
    COMMENT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#commit" class="md-nav__link">
    COMMIT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#copy" class="md-nav__link">
    COPY
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-aggregate" class="md-nav__link">
    CREATE AGGREGATE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-cast" class="md-nav__link">
    CREATE CAST
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-database" class="md-nav__link">
    CREATE DATABASE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-domain" class="md-nav__link">
    CREATE DOMAIN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-extension" class="md-nav__link">
    CREATE EXTENSION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-foreign-data-wrapper" class="md-nav__link">
    CREATE FOREIGN DATA WRAPPER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-foreign-table" class="md-nav__link">
    CREATE FOREIGN TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-function" class="md-nav__link">
    CREATE FUNCTION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-group" class="md-nav__link">
    CREATE GROUP
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-index" class="md-nav__link">
    CREATE INDEX
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-materialized-view" class="md-nav__link">
    CREATE MATERIALIZED VIEW
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-operator" class="md-nav__link">
    CREATE OPERATOR
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-operator-class" class="md-nav__link">
    CREATE OPERATOR CLASS
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-policy" class="md-nav__link">
    CREATE POLICY
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-procedure" class="md-nav__link">
    CREATE PROCEDURE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-role" class="md-nav__link">
    CREATE ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-rule" class="md-nav__link">
    CREATE RULE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-schema" class="md-nav__link">
    CREATE SCHEMA
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-sequence" class="md-nav__link">
    CREATE SEQUENCE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-server" class="md-nav__link">
    CREATE SERVER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-table" class="md-nav__link">
    CREATE TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-table-as" class="md-nav__link">
    CREATE TABLE AS
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-trigger" class="md-nav__link">
    CREATE TRIGGER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-type" class="md-nav__link">
    CREATE TYPE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-user" class="md-nav__link">
    CREATE USER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-user-mapping" class="md-nav__link">
    CREATE USER MAPPING
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-view" class="md-nav__link">
    CREATE VIEW
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#deallocate" class="md-nav__link">
    DEALLOCATE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#declare" class="md-nav__link">
    DECLARE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delete" class="md-nav__link">
    DELETE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#do" class="md-nav__link">
    DO
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-aggregate" class="md-nav__link">
    DROP AGGREGATE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-cast" class="md-nav__link">
    DROP CAST
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-database" class="md-nav__link">
    DROP DATABASE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-domain" class="md-nav__link">
    DROP DOMAIN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-extension" class="md-nav__link">
    DROP EXTENSION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-foreign-data-wrapper" class="md-nav__link">
    DROP FOREIGN DATA WRAPPER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-foreign-table" class="md-nav__link">
    DROP FOREIGN TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-function" class="md-nav__link">
    DROP FUNCTION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-group" class="md-nav__link">
    DROP GROUP
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-index" class="md-nav__link">
    DROP INDEX
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-materialized-view" class="md-nav__link">
    DROP MATERIALIZED VIEW
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-operator" class="md-nav__link">
    DROP OPERATOR
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-operator-class" class="md-nav__link">
    DROP OPERATOR CLASS
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-owned" class="md-nav__link">
    DROP OWNED
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-policy" class="md-nav__link">
    DROP POLICY
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-procedure" class="md-nav__link">
    DROP PROCEDURE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-role" class="md-nav__link">
    DROP ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-rule" class="md-nav__link">
    DROP RULE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-schema" class="md-nav__link">
    DROP SCHEMA
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-sequence" class="md-nav__link">
    DROP SEQUENCE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-server" class="md-nav__link">
    DROP SERVER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-table" class="md-nav__link">
    DROP TABLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-trigger" class="md-nav__link">
    DROP TRIGGER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-type" class="md-nav__link">
    DROP TYPE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drop-user" class="md-nav__link">
    DROP USER
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#end" class="md-nav__link">
    END
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#execute" class="md-nav__link">
    EXECUTE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#explain" class="md-nav__link">
    EXPLAIN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fetch" class="md-nav__link">
    FETCH
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grant" class="md-nav__link">
    GRANT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#import-foreign-schema" class="md-nav__link">
    IMPORT FOREIGN SCHEMA
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#insert" class="md-nav__link">
    INSERT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lock" class="md-nav__link">
    LOCK
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#move" class="md-nav__link">
    MOVE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prepare" class="md-nav__link">
    PREPARE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reassign-owned" class="md-nav__link">
    REASSIGN OWNED
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#refresh-materialized-view" class="md-nav__link">
    REFRESH MATERIALIZED VIEW
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#release-savepoint" class="md-nav__link">
    RELEASE SAVEPOINT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reset" class="md-nav__link">
    RESET
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#revoke" class="md-nav__link">
    REVOKE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rollback" class="md-nav__link">
    ROLLBACK
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rollback-to-savepoint" class="md-nav__link">
    ROLLBACK TO SAVEPOINT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#savepoint" class="md-nav__link">
    SAVEPOINT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#select" class="md-nav__link">
    SELECT
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set" class="md-nav__link">
    SET
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set-constraints" class="md-nav__link">
    SET CONSTRAINTS
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set-role" class="md-nav__link">
    SET ROLE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set-session-authorization" class="md-nav__link">
    SET SESSION AUTHORIZATION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set-transaction" class="md-nav__link">
    SET TRANSACTION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show" class="md-nav__link">
    SHOW
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show-transaction" class="md-nav__link">
    SHOW TRANSACTION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#start-transaction" class="md-nav__link">
    START TRANSACTION
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#truncate" class="md-nav__link">
    TRUNCATE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#update" class="md-nav__link">
    UPDATE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#values" class="md-nav__link">
    VALUES
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_192" class="md-nav__link">
    内置函数和运算符
  </a>
  
    <nav class="md-nav" aria-label="内置函数和运算符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_193" class="md-nav__link">
    逻辑操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_194" class="md-nav__link">
    比较函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="比较函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_195" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_196" class="md-nav__link">
    比较谓词
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_197" class="md-nav__link">
    比较函数
  </a>
  
    <nav class="md-nav" aria-label="比较函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#num_nonnulls" class="md-nav__link">
    num_nonnulls()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#num_nulls" class="md-nav__link">
    num_nulls()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_198" class="md-nav__link">
    数学函数和操作符
  </a>
  
    <nav class="md-nav" aria-label="数学函数和操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_199" class="md-nav__link">
    数学操作符
  </a>
  
    <nav class="md-nav" aria-label="数学操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_200" class="md-nav__link">
    +
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_201" class="md-nav__link">
    +
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_16" class="md-nav__link">
    -
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_17" class="md-nav__link">
    -
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_202" class="md-nav__link">
    *
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_203" class="md-nav__link">
    /
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_204" class="md-nav__link">
    %
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_205" class="md-nav__link">
    ^
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_206" class="md-nav__link">
    |/
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_207" class="md-nav__link">
    ||/
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_208" class="md-nav__link">
    !
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_209" class="md-nav__link">
    !!
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_210" class="md-nav__link">
    @
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_211" class="md-nav__link">
    &amp;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_212" class="md-nav__link">
    |
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_213" class="md-nav__link">
    #
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_214" class="md-nav__link">
    ~
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_215" class="md-nav__link">
    &lt;&lt;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_216" class="md-nav__link">
    &gt;&gt;
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_217" class="md-nav__link">
    数学函数
  </a>
  
    <nav class="md-nav" aria-label="数学函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#abs" class="md-nav__link">
    abs()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cbrt" class="md-nav__link">
    cbrt()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ceil" class="md-nav__link">
    ceil()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ceiling" class="md-nav__link">
    ceiling()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#degrees" class="md-nav__link">
    degrees()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#div" class="md-nav__link">
    div()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exp" class="md-nav__link">
    exp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#factorial" class="md-nav__link">
    factorial()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#floor" class="md-nav__link">
    floor()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ln" class="md-nav__link">
    ln()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#log" class="md-nav__link">
    log()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#log_1" class="md-nav__link">
    log()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mod" class="md-nav__link">
    mod()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pi" class="md-nav__link">
    pi()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#power" class="md-nav__link">
    power()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#radians" class="md-nav__link">
    radians()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#round" class="md-nav__link">
    round()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#round_1" class="md-nav__link">
    round()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scale" class="md-nav__link">
    scale()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sign" class="md-nav__link">
    sign()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sqrt" class="md-nav__link">
    sqrt()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trunc" class="md-nav__link">
    trunc()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trunc_1" class="md-nav__link">
    trunc()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#width_bucket" class="md-nav__link">
    width_bucket()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#width_bucket_1" class="md-nav__link">
    width_bucket()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_218" class="md-nav__link">
    随机函数
  </a>
  
    <nav class="md-nav" aria-label="随机函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#random" class="md-nav__link">
    random()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#setseed" class="md-nav__link">
    setseed()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_219" class="md-nav__link">
    三角函数
  </a>
  
    <nav class="md-nav" aria-label="三角函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#acos" class="md-nav__link">
    acos()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#acosd" class="md-nav__link">
    acosd()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asin" class="md-nav__link">
    asin()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asind" class="md-nav__link">
    asind()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#atan" class="md-nav__link">
    atan()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#atand" class="md-nav__link">
    atand()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#atan2" class="md-nav__link">
    atan2()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#atan2d" class="md-nav__link">
    atan2d()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cos" class="md-nav__link">
    cos()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cosd" class="md-nav__link">
    cosd()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cot" class="md-nav__link">
    cot()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cotd" class="md-nav__link">
    cotd()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sin" class="md-nav__link">
    sin()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sind" class="md-nav__link">
    sind()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tan" class="md-nav__link">
    tan()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tand" class="md-nav__link">
    tand()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_220" class="md-nav__link">
    数据类型格式化函数
  </a>
  
    <nav class="md-nav" aria-label="数据类型格式化函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_221" class="md-nav__link">
    格式化函数
  </a>
  
    <nav class="md-nav" aria-label="格式化函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#to_char_1" class="md-nav__link">
    to_char()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_char_2" class="md-nav__link">
    to_char()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_char_3" class="md-nav__link">
    to_char()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_date_1" class="md-nav__link">
    to_date()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_number" class="md-nav__link">
    to_number()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_timestamp_2" class="md-nav__link">
    to_timestamp()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_222" class="md-nav__link">
    模板模式
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_223" class="md-nav__link">
    模式匹配
  </a>
  
    <nav class="md-nav" aria-label="模式匹配">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#like" class="md-nav__link">
    LIKE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#similar-to" class="md-nav__link">
    SIMILAR TO正则表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#posix" class="md-nav__link">
    POSIX正则表达式
  </a>
  
    <nav class="md-nav" aria-label="POSIX正则表达式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_224" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_225" class="md-nav__link">
    # ~
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_226" class="md-nav__link">
    # ~*
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_227" class="md-nav__link">
    # !~
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_228" class="md-nav__link">
    # !~*
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_229" class="md-nav__link">
    函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_replace_1" class="md-nav__link">
    # regexp_replace
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_match_1" class="md-nav__link">
    # regexp_match
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_matches_1" class="md-nav__link">
    # regexp_matches
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_split_to_table_1" class="md-nav__link">
    # regexp_split_to_table
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regexp_split_to_array_1" class="md-nav__link">
    # regexp_split_to_array
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_230" class="md-nav__link">
    正则表达式细节
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_231" class="md-nav__link">
    方括号表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_232" class="md-nav__link">
    正则表达式逃逸
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_233" class="md-nav__link">
    正则表达式元语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_234" class="md-nav__link">
    正则表达式匹配规则
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_235" class="md-nav__link">
    条件表达式
  </a>
  
    <nav class="md-nav" aria-label="条件表达式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#case" class="md-nav__link">
    CASE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coalesce" class="md-nav__link">
    COALESCE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nullif" class="md-nav__link">
    NULLIF
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#greatestleast" class="md-nav__link">
    GREATEST和LEAST
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_236" class="md-nav__link">
    子查询表达式
  </a>
  
    <nav class="md-nav" aria-label="子查询表达式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#exists" class="md-nav__link">
    EXISTS
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#in" class="md-nav__link">
    IN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#not-in" class="md-nav__link">
    NOT IN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#anysome" class="md-nav__link">
    ANY/SOME
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#all" class="md-nav__link">
    ALL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_237" class="md-nav__link">
    单一行比较
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_238" class="md-nav__link">
    行和数组比较
  </a>
  
    <nav class="md-nav" aria-label="行和数组比较">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#in_1" class="md-nav__link">
    IN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#not-in_1" class="md-nav__link">
    NOT IN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#anysome-array" class="md-nav__link">
    ANY/SOME (array)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#all-array" class="md-nav__link">
    ALL (array)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_239" class="md-nav__link">
    行构造器比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_240" class="md-nav__link">
    组合类型比较
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_241" class="md-nav__link">
    集合返回函数
  </a>
  
    <nav class="md-nav" aria-label="集合返回函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_242" class="md-nav__link">
    系列生成函数
  </a>
  
    <nav class="md-nav" aria-label="系列生成函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#generate_series" class="md-nav__link">
    generate_series()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generate_series_1" class="md-nav__link">
    generate_series()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generate_series_2" class="md-nav__link">
    generate_series()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_243" class="md-nav__link">
    下标生成函数
  </a>
  
    <nav class="md-nav" aria-label="下标生成函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#generate_subscripts_1" class="md-nav__link">
    generate_subscripts()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generate_subscripts_2" class="md-nav__link">
    generate_subscripts()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_244" class="md-nav__link">
    窗口函数
  </a>
  
    <nav class="md-nav" aria-label="窗口函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_245" class="md-nav__link">
    特性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_246" class="md-nav__link">
    窗口函数语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_247" class="md-nav__link">
    通用窗口函数
  </a>
  
    <nav class="md-nav" aria-label="通用窗口函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#row_number" class="md-nav__link">
    row_number()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rank" class="md-nav__link">
    rank()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dense_rank" class="md-nav__link">
    dense_rank()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#percent_rank" class="md-nav__link">
    percent_rank()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cume_dist" class="md-nav__link">
    cume_dist()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ntile" class="md-nav__link">
    ntile()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lag" class="md-nav__link">
    lag()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lead" class="md-nav__link">
    lead()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#first_value" class="md-nav__link">
    first_value()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#last_value" class="md-nav__link">
    last_value()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nth_value" class="md-nav__link">
    nth_value()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_248" class="md-nav__link">
    示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_249" class="md-nav__link">
    聚集函数
  </a>
  
    <nav class="md-nav" aria-label="聚集函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_250" class="md-nav__link">
    通用聚集函数
  </a>
  
    <nav class="md-nav" aria-label="通用聚集函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#avg-count-max-min-sum" class="md-nav__link">
    avg() , count(), max(), min(), sum()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avg" class="md-nav__link">
    # avg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#count" class="md-nav__link">
    # count()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#max" class="md-nav__link">
    # max()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#min" class="md-nav__link">
    # min()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sum" class="md-nav__link">
    # sum()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_251" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by" class="md-nav__link">
    ## GROUP BY 语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#over" class="md-nav__link">
    ## OVER 语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit_and-bit_or-bool_and-bool_or-every" class="md-nav__link">
    bit_and(), bit_or(), bool_and(), bool_or(), every()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit_and" class="md-nav__link">
    # bit_and()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bit_or" class="md-nav__link">
    # bit_or()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bool_and" class="md-nav__link">
    # bool_and()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bool_or" class="md-nav__link">
    # bool_or()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#every" class="md-nav__link">
    # every()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_252" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by_1" class="md-nav__link">
    ## GROUP BY 语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#over_1" class="md-nav__link">
    ## OVER 语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_agg-string_agg-jsonb_agg-jsonb_object_agg" class="md-nav__link">
    array_agg(), string_agg(), jsonb_agg(), jsonb_object_agg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_agg_3" class="md-nav__link">
    # array_agg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_agg_1" class="md-nav__link">
    # jsonb_agg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jsonb_object_agg_1" class="md-nav__link">
    #  jsonb_object_agg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#string_agg" class="md-nav__link">
    # string_agg()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_253" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by_2" class="md-nav__link">
    ## GROUP BY 语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#over_2" class="md-nav__link">
    ## OVER 语法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_254" class="md-nav__link">
    统计性聚集函数
  </a>
  
    <nav class="md-nav" aria-label="统计性聚集函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#covar_pop-covar_samp-corr" class="md-nav__link">
    covar_pop(), covar_samp(), corr()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#covar_pop" class="md-nav__link">
    # covar_pop()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#covar_samp" class="md-nav__link">
    # covar_samp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#corr" class="md-nav__link">
    # corr()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_255" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_" class="md-nav__link">
    regr_%()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_avgy" class="md-nav__link">
    # regr_avgy()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_avgx" class="md-nav__link">
    # regr_avgx()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_count" class="md-nav__link">
    # regr_count()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_slope" class="md-nav__link">
    # regr_slope()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_intercept" class="md-nav__link">
    # regr_intercept()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_r2" class="md-nav__link">
    # regr_r2()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_syy" class="md-nav__link">
    # regr_syy()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_sxx" class="md-nav__link">
    # regr_sxx()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regr_sxy" class="md-nav__link">
    # regr_sxy()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_256" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#variance-var_pop-var_samp-stddev-stddev_pop-stddev_samp" class="md-nav__link">
    variance(), var_pop(), var_samp(), stddev(), stddev_pop(), stddev_samp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#variance" class="md-nav__link">
    # variance()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#var_pop" class="md-nav__link">
    # var_pop
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#var_samp" class="md-nav__link">
    # var_samp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stddev" class="md-nav__link">
    # stddev()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stddev_pop" class="md-nav__link">
    # stddev_pop()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stddev_samp" class="md-nav__link">
    # stddev_samp()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_257" class="md-nav__link">
    # 示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by_3" class="md-nav__link">
    ## GROUP BY 语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#over_3" class="md-nav__link">
    ## OVER 语法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_258" class="md-nav__link">
    组内有序集合聚合函数
  </a>
  
    <nav class="md-nav" aria-label="组内有序集合聚合函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mode" class="md-nav__link">
    # mode()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by_4" class="md-nav__link">
    ## 无GROUP BY的示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by_5" class="md-nav__link">
    ## 使用GROUP BY的示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#percentile_disc-percentile_cont" class="md-nav__link">
    # percentile_disc() ， percentile_cont()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_259" class="md-nav__link">
    ## 使用标量重载的基本示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by_6" class="md-nav__link">
    ## 使用GROUP BY的标量重载的基本示例
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_260" class="md-nav__link">
    ## 中值确定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_261" class="md-nav__link">
    ## 使用数组重载的示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_262" class="md-nav__link">
    系统信息函数和运算符
  </a>
  
    <nav class="md-nav" aria-label="系统信息函数和运算符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_263" class="md-nav__link">
    会话信息函数
  </a>
  
    <nav class="md-nav" aria-label="会话信息函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#current_catalog" class="md-nav__link">
    current_catalog
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_database" class="md-nav__link">
    current_database()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_query" class="md-nav__link">
    current_query()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_role" class="md-nav__link">
    current_role
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_schema" class="md-nav__link">
    current_schema[()]
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_schemas" class="md-nav__link">
    current_schemas()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#current_user" class="md-nav__link">
    current_user
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inet_client_addr" class="md-nav__link">
    inet_client_addr()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inet_client_port" class="md-nav__link">
    inet_client_port()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inet_server_addr" class="md-nav__link">
    inet_server_addr()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inet_server_port" class="md-nav__link">
    inet_server_port()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_backend_pid" class="md-nav__link">
    pg_backend_pid()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_blocking_pids" class="md-nav__link">
    pg_blocking_pids()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_conf_load_time" class="md-nav__link">
    pg_conf_load_time()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_current_logfile" class="md-nav__link">
    pg_current_logfile()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_my_temp_schema" class="md-nav__link">
    pg_my_temp_schema()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_is_other_temp_schema" class="md-nav__link">
    pg_is_other_temp_schema()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_jit_available" class="md-nav__link">
    pg_jit_available()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_listening_channels" class="md-nav__link">
    pg_listening_channels()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_notification_queue_usage" class="md-nav__link">
    pg_notification_queue_usage()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_postmaster_start_time" class="md-nav__link">
    pg_postmaster_start_time()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_safe_snapshot_blocking_pids" class="md-nav__link">
    pg_safe_snapshot_blocking_pids()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_trigger_depth" class="md-nav__link">
    pg_trigger_depth()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#session_user" class="md-nav__link">
    session_user
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#user" class="md-nav__link">
    user
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#version" class="md-nav__link">
    version()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_264" class="md-nav__link">
    访问权限查询函数
  </a>
  
    <nav class="md-nav" aria-label="访问权限查询函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#has_any_column_privilege" class="md-nav__link">
    has_any_column_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_column_privilege" class="md-nav__link">
    has_column_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_database_privilege" class="md-nav__link">
    has_database_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_foreign_data_wrapper_privilege" class="md-nav__link">
    has_foreign_data_wrapper_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_function_privilege" class="md-nav__link">
    has_function_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_language_privilege" class="md-nav__link">
    has_language_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_schema_privilege" class="md-nav__link">
    has_schema_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_sequence_privilege" class="md-nav__link">
    has_sequence_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_server_privilege" class="md-nav__link">
    has_server_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_table_privilege" class="md-nav__link">
    has_table_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_tablespace_privilege" class="md-nav__link">
    has_tablespace_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_type_privilege" class="md-nav__link">
    has_type_privilege()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_has_role" class="md-nav__link">
    pg_has_role()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#row_security_active" class="md-nav__link">
    row_security_active()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aclitem" class="md-nav__link">
    aclitem 操作符
  </a>
  
    <nav class="md-nav" aria-label="aclitem 操作符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_265" class="md-nav__link">
    =
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_266" class="md-nav__link">
    @&gt;
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aclitem_1" class="md-nav__link">
    aclitem 函数
  </a>
  
    <nav class="md-nav" aria-label="aclitem 函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#acldefault" class="md-nav__link">
    acldefault()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aclexplode" class="md-nav__link">
    aclexplode()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#makeaclitem" class="md-nav__link">
    makeaclitem()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_267" class="md-nav__link">
    模式可见性查询函数
  </a>
  
    <nav class="md-nav" aria-label="模式可见性查询函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pg_collation_is_visible" class="md-nav__link">
    pg_collation_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_conversion_is_visible" class="md-nav__link">
    pg_conversion_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_function_is_visible" class="md-nav__link">
    pg_function_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_opclass_is_visible" class="md-nav__link">
    pg_opclass_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_operator_is_visible" class="md-nav__link">
    pg_operator_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_opfamily_is_visible" class="md-nav__link">
    pg_opfamily_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statistics_obj_is_visible" class="md-nav__link">
    pg_statistics_obj_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_table_is_visible" class="md-nav__link">
    pg_table_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_config_is_visible" class="md-nav__link">
    pg_ts_config_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_dict_is_visible" class="md-nav__link">
    pg_ts_dict_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_parser_is_visible" class="md-nav__link">
    pg_ts_parser_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_template_is_visible" class="md-nav__link">
    pg_ts_template_is_visible()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_type_is_visible" class="md-nav__link">
    pg_type_is_visible()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_268" class="md-nav__link">
    系统目录信息函数
  </a>
  
    <nav class="md-nav" aria-label="系统目录信息函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#format_type" class="md-nav__link">
    format_type()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_get_constraintdef" class="md-nav__link">
    pg_get_constraintdef()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_269" class="md-nav__link">
    关键词
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_270" class="md-nav__link">
    保留名称
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_271" class="md-nav__link">
    系统表/视图
  </a>
  
    <nav class="md-nav" aria-label="系统表/视图">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pg_aggregate" class="md-nav__link">
    pg_aggregate
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_am" class="md-nav__link">
    pg_am
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_amop" class="md-nav__link">
    pg_amop
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_amproc" class="md-nav__link">
    pg_amproc
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_attrdef" class="md-nav__link">
    pg_attrdef
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_attribute" class="md-nav__link">
    pg_attribute
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_auth_members" class="md-nav__link">
    pg_auth_members
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_authid" class="md-nav__link">
    pg_authid
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_available_extension_versions" class="md-nav__link">
    pg_available_extension_versions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_available_extensions" class="md-nav__link">
    pg_available_extensions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_backend_memory_contexts" class="md-nav__link">
    pg_backend_memory_contexts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_bm_catalog_version" class="md-nav__link">
    pg_bm_catalog_version
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_bm_migration" class="md-nav__link">
    pg_bm_migration
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_bm_profile" class="md-nav__link">
    pg_bm_profile
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_bm_role_profile" class="md-nav__link">
    pg_bm_role_profile
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_bm_tablegroup" class="md-nav__link">
    pg_bm_tablegroup
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_cast" class="md-nav__link">
    pg_cast
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_class" class="md-nav__link">
    pg_class
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_collation" class="md-nav__link">
    pg_collation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_config" class="md-nav__link">
    pg_config
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_constraint" class="md-nav__link">
    pg_constraint
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_conversion" class="md-nav__link">
    pg_conversion
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_cursors" class="md-nav__link">
    pg_cursors
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_database" class="md-nav__link">
    pg_database
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_db_role_setting" class="md-nav__link">
    pg_db_role_setting
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_default_acl" class="md-nav__link">
    pg_default_acl
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_depend" class="md-nav__link">
    pg_depend
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_description" class="md-nav__link">
    pg_description
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_enum" class="md-nav__link">
    pg_enum
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_event_trigger" class="md-nav__link">
    pg_event_trigger
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_extension" class="md-nav__link">
    pg_extension
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_file_settings" class="md-nav__link">
    pg_file_settings
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_foreign_data_wrapper" class="md-nav__link">
    pg_foreign_data_wrapper
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_foreign_server" class="md-nav__link">
    pg_foreign_server
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_foreign_table" class="md-nav__link">
    pg_foreign_table
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_group" class="md-nav__link">
    pg_group
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_hba_file_rules" class="md-nav__link">
    pg_hba_file_rules
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_index" class="md-nav__link">
    pg_index
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_indexes" class="md-nav__link">
    pg_indexes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_inherits" class="md-nav__link">
    pg_inherits
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_init_privs" class="md-nav__link">
    pg_init_privs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_language" class="md-nav__link">
    pg_language
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_largeobject" class="md-nav__link">
    pg_largeobject
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_largeobject_metadata" class="md-nav__link">
    pg_largeobject_metadata
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_locks" class="md-nav__link">
    pg_locks
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_matviews" class="md-nav__link">
    pg_matviews
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_namespace" class="md-nav__link">
    pg_namespace
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_opclass" class="md-nav__link">
    pg_opclass
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_operator" class="md-nav__link">
    pg_operator
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_opfamily" class="md-nav__link">
    pg_opfamily
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_partitioned_table" class="md-nav__link">
    pg_partitioned_table
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_pltemplate" class="md-nav__link">
    pg_pltemplate
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_policies" class="md-nav__link">
    pg_policies
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_policy" class="md-nav__link">
    pg_policy
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_prepared_statements" class="md-nav__link">
    pg_prepared_statements
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_prepared_xacts" class="md-nav__link">
    pg_prepared_xacts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_proc" class="md-nav__link">
    pg_proc
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_publication" class="md-nav__link">
    pg_publication
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_publication_rel" class="md-nav__link">
    pg_publication_rel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_publication_tables" class="md-nav__link">
    pg_publication_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_range" class="md-nav__link">
    pg_range
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_replication_origin" class="md-nav__link">
    pg_replication_origin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_replication_origin_status" class="md-nav__link">
    pg_replication_origin_status
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_replication_slots" class="md-nav__link">
    pg_replication_slots
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_rewrite" class="md-nav__link">
    pg_rewrite
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_roles" class="md-nav__link">
    pg_roles
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_rules" class="md-nav__link">
    pg_rules
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_seclabel" class="md-nav__link">
    pg_seclabel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_seclabels" class="md-nav__link">
    pg_seclabels
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_sequence" class="md-nav__link">
    pg_sequence
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_sequences" class="md-nav__link">
    pg_sequences
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_settings" class="md-nav__link">
    pg_settings
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_shadow" class="md-nav__link">
    pg_shadow
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_shdepend" class="md-nav__link">
    pg_shdepend
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_shdescription" class="md-nav__link">
    pg_shdescription
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_shseclabel" class="md-nav__link">
    pg_shseclabel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_activity" class="md-nav__link">
    pg_stat_activity
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_all_indexes" class="md-nav__link">
    pg_stat_all_indexes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_all_tables" class="md-nav__link">
    pg_stat_all_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_archiver" class="md-nav__link">
    pg_stat_archiver
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_bgwriter" class="md-nav__link">
    pg_stat_bgwriter
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_database" class="md-nav__link">
    pg_stat_database
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_database_conflicts" class="md-nav__link">
    pg_stat_database_conflicts
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_progress_copy" class="md-nav__link">
    pg_stat_progress_copy
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_progress_create_index" class="md-nav__link">
    pg_stat_progress_create_index
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_progress_vacuum" class="md-nav__link">
    pg_stat_progress_vacuum
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_replication" class="md-nav__link">
    pg_stat_replication
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_ssl" class="md-nav__link">
    pg_stat_ssl
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_statements" class="md-nav__link">
    pg_stat_statements
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_subscription" class="md-nav__link">
    pg_stat_subscription
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_sys_indexes" class="md-nav__link">
    pg_stat_sys_indexes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_sys_tables" class="md-nav__link">
    pg_stat_sys_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_user_functions" class="md-nav__link">
    pg_stat_user_functions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_user_indexes" class="md-nav__link">
    pg_stat_user_indexes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_user_tables" class="md-nav__link">
    pg_stat_user_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_wal_receiver" class="md-nav__link">
    pg_stat_wal_receiver
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_xact_all_tables" class="md-nav__link">
    pg_stat_xact_all_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_xact_sys_tables" class="md-nav__link">
    pg_stat_xact_sys_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_xact_user_functions" class="md-nav__link">
    pg_stat_xact_user_functions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stat_xact_user_tables" class="md-nav__link">
    pg_stat_xact_user_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_all_indexes" class="md-nav__link">
    pg_statio_all_indexes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_all_sequences" class="md-nav__link">
    pg_statio_all_sequences
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_all_tables" class="md-nav__link">
    pg_statio_all_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_sys_indexes" class="md-nav__link">
    pg_statio_sys_indexes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_sys_sequences" class="md-nav__link">
    pg_statio_sys_sequences
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_sys_tables" class="md-nav__link">
    pg_statio_sys_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_user_indexes" class="md-nav__link">
    pg_statio_user_indexes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_user_sequences" class="md-nav__link">
    pg_statio_user_sequences
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statio_user_tables" class="md-nav__link">
    pg_statio_user_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statistic" class="md-nav__link">
    pg_statistic
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_statistic_ext" class="md-nav__link">
    pg_statistic_ext
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_stats" class="md-nav__link">
    pg_stats
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_subscription" class="md-nav__link">
    pg_subscription
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_subscription_rel" class="md-nav__link">
    pg_subscription_rel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_tables" class="md-nav__link">
    pg_tables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_tablespace" class="md-nav__link">
    pg_tablespace
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_timezone_abbrevs" class="md-nav__link">
    pg_timezone_abbrevs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_timezone_names" class="md-nav__link">
    pg_timezone_names
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_transform" class="md-nav__link">
    pg_transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_trigger" class="md-nav__link">
    pg_trigger
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_config" class="md-nav__link">
    pg_ts_config
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_config_map" class="md-nav__link">
    pg_ts_config_map
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_dict" class="md-nav__link">
    pg_ts_dict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_parser" class="md-nav__link">
    pg_ts_parser
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_ts_template" class="md-nav__link">
    pg_ts_template
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_type" class="md-nav__link">
    pg_type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_user" class="md-nav__link">
    pg_user
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_user_mapping" class="md-nav__link">
    pg_user_mapping
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_user_mappings" class="md-nav__link">
    pg_user_mappings
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pg_views" class="md-nav__link">
    pg_views
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h2 id="bsql"><strong>BSQL</strong></h2>
<p>AiSQL结构化查询语言（BSQL）是一种ANSI SQL、全关系API，适合弹性、大规模写入可扩展性和地理数据分布的扩展RDBMS应用程序。AiSQL SQL处理层是直接使用PostgreSQL代码（从11.2版本开始）构建的，使得与PostgreSQL完全兼容。</p>
<p>因此，BSQL支持所有传统的关系建模特性，例如引用完整性（使用从子表到其父表的主键的外键约束实现）、联接、部分索引、触发器和存储过程。它将熟悉的事务概念扩展到AiSQL 分布式SQL数据库体系结构中。</p>
<p>BSQL的主要组件包括数据定义语言（DDL）、数据操作语言（DML）、数据控制语言（DCL）、内置SQL函数和PL/pgSQL过程语言。</p>
<h3 id="_1"><strong>数据类型</strong></h3>
<p>下表列出了BSQL支持的基本数据类型和复合数据类型。</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>别名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>array</td>
<td></td>
<td>任何有效数据类型的一维或多维数组</td>
</tr>
<tr>
<td>bigint</td>
<td>int8</td>
<td>有符号的8字节整数</td>
</tr>
<tr>
<td>bigserial</td>
<td>serial8</td>
<td>自动增长的8字节整数</td>
</tr>
<tr>
<td>bit [ (n) ]¹</td>
<td></td>
<td>定长位串</td>
</tr>
<tr>
<td>bit varying [ (n) ]¹</td>
<td>varbit [ (n) ]</td>
<td>变长位串</td>
</tr>
<tr>
<td>boolean</td>
<td>bool</td>
<td>逻辑布尔值（真/假）</td>
</tr>
<tr>
<td>box¹</td>
<td></td>
<td>平面上的普通方框</td>
</tr>
<tr>
<td>bytea</td>
<td></td>
<td>二进制数据（“字节数组”）</td>
</tr>
<tr>
<td>character [ (n) ]</td>
<td>char [ (n) ]</td>
<td>定长字符串</td>
</tr>
<tr>
<td>character varying [ (n) ]</td>
<td>varchar [ (n) ]</td>
<td>变长字符串</td>
</tr>
<tr>
<td>cidr¹</td>
<td></td>
<td>IPv4或IPv6网络地址</td>
</tr>
<tr>
<td>circle¹</td>
<td></td>
<td>平面上的圆</td>
</tr>
<tr>
<td>date</td>
<td></td>
<td>日历日期（年、月、日）</td>
</tr>
<tr>
<td>double precision</td>
<td>float8</td>
<td>双精度浮点数（8字节）</td>
</tr>
<tr>
<td>inet¹</td>
<td></td>
<td>IPv4或IPv6主机地址</td>
</tr>
<tr>
<td>integer</td>
<td>int, int4</td>
<td>有符号4字节整数</td>
</tr>
<tr>
<td>interval [ fields ] [ (p) ]</td>
<td></td>
<td>时间段</td>
</tr>
<tr>
<td>json¹</td>
<td></td>
<td>文本 JSON 数据</td>
</tr>
<tr>
<td>jsonb¹</td>
<td></td>
<td>二进制 JSON 数据，已分解</td>
</tr>
<tr>
<td>line¹</td>
<td></td>
<td>平面上的无限长的线</td>
</tr>
<tr>
<td>lseg¹</td>
<td></td>
<td>平面上的线段</td>
</tr>
<tr>
<td>macaddr¹</td>
<td></td>
<td>MAC（Media Access Control）地址</td>
</tr>
<tr>
<td>macaddr8¹</td>
<td></td>
<td>MAC（Media Access Control）地址（EUI-64格式）</td>
</tr>
<tr>
<td>money</td>
<td></td>
<td>货币数量</td>
</tr>
<tr>
<td>numeric [ (p, s) ]</td>
<td>decimal [ (p, s) ]</td>
<td>可选择精度的精确数字</td>
</tr>
<tr>
<td>path¹</td>
<td></td>
<td>平面上的几何路径</td>
</tr>
<tr>
<td>pg_lsn¹</td>
<td></td>
<td>PostgreSQL日志序列号</td>
</tr>
<tr>
<td>point¹</td>
<td></td>
<td>平面上的几何点</td>
</tr>
<tr>
<td>polygon¹</td>
<td></td>
<td>平面上的封闭几何路径</td>
</tr>
<tr>
<td>real</td>
<td>float4</td>
<td>单精度浮点数（4字节）</td>
</tr>
<tr>
<td>smallint</td>
<td>int2</td>
<td>有符号2字节整数</td>
</tr>
<tr>
<td>int4range</td>
<td></td>
<td>integer的范围</td>
</tr>
<tr>
<td>int8range</td>
<td></td>
<td>bigint的范围</td>
</tr>
<tr>
<td>numrange</td>
<td></td>
<td>numeric的范围</td>
</tr>
<tr>
<td>tsrange</td>
<td></td>
<td>不带时区的 timestamp的范围</td>
</tr>
<tr>
<td>tstzrange</td>
<td></td>
<td>带时区的 timestamp的范围</td>
</tr>
<tr>
<td>daterange</td>
<td></td>
<td>date的范围</td>
</tr>
<tr>
<td>smallserial</td>
<td>serial2</td>
<td>自动增长的2字节整数</td>
</tr>
<tr>
<td>serial</td>
<td>serial4</td>
<td>自动增长的4字节整数</td>
</tr>
<tr>
<td>text</td>
<td></td>
<td>变长字符串</td>
</tr>
<tr>
<td>time [ (p) ] [ without time zone ]</td>
<td></td>
<td>一天中的时间（无时区）</td>
</tr>
<tr>
<td>time [ (p) ] with time zone</td>
<td>timetz</td>
<td>一天中的时间，包括时区</td>
</tr>
<tr>
<td>timestamp [ (p) ] [ without time zone ]</td>
<td></td>
<td>日期和时间（无时区）</td>
</tr>
<tr>
<td>timestamp [ (p) ] with time zone</td>
<td>timestamptz</td>
<td>日期和时间，包括时区</td>
</tr>
<tr>
<td>tsquery¹</td>
<td></td>
<td>文本搜索查询</td>
</tr>
<tr>
<td>tsvector¹</td>
<td></td>
<td>文本搜索文档</td>
</tr>
<tr>
<td>txid_snapshot¹</td>
<td></td>
<td>用户级别事务ID快照</td>
</tr>
<tr>
<td>uuid</td>
<td></td>
<td>通用唯一标识码</td>
</tr>
<tr>
<td>xml²</td>
<td></td>
<td>XML数据</td>
</tr>
</tbody>
</table>
<p>¹：此类型的表列不能是INDEX KEY的一部分。 
²：开发中</p>
<h5 id="array"><strong>数组（array）</strong></h5>
<h6 id="_2"><strong>概要</strong></h6>
<p>多维数组允许您在表中的单个字段中存储大的复合值；它允许您将这样的值分配给PL/pgSQL变量，或者通过过程或函数的形式参数传递它。
您可以从下面的声明中看到，数组中的每个值都是同一数据类型，要么是文本或数字等基本数据类型，要么是用户自定义的标量或复合数据类型（如“row”类型）。
根据定义，数组是一组N维的“单元”。可以将一维数组想象成一行单元格，将二维数组想象成矩形单元格，将三维数组想象成长方体单元格。“N维数组”包括这些和所有其他数组，N称为其维数。</p>
<p>数组中的值由元组的索引值指定，如下所示（对于四维数组）：
arr[13][7][5][17]</p>
<p>索引是所讨论维度上的单元格编号。每个维度上的索引值是连续的，换句话说，不能删除数组中的单元格。这反映了一个事实，即数组是线性化的。然而，单元格中的值可以是NULL的。
针对于上例，最左边的值（示例中为13）是第一维度的索引；最右边的值（本例中为17）是第N维度，即本例中的第四维度的索引。沿着特定维度的第一个单元格的索引的值被称为该维度的下界。如果在创建数组值时不采取任何特殊步骤，则每个维度的下界为1。但是，如果您觉得它很有用，您可以指定任何正整数，或负整数，或零作为指定维度的下界。数组的下限在创建时是固定的，其维度也是固定的。 
相应地，每个维度都有一个上界。这在数组创建时也是固定的。每个维度上的索引值是连续的。每个维度的上界和下界都有一个值，这反映了数组是线性化的。
如果您读取了一个数组边界之外的数组值，默认会得到NULL。但是，如果您试图设置这样一个越界值，那么，因为这是一个隐式的更改数组边界的尝试，您会得到“数组下标超出范围”的错误。
 请注意，通过沿源数组的每个轴指定所需的上下索引值，可以使用单个赋值，创建一个数组，作为数组的所谓“切片”。新数组的维度不能与其源维度不同。您应该指定切片的上下索引值，沿着源数组的每个维度，使其位于该维度的边界内（或最大限度地与该边界重合）。如果指定的切片的下界小于源数组的相应下界，则新的下界被默认地解释为现存的对应源下界，上界也是如此。此方法的语法意味着新数组的下界不可避免地都从1开始。下面是一个使用二维源数组的示例（使用PL/pgSQL语法）：</p>
<div class="highlight"><pre><span></span><code>new_arr := source_arr[3:4][7:9];
</code></pre></div>
<p>注：一维数组是一种特殊情况，因为在N维形状中，它是唯一的线性的。通过在索引值低于当前下界，或索引值高于当前上界的单元格中设置值，可以隐式增加此类数组的长度。一旦完成了这项操作，就无法减少长度，因为没有对此进行显式操作，也没有对指定单元格进行“取消设置”操作。但是，您可以创建一个切片，以便新数组具有源数组的原始大小。
以下属性决定数组的形状。每一个都可以使用下述专用函数进行查看。第一个形式参数（数据类型为anyarray）是数组。在适当的时候，还有第二个形式参数（数据类型为int），用于指定维度。返回值是一个int值，但有一种情况除外，它的返回值是一个text 值，如下所述。
array_ndims()：返回指定数组的维度。
array_lower()：返回指定维度上的数组的下界。 
array_upper()：返回指定维度上的数组的上界。
array_length()：返回指定维度上的数组的长度。对于特定维度，长度、上界和下界是相互关联的，因此
 "长度" = "上界" - "下界" + 1
cardinality()：返回指定数组中的单元格总数。沿着每个维度的基数和长度是相互关联的，因此：
"cardinality" = "length 1" * "length 2" * ... * "length N"</p>
<p>array_dims()：对于所有维度，在单个文本值中返回与array_lower（）和array_length（）相同信息的文本表示形式。例如，对于三维数组，返回类似[3:4][7:9][2:5]所示的上界和下界。
数组之所以特殊，是因为（与例如decimal和int等数字数据类型，或text和varchar等字符数据类型不同）没有现成的数组数据类型。相反，您可以使用数组类型构造函数来构造所需的数组数据类型。以下是一个示例：</p>
<div class="highlight"><pre><span></span><code>create table t1(k int primary key, arr text array[4]);
</code></pre></div>
<p>此语法符合SQL标准。请注意，数组是一个保留字。（例如，你不能用这个名称创建一个表。）</p>
<p>以下说明了PostgreSQL标准扩展：</p>
<div class="highlight"><pre><span></span><code>create table t2(
  k int primary key,
  one_dimensional_array int[],
  two_dimensional_array int[10][10]);
</code></pre></div>
<h6 id="nullnull"># 原子为Null与所有值为Null的对比</h6>
<p>这里是一个示例：</p>
<div class="highlight"><pre><span></span><code>create table t(k int primary key, v int[]);
insert into t(k) values(1);
insert into t(k, v) values (2, &#39;{null}&#39;::int[]);
\pset null &#39;&lt;is null&gt;&#39;
select k, v, array_dims(v) as dims from t order by k;
</code></pre></div>
<p>显示如下：</p>
<div class="highlight"><pre><span></span><code> k |     v     |   dims
---+-----------+-----------
 1 | &lt;is null&gt; | &lt;is null&gt;
 2 | {NULL}    | [1:1]
</code></pre></div>
<p>因为“v”没有约束，所以它可以是NULL，就像它的数据类型是标量一样。对于具有“k=1”的行，情况就是这样。在这里，“v”被称为原子Null。（这个术语通常只在数据类型是复合的时使用，以区分结果与“k=2”行的结果，而其中“v”不是原子Null）。第一行的“v”的数组属性，就像它的维度一样，都是NULL。但对于第二行，它们是有意义的值，而不是NULL。继续看如下示例：</p>
<div class="highlight"><pre><span></span><code>update t set v = v||&#39;{null}&#39;::int[] where k = 2;
select k, v, array_dims(v) as dims from t where k = 2;
</code></pre></div>
<p>查询显示如下：</p>
<div class="highlight"><pre><span></span><code> k |      v      | dims
---+-------------+-------
 2 | {NULL,NULL} | [1:2]
</code></pre></div>
<p>这里，第二行的“v”，虽然不是原子NULL，但其所有值都为NULL。它的维度不能改变，但因为它是一个一维数组，所以它的长度可以扩展，如上所述。这是允许的： </p>
<div class="highlight"><pre><span></span><code>update t set v[0] = 17 where k = 2;
select k, v, array_dims(v) as dims from t where k = 2;
</code></pre></div>
<p>查询显示如下：</p>
<div class="highlight"><pre><span></span><code> k |             v             | dims
---+---------------------------+-------
 2 | [0:3]={17,NULL,NULL,NULL} | [0:3]
</code></pre></div>
<p>同理，如下也是可以的：</p>
<div class="highlight"><pre><span></span><code>update t set v[1] = 42 where k = 1;
select k, v, array_dims(v) as dims from t where k = 1;
</code></pre></div>
<p>查询显示如下：</p>
<div class="highlight"><pre><span></span><code> k |  v   | dims
---+------+-------
 1 | {42} | [1:1]
</code></pre></div>
<h6 id="_3"># 类型构造</h6>
<p>数组并不是类型构造的唯一示例。“row”类型和DOMAIN也是如此，示例如下：</p>
<div class="highlight"><pre><span></span><code>create type rec_t as(f1 int, f2 text);
</code></pre></div>
<div class="highlight"><pre><span></span><code>create domain medal_t as text
check(
  length(value) &lt;= 6 and
  value in (&#39;gold&#39;, &#39;silver&#39;, &#39;bronze&#39;)
);
</code></pre></div>
<div class="highlight"><pre><span></span><code>create table t3(k int primary key, rec rec_t, medal medal_t);
</code></pre></div>
<p>请注意，必须将“row”类型或DOMAIN定义为架构对象。但是，在创建表或编写PL/pgSQL代码时，您可以定义数组的数据类型，如上所示。换句话说，您不能命名构造数组类型。相反，您只能“动态”使用它来定义列、PL/pgSQL变量或PL/pgSQL形式参数的数据类型。</p>
<h6 id="_4"># 数组应用</h6>
<p>首先，观察如下示例中，将创建一个带有int[]列的表，并适当地填充二维数组。</p>
<div class="highlight"><pre><span></span><code>create table t ( k int primary key, v int[]);
</code></pre></div>
<div class="highlight"><pre><span></span><code>insert into t(k, v) values(1,
   &#39;{
      {11, 12, 13},
      {21, 22, 23}
    }
  &#39;::int[]);
</code></pre></div>
<p>接下来，查看插入的值，这里，使用::text，进行类型转换：</p>
<div class="highlight"><pre><span></span><code>select v::text from t where k = 1;
</code></pre></div>
<p>查询显示如下：</p>
<div class="highlight"><pre><span></span><code>            v
-------------------------
 {{11,12,13},{21,22,23}}
</code></pre></div>
<p>请注意，除了没有空格之外，与定义时，插入数组的文本内容完全相同。</p>
<p>接下来，检查插入的数组值，是否具有预期的属性：</p>
<div class="highlight"><pre><span></span><code>select
  array_ndims(v),
  array_length(v, 1),
  array_length(v, 2),
  array_dims(v)
from t where k = 1;
</code></pre></div>
<p>查询显示如下：</p>
<div class="highlight"><pre><span></span><code>  array_ndims | array_length | array_length | array_dims
------------+--------------+--------------+------------
              2 |              2 |               3 | [1:2][1:3]
</code></pre></div>
<p>array_ndims() 报告数组的维度；
array_length() 报告指定维度的长度（即该维度具有的值的数目）；
array_dims() 作为单个文本值显示相同的信息，就像对每个维度依次使用array_length（）一样。请注意，array_length（）为指定的维度返回一个int值。它的设计基于一条规则，例如二维数组必须是矩形。同样，三维阵列必须是长方体。
请注意，如下是违反规则的示例：</p>
<div class="highlight"><pre><span></span><code>insert into t(k, v) values(2,
   &#39;{
      {11, 12, 13},
      {21, 22, 23, 24}
    }
  &#39;::int[]);
</code></pre></div>
<p>最后，这个DO块显示了如何将二维数组中的值，可视化为矩形网格。</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  arr constant int[] not null:= &#39;{
      {11, 12, 13, 14},
      {21, 22, 23, 24},
      {31, 32, 33, 34}
    }&#39;::int[];

  ndims constant int not null := array_ndims(arr);
  line text;
begin
  if array_ndims(arr) &lt;&gt; 2 then
    raise exception &#39;This code handles only a two-dimensional array.&#39;;
  end if;

  declare
    len1 constant int not null := array_length(arr, 1);
    len2 constant int not null := array_length(arr, 2);
  begin
    for row in 1..len1 loop
      line := &#39; &#39;;
      for col in 1..len2 loop
        line := line||lpad(arr[row][col]::text, 5);
      end loop;
      raise info &#39;%&#39;, line;
    end loop;
  end;
end;
$body$;
</code></pre></div>
<p>查询显示类似如下：</p>
<div class="highlight"><pre><span></span><code>   11   12   13   14
   21   22   23   24
   31   32   33   34
</code></pre></div>
<p>这种方法对于具有更高维度的数组，或第二维度较大的二维数组来说并不实用。相反，这里包含的代码仅仅是为了展示如何处理各个元素。隐式声明的FOR循环变量“row”和“col”的名称直观地对应于值在定义数组值的文字中的排列方式。嵌套循环被设计为以所谓的行主顺序访问值（最后一个下标变化最快）。 
例如，当比较相同维度的多维数组的值时，按此顺序访问它们，并以与比较标量值相同的方式成对进行比较。
请注意，在上面的示例中，每个维度中的第一个值的索引值为1。当数组值是使用文本创建的，而对索引值不提及时，就会出现这种情况。下一个示例显示了如何控制每个维度的索引值的起点和终点。 </p>
<div class="highlight"><pre><span></span><code>\pset null &#39;&lt;is null&gt;&#39;
with v as (
  select &#39;[2:4][5:8]=
    {
      {25, 26, 27, 28},
      {35, 36, 37, 38},
      {45, 46, 47, 48}
    }&#39;::int[] as arr)
select
  arr[0][0] as &quot;[0][0]&quot;,
  arr[2][5] as &quot;[2][5]&quot;,
  arr[2][8] as &quot;[2][8]&quot;,
  arr[4][5] as &quot;[4][5]&quot;,
  arr[4][8] as &quot;[4][8]&quot;,
  arr[9][9] as &quot;[9][9]&quot;
from v;
</code></pre></div>
<p>在此语法中，[2:4]意味着索引在第一个维度上从2到4；[5:8]意味着在第二维度上从5到8。此例中，选择这些值是仅仅为了说明这一点。当然，您必须为每个维度提供正确数量的值。查询会产生以下结果：</p>
<div class="highlight"><pre><span></span><code>  [0][0]   | [2][5] | [2][8] | [4][5] | [4][8] |  [9][9]
-----------+--------+--------+--------+--------+-----------
 &lt;is null&gt; |     25 |     28 |     45 |     48 | &lt;is null&gt;
</code></pre></div>
<p>请注意，如果您访问的元素的索引值超出了定义值的范围，那么，如前所述，您会得到NULL。 
数组中的值，在内部，是通过按行主顺序连续排列来存储的。因为每个值都有相同的数据类型，这意味着可以在没有索引支持的情况下，通过计算其偏移量来快速处理感兴趣的值。值本身就可以知道它的维度。这也解释了如何将不同维度的数组存储在单个表列中。即使表示是可变长度的（例如文本值），每一个都知道自己的长度，因此可以计算值边界值。</p>
<h6 id="_5"># 数组应用示例</h6>
<p>业余自行车手喜欢使用GPS设备记录他们的行程，然后将记录的数据上传到一个专门用于此目的的互联网网站，这样他们就可以在未来，随时查看自己和其他人的行程。这样的网站可能会使用SQL数据库来存储所有这些行程。
GPS设备可以让骑自行车的人将行程分成连续的间隔，通常称为圈数，这样以后就可以将注意力集中在感兴趣的特定圈数上，比如陡坡。所以每次行程都有一圈，或多圈。一圈通常不超过100公里，通常更像5-10公里。但它可能大到300公里。在良好的条件下，现代设备的分辨率通常只有几步，比如3米。因此，一圈可能有多达100000个GPS数据点，每个数据点都记录时间戳、位置，以及其他相关的瞬时值，例如心率。
这看起来像是一个经典的三表设计，带有外键约束，捕捉一圈的GPS数据点，而这一圈又属于一次行程。数组类型允许属于一圈的所有GPS数据点，记录在“圈”表的单行中，换句话说，其是作为多值字段存储的，例如如下设计：</p>
<div class="highlight"><pre><span></span><code>create type gps_data_point_t as (
  ts          timestamp,
  lat         numeric,
  long        numeric,
  alt         numeric,
  cadence     int,
  heart_rate  int

  );
</code></pre></div>
<div class="highlight"><pre><span></span><code>create table trips(
  trip_start_ts    timestamp,
  userid           uuid,
  constraint trips_pk primary key (trip_start_ts, userid)
);
</code></pre></div>
<div class="highlight"><pre><span></span><code>create table laps(
  lap_start_ts     timestamp,
  trip_start_ts    timestamp,
  userid           uuid,
  gps_data_points  gps_data_point_t[],

  constraint laps_pk primary key (lap_start_ts, trip_start_ts, userid),

  constraint laps_fk foreign key (trip_start_ts, userid)
    references trips(trip_start_ts, userid)
    match full on delete cascade on update restrict);
</code></pre></div>
<p>注：在PostgreSQL中，任何维度的数组可以容纳的最大值为（2^27-1）（约1.37亿）。如果超过此限制，则会得到一个“54000:数组大小超过允许的最大值（134217727）”的错误。这映射到PL/pgSQL异常“program_limit_exceeded”。在PostgreSQL中，数组的值不是按行存储的。然而，在AiSQL BSQL子系统中，它们是按行存储的，例如，就像json或jsonb值一样。因此，BSQL数组可以容纳的最大值数小于PostgreSQL的限制。此外，实际的BSQL限制取决于具体情况，当超过时，会出现“超时”错误。实验表明，该极限值约为3000万。您可以使用array_fill（）函数对其进行测试。</p>
<h6 id="array_1"><strong>array[]构造函数</strong></h6>
<h6 id="_6"># 用途与用法</h6>
<p>array[]值构造函数是一个特殊的变量函数，使用方括号（[]）将实际参数列表括起来。</p>
<p>用途：使用数组的值表达式创建数组。这样的表达式本身可以使用array[]构造函数或数组文本。 </p>
<p>用法：
输入值:       [anyarray | [ anyelement, [anyelement]* ]
返回值:      anyarray</p>
<p>下述函数用以创建一个数组： </p>
<ul>
<li>array_fill()：创建一个指定形状的“空白画布”数组，所有值都设置为所需值。</li>
<li>array_agg()：从SQL子查询创建一个数组（通常为隐含的“row”类型）。</li>
<li>text_to_array()：从单个文本值创建一个text[]数组，该数组使用可指定的分隔符将其分隔为各个值。</li>
</ul>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>create type rt as (f1 int, f2 text);
select array[(1, &#39;a&#39;)::rt, (2, &#39;b&#39;)::rt, (3, &#39;dog \ house&#39;)::rt]::rt[] as arr;
</code></pre></div>
<p>查询显示如下：</p>
<div class="highlight"><pre><span></span><code>                    arr
--------------------------------------------
 {&quot;(1,a)&quot;,&quot;(2,b)&quot;,&quot;(3,\&quot;dog \\\\ house\&quot;)&quot;}
</code></pre></div>
<p>无论何时，显示在bsqlsh中的数组，都会经过隐式的::text类型转换。通过查询该文本值，并将其转换为适当的数组数据类型，可以重新创建起始值。BSQL文档将这种形式的文本称为其规范形式。它的特点是除了文本标量值和日期时间标量值之外，完全没有空白。</p>
<h6 id="plpgsqlarray"># 在PL/pgSQL代码中使用array[]构造函数</h6>
<p>下面的示例会在一段代码中提出许多要点。
当array[]构造函数使用的表达式都是文本文字时，实际的语法要比控制如何构造数组文字的语法简单得多。
您可以在PL/pgSQL代码中使用所有BSQL数组功能，就像在SQL语句中一样。代码创建并调用一个表函数，而不仅仅是一个DO块，来强调这一互操作性。
类似数组的功能在任何编程语言中都是必不可少的。
当array[]构造函数使用声明的变量（尤其是用于构建任何预期值的形式参数）组成表达式时，最有价值的。在本例中，值是用户定义的数据类型“rt”。换句话说，当您从运行时首先知道的标量值是以编程方式构建数组时，array[]构造函数特别有价值。
它生动地展示了array[]构造函数的语义效果，如下所示： </p>
<div class="highlight"><pre><span></span><code>declare
  r     rt[];
  two_d rt[];
begin
  ...
  assert (array_dims(r) = &#39;[1:3]&#39;), &#39;assert failed&#39;;
  one_d_1 := array[r[1], r[2], r[3]];
  assert (one_d_1 = r), &#39;assert failed&#39;;
</code></pre></div>
<p>运行此操作以创建所需的用户定义的“row”类型和表函数，然后调用它。</p>
<div class="highlight"><pre><span></span><code>-- Don&#39;t create &quot;type rt&quot; if it&#39;s still there following the previous example.
create type rt as (f1 int, f2 text);

create function some_arrays()
  returns table(arr text)
  language plpgsql
as $body$
declare
  i1 constant int := 1;
  t1 constant text := &#39;a&#39;;
  r1 constant rt := (i1, t1);

  i2 constant int := 2;
  t2 constant text := &#39;b&#39;;
  r2 constant rt := (i2, t2);

  i3 constant int := 3;
  t3 constant text := &#39;dog \ house&#39;;
  r3 constant rt := (i3, t3);

  a1 constant rt[] := array[r1, r2, r3];
begin
  arr := a1::text;
  return next;

  declare
    r rt[];
    one_d_1 rt[];
    one_d_2 rt[];
    one_d_3 rt[];
    two_d   rt[];
    n int not null := 0;
  begin
    ----------------------------------------------
    -- Show how arrays are useful, in the classic
    -- sense, as what EVERY programming language
    -- needs to handle a number of items when the
    -- number isn&#39;t known until run time.
    for j in 1..3 loop
      n := j + 100;
      r[j] := (n, chr(n));
    end loop;

    -- This further demonstrates the semantics
    -- of the array[] constructor.
    assert (array_dims(r) = &#39;[1:3]&#39;), &#39;assert failed&#39;;
    one_d_1 := array[r[1], r[2], r[3]];
    assert (one_d_1 = r), &#39;assert failed&#39;;
    ----------------------------------------------

    one_d_2 := array[(104, chr(104)), (105, chr(105)), (106, chr(106))];
    one_d_3 := array[(107, chr(107)), (108, chr(108)), (109, chr(109))];

    -- Show how the expressions that define the outcome
    -- of the array[] constructor can themselves be arrays.
    two_d := array[one_d_1, one_d_2, one_d_3];
    arr := two_d::text;
    return next;
  end;

end;
$body$;

select arr from some_arrays();
</code></pre></div>
<p>产生两行，下面是第一行：</p>
<div class="highlight"><pre><span></span><code>                    arr
--------------------------------------------
 {&quot;(1,a)&quot;,&quot;(2,b)&quot;,&quot;(3,\&quot;dog \\\\ house\&quot;)&quot;}
</code></pre></div>
<p>这是第二行。通过手动添加一些空白，提高了可读性： </p>
<div class="highlight"><pre><span></span><code>{
  {&quot;(101,e)&quot;,&quot;(102,f)&quot;,&quot;(103,g)&quot;},
  {&quot;(104,h)&quot;,&quot;(105,i)&quot;,&quot;(106,j)&quot;},
  {&quot;(107,k)&quot;,&quot;(108,l)&quot;,&quot;(109,m)&quot;}
}
</code></pre></div>
<h6 id="array_2"># 在准备好的语句中使用array[]构造函数</h6>
<p>这个示例强调了使用array[]构造函数，而不是使用数组文本文字的价值，因为它允许您在其中使用类似chr() 的表达式。</p>
<div class="highlight"><pre><span></span><code>-- Don&#39;t create &quot;type rt&quot; if it&#39;s still there followng the previous examples.
create type rt as (f1 int, f2 text);
create table t(k serial primary key, arr rt[]);

prepare stmt(rt[]) as insert into t(arr) values($1);

-- It&#39;s essential to typecast the individual &quot;rt&quot; values.
execute stmt(array[(104, chr(104))::rt, (105, chr(105))::rt, (106, chr(106))::rt]);
</code></pre></div>
<p>使用数组文本文字作为实际参数来执行准备好的语句，在语义上是等效的：</p>
<div class="highlight"><pre><span></span><code>execute stmt(&#39;{&quot;(104,h)&quot;,&quot;(105,i)&quot;,&quot;(106,j)&quot;}&#39;);
</code></pre></div>
<p>但在这里，当然，你只需要事先知道chr(104)是h，依此类推。因此，证明准备语句的两次执行的结果是相同的：</p>
<div class="highlight"><pre><span></span><code>select
  (
    (select arr from t where k = 1)
    =
    (select arr from t where k = 2)
  )::text as result;
</code></pre></div>
<p>显示如下：</p>
<div class="highlight"><pre><span></span><code> result
--------
 true
</code></pre></div>
<h6 id="_7"><strong>常量</strong></h6>
<p>本节通过几个示例非正式地介绍数组文字。下面列出的小节正式解释了如何构造语法正确的数组文字，以确定创建想要的值。
数组文本文字以左大括号开头，接下来是数组值的一些逗号分隔的文本文字表示。有时，值的表示不需要双引号，但也可以使用双引号，但有时值的表示必须使用双引号，然后数组文本文字以右大括号结束。
根据数组的数据类型，其值可能是标量，也可能是复合值。
例如，它们可能是“row”类型的值；或者它们可以是数组。多维数组的文本文字被写成数组的数组，等等。它们甚至可能是基于数组数据类型的用户定义DOMAIN的值。这个强大的概念将在专门的使用DOMAIN值数组一节中讨论。
要在SQL或PL/pgSQL中使用这样的文本文字，必须以与普通文本文本相同的方式对其进行查询。如果这符合您的目标，您可以使用美元引号查询数组文字，就像您可以查询文本文字一样。有时，您需要在右引号后面为所需的数组数据类型添加合适的类型转换运算符。有时，使用上下文唯一地决定了文本文字的数据类型。推荐使用显式地类型转换。 
在这里，SQL SELECT语句中使用的，是基于int值的一维数组的文本文字：</p>
<div class="highlight"><pre><span></span><code>\t on
select &#39;{1, 2, 3}&#39;::int[];
</code></pre></div>
<p>\t on 元命令禁止列标题，并在这些标题下取消规则。除非标题很重要，否则bsqlsh的查询输出将在当前的“数组”主要部分中显示，而不显示这些。</p>
<p>这是第一个示例产生的输出： </p>
<div class="highlight"><pre><span></span><code>{1,2,3}
</code></pre></div>
<p>第二个示例，是使用双引号，来引起数组文本文字定义的值：</p>
<div class="highlight"><pre><span></span><code>select &#39;{&quot;1&quot;, &quot;2&quot;, &quot;3&quot;}&#39;::int[];
</code></pre></div>
<p>它产生的输出与第一个示例相同，其中没有使用双引号。</p>
<p>第三个示例定义了int值的二维数组： </p>
<div class="highlight"><pre><span></span><code>select &#39;
   {
      {11, 12, 13},
      {21, 22, 23}
    }
  &#39;::int[];
</code></pre></div>
<p>输出返回如下信息：</p>
<div class="highlight"><pre><span></span><code> {{11,12,13},{21,22,23}}
</code></pre></div>
<p>第四个示例定义了一个数组，其值是“row”类型的实例： </p>
<div class="highlight"><pre><span></span><code>create type rt as (f1 int, f2 text);

select &#39;
  {
    &quot;(1,a1 a2)&quot;,
    &quot;(2,b1 b2)&quot;,
    &quot;(3,c1 v2)&quot;
  }
&#39;::rt[];
</code></pre></div>
<p>输出返回如下信息：</p>
<div class="highlight"><pre><span></span><code>{&quot;(1,\&quot;a1 a2\&quot;)&quot;,&quot;(2,\&quot;b1 b2\&quot;)&quot;,&quot;(3,\&quot;c1 v2\&quot;)&quot;}
</code></pre></div>
<p>所有空白（除了文本值中的空白之外）都已删除。每个“row”类型值的表示形式周围的双引号将被保留（删除会导致“22P02:格式错误的行文字”错误）。最值得注意的是，在每个“row”类型值的表示中，有明显的规则与每个文本的值有关。 </p>
<p>以下各节仔细介绍了规则，并在规则允许情况下，提出一定的建议。</p>
<h6 id="_8"># 值文本类型转换、该值的文本文字，以及它们之间的关系</h6>
<p>本节建立了一些基本概念，这些概念的适用范围远不止数组。但是，因为使用数组文本文字是基于这些概念，所以在这里对它们进行了总结。</p>
<h6 id="_9">## <em>值到文本的类型转换和返回值</em></h6>
<p>考虑以下模式：</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  original   constant &lt;some data type&gt;  not null := &lt;some value&gt;;
  text_cast  constant text              not null := original::text;
  recreated  constant &lt;some data type&gt;  not null := text_cast::&lt;some data type&gt;;
begin
  assert
    (recreated = original),
  &#39;assert failed&#39;;
end;
$body$;
</code></pre></div>
<p>它展示了BSQL从PostgreSQL继承的一个通用规则： </p>
<ul>
<li>任意数据类型的任意值都可以使用::text转换。类似地，总是存在一个文本值，当拼写正确时，可以将其类型转换为任何所需数据类型的值，无论是基本还是复合数据类型。</li>
<li>如果使用::text对任何数据类型的值进行类型转换，然后将该文本值类型转换为原始值的数据类型，则获得的值与原始值相同。 </li>
</ul>
<p>如下的DO块使用基本和复合数据类型的代表性范围应用模式（不包括退化大小写的数据类型text）。它还显示每个数据类型的::text转换值。</p>
<div class="highlight"><pre><span></span><code>-- Needed by the &#39;1-d array of &quot;row&quot; type values&#39; test.
create type rt as (n numeric, s text, t timestamp, b boolean);

-- Needed by the &#39;Ragged array&#39; test.
create domain int_arr_t as int[];

do $body$
begin
  -- numeric
  declare
    original   constant numeric  not null := 42.1763;
    text_cast  constant text     not null := original::text;
    recreated  constant numeric  not null := text_cast::numeric;
  begin
    assert
      (recreated = original),
    &#39;assert failed&#39;;
    raise info &#39;numeric:              %&#39;, text_cast;
  end;

  -- timestamp
  declare
    original   constant timestamp  not null := now()::timestamp;
    text_cast  constant text       not null := original::text;
    recreated  constant timestamp  not null := text_cast::timestamp;
  begin
    assert
      (recreated = original),
    &#39;assert failed&#39;;
    raise info &#39;timestamp:            %&#39;, text_cast;
  end;

  -- timestamp with timezone
  declare
    original   constant timestamptz  not null := now()::timestamptz;
    text_cast  constant text         not null := original::text;
    recreated  constant timestamptz  not null := text_cast::timestamp;
  begin
    assert
      (recreated = original),
    &#39;assert failed&#39;;
    raise info &#39;timestamptz:          %&#39;, text_cast;
  end;

  -- boolean
  declare
    original   constant boolean  not null := true;
    text_cast  constant text     not null := original::text;
    recreated  constant boolean  not null := text_cast::boolean;
  begin
    assert
      (recreated = original),
    &#39;assert failed&#39;;
    raise info &#39;boolean:              %&#39;, text_cast;
  end;

  -- &quot;row&quot; type
  declare
    original   constant rt    not null := row(42.1763, &#39;dog house&#39;, now(), true);
    text_cast  constant text  not null := original::text;
    recreated  constant rt    not null := text_cast::rt;
  begin
    assert
      (recreated = original),
    &#39;assert failed&#39;;
    raise info &#39;&quot;row&quot; type:           %&#39;, text_cast;
  end;

  -- 2-d array
  declare
    original   constant int[]  not null := array[array[1, 2], array[3, 4]];
    text_cast  constant text   not null := original::text;
    recreated  constant int[]  not null := text_cast::int[];
  begin
    assert
      (recreated = original),
    &#39;assert failed&#39;;
    raise info &#39;2-d array             %&#39;, text_cast;
  end;

  -- 1-d array of &quot;row&quot; type values
  declare
    original   constant rt[]  not null :=
      array[
        row(42.1763, &#39;dog house&#39;, now(),                    true),
        row(19.8651, &#39;cat flap&#39;,  now() + interval &#39;1&#39; day, false)
      ];
    text_cast  constant text  not null := original::text;
    recreated  constant rt[]  not null := text_cast::rt[];
  begin
    assert
      (recreated = original),
    &#39;assert failed&#39;;
    raise info &#39;array of &quot;row&quot; type:  %&#39;, text_cast;
  end;

  -- Ragged array: 1-d array of 1-da arrays of different lengths.
  declare
    arr_1      constant int_arr_t    not null := array[1, 2];
    arr_2      constant int_arr_t    not null := array[3, 4, 5];
    original   constant int_arr_t[]  not null := array[arr_1, arr_2];
    text_cast  constant text         not null := original::text;
    recreated  constant int_arr_t[]  not null := text_cast::int_arr_t[];
  begin
    assert
      (recreated = original),
    &#39;assert failed&#39;;
    raise info &#39;array of arrays:      %&#39;, text_cast;
  end;
end;
$body$;
</code></pre></div>
<p>输出如下类似结果（在手动删除每个输出行上的“INFO:”提示）</p>
<div class="highlight"><pre><span></span><code>numeric:              42.1763
timestamp:            2020-05-03 22:25:42.932771
timestamptz:          2020-05-03 22:25:42.932771-07
boolean:              true
&quot;row&quot; type:           (42.1763,&quot;dog house&quot;,&quot;2020-05-03 22:25:42.932771&quot;,t)
2-d array             {{1,2},{3,4}}
array of &quot;row&quot; type:  {&quot;(42.1763,\&quot;dog house\&quot;,\&quot;2020-05-03 22:25:42.932771\&quot;,t)&quot;,&quot;(19.8651,\&quot;cat flap\&quot;,\&quot;2020-05-04 22:25:42.932771\&quot;,f)&quot;}
array of arrays:      {&quot;{1,2}&quot;,&quot;{3,4,5}&quot;}
</code></pre></div>
<p>请注意数组的数组的text值语法与二维数组text值的语法的比较。因为数组的数组是不规则的，所以两个内部{}对分别包含两个和三个值。为了区分这种情况和普通的直线情况，内{}对被双引号包围。</p>
<h6 id="bsqlsh">## <em>布尔值显示在bsqlsh中的特殊文本形式</em></h6>
<p>尝试执行如下脚本：</p>
<div class="highlight"><pre><span></span><code>select true as &quot;bare true&quot;, true::text as &quot;true::text&quot;;
</code></pre></div>
<p>返回如下：</p>
<div class="highlight"><pre><span></span><code> bare true | true::text
-----------+------------
 t         | true
</code></pre></div>
<p>对于除布尔值以外的所有值，bsqlsh用于显示任何值的字符串都是该值的::text 类型转换。毕竟，唯一可行的显示方式是字符串。但对于关键字TRUE和FALSE表示的两个布尔值，它唯一使用的是单个字符t和f，而不是它们的::text 类型转换，除非显式类型转换。 
此行为是从psql继承来的。
从上面可以看到，即使显式地::text 类型转换为复合值，TRUE和FALSE也表示为t和f。您不能影响此结果，因为它与派生类型转换文本的规则有关，而与bsqlsh使用的约定无关。这种不对称性是多年前建立的，无法改变。</p>
<h6 id="text">## <em>值的text类型转换与创建该值的文字之间的关系</em></h6>
<p>尝试执行如下脚本：</p>
<div class="highlight"><pre><span></span><code>select
  42.932771::numeric          as n,
  &#39;cat&#39;::text                 as t1,
  $$dog&#39;s breakfast$$::text   as t2,
  array[1, 2, 3]::int[]       as &quot;int array&quot;;
</code></pre></div>
<p>输出如下类似结果</p>
<div class="highlight"><pre><span></span><code>  n     | t1  |       t2      | int array
-----------+-----+---------------------+-----------
42.932771 | cat | dog&#39;s breakfast  | {1,2,3}}
</code></pre></div>
<p>首先考虑这一点：</p>
<div class="highlight"><pre><span></span><code>42.932771::numeric
</code></pre></div>
<p>这是SQL语言（至少在BSQL和PostgreSQL中）用来建立相应的强类型数值的文字。PL/pgSQL使用相同的形式用于相同的目的。但是，显而易见的是，SQL语句和PL/pgSQL源只不过是字符串。这意味着，在目前的情况下，这个： </p>
<div class="highlight"><pre><span></span><code>42.932771
</code></pre></div>
<p>是文本文字</p>
<p>接下来，考虑如下：</p>
<div class="highlight"><pre><span></span><code>&#39;cat&#39;::text          $$dog&#39;s breakfast$$::text
</code></pre></div>
<p>SQL和PL/pgSQL的解析规则（或者更恰当地说，这两种语言的语法定义）都要求对文本文本进行查询。此外，有两种句法机制可以做到这一点：普通的单引号；以及所谓的美元符号，其中$$是更一般的$anything_you_want$的特例。您可能会认为::text类型转换在这里是多余的。但不要忘记，这些文字的文本可能用于建立varchar或char值。 
可以看到，组成数字文字和文本文字的规则是不同的：</p>
<ul>
<li>您可以使用纯文本编写指定带有::numeric转换运算符的预期值的数字文本。</li>
<li>您可以使用纯文本编写指定带有::text 转换运算符的预期值的文本文字。
  （如果你确实在数字文本中查询了纯文本，那么你不会看到错误。相反，你会得到隐含但不期望的行为：首先，会在内部生成一个真正的文本值，然后，它会被转换为数字值。）
  您已经看到了一些数组文字的示例。规则如下：</li>
<li>通过用专用语法编写一个以左大括号开始、以右大括号结束，可以编写指定预期值的纯文本，此语法是使用文本文字创建数组值的剩余部分的重点。然后查询这个纯文本（无论您选择如何引用），然后将其类型转换为所需的目标数组数据类型。</li>
</ul>
<p>这些是一个更一般规则的三种特殊情况。在某些情况下（例如，在“row”类型值的文字中），查询机制可能是可选的（取决于预期值），并且在编写时使用双引号作为查询字符。但在这里，一般规则也是一样的。指定预期值的纯文本始终可以正确地写成该值的::text类型转换。</p>
<p>一般规则
如下是一般规则：</p>
<ul>
<li>任何数据类型的值的文本都可能是指定预期值的查询纯文本，后面是所需目标数据类型的转换运算符。</li>
<li>这个规则被递归应用于复合值的文字，但在不同的嵌套级别上有不同的实际规则。例如，数组值的文字作为一个整体必须是类型转换的。但是，因为数组中每个值的数据类型都已经确定，所以指定这些值的纯文本不是类型转换的。</li>
<li>任何值的::text类型转换都可以用作将重新创建该值的文字的纯文本。 </li>
</ul>
<p>您可以看到创建数组值的文字的文本示例，方法是使用构造函数创建值，然后检查其::text类型转换。但是，为预期值创建文本的安全方法是理解支配其组成的语法和语义。</p>
<h6 id="_10">## <em>定义“文字的规范形式”</em></h6>
<p>术语“规范形式”专门适用于文字的文本，而不是整个文字。但是，当文字的文本是规范形式时，文字作为一个整体也是规范形式的。 
产生任何数据类型的特定值的文本的规范形式是该值的::text 类型转换。 
“数组数据类型和功能”主要部分中的许多示例表明，除了规范形式外，数组文本的许多拼写还会产生特定的目标值。不同之处在于空格、标点符号和转义符的使用方式。</p>
<h6 id="_11"><strong>基础值数字文字文本</strong></h6>
<p>本节介绍了足够多的规则子集，这些规则允许您编写语法正确的数组文字，该文字表示您可能想要创建的任何标量数据类型的数组。全套规则比这里所说的规则更具灵活性。但因为这些是足够的，所以这里没有记录完整的、相当复杂的集合。本节中的解释肯定允许您解释您可能看到的任何数组值的 ::text类型转换，例如在bsqlsh中，阐述了AiSQL在这一领域的建议，然后举例说明这些规则。</p>
<h6 id="_12"># 规则声明</h6>
<p>这些规则的声明取决于对文字规范形式概念的理解。定义“文本的规范形式”解释说，任何类型的数组的::text 类型转换都会向您表明，这种形式的文本（更仔细地说，是这个文本的文字）可以用于重新创建该值。
事实上，这个定义，以及文字的规范形式足以重新创建值的属性，适用于所有数据类型的值。
数组中的每个值都必须具有相同的数据类型。如果遵循规则，那么将始终生成一个语法有效的文本。事实证明，许多其他变体，尤其是text[]数组，都是合法的，可以产生您想要的值。然而，外来用途的规则将不会被记录下来，因为以规范的形式创建文本文字已经足够了。
这是一套足够充分的规则：</p>
<ul>
<li>分隔连续值的逗号、包含整个文字的大括号，以及多维数组的文字中使用的内部大括号，可以被任意数量的空格包围。如果想严格遵守规范的形式，那么不应该这样做。但是这样做可以提高临时手动键入文字的可读性，它还可以使在以编程方式构造数组文字的程序中读取跟踪输出变得更加容易。</li>
<li>在numeric 和boolean 数组文字中，不要用双引号将各个值括起来。 </li>
<li>在timestamp[]数组的文本中，请使用双引号将各个值括起来，尽管这不是绝对必要的。</li>
<li>在text[]数组的文本中，用双引号将每个单独的值括起来，尽管这并不总是必要的。但是对于本身包含最外层大括号对，其中具有语法意义的任何空白或任何字符，却是必要的。以下是列表：
  <space>   {   }   ,   "   \</li>
<li>通常在括起来的双引号内写大括号和逗号就足够了。但是，每个双引号字符和反斜杠字符，都必须使用紧挨在前的单个反斜杠进行转义。</li>
</ul>
<h6 id="_13"># 以规范形式写入数组文本文字</h6>
<p>一般来讲，很少会像本节演示规则那样手动键入文本，可能只有在自学、构建新代码原型或调试时，才会这样做。通常，会在客户端程序中以编程方式创建文本，该程序解析数据值，例如，XML文本文件，或者，可能是JSON文本文件。在这些场景中，目标数组的数据类型可能为“some_user_defined_row_type[]”。当以编程方式创建时，希望使用最简单的规则工作，并且无需省略不必要的双引号字符。</p>
<p>注：AiSQL建议，通过编程生成的数组文本文字始终使用规范表示进行拼写</p>
<p>您可以放宽这一建议，以便更容易地跟踪或调试代码，方法是在数组中的每个连续编码值之间使用一换行符，至少当值本身使用大量字符时是这样，因为它们可能用于“row”类型的值。
注意：您希望您使用的客户端编程语言，以及用于向AiSQL发布SQL和检索结果的驱动程序，允许直接使用映射到BSQL数组和“row”类型的数据类型，就像它们具有映射到int、text、timestamp和boolean的标量数据类型一样。例如，Python有映射到数组的“list”，映射到“row”类型的“tuple”。用于AiSQL的“psycopg2”驱动程序可以将这些数据类型的值映射到，如下所示的PREPARE语句。
注意：BSQL支持将JSON数组（其中包括JSON对象的JSON数组）直接转换为相应的BSQL数组值。
在“row”类型值数组的文本部分中，描述了为“row”型值数组构造文本的规则。
您的程序将解析输入，并创建所需的文字作为普通文本字符串，然后将其作为PREPARE语句执行的实际参数提供，将文本实际参数的类型转换为适当的数组数据类型，提供给准备好的INSERT或UPDATE语句，如下所示： </p>
<div class="highlight"><pre><span></span><code>prepare stmt(text) as insert into t(rs) values($1::rt[]);
</code></pre></div>
<p>假设在本例中，“rt”是某个特定的用户定义的“row”类型。</p>
<h6 id="_14"># 举例说明规则</h6>
<p>以下是基本数据类型值的数组的一些示例：</p>
<ul>
<li>数值数组（如int和numeric）</li>
<li>字符串值数组（如text、varchar和char）</li>
<li>日期-时间值数组（如时间戳）</li>
<li>布尔值数组。</li>
</ul>
<p>为了解释说明数组文本文字构造的规则，只考虑这些规则就已经足够了。
使用array[]构造函数来创建每种类型，并检查其::text类型转换 </p>
<h6 id="int">## <em>int值的一维数组</em></h6>
<p>看一下如下示例： </p>
<div class="highlight"><pre><span></span><code>create table t(k serial primary key, v1 int[], v2 int[]);
insert into t(v1) values (array[1, 2, 3]);
select v1::text as text_typecast from t where k = 1
\gset result_
\echo :result_text_typecast
</code></pre></div>
<p>此示例演示了以下原则：
“数组数据类型和功能”章节部分中的array_agg（）和unnest（），使用了\gset meta命令。
请注意，在本例中，SELECT语句由下一行的\gset 元命令终止，而不是由通常的分号终止。\echo 元命令显示以下内容：</p>
<div class="highlight"><pre><span></span><code>{1,2,3}
</code></pre></div>
<p>您已经可以看到一般形式如：</p>
<ul>
<li>数组文本文字的以左大括号开始，以右大括号结束。</li>
<li>大括号内的项由逗号分隔，项、逗号，于下一项之间没有空格。左大括号和第一个项之间，或者最后一项和右大括号之间，均没有任何空格。 </li>
</ul>
<p>文本值的一维数组表明，还需要说明更多内容。但你已经注意到的两条规则始终适用。
若要使用生成的文本文字来创建值，必须对其进行查询，并进行类型转换。请使用\set 元命令执行以下操作：</p>
<div class="highlight"><pre><span></span><code>\set canonical_literal &#39;\&#39;&#39;:result_text_typecast&#39;\&#39;::int[]&#39;
\echo :canonical_literal
</code></pre></div>
<p>\echo 元命令显示以下内容： </p>
<div class="highlight"><pre><span></span><code>&#39;{1,2,3}&#39;::int[]
</code></pre></div>
<p>接下来，使用生成的规范文本来更新“t.v2”，以确认行构造函数创建的值已重新创建：</p>
<div class="highlight"><pre><span></span><code>update t set v2 = :canonical_literal where k = 1;
select (v1 = v2)::text as &quot;v1 = v2&quot; from t where k = 1;
</code></pre></div>
<p>查询返回如下：</p>
<div class="highlight"><pre><span></span><code> v1 = v2
---------
 true
</code></pre></div>
<p>可以看到，数组文字的规范形式确实重新创建了array[]构造函数创建的相同值。</p>
<p>注意：
尝试执行如下：</p>
<div class="highlight"><pre><span></span><code>select 12512454.872::text;
</code></pre></div>
<p>结果是规范形式，12512454.872</p>
<div class="highlight"><pre><span></span><code>select 12512454.872::numeric;
</code></pre></div>
<p>运行时也没有出现错误。现在试试这个</p>
<div class="highlight"><pre><span></span><code>select to_number(&#39;12,512,454.872&#39;, &#39;999G999G999D999999&#39;)::text;

This, too, runs without error because it uses the to_number() built-in function. The result here, too, is the canonical form, 12512454.872—with no commas. Now try this:
</code></pre></div>
<p>由于它使用了to_number（）内置函数，因此运行时也不会出错。这里的结果也是规范形式，12512454.872，没有逗号。现在试试这个：</p>
<div class="highlight"><pre><span></span><code>select &#39;12,512,454.872&#39;::numeric;
</code></pre></div>
<p>这个会引发“22P02:类型数字的无效输入语法”错误。换句话说，只有规范形式的数值才能使用::numeric直接进行类型转换。</p>
<p>这里，使用数组文字，是对以下内容第一次了解。现在，把它的语法理解为你直觉上所期望的意思。必须以规范形式拼写numeric[] 数组中值的表示形式。请尝试以下操作：</p>
<div class="highlight"><pre><span></span><code>select (&#39;{123.456, -456.789}&#39;::numeric[])::text;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code> {123.456,-456.789}
</code></pre></div>
<p>继续尝试如下操作：</p>
<div class="highlight"><pre><span></span><code>select (&#39;{9,123.456, -8,456.789}&#39;::numeric[])::text;
</code></pre></div>
<p>它会无声地产生这种可能是意外的结果（四个数值的数组），因为逗号被用作分隔符，而不是单个数值表示的一部分：</p>
<div class="highlight"><pre><span></span><code> {9,123.456,-8,456.789}
</code></pre></div>
<p>在数组文字（或“row”类型值文字）中，无法容纳不能直接进行类型转换的表单。（时间戳值和数值也是如此。）BSQL从PostgreSQL继承了这一限制。在准备文本文字时，用户有责任解决这个问题，因为，像“to_number()”这样的函数不能在文字中使用。然而，函数可以在值构造函数中使用，如array[]值构造函数所示 ：</p>
<h6 id="text_1">## <em>一维text值数组</em></h6>
<p>看一下如下示例：</p>
<div class="highlight"><pre><span></span><code>create table t(k serial primary key, v1 text[], v2 text[]);
insert into t(v1) values (array[&#39;a&#39;, &#39;a b&#39;, &#39;()&#39;, &#39;,&#39;, &#39;{}&#39;, $$&#39;$$, &#39;&quot;&#39;, &#39;\&#39;]);
select v1::text as text_typecast from t where k = 1
\gset result_
\echo :result_text_typecast
</code></pre></div>
<p>出于特殊原因，数组值本身必须被引起来，需要一些特殊的东西构成单引号，才能在SQL中使用，此时，美元符号就是一个方便的选择。\echo 元命令显示以下内容：</p>
<div class="highlight"><pre><span></span><code>{a,&quot;a b&quot;,(),&quot;,&quot;,&quot;{}&quot;,&#39;,&quot;\&quot;&quot;,&quot;\\&quot;}
</code></pre></div>
<p>这或许很难解析。为了使规则更易于查看，此列表不会显示左和右大括号。语法上有意义的逗号两边各有四个空格：</p>
<pre><code>a    ,    "a b"    ,    ()    ,    ","    ,    "{}"    '    ,    "\\""    ,    "\\\\"
</code></pre>
<p>除了前两条规则外，还应注意以下： </p>
<ul>
<li>双引号用于将包含任何空格的值括起来。（虽然示例中没有显示，但这也适用于前导空格和尾随空格。）</li>
<li>左右括号没有用双引号括起来。尽管这些在其他解析上下文中具有语法意义，但在数组文字的大括号中是无关紧要的。</li>
<li>逗号被双引号括起来。这是因为，它在数组文字的大括号中，作为值分隔符，确实具有语法意义。</li>
<li>大括号被双引号括起来。这是因为，内部大括号在多维数组的数组文字中确实具有语法意义，如下所示。</li>
<li>单引号不会被双引号括起来。尽管它在其他解析上下文中具有语法意义，但在数组文字的大括号中是无关紧要的。这也适用于其他各种标点符号，比如 ; 和 : 和 [ 和 ] 等等。</li>
<li>双引号用一个反斜杠转义，然后用双引号括起来。这是因为它作为（唯一的）引用机制，在数组文字的大括号中确实具有语法意义。 </li>
<li>反斜杠也用另一个单反斜杠转义，然后用双引号将其括起来。这是因为它作为转义符在数组文字的大括号中确实具有语法意义。
  还有另一条规则，这个示例没有显示出来。虽然不是每个逗号分隔的值都被双引号括起来，但这样做没有坏处。你可以通过自己的测试来证实这一点，AiSQL建议，为了保持一致性，你总是用双引号将text[]数组文字的每个文本值都括在大括号内。
  若要使用上面生成的文本来重新创建值，必须对其进行查询，并进行类型转换。请使用\set 元命令执行此操作，就像对上面的int[] 示例所做的那样。但您必须使用美元符号，因为文字本身有一个内部单引号。</li>
</ul>
<div class="highlight"><pre><span></span><code>\set canonical_literal &#39;$$&#39;:result_text_typecast&#39;$$&#39;::text[]
\echo :canonical_literal
</code></pre></div>
<p>\echo 元命令现在显示以下内容：</p>
<div class="highlight"><pre><span></span><code>$${a,&quot;a b&quot;,(),&quot;,&quot;,&#39;,&quot;\&quot;&quot;,&quot;\\&quot;}$$::text[]
</code></pre></div>
<p>接下来，使用规范文本更新“t.v2”，来确认行构造函数创建的值已重新创建：</p>
<div class="highlight"><pre><span></span><code>update t set v2 = :canonical_literal where k = 1;
select (v1 = v2)::text as &quot;v1 = v2&quot; from t where k = 1;
</code></pre></div>
<p>应该返回如下信息：</p>
<div class="highlight"><pre><span></span><code> v1 = v2
---------
 true
</code></pre></div>
<h6 id="timestamp">## <em>一维timestamp值数组</em></h6>
<p>看一下如下示例：</p>
<div class="highlight"><pre><span></span><code>create table t(k serial primary key, v1 timestamp[], v2 timestamp[]);
insert into t(v1) values (array[
    &#39;2019-01-27 11:48:33&#39;::timestamp,
    &#39;2020-03-30 14:19:21&#39;::timestamp
  ]);
select v1::text as text_typecast from t where k = 1
\gset result_
\echo :result_text_typecast
</code></pre></div>
<p>\echo 元命令现在显示以下内容：</p>
<div class="highlight"><pre><span></span><code>{&quot;2019-01-27 11:48:33&quot;,&quot;2020-03-30 14:19:21&quot;}
</code></pre></div>
<p>您可以从中进一步了解一条规则：</p>
<ul>
<li>大括号中的::timestamp类型转换字符串用双引号括起来。</li>
</ul>
<p>若要使用生成的文本来创建值，必须对其进行查询，并进行类型转换。请使用\set 元命令执行此操作：</p>
<div class="highlight"><pre><span></span><code>\set canonical_literal &#39;\&#39;&#39;:result_text_typecast&#39;\&#39;::timestamp[]&#39;
\echo :canonical_literal
</code></pre></div>
<p>\echo 元命令现在显示以下内容：</p>
<div class="highlight"><pre><span></span><code>&#39;{&quot;2019-01-27 11:48:33&quot;,&quot;2020-03-30 14:19:21&quot;}&#39;::timestamp[]
</code></pre></div>
<p>接下来，使用规范文本更新“t.v2”，来确认行构造函数创建的值已重新创建：</p>
<div class="highlight"><pre><span></span><code>update t set v2 = :canonical_literal where k = 1;
select (v1 = v2)::text as &quot;v1 = v2&quot; from t where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> v1 = v2
---------
 true
</code></pre></div>
<h6 id="booleannull">## <em>一维Boolean值数组（通常为NULL）</em></h6>
<p>看一下如下示例：</p>
<div class="highlight"><pre><span></span><code>create table t(k serial primary key, v1 boolean[], v2 boolean[]);
insert into t(v1) values (array[
    true,
    false,
    null
  ]);
select v1::text as text_typecast from t where k = 1
\gset result_
\echo :result_text_typecast
</code></pre></div>
<p>\echo 元命令现在显示以下内容：</p>
<div class="highlight"><pre><span></span><code>{t,f,NULL}
</code></pre></div>
<p>可从中了解两条规则:</p>
<ul>
<li>boolean[]数组的花括号中，TRUE和FALSE的规范表示为t和f。它们不被双引号括起来。</li>
<li>指定NULL，规范形式使用大写NULL，并且不使用双引号将其括起来。</li>
</ul>
<p>尽管示例中没有显示这一点，但NULL不区分大小写。但要编写一个符合规范形式的文字，您应该使用大写字母拼写。这就是在任何数据类型的数组文字中指定NULL的方法。（不同的规则适用于“row”类型值的文字中的字段）。 </p>
<p>注意：如果您在text[]数组的文本中括起来NULL，那么它将被无声地解释为一个普通的文本值。
若要使用生成的文字来创建值，必须对其进行查询，并进行类型转换。请使用\set 元命令执行以下操作：</p>
<div class="highlight"><pre><span></span><code>\set canonical_literal &#39;\&#39;&#39;:result_text_typecast&#39;\&#39;::boolean[]&#39;
\echo :canonical_literal
</code></pre></div>
<p>\echo 元命令现在显示以下内容：</p>
<div class="highlight"><pre><span></span><code>&#39;{t,f,NULL}&#39;::boolean[]
</code></pre></div>
<p>接下来，使用规范文本更新“t.v2”，来确认行构造函数创建的值已被重新创建：</p>
<div class="highlight"><pre><span></span><code>update t set v2 = :canonical_literal where k = 1;
select (v1 = v2)::text as &quot;v1 = v2&quot; from t where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> v1 = v2
---------
 true
</code></pre></div>
<h6 id="int_1">## <em>int值的多维数组</em></h6>
<p>看一下如下示例：</p>
<div class="highlight"><pre><span></span><code>create table t(k serial primary key, v int[]);

-- Insert a 1-dimensional int[] value.
insert into t(v) values(&#39;
    {1,  2}
  &#39;::int[]);

-- Insert a 2-dimensional int[] value.
insert into t(v) values(&#39;
    {
      {1,  2},
      {3,  4}
    }
  &#39;::int[]);

-- Insert a 3-dimensional int[] value.
insert into t(v) values(&#39;
    {
      {
        {1,  2}, {3,  4}
      },
      {
        {5,  6}, {7,  8}
      }
    }
  &#39;::int[]);

-- Insert a 3-dimensional int[] value, specifying
-- the lower and upper bounds along each dimension.
insert into t(v) values(&#39;
    [3:4][5:6][7:8]=
    {
      {
        {1,  2}, {3,  4}
      },
      {
        {5,  6}, {7,  8}
      }
    }
  &#39;::int[]);

select k, array_ndims(v) as &quot;ndims&quot;, v::text as &quot;v::text&quot; from t order by k;
</code></pre></div>
<p>请注意，三个不同的INSERT语句定义了具有不同维度的数组。这说明了大纲中所解释的内容：列“t.v”可以包含任何维度的数组值。</p>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k | ndims |                    v::text
---+-------+-----------------------------------------------
 1 |     1 | {1,2}
 2 |     2 | {{1,2},{3,4}}
 3 |     3 | {{{1,2},{3,4}},{{5,6},{7,8}}}
 4 |     3 | [3:4][5:6][7:8]={{{1,2},{3,4}},{{5,6},{7,8}}}
</code></pre></div>
<p>同样，为数值插入的文字中的空白是无关紧要的，而文本类型转换通常使用空白（实际上，缺少空白）。 </p>
<p>多维数组的文字根据维度有嵌套的｛｝对，最里面的一对包含基本数据类型值的文本文字。</p>
<p>请注意带有“k = 4”的行的数组文本文字的拼写。可选语法[3:4][5:6][7:8]分别指定第一维度、第二维度和第三维度的下界和上界。这与用于指定数组切片的语法相同。当没有指定边界时，它们都是从1开始，然后文本文字的规范形式不显示边界。</p>
<p>在指定边界时，可能会引发出错。如果您（隐含地）指定的沿每个轴的长度，与｛｝对之间列出的实际值中出现的长度不一致，则您会得到“22P02 invalid_text_representation”的错误： </p>
<div class="highlight"><pre><span></span><code>malformed array literal...
Specified array dimensions do not match array contents.
</code></pre></div>
<h6 id="row"><strong>“row”类型值的文本文字</strong></h6>
<p>“row”一词有两种不同的用法。模式级表中的行实际上是“row”类型的一个实例，换句话说，是一个“row”型值。在这种情况下，模式级别的“row”类型是作为执行CREATE TABLE语句的副作用而自动创建的。它与表同名。这是允许的，因为表和类型位于不同的命名空间中。此外，模式级表中的列可以具有用户定义的“row”类型作为其数据类型，在这种情况下，“row”类型不需要与表合作。</p>
<p>当您使用\df 元命令来显示函数时，您可能会看到术语“record”。简单地说，它是一种匿名的“row”类型。当您使用具有正确形式的“row”类型的文本文字，但省略了类型转换运算符时，将生成记录实例。如果你坚持推荐的做法，并且总是明确地键入这样的文字，那么你就不必试图理解什么是记录。您可以在PostgreSQL文档中阅读更多关于这些概念的相关信息。</p>
<h6 id="_15"># 规则声明</h6>
<p>如果您遵循这里所述的规则，并进行说明，那么您将始终生成一个语法有效的文本。事实证明，许多其他变体，尤其是text[]值，是合法的，可以产生您想要的结果。然而，管理这些外来用途的规则不会被记录下来，因为以规范的形式创建文本文字已经足够了。
规则如下：</p>
<ul>
<li>分隔连续值的逗号，以及左括号和右括号，不能被空格包围。</li>
<li>不要用双引号将数字和布尔基本数据类型的值括起来。</li>
<li>请用双引号将时间戳值的各个表示形式括起来，即使这不是绝对必要的。</li>
<li>请用双引号将文本值的每个单独表示形式括起来，即使这并不总是必要的。对于任何值，如普通文本，其本身包含最外层大括号对，其中具有语法意义的任何空白或任何字符，则都是必要的。以下是列表：
  \<space>   (   )   ,   "   \</li>
<li>那么，除了双引号字符本身和反斜杠字符之外，通常在括起来的双引号中写入所有特殊字符就足够了。双引号字符是通过将其加倍来转义的。并且反斜杠字符使用紧挨在前的单个反斜杠进行转义。 </li>
<li>要指定字段的值为NULL，必须在其位置周围的一对分隔符（左括号、逗号或右括号）之间不留空白。</li>
</ul>
<h6 id="_16"># 示例</h6>
<p>只考虑具有以下数据类型的字段的“row”类型就足够了解规则了： </p>
<ul>
<li>数字数据类型（如int和numeric）</li>
<li>字符串数据类型（如text、varchar和char）</li>
<li>日期-时间数据类型（如时间戳）</li>
<li>布尔数据类型。
  使用“row”类型构造函数创建每种类型，并检查其::text 类型转换。</li>
</ul>
<h6 id="introw">## <em>int字段的“row”类型</em></h6>
<p>看一下如下示例：</p>
<div class="highlight"><pre><span></span><code>create type row_t as (f1 int, f2 int, f3 int);
create table t(k serial primary key, v1 row_t, v2 row_t);
insert into t(v1) values (row(1, 2, 3)::row_t);
select v1::text as text_typecast from t where k = 1
\gset result_
\echo :result_text_typecast
</code></pre></div>
<p>关键字ROW命名“row”类型的构造函数函数，是可选的。 
“数组数据类型和功能”章节部分中的array_agg（）和unnest（），使用了\gset meta命令。
请注意，在本例中，SELECT语句由下一行的\gset 元命令终止，而不是由通常的分号终止。\echo 元命令显示以下内容：</p>
<div class="highlight"><pre><span></span><code>(1,2,3)
</code></pre></div>
<p>在这种情况下，::text类型转换的值与“row”类型构造函数的值具有相同的形式。但是，正如下文所示，情况并非如此。 
一般来说：</p>
<ul>
<li>“row”类型文字的（文本）以左括号开始，以右括号结束。
  括号内的项由逗号分隔，项、逗号和下一个项之间没有空格。左括号和第一项之间，或最后一项和右括号之间也没有空格。</li>
</ul>
<p>若要使用生成的文本文字来创建值，必须对其进行查询，并进行类型转换。请使用\set 元命令执行此操作：</p>
<div class="highlight"><pre><span></span><code>\set canonical_literal &#39;\&#39;&#39;:result_text_typecast&#39;\&#39;&#39;::row_t
\echo :canonical_literal
</code></pre></div>
<p>\echo 元命令显示以下内容：</p>
<div class="highlight"><pre><span></span><code>&#39;(1,2,3)&#39;::row_t
</code></pre></div>
<p>接下来，使用规范文本更新“t.v2”，来确认行构造函数创建的值已被重新创建：</p>
<div class="highlight"><pre><span></span><code>update t set v2 = :canonical_literal where k = 1;
select (v1 = v2)::text as &quot;v1 = v2&quot; from t where k = 1;
</code></pre></div>
<p>输出信息如下：</p>
<div class="highlight"><pre><span></span><code> v1 = v2
---------
 true
</code></pre></div>
<h6 id="textrow">## <em>text字段的“row”类型</em></h6>
<p>看一下如下示例：</p>
<div class="highlight"><pre><span></span><code>create type row_t as (f1 text, f2 text, f3 text, f4 text, f5 text, f6 text, f7 text, f8 text);
create table t(k serial primary key, v1 row_t, v2 row_t);
insert into t(v1) values (  (&#39;a&#39;, $$&#39;$$, &#39;a b&#39;, &#39;()&#39;, &#39;,&#39;, &#39;&quot;&#39;, &#39;\&#39;, null)::row_t);

select v1::text as text_typecast from t where k = 1
\gset result_
\echo :result_text_typecast
</code></pre></div>
<p>这里，省略了“row”类型构造函数函数中的ROW关键字，以强调其可选状态。
\echo 元命令显示以下内容：</p>
<div class="highlight"><pre><span></span><code>(a,&#39;,&quot;a b&quot;,&quot;()&quot;,&quot;,&quot;,&quot;&quot;&quot;&quot;,&quot;\\&quot;,)
</code></pre></div>
<p>这或许很难解析。为了使规则更易于查看，语法上有意义的逗号两边各用三个空格括起来：</p>
<p>(   a   ,   '   ,   "a b"   ,   "()"   ,   ","   ,   """"   ,   "\\"   ,   )</p>
<p>注意：为了便于阅读，此处引入空格仅用于此目的。与数组文字的情况不同，这样做实际上会影响文字产生的值。您将在本节末尾演示这一点。  </p>
<p>除了前两条规则外，还应注意以下：</p>
<ul>
<li>双引号用于将包含任何空格的值括起来。（虽然示例中没有显示，但这也适用于前导空格和尾随空格。）</li>
<li>逗号被双引号括起来。这是因为它作为值分隔符，在“row”类型文字的括号内确实具有语法意义。</li>
<li>括号被双引号括起来。这是因为这些确实具有句法意义。</li>
<li>单引号不会被双引号括起来。尽管它在其他解析上下文中具有语法意义，但在“row”类型文字的括号中是无关紧要的。这也适用于其他各种标点符号，比如 ; 和 : 和 [ 和 ] 等等。</li>
<li>双引号是通过将其加倍来转义的，然后用双引号将其括起来。这是因为它确实具有句法意义，作为（唯一的）引用机制，位于“row”类型文字的括号内。</li>
<li>反斜杠也用另一个单反斜杠转义，然后用双引号将其括起来。这是因为它确实具有语法意义，作为转义符，位于“row”类型文字的括号内。 </li>
<li>NULL在“row”类型的文字中表示为两个连续分隔符之间没有任何字符：左括号和第一个逗号之间，两个连续逗号之间，或最后一个逗号和右括号之间。
  还有另一条规则，这个示例没有显示出来。虽然不是每个逗号分隔的值都被双引号括起来，但这样做从来没有坏处。你可以通过自己的测试来证实这一点，AiSQL建议，为了保持一致性，你应该总是用双引号将“row”类型的括号内的每个文本值括起来。
  要使用生成的文本来创建值，必须对其进行查询，并进行类型转换。请使用\set 元命令执行此操作，就像上面的int示例一样。但您必须使用美元符号，因为文字本身有一个内部单引号。</li>
</ul>
<div class="highlight"><pre><span></span><code>\set canonical_literal &#39;$$&#39;:result_text_typecast&#39;$$&#39;::row_t
\echo :canonical_literal
</code></pre></div>
<p>\echo 元命令显示以下内容：</p>
<div class="highlight"><pre><span></span><code>$$(a,&#39;,&quot;a b&quot;,&quot;()&quot;,&quot;,&quot;,&quot;&quot;&quot;&quot;,&quot;\\&quot;,)$$::row_t
</code></pre></div>
<p>接下来，使用规范文本更新“t.v2”，来确认行构造函数创建的值已被重新创建：</p>
<div class="highlight"><pre><span></span><code>update t set v2 = :canonical_literal where k = 1;
select (v1 = v2)::text as &quot;v1 = v2&quot; from t where k = 1;
</code></pre></div>
<p>输出信息如下：</p>
<div class="highlight"><pre><span></span><code> v1 = v2
---------
 true
</code></pre></div>
<p>在本节的最后，考虑用空格括起来逗号分隔符的意义。如下示例：</p>
<div class="highlight"><pre><span></span><code>create type row_t as (f1 text, f2 text, f3 text);
select &#39;(   a   ,   &quot;(a b)&quot;   ,   c   )&#39;::row_t;;
</code></pre></div>
<p>输出信息如下：</p>
<div class="highlight"><pre><span></span><code> (&quot;   a   &quot;,&quot;   (a b)   &quot;,&quot;   c   &quot;)
</code></pre></div>
<p>可以将一对分隔符之间的整个字符序列都理解为值来理解这一点。双引号起到了内部逃逸机制的作用。仅当一对分隔符之间的值被解释为文本值时，该模型才成立（因为在此位置，这是被声明的“row”类型字段的数据类型）。 </p>
<p>这个规则与数组文字的规则不同，而且，也不同于JSON文档的规则。在这些情况下，值完全在双引号内，双引号外，标点符号周围的空格是无关紧要的。</p>
<p>注：AiSQL建议您始终使用“几乎规范”的文本形式。换句话说，即使不需要双引号，也要用双引号将每个文本值括起来，并且在这些双引号值，和每个此类值开头和结尾的分隔符之间不允许有空格。</p>
<h6 id="timestamprow">## <em>timestamp字段的“row”类型</em></h6>
<p>看一下如下示例：</p>
<div class="highlight"><pre><span></span><code>create type row_t as (f1 timestamp, f2 timestamp);
create table t(k serial primary key, v1 row_t, v2 row_t);
insert into t(v1) values ((&#39;2019-01-27 11:48:33&#39;, &#39;2020-03-30 14:19:21&#39;)::row_t);
select v1::text as text_typecast from t where k = 1
\gset result_
\echo :result_text_typecast 
</code></pre></div>
<p>\echo 元命令显示以下内容：</p>
<div class="highlight"><pre><span></span><code>(&quot;2019-01-27 11:48:33&quot;,&quot;2020-03-30 14:19:21&quot;)
</code></pre></div>
<p>若要使用生成的文本来创建值，必须对其进行查询，并进行类型转换。请使用\set 元命令执行此操作：</p>
<div class="highlight"><pre><span></span><code>\set canonical_literal &#39;\&#39;&#39;:result_text_typecast&#39;\&#39;&#39;::row_t
\echo :canonical_literal
</code></pre></div>
<p>\echo 元命令显示以下内容：</p>
<div class="highlight"><pre><span></span><code>&#39;(&quot;2019-01-27 11:48:33&quot;,&quot;2020-03-30 14:19:21&quot;)&#39;::row_t
</code></pre></div>
<p>接下来，使用规范文本更新“t.v2”，来确认行构造函数创建的值已被重新创建：</p>
<div class="highlight"><pre><span></span><code>update t set v2 = :canonical_literal where k = 1;
select (v1 = v2)::text as &quot;v1 = v2&quot; from t where k = 1;
</code></pre></div>
<p>输出信息如下：</p>
<div class="highlight"><pre><span></span><code> v1 = v2
---------
 true
</code></pre></div>
<h6 id="booleanrow">## <em>boolean字段的“row”类型</em></h6>
<p>看一下如下示例：</p>
<div class="highlight"><pre><span></span><code>create type row_t as (f1 boolean, f2 boolean, f3 boolean);
create table t(k serial primary key, v1 row_t, v2 row_t);
insert into t(v1) values ((true, false, null)::row_t);
select v1::text as text_typecast from t where k = 1
\gset result_
\echo :result_text_typecast 
</code></pre></div>
<p>\echo 元命令显示以下内容：</p>
<div class="highlight"><pre><span></span><code> (t,f,)
</code></pre></div>
<p>若要使用生成的文本来创建值，必须对其进行查询，并进行类型转换。请使用\set 元命令执行此操作：</p>
<div class="highlight"><pre><span></span><code>\set canonical_literal &#39;\&#39;&#39;:result_text_typecast&#39;\&#39;&#39;::row_t
\echo :canonical_literal
</code></pre></div>
<p>\echo 元命令显示以下内容：</p>
<div class="highlight"><pre><span></span><code>&#39;(t,f,)&#39;::row_t
</code></pre></div>
<p>接下来，使用规范文本更新“t.v2”，来确认行构造函数创建的值已被重新创建：</p>
<div class="highlight"><pre><span></span><code>update t set v2 = :canonical_literal where k = 1;
select (v1 = v2)::text as &quot;v1 = v2&quot; from t where k = 1;
</code></pre></div>
<p>输出信息如下：</p>
<div class="highlight"><pre><span></span><code> v1 = v2
---------
 true
</code></pre></div>
<h6 id="rowrow"># “Row”类型的文本文字与“Row”类型的构造函数</h6>
<p>类型构造函数和文本文字这两个概念在功能上有很大的不同。您可以使用DO块来演示差异，允许使用声明变量。使用SQL语句要付出更多的努力，因为您必须使用标量子查询来代替PL/pgSQL变量。ROW关键字在这里被故意省略，以强调其可选状态。</p>
<div class="highlight"><pre><span></span><code>create type rt as (n numeric, s text, t timestamp, b boolean);

do $body$
declare
  n constant numeric := 42.17;
  s constant text := &#39;dog house&#39;;
  t constant timestamp := &#39;2020-04-01 23:44:13&#39;;
  b constant boolean := true;
  r1 constant rt := (n, s, t, b)::rt;
  r2 constant rt := &#39;(42.17,&quot;dog house&quot;,&quot;2020-04-01 23:44:13&quot;,t)&#39;::rt;
begin
  assert r1 = r2, &#39;unexpected&#39;;
end;
$body$;
</code></pre></div>
<h6 id="row_1"><strong>“row”类型值数组的文本文字</strong></h6>
<p>现在，您将如何为基本数据类型值数组编写文本文字，与如何为“row”类型值编写文本文字的理解结合起来。</p>
<h6 id="_17"># 规则声明</h6>
<p>如果您遵循这里所述的规则，并进行说明，那么您将始终生成一个语法有效的文本。事实证明，许多其他变体，尤其是text[]值，是合法的，可以产生您想要的结果。然而，管理这些外来用途的规则不会被记录下来，因为以规范的形式创建文本文字已经足够了。
一般来说：</p>
<ul>
<li>从左大括号开始。</li>
<li>首先，根据“row”类型值的文本文字中列出的规则，为每个“row”型值准备文本文字。</li>
<li>要明白，当这些在数组的文本中的“row”类型值的文本中使用时，“row”本身必须用双引号括起来，就像时间戳值或包含空格或其他麻烦字符的文本值的规则一样。</li>
<li>“row”类型文字的括号内出现的任何双引号和反斜杠都必须再次转义：双引号变为反斜杠双引号；并且反斜杠变为反斜杠-反斜杠。 </li>
<li>为了避免错误地转义括起来的双引号，需要：
  进行内部转义
  用未转义的双引号将“row”类型值的完整表示形式括起来。 </li>
<li>最后用右大括号结束。 </li>
</ul>
<h6 id="_18"># 示例</h6>
<p>该示例使用了一个包含四个字段的“row”类型：一个int字段；一个text 字段；一个timestamp 字段；和一个boolean 字段。但要注意如下：
     \<space>     ,     (     )     "     \</p>
<p>首先，创建“row”类型： </p>
<p>接下来，创建一个具有数据类型为“rt”的列的表，填充六行数据，这些行在其文本字段中，使用上面列出的所有特别需要注意的字符：</p>
<div class="highlight"><pre><span></span><code>create table t1(k int primary key, v rt);
</code></pre></div>
<p>最后，通过在DO块中，使用适当类型的PL/pgSQL变量，自下而上构建“row”类型值来填充表，并检查结果。这种技术允许为本演示选择的实际基本数据类型值，被单独看做是每个数据类型所需的普通SQL文字。这使得代码比任何其他方法都更可读、更易于理解。换句话说，它表明，对于人工编写的代码来说，任何复合值的值构造函数的可用性，都远大于产生相同值的文字的可用性。</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  n1 constant int := 1;
  s1 constant text := &#39; &#39;;
  t1 constant timestamp := &#39;2091-01-20 12:10:05&#39;;
  b1 constant boolean := true;

  n2 constant int := 2;
  s2 constant text := &#39;,&#39;;
  t2 constant timestamp := &#39;2002-01-20 12:10:05&#39;;
  b2 constant boolean := false;

  n3 constant int := 3;
  s3 constant text := &#39;(&#39;;
  t3 constant timestamp := &#39;2003-01-20 12:10:05&#39;;
  b3 constant boolean := null;

  n4 constant int:= 4;
  s4 constant text := &#39;)&#39;;
  t4 constant timestamp := &#39;2004-01-20 12:10:05&#39;;
  b4 constant boolean := true;

  n5 constant int:= 5;
  s5 constant text := &#39;&quot;&#39;;
  t5 constant timestamp := &#39;2005-01-20 12:10:05&#39;;
  b5 constant boolean := false;

  n6 constant int:= 6;
  s6 constant text := &#39;\&#39;;
  t6 constant timestamp := &#39;2006-01-20 12:10:05&#39;;
  b6 constant boolean := null;
begin
  insert into t1(k, v) values
    (1, (n1, s1, t1, b1)),
    (2, (n2, s2, t2, b2)),
    (3, (n3, s3, t3, b3)),
    (4, (n4, s4, t4, b4)),
    (5, (n5, s5, t5, b5)),
    (6, (n6, s6, t6, b6));
end;
$body$;
</code></pre></div>
<div class="highlight"><pre><span></span><code>select v::text as lit from t1 order by k;
</code></pre></div>
<p>输出信息如下：</p>
<div class="highlight"><pre><span></span><code>               lit
----------------------------------
 (1,&quot; &quot;,&quot;2091-01-20 12:10:05&quot;,t)
 (2,&quot;,&quot;,&quot;2002-01-20 12:10:05&quot;,f)
 (3,&quot;(&quot;,&quot;2003-01-20 12:10:05&quot;,)
 (4,&quot;)&quot;,&quot;2004-01-20 12:10:05&quot;,t)
 (5,&quot;&quot;&quot;&quot;,&quot;2005-01-20 12:10:05&quot;,f)
 (6,&quot;\\&quot;,&quot;2006-01-20 12:10:05&quot;,)
</code></pre></div>
<p>int字段和timestamp字段是不起眼的，仅仅是为了满足规范形式的要求，时间戳值的表示必须是双引号的。布尔字段也不起眼，只要你记得NULL是通过在该字段周围的分隔符之间不留空格来表示的。这只留下文本字段供参考，以下是字段表示本身，没有分隔符的混乱：</p>
<pre><code> " "     ","     "("     ")"     """"     "\\\\"
</code></pre>
<p>前四个并不起眼，只要你记得这四个单独的字符中的每一个，如开头所示，通常都必须用双引号括起来。则，只剩下最后两个：</p>
<ul>
<li>源数据中出现的单双引号必须加倍，然后用双引号括起来。</li>
<li>源数据中出现的单个反斜杠必须加倍，然后用双引号括起来。</li>
</ul>
<p>接下来，通过使用array_agg() 函数，将这六个“row”类型值拼接到一个数组值中，如下所示：</p>
<div class="highlight"><pre><span></span><code>select array_agg(v order by k) from t1;
</code></pre></div>
<p>最后将此值插入到新表中，如下所示： </p>
<div class="highlight"><pre><span></span><code>create table t2(k int primary key, v1 rt[], v1_text_typecast text, v2 rt[]);
insert into t2(k, v1)
select 1, array_agg(v order by k) from t1;
</code></pre></div>
<p>您在前几节中使用的\get技术在这里是不可行的，因为它的大小有上限。因此，在这里，会将您通过文本类型转换“t2.v1”生成的文本插入到同一表中的“v1_text_typecast”字段中，如下所示：</p>
<div class="highlight"><pre><span></span><code>update t2 set v1_text_typecast =
(select v1::text from t2 where k = 1);
</code></pre></div>
<p>最后，使用这个数组文字来重新创建原始值，并检查它是否与您开始使用的值相同。</p>
<div class="highlight"><pre><span></span><code>update t2 set v2 =
(select v1_text_typecast from t2 where k = 1)::rt[];

select (v1 = v2)::text as &quot;v1 = v2&quot; from t2 where k = 1;
</code></pre></div>
<p>输出信息如下：</p>
<div class="highlight"><pre><span></span><code> v1 = v2
---------
 true
</code></pre></div>
<p>查看“row”类型值数组的文字：</p>
<div class="highlight"><pre><span></span><code>select v1_text_typecast from t2 where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>{
  &quot;(1,\&quot;a \&quot;,\&quot;2091-01-20 12:10:05\&quot;,t)&quot;,
  &quot;(2,\&quot;, \&quot;,\&quot;2002-01-20 12:10:05\&quot;,f)&quot;,
  &quot;(3,\&quot;( \&quot;,\&quot;2003-01-20 12:10:05\&quot;,)&quot;,
  &quot;(4,\&quot; )\&quot;,\&quot;2004-01-20 12:10:05\&quot;,t)&quot;,
  &quot;(5,\&quot;\&quot;\&quot;\&quot;,\&quot;2005-01-20 12:10:05\&quot;,f)&quot;,
  &quot;(6,\&quot;\\\\\&quot;,\&quot;2006-01-20 12:10:05\&quot;,)&quot;
}
</code></pre></div>
<p>注意：为了便于阅读，这里，手动添加了空格。</p>
<h6 id="row_2"># 用于为“row”类型值的一维数组生成文字的伪代码</h6>
<p>这个伪代码显示了如何创建一个“row”类型值的数组文字，这些值的格式与上面示例中的“type rt”的格式相同。输入是任意数量的"(n, s, t, b)"。下面的文本是从实际工作和测试的Python代码中派生出来的。编写该代码是为了验证算法的正确性。
伪代码保留了Python语句，其含义足够清晰，可以对算法进行描述。各种特殊字符都被设置为具有自我描述名称的显式常量。
请注意，该算法在开头大括号之后、每个“row”类型值的成对表示之间，以及结尾大括号之前，插入一新行。虽然严格地说，这意味着它产生的文字不是规范形式的，但这没有任何影响。</p>
<div class="highlight"><pre><span></span><code>&quot;Start a new array literal&quot;:
  wip_literal = lft_crly_brace + nl

&quot;For each next (n, s, t, b) tuple that defines a &quot;row&quot; type value&quot;:
  curr_rec = dbl_quote + lft_parens

  # Field &quot;n&quot; maps to a SQL numeric
  if n is None:
    curr_rec += comma
  else:
    curr_rec += (str(n) + comma)

  # Field &quot;s&quot; maps to a SQL text.
  if s is None:
    curr_rec += comma
  else:
    # First, do the escaping needed for any stringy value
    # as field in record literal value.
    s = s.replace(bk_slash, two_bk_slashes)
    s = s.replace(dbl_quote, two_dbl_quotes)
    s = dbl_quote + s + dbl_quote

    # Next, do the escaping to fix the bare record representation
    # for use as a array element.
    s = s.replace(bk_slash, two_bk_slashes)
    s = s.replace(dbl_quote, bk_slash_dbl_quote)
    curr_rec += (s + comma)

    # Field &quot;t&quot; maps to a SQL timestamp.
    if t is None:
      curr_rec += comma
    else:
      curr_rec += (bk_slash_dbl_quote + t + bk_slash_dbl_quote + comma)

    # Field &quot;b&quot; maps to a SQL boolean.
    # It&#39;s the last field, do nothing if it&#39;s neither &quot;t&quot; nor &quot;f&quot;
    if (b == &quot;t&quot; or b == &quot;f&quot;):
      curr_rec += b

  # Now there are no more inout tuples.
  curr_rec = curr_rec + rgt_parens + dbl_quote
  wip_literal = wip_literal + curr_rec + comma + nl

# Now there are no more input tuples.
&quot;Finish off&quot;:
  # Remove the final (comma + nl), put the nl back,
  # and add the closing curly brace.
  wip_literal = wip_literal[:-2] + nl + rgt_crly_brace
</code></pre></div>
<h5 id="plpgsql"><strong>PL/pgSQL中的数组循环</strong></h5>
<p>PL/pgSQL FOREACH循环是用于在数组上循环的专用语法。</p>
<h6 id="_19"><strong>概述</strong></h6>
<p>注意：下面有关以下涉及到的函数描述，请参见array_lower()、array_upper()、 array_ndims() 和 cardinality() 。涉及到的“行主顺序”术语，请参阅Joint中的“数组几何属性函数”章节。语法和语义显示了FOREACH循环头中SLICE关键字的使用位置。</p>
<ul>
<li>当SLICE子句的操作数为0时，适用于具有任意数量维度的迭代数组的一般情况，BSQL将其连续值按行主顺序分配给循环迭代器。在这里，它的效果在功能上类似于unnest()。 </li>
<li>对于迭代数组为一维的特殊情况，只有当SLICE子句的操作数为0时，FOREACH循环才有用。在使用中，它是一种语法上更紧凑的方式来实现FOR var In循环所实现的效果，如下所示：</li>
</ul>
<div class="highlight"><pre><span></span><code>for var in array_lower(iterand_arr, 1)..array_upper(iterand_arr, 1) loop
  ... iterand_arr[var] ...
end loop;
</code></pre></div>
<ul>
<li>当SLICE子句的操作数大于0，并且迭代数组的维度大于1时，FOREACH循环提供unnest()无法提供的功能。简单地说，当迭代数组有n个维度，并且SLICE子句的操作数是s时，BSQL将维度为s的切片（即子数组）分配给迭代器。这样一个切片中的值是迭代数组中的值，当使用第一个 (n - s) 索引的不同值来驱动迭代时，这些值会保留下来。下面两个伪代码块解释了这个想法：</li>
</ul>
<p>伪代码一：</p>
<div class="highlight"><pre><span></span><code>-- In this example, the SLICE operand is 1.
-- As a consequence, array_ndims(iterator_array) is 1.
-- Assume that array_ndims(iterand_arr) is 4.
-- There are therefore (4 - 1) = 3 nested loops in this pseudocode.
for i in array_lower(iterand_arr, 1)..array_upper(iterand_arr, 1) loop
  for j in array_lower(iterand_arr, 2)..array_upper(iterand_arr, 2) loop
    for k in array_lower(iterand_arr, 3)..array_upper(iterand_arr, 3) loop

      the (i, j, k)th iterator_array is set to
        iterand_arr[i][j][k][ for all values the remaining 4th index ]

    end loop;
  end loop;
end loop;
</code></pre></div>
<p>伪代码二：</p>
<div class="highlight"><pre><span></span><code>-- In this example, the SLICE operand is 3.
-- As a consequence, array_ndims(iterator_array) is 3.
-- Assume that array_ndims(iterand_arr) is 4.
-- There is therefore (4 - 3) = 1 nested loop in this pseudocode.
for i in array_lower(iterand_arr, 1)..array_upper(iterand_arr, 1) loop

  the (i)th iterator_array is set to
    iterand_arr[i][ for all values the remaining 2nd, 3rd, and 4th indexes ]

end loop;
</code></pre></div>
<p>下面的示例阐明了FOREACH的行为。</p>
<h6 id="_20"><strong>语法和语义</strong></h6>
<p>基本语法：
[ &lt;\<label>&gt; ]
FOREACH var [ SLICE non_negative_integer_literal ] IN ARRAY expression LOOP
  statements
END LOOP [ label ];</p>
<ul>
<li>var必须在FOREACH循环之前显式声明。</li>
<li>可选SLICE子句的操作数必须是非负整数。</li>
<li>假设表达式的数据类型为some_type[]。当使用SLICE 0时，var必须声明为some_type。
  当SLICE子句的操作数为正时，var必须声明为some_type[]。
  SLICE 0 has the same effect as omitting the SLICE clause.</li>
<li>SLICE 0等同于省略SLICE子句。</li>
<li>当使用SLICE 0或省略SLICE子句时，BSQL将数组中按行主顺序访问的每个值依次分配给var。</li>
<li>当SLICE子句的操作数为正时，BSQL根据以下规则将迭代数组的连续切片分配给var：
  1）所提取的切片都具有由该等式给出的相同维度：array_ndims(iterator_array) = slice_operand。
  2）提取的切片的数量由以下等式给出：number_of_slices = cardinality(iterand_array)/cardinality(iterator_array)
  3）SLICE操作数的值不得超过 array_ndims(iterator_array)
  4）当SLICE操作数的值等于array_ndims(iterator_array) - 1时，FOREACH循环只生成一个迭代器数组值，这与迭代数组相同。</li>
<li>因此，SLICE操作数的有用范围是：0 到 (array_ndims(iterator_array) - 1) </li>
</ul>
<h6 id="slice"><strong>在不带SLICE关键字的数组中循环使用值</strong></h6>
<p>该循环在功能上与FOR var IN循环相同。然而，在FOR循环中，BSQL会自动定义类型为int的var，其范围仅限于循环；但在FOREACH循环中，必须显式声明var，如上面“<a href="#_语法和语义">语法和语义</a>”部分所述。
示例如下：</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  arr1 int[] := array[1, 2];
  arr2 int[] := array[3, 4, 5];
  var int;
begin
  &lt;&lt;&quot;FOREACH eaxmple&quot;&gt;&gt;
  foreach var in array arr1||arr2 loop
    raise info &#39;%&#39;, var;
  end loop &quot;FOREACH eaxmple&quot;;
end;
$body$;
</code></pre></div>
<p>显示信息如下（为方便阅读，手动去除了“INFO:”提示）：</p>
<div class="highlight"><pre><span></span><code>1
2
3
4
5
</code></pre></div>
<p>下一个循环示例显示了以下注意事项： </p>
<ul>
<li>迭代数组是多维的</li>
<li>数组类型为“rt[]”，其中rt是用户定义的“row”类型。</li>
<li>上面使用“var”的语法点不需要由单个变量独占。相反，可以使用“f1”和“f2”来对应“rt”中的字段。</li>
<li>FOREACH循环后面跟着一个“cursor”循环，其SELECT语句使用unnest()。</li>
<li>FOREACH循环比“cursor”循环更简洁。您可以使用一对声明的变量“f1”和“f2”作为迭代器，而不会有任何麻烦（就像您可以使用类型为“rt”的单个变量“r”一样）。BSQL在这两种情况下都会处理正确的赋值。但是当你使用unnest()时，你必须自己处理这个问题。</li>
</ul>
<div class="highlight"><pre><span></span><code>create type rt as (f1 int, f2 text);

do $body$
declare
  a1 rt[] := array[(1, &#39;dog&#39;), (2, &#39;cat&#39;)];
  a2 rt[] := array[(3, &#39;ant&#39;), (4, &#39;rat&#39;)];
  arr rt[] := array[a1, a2];
  f1 int;
  f2 text;
begin
  raise info &#39;&#39;;
  raise info &#39;FOREACH&#39;;
  foreach f1, f2 in array arr loop
    raise info &#39;% | %&#39;, f1::text, f2;
  end loop;

  raise info &#39;&#39;;
  raise info &#39;unnest()&#39;;
  for f1, f2 in (
    with v as (
      select unnest(arr) as r)
    select (r).f1, (r).f2 from v)
  loop
    raise info &#39;% | %&#39;, f1::text, f2;
  end loop;
end;
$body$;
</code></pre></div>
<p>显示信息如下（为方便阅读，手动去除了“INFO:”提示）：</p>
<div class="highlight"><pre><span></span><code>FOREACH
1 | dog
2 | cat
3 | ant
4 | rat

unnest()
1 | dog
2 | cat
3 | ant
4 | rat
</code></pre></div>
<p>这表明FOREACH循环的使用（隐含的0作为SLICE子句的操作数）在功能上等同于 unnest()。</p>
<h6 id="slice_1"><strong>非零SLICE操作数在多维数组的内容上循环</strong></h6>
<p>首先，将三维二乘二乘二的数组存储在表中的 ::text[]字段中。随后，每个DO块都会使用它。
示例如下：</p>
<div class="highlight"><pre><span></span><code>create table t(k int primary key, arr text[] not null);
insert into t(k, arr) values(1, &#39;
  {
    {
      {001,002},
      {003,004}
    },
    {
      {005,006},
      {007,008}
    }
  }&#39;::text[]);
</code></pre></div>
<p>接下来，显示SLICE操作数使用错误值时的结果：</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  arr constant text[] not null := (select arr from t where k = 1);
  slice_iterator text[] not null := &#39;{?}&#39;;
begin
  raise info &#39;array_ndims(arr): %&#39;, array_ndims(arr)::text;
  foreach slice_iterator slice 4 in array arr loop
    raise info &#39;%&#39;, slice_iterator::text;
  end loop;
end;
$body$;
</code></pre></div>
<p>执行，会显示array_ndims（arr）：3，并且报告如下错误：</p>
<div class="highlight"><pre><span></span><code>ERROR:  slice dimension (4) is out of the valid range 0..3
</code></pre></div>
<p>此测试确认SLICE操作数的值不得超过迭代数组的维度。
如前所述，SLICE 0（或等效地省略SLICE子句）按行主顺序扫描数组值。下一个测试，使用SLICE 3，演示了当SLICE操作数等于迭代数组的维度时的含义。</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  arr constant text[] not null := (select arr from t where k = 1);
  slice_iterator text[] not null := &#39;{?}&#39;;
  n int not null := 0;
begin
  raise info &#39;FOREACH SLICE 3&#39;;
  n := 0;
  foreach slice_iterator slice 3 in array arr loop
    assert
      (array_ndims(slice_iterator) = 3) and
      (slice_iterator = arr)           ,
    &#39;assert failed&#39;;
    n := n + 1;
    raise info &#39;% | %&#39;, n::text, slice_iterator::text;
  end loop;
end;
$body$;
</code></pre></div>
<p>输出信息如下：</p>
<div class="highlight"><pre><span></span><code>FOREACH SLICE 3
1 | {{{001,002},{003,004}},{{005,006},{007,008}}}
</code></pre></div>
<p>FOREACH循环只生成一个迭代器切片。而且，正如assert所示，这与迭代数组完全相同。换句话说，将SLICE操作数设置为等于迭代数组的维度，而结果是明确定义的，这是没有用的。因此，使用这个示例迭代数组，SLICE操作数的有用范围是0..2。</p>
<p>接下来，使用SLICE 2来做测试：</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  arr constant text[] not null := (select arr from t where k = 1);
  slice_iterator text[] not null := &#39;{?}&#39;;
  n int not null := 0;
begin
  raise info &#39;FOREACH SLICE 2&#39;;
  n := 0;
  foreach slice_iterator slice 2 in array arr loop
    assert (array_ndims(slice_iterator) = 2), &#39;assert failed&#39;;
    n := n + 1;
    raise info &#39;% | %&#39;, n::text, slice_iterator::text;
  end loop;
end;
$body$;
</code></pre></div>
<p>输出信息如下：</p>
<div class="highlight"><pre><span></span><code>FOREACH SLICE 2
1 | {{001,002},{003,004}}
2 | {{005,006},{007,008}}
</code></pre></div>
<p>如assert所示，SLICE运算符的操作数决定了迭代器切片的维度。</p>
<p>再接下来，使用SLICE 1来做测试：</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  arr constant text[] not null := (select arr from t where k = 1);
  slice_iterator text[] not null := &#39;{?}&#39;;
  n int not null := 0;
begin
  raise info &#39;FOREACH SLICE 1&#39;;
  n := 0;
  foreach slice_iterator slice 1 in array arr loop
    assert (array_ndims(slice_iterator) = 1), &#39;assert failed&#39;;
    n := n + 1;
    raise info &#39;% | %&#39;, n::text, slice_iterator::text;
  end loop;
end;
$body$;
</code></pre></div>
<p>输出信息如下：</p>
<div class="highlight"><pre><span></span><code>FOREACH SLICE 1
1 | {001,002}
2 | {003,004}
3 | {005,006}
4 | {007,008}
</code></pre></div>
<p>最后，使用SLICE 0进行测试。请注意，现在，迭代器被声明为标量文本变量“var”：</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  arr constant text[] not null := (select arr from t where k = 1);
  var text not null := &#39;?&#39;;
  n int not null := 0;
begin
  raise info &#39;FOREACH SLICE 0&#39;;
  n := 0;
  foreach var slice 0 in array arr loop
    n := n + 1;
    raise info &#39;% | %&#39;, n::text, var;
  end loop;
end;
$body$;
</code></pre></div>
<p>输出信息如下：</p>
<div class="highlight"><pre><span></span><code>FOREACH SLICE 0
1 | 001
2 | 002
3 | 003
4 | 004
5 | 005
6 | 006
7 | 007
8 | 008
</code></pre></div>
<p>如下，在功能上等效于unnestt()：</p>
<div class="highlight"><pre><span></span><code>do $body$
&lt;&lt;b&gt;&gt;declare
  arr constant text[] not null := (select arr from t where k = 1);
  var text not null := &#39;?&#39;;
  n int not null := 0;
begin
  raise info &#39;unnest()&#39;;
  n := 0;
  for b.n, b.var in (
    with
      v1 as (
        select unnest(arr) as var),
      v2 as (
        select
          v1.var,
          row_number() over(order by v1.var) as n
        from v1)
    select v2.n, v2.var from v2)
  loop
    n := n + 1;
    raise info &#39;% | %&#39;, n::text, var;
  end loop;
end b;
$body$;
</code></pre></div>
<p>输出信息如下：</p>
<div class="highlight"><pre><span></span><code>FOREACH SLICE 0
1 | 001
2 | 002
3 | 003
4 | 004
5 | 005
6 | 006
7 | 007
8 | 008
</code></pre></div>
<h6 id="foreachdomain"><strong>使用FOREACH迭代DOMAIN值数组中的元素</strong></h6>
<p>您需要了解一些特殊注意事项才能实现此场景。将FOREACH与DOMAIN数组一起使用，请参阅“<a href="#_使用DOMAIN值数组">使用DOMAIN值数组</a>”进行了解。</p>
<div class="highlight"><pre><span></span><code>Using a wrapper PL/pgSQL table function to expose the SLICE operand as a formal parameter
</code></pre></div>
<h6 id="plpgsqlslice"><strong>使用包装PL/pgSQL表函数将SLICE操作数公开为形式参数</strong></h6>
<p>SLICE操作数必须是一个文字，这意味着只有两种方法可以将其参数化，而对于实际的应用程序代码来说，这两种方法都不令人满意。每一个都使用一个表函数，其输入是迭代数组和SLICE操作数的值，其输出是SETOF迭代器数组值。</p>
<ul>
<li>第一种方法：在一个普通的静态定义函数中封装一些特定范围的SLICE操作数值，该函数使用CASE语句来选择具有所需SLICE操作数字的FOREACH循环。这是不令人满意的，因为您必须预先决定支持的SLICE操作数值的范围。</li>
<li>第二种方法：通过将代码封装在静态定义的函数中，克服了预先确定支持的SLICE操作数值范围的限制，该函数进而动态生成具有所需FOREACH循环和SLICE操作数值的函数，然后动态调用该函数。但它并不令人满意，主要是因为动态生成和执行带来的性能成本。
  但是，实际应用程序代码的需求规范不太可能需要SLICE操作数的多个，或者可能只需要几个特定值。因此，在绝大多数实际重要的用例中，您可以在需要的地方准确地编写所需的代码。</li>
</ul>
<p>下面的代码使用第一种方法。它展示了一种常用又价值的PL/pgSQL编程技术：具有多态形式参数的用户定义函数和过程（在本例中为anyarray和anyelement）。示例中使用assert语句来确认如下预期关系：</p>
<ul>
<li>迭代数组的维数</li>
<li>SLICE操作数的值</li>
<li>迭代数组维度的长度</li>
<li>迭代数组和迭代器数组的基数</li>
<li>返回的迭代器值的数量。</li>
</ul>
<p>以下是基本封装。它是硬编码的，用于处理0..4范围内的SLICE操作数的值。</p>
<p>对于SLICE为0的迭代是一个标量，SLICE为其他值的是数组。请记住，输入形式参数定义相同的两个函数，不能通过其返回值的数据类型进行重载区分。因此，SLICE 0的FOREACH循环的封装是一个只有一个输入形式参数的专用函数：迭代数组。对于SLICE操作数的其他值，FOREACH循环的封装是具有两个输入形式参数的第二个函数：迭代数组和SLICE操作数值。如下所示两个示例： </p>
<p>第一个示例：</p>
<div class="highlight"><pre><span></span><code>-- First overload
create function array_slices(arr in anyarray)
  returns table(ret anyelement)
  language plpgsql
as $body$
declare
  no_of_values int not null := 0;
begin
  -- &quot;slice 0&quot; means the same
  -- as omitting the &quot;slice&quot; clause.
  foreach ret slice 0 in array arr
  loop
    no_of_values := no_of_values + 1;
    return next;
  end loop;
  assert
    (no_of_values = cardinality(arr)),
  &#39;array_slices 1st overload: no_of_values assert failed&#39;;
end;
$body$;
</code></pre></div>
<p>第二个示例：</p>
<div class="highlight"><pre><span></span><code>-- Second overload
create function array_slices(arr in anyarray, slice_operand in int)
  returns table(ret anyarray)
  language plpgsql
as $body$
declare
  no_of_values int not null := 0;
  lengths_product int not null := 0;
begin
  case slice_operand
    when 1 then
      lengths_product := array_length(arr, 4);
      foreach ret slice 1 in array arr
      loop
        no_of_values := no_of_values + 1;
        assert
          (array_ndims(ret) = 1)               and
          (cardinality(ret) = lengths_product) ,
        &#39;assert failed&#39;;
        return next;
      end loop;
      assert
        (no_of_values = cardinality(arr)/lengths_product),
      &#39;array_slices 2nd overload: no_of_values assert #1 failed&#39;;

    when 2 then
      lengths_product := array_length(arr, 4) *
                         array_length(arr, 3);
      foreach ret slice 2 in array arr
      loop
        no_of_values := no_of_values + 1;
        assert
          (array_ndims(ret) = 2)               and
          (cardinality(ret) = lengths_product) ,
        &#39;assert failed&#39;;
        return next;
      end loop;
      assert
        (no_of_values = cardinality(arr)/lengths_product),
      &#39;array_slices 2nd overload: no_of_values assert #2 failed&#39;;

    when 3 then
      lengths_product := array_length(arr, 4) *
                         array_length(arr, 3) *
                         array_length(arr, 2);
      foreach ret slice 3 in array arr
      loop
        no_of_values := no_of_values + 1;
        assert
          (array_ndims(ret) = 3)               and
          (cardinality(ret) = lengths_product) ,
        &#39;assert failed&#39;;
        return next;
      end loop;
      assert
        (no_of_values = cardinality(arr)/lengths_product),
      &#39;array_slices 2nd overload: no_of_values assert #3 failed&#39;;

    when 4 then
      lengths_product := array_length(arr, 4) *
                         array_length(arr, 3) *
                         array_length(arr, 2) *
                         array_length(arr, 1);
      foreach ret slice 4 in array arr
      loop
        no_of_values := no_of_values + 1;
        assert
          (array_ndims(ret) = 4)               and
          (cardinality(ret) = lengths_product) ,
        &#39;assert failed&#39;;
        return next;
      end loop;
      assert
        (no_of_values = cardinality(arr)/lengths_product),
      &#39;array_slices 2nd overload: no_of_values assert #4 failed&#39;;

    else
      raise exception &#39;slice_operand &gt; 4 not supported&#39;;
  end case;
end;
$body$;
</code></pre></div>
<p>可以看到，CASE的每个分支都是公式化地“生成”的，尽管是通过遵循可参数化的模式手动生成的。您可以将这些封装用于任何维度的迭代和数组。但是，您必须负责遵守SLICE操作数的值必须在可接受范围内的规则。否则，您将得到上面演示的类似错误： </p>
<div class="highlight"><pre><span></span><code>ERROR:  slice dimension % is out of the valid range 0..%
</code></pre></div>
<p>如下是一个测试封装模块，这个过程和生成要测试的迭代数组的函数都是维度为4的硬编码。</p>
<div class="highlight"><pre><span></span><code>-- Exercise each of the meaningful calls to array_slices().
--
-- You cannot declare local variables as &quot;anyelement&quot; or &quot;anyarray&quot;.
-- (The attempt causes a compilation error). It&#39;s obvious why.
-- It&#39;s the caller&#39;s responsibility to determine the
-- real type by using appropriate actual arguments.
-- &quot;val&quot; (scalar) and &quot;slice&quot; (array) are needed as FOREACH loop runners.
-- &quot;in out&quot; is used to avoid the nominal performance penalty
--  of extra copying brought by plain &quot;out&quot;.
-- The caller has no interest in whatever values they have
-- on return from this procedure.
--
-- NOTE: while you _can_ declare a local variable as
-- &quot;some_formal%type&quot;, you _cannot_ use that mechanism to declare
-- a scalar with the data type that defines an array when
-- all you have to anchor &quot;%type&quot; to is the array.
--
create procedure test_array_slices(
  -- The &quot;real&quot; formal.
  arr   in     anyarray,

  -- used as &quot;local varables
  val   in out anyelement,
  slice in out anyarray)
  language plpgsql
as $body$
declare
  arr_ndims constant int := array_ndims(arr);
begin
  assert
    (arr_ndims = 4),
  &#39;assert failed: test_array_slices() requires a 4-d array&#39;;
  raise info &#39;%&#39;, array_dims(arr);

  declare
    len_1 constant int := array_length(arr, 1);
    len_2 constant int := array_length(arr, 2);
    len_3 constant int := array_length(arr, 3);
    len_4 constant int := array_length(arr, 4);

    expected_slice_cardinalities constant int[] not null :=
      array[
        len_4,
        len_4*len_3,
        len_4*len_3,
        len_4*len_3*len_2,
        len_4*len_3*len_2*len_1];

    slice_cardinality int not null := 0;

    -- val anyelement not null := &#39;?&#39;;
    -- slice anyarray not null := &#39;{?}&#39;;
  begin
    raise info &#39;&#39;; raise info &#39;slice_operand: %&#39;, 0;

    for val in (select array_slices(arr)) loop
      raise info &#39;%&#39;, val::text;
    end loop;

    for slice_operand in 1..arr_ndims loop
      raise info &#39;&#39;; raise info &#39;slice_operand: %&#39;, slice_operand;

      for slice in (select array_slices(arr, slice_operand)) loop
        slice_cardinality := cardinality(slice);
        assert
          (array_ndims(slice) = slice_operand) ,
          (slice_cardinality = expected_slice_cardinalities[slice_operand]) ,
        &#39;assert failed.&#39;;
        raise info &#39;%&#39;, slice::text;
        if slice_operand = arr_ndims then
          assert (slice = arr), &#39;assert (slice = arr) failed&#39;;
        end if;
      end loop;
    end loop;
  end;
end;
$body$;
</code></pre></div>
<p>下面是一个生成四维数组的函数。请注意，“length”形式参数的实际参数必须是具有四个值的一维int[]数组。这些指定了沿输出数组的每个维度的长度。</p>
<div class="highlight"><pre><span></span><code>create function four_d_array(lengths in int[])
  returns text[]
  language plpgsql
as $body$
declare
  lengths_ndims       constant int := array_ndims(lengths);
  lengths_cardinality constant int := cardinality(lengths);
begin
  assert
    (lengths_ndims = 1)       and
    (lengths_cardinality = 4) ,
  &#39;assert failed: four_d_array() creates only a 4-d array.&#39;;

  declare
    -- Take the default for array_fill&#39;s optional 2nd formal:
    -- all lower bounds are 1.
    arr text[] not null := array_fill(&#39;00&#39;::text, lengths);
  begin
    -- For readability of the results, define the created array&#39;s values so that,
    -- when scanned in row-major order, they are seen to be a dense series
    -- that increases in even steps, 001, 002, 003, and so on.
    declare
      n int not null := 0;
    begin
      for i1 in 1..lengths[1] loop
        for i2 in 1..lengths[2] loop
          for i3 in 1..lengths[3] loop
            for i4 in 1..lengths[4] loop
              n := n + 1;
              arr[i1][i2][i3][i4] := ltrim(to_char(n, &#39;009&#39;));
            end loop;
          end loop;
        end loop;
      end loop;
    end;
    assert
      (array_ndims(arr) = lengths_cardinality),
    &#39;assert failed.&#39;;

    -- Sanity check. Include to demonstrate the useful
    -- terseness of the FOREACH loop.
    declare
      product int not null := 1;
      len int not null := 0;
    begin
      foreach len in array lengths loop
        product := product*len;
      end loop;
      assert
        (cardinality(arr) = product) ,
      &#39;assert failed.&#39;;
    end;
    return arr;
  end;
end;
$body$;

下面是一个测试调用的示例：
do $body$
declare
  arr constant text[] not null := four_d_array(&#39;{2, 2, 2, 2}&#39;::int[]);
  dummy_var text := &#39;?&#39;;
  dummy_arr text[] := &#39;{/}&#39;;
begin
  call test_array_slices(arr, dummy_var, dummy_arr);
end;
$body$;
</code></pre></div>
<p>返回信息如下（为方便阅读，手动去除了“INFO:”提示）：</p>
<div class="highlight"><pre><span></span><code>[1:2][1:2][1:2][1:2]

slice_operand: 0
001
002
003
004
005
006
007
008
009
010
011
012
013
014
015
016

slice_operand: 1
{001,002}
{003,004}
{005,006}
{007,008}
{009,010}
{011,012}
{013,014}
{015,016}

slice_operand: 2
{{001,002},{003,004}}
{{005,006},{007,008}}
{{009,010},{011,012}}
{{013,014},{015,016}}

slice_operand: 3
{{{001,002},{003,004}},{{005,006},{007,008}}}
{{{009,010},{011,012}},{{013,014},{015,016}}}

slice_operand: 4
{{{{001,002},{003,004}},{{005,006},{007,008}}},{{{009,010},{011,012}},{{013,014},{015,016}}}}
</code></pre></div>
<h5 id="domain"><strong>使用DOMAIN值数组</strong></h5>
<p>DOMAIN值的数组可以创建一个一维数组，其值本身就是不同长度的一维数组。概括地说，它允许您实现一个不规则的多维数组，从而打破了数组通常必须是线性化的限制。</p>
<h6 id="gps"><strong>示例：GPS行程数据</strong></h6>
<p>在某些用例中，不规则的结构是必不可少的。因此，大多数编程语言都会支持这一特性。
下面来查看此示例：GPS行程数据。考虑GPS的行程，其记录被分解为圈，因此：</p>
<ul>
<li>每次行程由一圈，或多圈组成。</li>
<li>每圈通常由大量的GPS数据点组成。 </li>
</ul>
<p>以下的实现可以达到期望： </p>
<ul>
<li>每个圈都被表示为“圈”表中的一行，该表含有作为GPS数据点数组实现的多值字段。</li>
<li>但每一次行程都由“行程”表中的一行代表，该行的圈数是“圈数”表中的某一子行。这个父子关系通常由外键约束来支持。但请注意，每圈的GPS点的数量可能与其他圈的点的数量不相同。</li>
</ul>
<p>接下来，下一个目标，是通过将整个行程表示为“行程”表中的一个不规则数组，而省去了单独的“圈数”表。该方案要求能够将行程表示为“GPS数据点数组”数据类型。换句话说，这取决于创建此类命名数据类型的能力，而DOMAIN 具有此种能力。</p>
<h6 id="_21"><strong>创建不规则数组</strong></h6>
<h6 id="_22"># 矛盾</h6>
<p>乍一看，定义表列、PL/pgSQL变量或形式参数的语法似乎存在阻碍目标实现的矛盾。例如，这个PL/pgSQL声明显然将“v”定义为一维数组。</p>
<div class="highlight"><pre><span></span><code>declare v int[];
</code></pre></div>
<p>然而，这个可执行部分首先将一个二维数组值（大小为三乘三）分配给“v”，将数组的每个值初始化为17。然后，它将三维数组值（大小为2乘2乘2）分配给“v”，将数组的每个值初始化为42：</p>
<div class="highlight"><pre><span></span><code>    begin
    v := array_fill(17, &#39;{3, 3}&#39;);
    ...
    v := array_fill(42, &#39;{2, 2, 2}&#39;);
</code></pre></div>
<p>数组数据类型和功能中指出了数组变量声明的属性，即它无法修复随后分配给该变量的值的维度。表中具有数组数据类型的列共享此属性，以便该列可以在不同的行中容纳不同维度的数组。这与以下“v1”和“v2”的声明虽然明显不同，但定义了相同的语义这一事实密切相关。</p>
<div class="highlight"><pre><span></span><code>declare
  v1 int[];
  v2 int[][];
</code></pre></div>
<p>这种句法上的怪癖恰恰说明了这个矛盾。“v2”是二维数组，还是int[]类型的数组？答案是两者都不是。相反，它是一个任意维度的数组。</p>
<p>那么如何编写数组的声明，你可能会猜测这会起作用：</p>
<div class="highlight"><pre><span></span><code>declare
  v (int[])[];

But this causes a compilation error. The paradox is exactly that int[] is anonymou
</code></pre></div>
<p>但这会导致编译错误。矛盾之处恰恰在于int[]是匿名的。</p>
<h6 id="_23"># 解决方案</h6>
<p>DOMAIN带来了打破限制的功能。首先，请执行以下操作：</p>
<div class="highlight"><pre><span></span><code>set client_min_messages = warning;
drop domain if exists int_arr_t cascade;
create domain int_arr_t as int[];
create table t(k serial primary key, v1 int_arr_t[], typecast text, v2 int_arr_t[]);
</code></pre></div>
<p>请注意，CREATE DOMAIN语句的使用是类型构造的一个示例。用户定义的数据类型“int_arr_t”就是这种构造的数据类型的一个示例。</p>
<p>列“v1”和“v2”现在可以存储数组的不规则数组。如下证明：</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  arr_1      constant int_arr_t := array[1, 2];
  arr_2      constant int_arr_t := array[3, 4, 5];
  ragged_arr constant int_arr_t[] := array[arr_1, arr_2];
begin
  insert into t(v1) values(ragged_arr);
end;
$body$;
</code></pre></div>
<p>通过使用DO块，通过自下而上构建来设置“ragged_arr”的值，可以强调它实际上是一个由不同长度的一维数组组成的一维数组。那么，它显然不是一个二维线性化数组。</p>
<p>现在使用<a href="#_值到文本的类型转换和返回值">值到文本的类型转换和返回值</a>解释的技术来检查不规则数组的::text类型转换，通过类型转换转换回原始数据类型的值。首先，请执行以下操作： </p>
<div class="highlight"><pre><span></span><code>update t
set typecast = v1::text
where k = 1;

select typecast from t where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>      typecast
---------------------
 {&quot;{1,2}&quot;,&quot;{3,4,5}&quot;}
</code></pre></div>
<p>接下来：</p>
<div class="highlight"><pre><span></span><code>update t
set v2 = typecast::int_arr_t[]
where k = 1;

select (v1 = v2)::text as &quot;v1 = v2&quot; from t where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> v1 = v2 
---------
 true
</code></pre></div>
<p>已重新创建原始值。</p>
<h6 id="_24"># 处理数组的不规则数组</h6>
<p>首先，考虑这个反例：</p>
<div class="highlight"><pre><span></span><code>\pset null &#39;&lt;IS NULL&#39;&gt;
with v as (
  select  &#39;{{1,2},{3,4}}&#39;::int[] as two_d_arr)
select
  two_d_arr[2][1] as &quot;[2][1] -- meaningful&quot;,
  two_d_arr[2]    as    &quot;[2] -- meaningless&quot;
from v;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> [2][1] -- meaningful | [2] -- meaningless
----------------------+--------------------
                3 |     &lt;IS NULL&gt;
</code></pre></div>
<p>如何处理线性多维数组中的单个值？可以使用以下通用方案：</p>
<div class="highlight"><pre><span></span><code>[idx_1][idx_2]...[idx_n]
</code></pre></div>
<p>必须提供与数组的维数完全相同的索引值。此外，如果您做错了，并且提供了太多或太少的索引值，那么您不会看到错误，而是得到值NULL。在此，一个显而易见的问题是： 
如何寻址？例如，如何寻址数组中的第一个值，而该值本身就是数组的不规则数组中的第二个数组？</p>
<p>在输入之前，您知道这不可能是正确的：</p>
<div class="highlight"><pre><span></span><code>select v1[2][1] as &quot;v1[2][1]&quot; from t where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> v1[2][1]
-----------
 &lt;IS NULL&gt;
</code></pre></div>
<p>不会出错，但也得不到想要的。请尝试以下操作： </p>
<div class="highlight"><pre><span></span><code>select v1[2] as &quot;v1[2]&quot; from t where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>  v1[2]
---------
 {3,4,5}
</code></pre></div>
<p>您已经在数组的数组中标识了想要的叶数组。现在您必须在该数组中标识所需的值。试试这个：</p>
<div class="highlight"><pre><span></span><code>select (v1[2])[1] as &quot;(v1[2])[1]&quot; from t where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (v1[2])[1]
------------
          3
</code></pre></div>
<p>同样，您可以如下检查叶数组的几何属性，如下所示：</p>
<div class="highlight"><pre><span></span><code>select
  array_lower(v1[1], 1) as v1_lb,
  array_upper(v1[1], 1) as v1_ub,
  array_lower(v1[2], 1) as v2_lb,
  array_upper(v1[2], 1) as v2_ub
from t where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> v1_lb | v1_ub | v2_lb | v2_ub
-------+-------+-------+-------
     1 |    2 |    1 |    3
</code></pre></div>
<p>最后，试试这个反例：</p>
<div class="highlight"><pre><span></span><code>with v as (
  select  &#39;{{1,2},{3,4}}&#39;::int[] as two_d_arr)
select
  (two_d_arr[2])[1]
from v;
</code></pre></div>
<p>它会导致SQL编译错误。您必须知道，要在其中寻址值的当前值是线性化多维数组，还是不规则的数组的数组。</p>
<h6 id="foreachdomains"># 将FOREACH与DOMAINs数组结合使用</h6>
<p>这个示例解释说明了这个问题。</p>
<div class="highlight"><pre><span></span><code>set client_min_messages = warning;
drop domain if exists array_t cascade;
drop domain if exists arrays_t cascade;

create domain array_t  as int[];
create domain arrays_t as array_t[];

\set VERBOSITY verbose
do $body$
declare
  arrays arrays_t := array[
    array[1, 2]::array_t, array[3, 4, 5]::array_t];

  runner array_t not null := &#39;{}&#39;;
begin
  -- Error 42804 here.
  foreach runner in array arrays loop
    raise info &#39;%&#39;, runner::text;
  end loop;
end;
$body$;
</code></pre></div>
<p>引发如下错误：</p>
<div class="highlight"><pre><span></span><code>ERROR:  42804: FOREACH expression must yield an array, not type arrays_t
</code></pre></div>
<p>错误文本可能会使您感到困惑。实际上，这意味着循环头中ARRAY关键字的参数必须是一个显式数组，而不是为这样的数组命名的domain 。 </p>
<p>一个简单的解决方法是将“arrays”显式声明为“array_t[]”，而不是使用“array_t”作为简写。如下所示：</p>
<div class="highlight"><pre><span></span><code>\set VERBOSITY default
do $body$
declare
  arrays array_t[] := array[
    array[1, 2]::array_t, array[3, 4, 5]::array_t];

  runner array_t not null := &#39;{}&#39;;
begin
  foreach runner in array arrays loop
    raise info &#39;%&#39;, runner::text;
  end loop;
end;
$body$;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>INFO:  {1,2}
INFO:  {3,4,5}
</code></pre></div>
<p>如果真的需要使用DOMAIN怎么办？例如，您可能希望定义这样的约束：</p>
<div class="highlight"><pre><span></span><code>set client_min_messages = warning;
drop domain if exists arrays_t cascade;
create domain arrays_t as array_t[]
check ((cardinality(value) = 2));
</code></pre></div>
<p>解决方法是：将ARRAY关键字的参数类型转换为适当元素数据类型的数组。 </p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  arrays arrays_t := array[
    array[1, 2]::array_t, array[3, 4, 5]::array_t];

  runner array_t not null := &#39;{}&#39;;
begin
  foreach runner in array arrays::array_t[] loop
    raise info &#39;%&#39;, runner::text;
  end loop;
end;
$body$;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>INFO:  {1,2}
INFO:  {3,4,5}
</code></pre></div>
<h6 id="array_aggdomain"># 使用array_agg()生成DOMAIN值数组</h6>
<p>事实证明，不支持直接聚合表示不规则数组的DOMAIN值。但是一个简单的PL/pgSQL函数提供了解决方法。</p>
<div class="highlight"><pre><span></span><code>set client_min_messages = warning;
drop table if exists t cascade;
drop domain if exists array_t cascade;
drop domain if exists arrays_t cascade;

create domain array_t  as int[];
create domain arrays_t as array_t[];

create table t(k serial primary key, v array_t);

insert into t(v) values
  (&#39;{2,6}&#39;),
  (&#39;{1,4,5,6}&#39;),
  (&#39;{4,5}&#39;),
  (&#39;{2,3}&#39;),
  (&#39;{4,5}&#39;),
  (&#39;{3,5,7}&#39;);

select v from t order by k;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>     v
-----------
 {2,6}
 {1,4,5,6}
 {4,5}
 {2,3}
 {4,5}
 {3,5,7}
</code></pre></div>
<p>如下说明了问题：</p>
<div class="highlight"><pre><span></span><code>\set VERBOSITY verbose
select
  array_agg(v order by k)
from t;
</code></pre></div>
<p>会返回如下错误信息：</p>
<div class="highlight"><pre><span></span><code>2202E: cannot accumulate arrays of different dimensionality
</code></pre></div>
<p>类型转换不能生效，但此函数会产生所需的结果：</p>
<div class="highlight"><pre><span></span><code>\set VERBOSITY default
create or replace function array_agg_v()
  returns arrays_t
  language plpgsql
as $body$
&lt;&lt;b&gt;&gt;declare
  v  array_t    not null := &#39;{}&#39;;
  n  int        not null := 0;
  r  array_t[]  not null := &#39;{}&#39;;
begin
  for b.v in (select t.v from t order by k) loop
    n := n + 1;
    r[n] := b.v;
  end loop;
  return r;
end b;
$body$;
</code></pre></div>
<p>执行：</p>
<div class="highlight"><pre><span></span><code>select array_agg_v();
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>                       array_agg_v
------------------------------------------------------------------------
 {&quot;{2,6}&quot;,&quot;{1,4,5,6}&quot;,&quot;{4,5}&quot;,&quot;{2,3}&quot;,&quot;{4,5}&quot;,&quot;{3,5,7}&quot;}
</code></pre></div>
<h6 id="_25"><strong>创建矩阵</strong></h6>
<p>数学、物理学等领域的各种学科都使用块矩阵。数组的使用说明了这种情况如何在客户端程序中生成各种数组，以及以后需要在客户端程序中将这些值再次使用。在当前用例中，这带来了持久化和检索块矩阵的需求。
尽管这个用例相对来说比较奇特，但用于实现所需结构的技术（尤其是可行解决方案对用户定义的DOMAIN数据类型的依赖性）具有通用性。正是由于这个原因，这里解释了这种方法。</p>
<h6 id="_26"># 定义需要的数据类型</h6>
<p>首先，定义“有效负载”矩阵的数据类型。假设需要执行以下规则：</p>
<ul>
<li>有效负载矩阵在原子上不能为null。</li>
<li>根据定义，它必须是二维的。</li>
<li>一定是三乘三。</li>
<li>每个维度的下限必须为1。</li>
<li>矩阵的每个值都不能是NULL。</li>
</ul>
<p>DOMAIN类型构造函数的要求是，它必须允许在构造类型的值上定义任意约束，如下所示：</p>
<div class="highlight"><pre><span></span><code>create domain matrix_t as text[]
check (
  (value is not null)         and
  (array_ndims(value) = 2)    and
  (array_lower(value, 1) = 1) and
  (array_lower(value, 2) = 1) and
  (array_upper(value, 1) = 3) and
  (array_upper(value, 2) = 3) and
  (value[1][1] is not null  ) and
  (value[1][2] is not null  ) and
  (value[1][3] is not null  ) and
  (value[2][1] is not null  ) and
  (value[2][2] is not null  ) and
  (value[2][3] is not null  ) and
  (value[3][1] is not null  ) and
  (value[3][2] is not null  ) and
  (value[3][3] is not null  )
);
</code></pre></div>
<p>接下来，定义一个“matrix_t”的块矩阵。假设需要执行类似的以下规则：</p>
<ul>
<li>块矩阵在原子上不能为null。</li>
<li>根据定义，它必须是二维的。</li>
<li>一定是二乘二。</li>
<li>每个维度的下限必须为1。</li>
<li>矩阵的每个值都必须不是NULL。 </li>
</ul>
<p>因此，“block_matrix_t”的CREATE DOMAIN语句，与“matrix_t”的语句类似：</p>
<div class="highlight"><pre><span></span><code>create domain block_matrix_t as matrix_t[]
check (
  (value is not null)         and
  (array_ndims(value) = 2)    and
  (array_lower(value, 1) = 1) and
  (array_lower(value, 2) = 1) and
  (array_upper(value, 1) = 2) and
  (array_upper(value, 2) = 2) and
  (value[1][1] is not null  ) and
  (value[1][2] is not null  ) and
  (value[2][1] is not null  ) and
  (value[2][2] is not null  )
);
</code></pre></div>
<p>这两个CREATE DOMAIN语句冗长而重复，但它们足以说明该方法的基础。为了在实际应用程序中使用，最好将所有CHECK规则封装在PL/pgSQL函数中，该函数以DOMAIN值为输入并返回布尔值，并将其用作单个CHECK谓词。该函数可以使用array_lower（）和array_length（）函数来计算两个嵌套FOR循环的范围，以检查数组的各个值是否都满足NOT NULL规则。</p>
<h6 id="block_matrix_tdomain"># 使用“block_matrix_t”DOMAIN</h6>
<p>接下来，创建一个块矩阵值，将其及其 ::text 类型转换插入到表中，并检查类型转换的值。</p>
<div class="highlight"><pre><span></span><code>create table block_matrices_1(k int primary key, v block_matrix_t, text_typecast text);

do $body$
declare
  -- The definitions of the two domains imply &quot;not null&quot; constraints
  -- on each of the variables &quot;matrix_t&quot; and &quot;block_matrix_t&quot;.
  m matrix_t       := array_fill(&#39;00&#39;::text, array[3, 3], array[1, 1]);
  b block_matrix_t := array_fill(m,          array[2, 2], array[1, 1]);

  n int not null := 0;
  ms matrix_t[];
begin
  -- Define four matrix_t values so that, for readability of the result,
  -- the in-total 24 values are taken from an increasing dense series.
  for i in 1..4 loop
    for j in 1..3 loop
      for k in 1..3 loop
        n := n + 1;
        m[j][k] := ltrim(to_char(n, &#39;09&#39;));
      end loop;
    end loop;
    ms[i] := m;
  end loop;

  n := 0;
  for j in 1..2 loop
    for k in 1..2 loop
      n := n + 1;
      b[j][k] := ms[n];
    end loop;
  end loop;

  insert into block_matrices_1(k, v, text_typecast)
  values(1, b, b::text);
end;
$body$;

select text_typecast
from block_matrices_1
where k = 1;
</code></pre></div>
<p>返回信息如下（为方便阅读，手动增加了空格）：</p>
<div class="highlight"><pre><span></span><code>{
  {
    &quot;{
      {01,02,03},     block_matrix[1][1]
      {04,05,06},
      {07,08,09}
    }&quot;,
    &quot;{
      {10,11,12},     block_matrix[1][2]
      {13,14,15},
      {16,17,18}
    }&quot;
  },
  {
    &quot;{
      {19,20,21},     block_matrix[2][1]
      {22,23,24},
      {25,26,27}
    }&quot;,
    &quot;{
      {28,29,30},     block_matrix[2][2]
      {31,32,33},
      {34,35,36}
    }&quot;
  }
}
</code></pre></div>
<p>注意：注释“block_matrix”等等这些信息是手动添加的，只是为了突出显示整个文本值的含义。</p>
<p>最后，检查一下结构是否符合通用规则：</p>
<div class="highlight"><pre><span></span><code>create table block_matrices_2(k int primary key, v block_matrix_t);

insert into block_matrices_2(k, v)
select k, text_typecast::block_matrix_t
from block_matrices_1
where k = 1;

with a as (
  select k, t1.v as v1, t2.v as v2
  from
  block_matrices_1 as t1
  inner join
  block_matrices_2 as t2
  using (k)
  )
select (v1 = v2)::text as &quot;v1 = v2&quot;
from a
where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> v1 = v2
---------
 true
</code></pre></div>
<h6 id="unnest"># 对数组使用unnest()</h6>
<p>首先，按行主要顺序生成“matrix_t”值列表：</p>
<div class="highlight"><pre><span></span><code>with matrices as (
  select unnest(v) as m
  from block_matrices_1
  where k = 1)
select
  row_number() over(order by m) as r,
  m
from matrices order by m;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> r |                 m
---+----------------------------------------------
 1 | {{01,02,03},{04,05,06},{07,08,09}}
 2 | {{10,11,12},{13,14,15},{16,17,18}}
 3 | {{19,20,21},{22,23,24},{25,26,27}}
 4 | {{28,29,30},{31,32,33},{34,35,36}}
</code></pre></div>
<p>现在运行unnest：</p>
<div class="highlight"><pre><span></span><code>select unnest(v[2][1]) as val
from block_matrices_1
where k = 1
order by val;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> val 
-----
 19
 20
 21
 22
 23
 24
 25
 26
 27
</code></pre></div>
<p>如果希望按行主顺序查看所有叶值，请使用此查询：</p>
<div class="highlight"><pre><span></span><code>with
  matrixes as (
    select unnest(v) as m
    from block_matrices_1
    where k = 1),
  vals as (
    select unnest(m) as val
    from matrixes)
select
  row_number() over(order by val) as r,
  val
from vals
order by 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> r  | val
----+-----
  1 | 01
  2 | 02
  3 | 03
 ...
 34 | 34
 35 | 35
 36 | 36
</code></pre></div>
<h5 id="_27"><strong>数组函数和运算符</strong></h5>
<p>这里列出的大多数函数和运算符可以使用任何维度的数组，但其中四个函数只接受或生成一维数组。当存在一维数组限制时，下表中的第二列“1-d only?”以“1-d”表示。否则为空，代表没有维度限制。</p>
<h6 id="_28"><strong>创建函数</strong></h6>
<table>
<thead>
<tr>
<th>函数和运算符</th>
<th>1-d only?</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_array[]构造函数">array[]</a></td>
<td></td>
<td>array[]值构造函数是一个特殊的函数，它使用每个数组值的表达式从头开始创建数组。表达式本身可以使用array[]构造函数或文本文字。</td>
</tr>
<tr>
<td><a href="#_array_fill()">array_fill()</a></td>
<td></td>
<td>返回一个用指定值和维度初始化好的数组</td>
</tr>
<tr>
<td><a href="#_array_agg()">array_agg()</a></td>
<td></td>
<td>从SQL子查询返回一个数组（隐含的“row”类型）。</td>
</tr>
<tr>
<td><a href="#_string_to_array()">string_to_array()</a></td>
<td>1-d</td>
<td>通过使用指定的分隔符将输入文本值拆分为子值，返回一维text[]数组。（可选）允许将指定的文本值解释为NULL</td>
</tr>
</tbody>
</table>
<h6 id="array_fill"># array_fill()</h6>
<p>目的：返回一个用指定值和维度初始化好的数组</p>
<p>用法：
输入值:       anyelement, int[] [, int[]]
返回值:      anyarray</p>
<p>第一个参数确定每个单元格的值和数据类型，从而确定整个新数组的数据类型。它可以是基本数据类型的值，也可以是“row”类型的值。出于某种目的，也可以写成行如NULL::some_type。您可能会设置NOT NULL值，例如，如果您想将数组插入到已创建约束的表列中，该约束基于PL/pgSQL函数，则该函数显式测试数组的几何属性，及其每个值的NOT NULL状态。示例如下：</p>
<div class="highlight"><pre><span></span><code>select pg_typeof(array_fill(null::text, &#39;{1}&#39;)) as &quot;type of the new array&quot;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> type of the new array
------------------------
 text[]
</code></pre></div>
<p>第二个参数是一个int[]数组。它的每个值都是array_length(new_arr，n)返回的值，其中“n”是从主维度开始的维度编号。因此，您在这里提供的数组的基数指定了array_ndims(new_arr)返回的值。
第三个参数是可选的。提供时，它必须是一个与第二个参数具有相同基数的int[]数组。它的每个值都指定array_lower(new_arr, n)返回的值。
因此，新数组的形状完全由第二和第三参数指定。 
注意：array_fill()为什么存在？换言之，为什么不直接为每个单元格建立索引，并为其分配你想赋予的值呢？回想一下，正如大纲中所描述的，数组值是线性的。这意味着，当其维度数超过一时，其形状在创建时是无法协商的。如下这个DO块强调了这一点。</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  a int[];
  b int[] := array_fill(null::int, &#39;{3, 4}&#39;);
begin
  a[1][1] := 42;
  begin
    -- Causes ERROR: array subscript out of range
    a[2][2] := 17;
  exception
    when array_subscript_error then null;
  end;
  raise info
    &#39;cardinality(a), cardinality(b): %, %&#39;, cardinality(a), cardinality(b);
end;
$body$;
</code></pre></div>
<p>返回信息如下（为方便阅读，手动去除了“INFO:”提示）：</p>
<div class="highlight"><pre><span></span><code>  cardinality(a), cardinality(b): 1, 12
</code></pre></div>
<p>所以数组“a”被固定为一维的，一个接一个的值。</p>
<p>例如：
运行如下脚本：</p>
<div class="highlight"><pre><span></span><code>create table t(k int primary key, arr text[]);

insert into t(k, arr)
values(1, array_fill(&#39;-----&#39;::text, &#39;{3, 4}&#39;, &#39;{2, 7}&#39;)::text[]);

select
  array_length(arr, 1)  as len_1,
  array_length(arr, 2)  as len_2,
  array_lower(arr,  1)  as lb_1,
  array_lower(arr,  2)  as lb_2,
  array_ndims(arr)      as ndims,
  cardinality(arr)      as cardinality
from t
where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> len_1 | len_2 | lb_1 | lb_2 | ndims | cardinality
-------+-------+------+------+-------+-------------
   3 |     4 |   2 |   7 |    2 |      12
</code></pre></div>
<p>接下来，运行如下：</p>
<div class="highlight"><pre><span></span><code>update t
set
  arr[2][ 7] = &#39;2---7&#39;,
  arr[2][10] = &#39;2--10&#39;,
  arr[4][ 7] = &#39;4---7&#39;,
  arr[4][10] = &#39;4--10&#39;
where k = 1;
</code></pre></div>
<div class="highlight"><pre><span></span><code>select arr::text from t where k = 1;
</code></pre></div>
<p>返回信息如下（为方便阅读，手动增加了空格）：</p>
<div class="highlight"><pre><span></span><code>[2:4][7:10]=
  {
    {2---7,-----,-----,2--10},
    {-----,-----,-----,-----},
    {4---7,-----,-----,4--10}
  }
</code></pre></div>
<p>最后，再运行如下：</p>
<div class="highlight"><pre><span></span><code>\set VERBOSITY verbose
update t
set
  arr[1][17] = &#39;Hmm...&#39;
where k = 1;
</code></pre></div>
<p>会报告如下错误信息：</p>
<div class="highlight"><pre><span></span><code>2202E: array subscript out of range
</code></pre></div>
<h6 id="array_agg"># array_agg()</h6>
<p>此函数有两个重载函数。</p>
<h6 id="array_agg_1">## <em>array_agg() 重载函数一</em></h6>
<p>目的：从SQL子查询返回一维数组。它的行可能是标量（也就是说，SELECT列表可能是单列）。但是，一般情况下，可能是“row”类型的值。 </p>
<p>用法：
输入值:       SETOF anyelement
返回值:      anyarray</p>
<p>一般情况下，array_agg()是被应用于SELECT，从物理表或封装视图中进行查询。这在下面的示例中会被演示。但是，首先，您可以通过使用VALUES语句来演示该功能，而无需创建和填充表。示例如下：</p>
<div class="highlight"><pre><span></span><code>values
  (1::int, &#39;dog&#39;::text),
  (2::int, &#39;cat&#39;::text),
  (3::int, &#39;ant&#39;::text);
</code></pre></div>
<p>生成的结果为：</p>
<div class="highlight"><pre><span></span><code> column1 | column2
---------+---------
       1 | dog
       2 | cat
       3 | ant
</code></pre></div>
<p>请注意，BSQL已将SELECT列表项命名为“column1”和“column2”。其结果就是所谓的SETOF。它意味着一组行，就像使用SELECT语句产生的一样，如果用 \df 元命令描述generate_series()内置表函数，就会看到这个术语。要使用VALUES语句生成的行作为array_agg()的输入，需要使用命名类型，因此： </p>
<div class="highlight"><pre><span></span><code>create type rt as (f1 int, f2 text);

with tab as (
  values
    (1::int, &#39;dog&#39;::text),
    (2::int, &#39;cat&#39;::text),
    (3::int, &#39;ant&#39;::text))
select array_agg((column1, column2)::rt order by column1) as arr
from tab;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>               arr
---------------------------------
 {&quot;(1,dog)&quot;,&quot;(2,cat)&quot;,&quot;(3,ant)&quot;}
</code></pre></div>
<p>您可以这样理解array_agg()：</p>
<ul>
<li>将每一行视为具有单个值的 “rt[]” 数组。</li>
<li>将所有行中的值按指定顺序连接到一个新的 “rt[]” 数组中。</li>
</ul>
<p>下面代码说明了这一点：</p>
<div class="highlight"><pre><span></span><code>-- Consider this SELECT:
with tab as (
  values
    ((1, &#39;dog&#39;)::rt),
    ((2, &#39;cat&#39;)::rt),
    ((3, &#39;ant&#39;)::rt))
select array_agg(column1 order by column1) as arr
from tab;

-- It can be seen as equivalent this SELECT:
select
  array[(1, &#39;dog&#39;)::rt] ||
  array[(2, &#39;cat&#39;)::rt] ||
  array[(3, &#39;ant&#39;)::rt]
as arr;
</code></pre></div>
<p>上面三个“select…as arr”查询中的每一个都会产生相同的结果，证明了它们在语义上的等价性。</p>
<p>要准备unnest()的演示，请使用 \gset 元命令将三个查询中最近一个查询的单值结果（其中任何一个都可以）保存到bsqlsh变量中。这需要一个单独的参数，通常会加下划线（例如，“result_”），并重新运行SELECT语句，该语句作为最后提交的bsqlsh命令，仍在命令缓冲区中。如果SELECT不是返回单行，则会得到一个明显的错误。通常，当SELECT列表有N个成员，称为“c1”到“cN”，这些值中的每一个都存储在自动创建的变量中，称为”result_c1“到”result_cN“。 </p>
<p>在运行上面的“with…select array_agg（…）as arr…”查询后，立即执行以下操作：</p>
<div class="highlight"><pre><span></span><code>\gset result_
\echo :result_arr
</code></pre></div>
<p>\echo 元命令显示以下内容：</p>
<div class="highlight"><pre><span></span><code>{&quot;(1,dog)&quot;,&quot;(2,cat)&quot;,&quot;(3,ant)&quot;}
</code></pre></div>
<h6 id="array_agg_2">## <em>array_agg() 重载函数二</em></h6>
<p>目的：从行为N维数组的SQL子查询，返回一个（N+1）维数组。聚合数组必须都具有相同的维度。</p>
<p>用法：</p>
<p>输入值:      SETOF anyarray
返回值:      anyarray</p>
<p>示例如下：</p>
<div class="highlight"><pre><span></span><code>with tab as (
  values
    (&#39;{a, b, c}&#39;::text[]),
    (&#39;{d, e, f}&#39;::text[]))
select array_agg((column1)::text[] order by column1) as arr
from tab;
</code></pre></div>
<p>生成如下结果：</p>
<div class="highlight"><pre><span></span><code>        arr
-------------------
 {{a,b,c},{d,e,f}}
</code></pre></div>
<p>如下是一个不可用的示例：</p>
<div class="highlight"><pre><span></span><code>with tab as (
  values
    (&#39;{a, b, c}&#39;::text[]),
    (&#39;{d, e   }&#39;::text[]))
select array_agg((column1)::text[] order by column1) as arr
from tab;
</code></pre></div>
<p>会报告如下错误信息：</p>
<div class="highlight"><pre><span></span><code>2202E: cannot accumulate arrays of different dimensionality
</code></pre></div>
<h6 id="string_to_array"># string_to_array()</h6>
<p>目的：通过使用指定的文本值作为“分隔符”，将输入文本值拆分为子值，返回一维text[] 数组。（可选）允许将指定的文本值解释为NULL。</p>
<p>用法：</p>
<p>输入值:      text, text [, text]
返回值:      text[]</p>
<p>示例如下：</p>
<div class="highlight"><pre><span></span><code>select string_to_array(
  &#39;a|b|?|c&#39;, -- the to-be-split string
  &#39;|&#39;,       -- the character(s) to be taken as the delimiter
  &#39;?&#39;        -- the character(s) to be taken to the null indicator
) as &quot;string_to_array result&quot;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> string_to_array result
------------------------
 {a,b,NULL,c}
</code></pre></div>
<p>语法：
“分隔符”和“null指示符”，使用以下优先级规则：“分隔符”优先于“null指示符”。 
然而，只有当这两个由多个字符定义时，以及当其中一个以序列开头而另一个以顺序结尾时，此规则才重要。</p>
<p>因此，AiSQL建议，就像上面的示例一样，当选择“分隔符”和“null指示符”的文本值时，可以选择两个不同的单个字符。当然，您必须确保在要转换为text[]数组的任何文本值中都不会出现这两个值。</p>
<p>下面的DO块演示了一个不恰当的选择示例：</p>
<ul>
<li>“分隔符”为 ' !'::text</li>
<li>“null指示符”是 '~ '::text。 </li>
</ul>
<div class="highlight"><pre><span></span><code>do $body$
declare
  delim_text  constant text := &#39; !&#39;;
  null_text   constant text := &#39;~ &#39;;

  input_text  constant text := &#39;dog house !~  !x! ~ ! cat flap !  !&#39;;

  result constant text[] :=
    string_to_array(input_text, delim_text, null_text);

  good_delim_text constant text := &#39;|&#39;;
  good_null_text  constant text := &#39;?&#39;;

  delim_first_text constant text :=
    replace(replace(
      input_text,
      delim_text, good_delim_text),
      null_text,  good_null_text);

  null_first_text constant text :=
    replace(replace(
      input_text,
      null_text,  good_null_text),
      delim_text, good_delim_text);

  delim_first_result constant text[] :=
    string_to_array(delim_first_text, good_delim_text, good_null_text);

  null_first_result constant text[] :=
    string_to_array(null_first_text, good_delim_text, good_null_text);

  -- Notice that one of the special characters, &quot;!&quot;, remains in
  -- both expected_result and unexpected_result.
  -- If
  expected_result constant text[] :=
    &#39;{&quot;dog house&quot;,NULL,&quot;x! ~&quot;,&quot; cat flap&quot;,&quot; &quot;,&quot;&quot;}&#39;;
  unexpected_result constant text[] :=
    &#39;{&quot;dog house&quot;,NULL,&quot;x! ?! cat flap&quot;,&quot; &quot;,&quot;&quot;}&#39;;

begin
  assert
  (result             =  expected_result)    and
  (delim_first_result =  expected_result)    and
  (null_first_result  &lt;&gt; delim_first_result) and
  (null_first_result  =  unexpected_result)  and
    true,
  &#39;unexpected&#39;;
end;
$body$;
</code></pre></div>
<h6 id="_29"><strong>几何函数</strong></h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>1-d only?</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_array_ndims()">array_ndims()</a></td>
<td></td>
<td>返回数组的维度数</td>
</tr>
<tr>
<td><a href="#_array_lower()">array_lower()</a></td>
<td></td>
<td>返回指定数组沿指定维度的下界</td>
</tr>
<tr>
<td><a href="#_array_upper()">array_upper()</a></td>
<td></td>
<td>返回指定数组沿指定维度的上界</td>
</tr>
<tr>
<td><a href="#_array_length()">array_length()</a></td>
<td></td>
<td>返回指定数组沿指定维度的长度</td>
</tr>
<tr>
<td><a href="#_cardinality()">cardinality()</a></td>
<td></td>
<td>返回数组中元素的总数，如果数组为空则返回 0</td>
</tr>
<tr>
<td><a href="#_array_dims()">array_dims()</a></td>
<td></td>
<td>返回数组的维度的文本表示，对于所有维度，在单个文本值中返回与array_lower（）和array_length（）相同信息的文本表示形式。</td>
</tr>
</tbody>
</table>
<p>本节函数示例均使用如下表及其相关数据：</p>
<div class="highlight"><pre><span></span><code>create table t(k int primary key, arr_1 text[], arr_2 text[]);
insert into t(k, arr_1, arr_2) values(1,
      &#39;[3:10]={ 1, 2, 3, 4,   5, 6, 7, 8}&#39;,
  &#39;[2:3][4:7]={{1, 2, 3, 4}, {5, 6, 7, 8}}&#39;
  );
</code></pre></div>
<h6 id="array_ndims"># array_ndims()</h6>
<p>目的：返回指定数组的维数（即维度）。</p>
<p>用法：</p>
<p>输入值:       anyarray
返回值:      int</p>
<p>示例如下：</p>
<div class="highlight"><pre><span></span><code>select
  array_ndims(arr_1) as ndims_1,
  array_ndims(arr_2) as ndims_2
from t where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>  ndims_1 | ndims_2
---------+---------
       1 |       2
</code></pre></div>
<h6 id="array_lower"># array_lower()</h6>
<p>目的：返回指定数组沿指定维度的下界。</p>
<p>用法：</p>
<p>输入值:       anyarray, int
返回值:      int</p>
<p>示例如下：</p>
<div class="highlight"><pre><span></span><code>select
  array_lower(arr_1, 1) as arr_1_lb,
  array_lower(arr_2, 1) as arr_2_lb_1,
  array_lower(arr_2, 2) as arr_2_lb_2
from t where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> arr_1_lb | arr_2_lb_1 | arr_2_lb_2
----------+------------+--------------
       3 |        2 |        4
</code></pre></div>
<h6 id="array_upper"># array_upper()</h6>
<p>目的：返回指定数组沿指定维度的上界。</p>
<p>用法：</p>
<p>输入值:       anyarray, int
返回值:      int</p>
<p>示例如下：</p>
<div class="highlight"><pre><span></span><code>select
  array_upper(arr_1, 1) as arr_1_ub,
  array_upper(arr_2, 1) as arr_2_ub_1,
  array_upper(arr_2, 2) as arr_2_ub_2
from t where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> arr_1_ub | arr_2_ub_1 | arr_2_ub_2
----------+------------+----------------
       10 |        3 |        7
</code></pre></div>
<h6 id="array_length"># array_length()</h6>
<p>目的：返回指定数组沿指定维度的长度</p>
<p>用法：</p>
<p>输入值:       anyarray, int
返回值:      int</p>
<p>示例如下：</p>
<div class="highlight"><pre><span></span><code>select
  array_length(arr_1, 1) as arr_1_len,
  array_length(arr_2, 1) as arr_2_len_1,
  array_length(arr_2, 2) as arr_2_len_2
from t where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> arr_1_len | arr_2_len_1 | arr_2_len_2
-----------+-------------+----------------
        8 |         2 |         4
</code></pre></div>
<h6 id="cardinality"># cardinality()</h6>
<p>目的：返回数组中元素的总数，如果数组为空则返回 0。请注意，此函数返回的值可以计算为array_length()函数的每一个维度返回的值的乘积。 </p>
<p>用法：</p>
<p>输入值:       anyarray
返回值:      int</p>
<p>示例如下：</p>
<div class="highlight"><pre><span></span><code>select
  cardinality(arr_1) as card_1,
  cardinality(arr_2) as card_2
from t where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> card_1 | card_2
--------+--------
      8 |    8
</code></pre></div>
<h6 id="array_dims"># array_dims()</h6>
<p>目的：返回数组的维度的文本表示，对于所有维度，在单个文本值中返回与array_lower（）和array_length（）相同信息的文本表示形式。</p>
<p>用法：</p>
<p>输入值:       anyarray
返回值:      text</p>
<p>示例如下：</p>
<div class="highlight"><pre><span></span><code>select
  array_dims(arr_1) as arr_1_dims,
  array_dims(arr_2) as arr_2_dims
from t where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> arr_1_dims | arr_2_dims
------------+------------
 [3:10]     | [2:3][4:7]
</code></pre></div>
<h6 id="_30"><strong>查找函数</strong></h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>1-d only?</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_array_position()">array_position()</a></td>
<td>1-d</td>
<td>在提供的数组中返回指定值的索引。（可选）在指定索引处开始搜索。</td>
</tr>
<tr>
<td><a href="#_array_positions()">array_positions()</a></td>
<td>1-d</td>
<td>在提供的数组中，返回所有出现指定值的索引</td>
</tr>
</tbody>
</table>
<p>这些函数要求要搜索的数组是一维的。它们返回指定要搜索数组中指定要搜索值的索引值。
本节函数示例均使用如下自定义函数：</p>
<div class="highlight"><pre><span></span><code>drop function if exists arr() cascade;
create function arr()
  returns text[]
  language sql
as $body$
  select array[
                &#39;mon&#39;, &#39;tue&#39;, &#39;wed&#39;, &#39;thu&#39;,&#39;fri&#39;, &#39;sat&#39;, &#39;sun&#39;, 
                &#39;mon&#39;, &#39;tue&#39;, &#39;wed&#39;, &#39;thu&#39;,&#39;fri&#39;, &#39;sat&#39;, &#39;sun&#39;,
                &#39;mon&#39;, &#39;tue&#39;, &#39;wed&#39;
              ];
$body$;
</code></pre></div>
<p>按索引号列出days_arr列的元素，使用内置函数generate_subscripts（）。</p>
<div class="highlight"><pre><span></span><code>with c(days, pos) as (
  select a, subscripts.pos
  from arr() as a
  cross join lateral
  generate_subscripts(arr(), 1) as subscripts(pos))
select pos, days[pos] as day from c order by pos;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> pos | day 
-----+-----
   1 | mon
   2 | tue
   3 | wed
   4 | thu
   5 | fri
   6 | sat
   7 | sun
   8 | mon
   9 | tue
  10 | wed
  11 | thu
  12 | fri
  13 | sat
  14 | sun
  15 | mon
  16 | tue
  17 | wed
</code></pre></div>
<h6 id="array_position"># array_position()</h6>
<p>目的：在提供的数组中返回指定值的索引。（可选）在指定索引处开始搜索。</p>
<p>用法：</p>
<p>输入值:       anyarray, anyelement [, int]
返回值:      int</p>
<p>注：第三个参数是可选的，包含指定的开始搜索的索引值。</p>
<p>示例如下：</p>
<div class="highlight"><pre><span></span><code>select array_position(
    arr(),        -- The to-be-searched array.
    &#39;tue&#39;::text,  -- The to-be-searched-for value.
    3::int        -- The (inclusive) position
                  --   at which to start searching. [optional]
  ) as position;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> position 
-----------
      9
</code></pre></div>
<h6 id="array_positions"># array_positions()</h6>
<p>目的：在提供的数组中，返回所有出现指定值的索引</p>
<p>用法：</p>
<p>输入值:       anyarray, anyelement
返回值:      integer[]</p>
<p>示例如下：</p>
<div class="highlight"><pre><span></span><code>select unnest(
  array_positions(
      arr(),       -- The to-be-searched array.
      &#39;tue&#39;::text  -- The to-be-searched-for value.
    )
  ) as position;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> position 
-----------
      2
      9
     16
</code></pre></div>
<h6 id="anyall"><strong>ANY/ALL运算符</strong></h6>
<p>这些运算符要求LHS是标量，RHS是该LHS数据类型的数组
注：LHS代表操作符的左边，RHS代表操作符的右边，下文中，如未做特殊说明，LHS，RHS均代表此意义。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>1-d only?</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_ANY和ALL">ANY</a></td>
<td></td>
<td>如果LHS元素和RHS数组的每个元素之间，至少有一个指定的不等式测试结果为TRUE，则返回TRUE。</td>
</tr>
<tr>
<td><a href="#_ANY和ALL">ALL</a></td>
<td></td>
<td>如果LHS元素和RHS数组的每个元素之间，每个指定不等式测试的结果均为TRUE，则返回TRUE。</td>
</tr>
</tbody>
</table>
<h6 id="any-all"># ANY 和 ALL</h6>
<p>ANY和ALL运算符中的每一个都具有相同的用法。</p>
<h6 id="_31">## <em>概述</em></h6>
<p>注意：SOME是ANY的同义词。</p>
<p>用法：</p>
<p>输入值:       anyelement, anyarray
返回值:      boolean</p>
<p>这些运算符中的每一个都要求LHS表达式所计算的元素值的数据类型，与RHS表达式所计算的数组值的数据类型相对应。例如，当LHS元素的数据类型为“t”时，RHS数组的数据类型必须为“t[]”。RHS数组可以具有任何维度。运算符对数组中的实际元素是敏感的。</p>
<p>目的：
根据指定的一组比较的结果，返回TRUE、FALSE或NULL。如下是调用的一般形式：</p>
<div class="highlight"><pre><span></span><code>any_all_boolean_expression ::=
  lhs_element { = | &lt;&gt; | &lt; | &lt;= | &gt;= | &gt; } { ANY | ALL} rhs_array
</code></pre></div>
<p>注意：!= 从等式和不等式运算符列表中省略，因为这只是 &lt;&gt; 不等式运算符的另一种拼写形式。 </p>
<p>因为“any_all_boolean_expression”只是一个布尔表达式，它可以选择性地在前面加上NOT一元运算符，并且可以以正常方式使用AND和OR与其他布尔表达式相结合使用。
“any_all_boolean_expression”依次访问数组的每个元素（如前所述，数组的维度无关紧要），并在LHS元素和当前数组元素之间，进行相等或不相等的比较。</p>
<h6 id="_32">## <em>用途</em></h6>
<p>ANY和ALL是互补的。
注意，元素和数组的使用（在关于ANY和AND的整个部分中）指出了一个事实，就是LHS和RHS通常都是表达式。所以元素充当LHS表达式计算值的简写，数组充当RHS表达式计算值的简写。
分为简单场景与特别需求场景解释如下：
1）简单的场景
简单的场景仅限于LHS元素为NOT NULL、RHS数组为NOT NULL，并且RHS数组的基数至少为1的情况。</p>
<p>当LHS元素与RHS数组的每个元素进行比较时，这个比较会使用在“any_all_boolean_expression”中使用的特定等式或不等式运算符的适当的数据类型重载。</p>
<ul>
<li>如果使用了ANY，则只有在连续比较中，至少有一个对比结果为TRUE时，最终结果才为TRUE。如果其他比较中有零个，或多个对比结果为NULL，也并并不会有任何的影响。如果每个比较的结果都为FALSE，则最终结果为FALSE。如果每个比较的计算结果都为NULL，则结果为NULL。</li>
<li>如果使用了ALL，则只有当每个连续比较的求值结果为TRUE时，结果才为TRUE。如果至少有一个比较结果为FALSE，而没有一个结果为NULL，则结果为FALSE；如果至少有一个比较结果为NULL，则结果为NULL。</li>
</ul>
<p>请注意，ANY与OR类似，ALL与AND 类似：</p>
<ul>
<li>如果使用ANY，则结果是连续的单个比较的OR组合。</li>
<li>如果使用ALL，则结果是连续的单个比较的AND组合。</li>
</ul>
<p>下面这个DO块演示了如何使用OR和AND：</p>
<div class="highlight"><pre><span></span><code>do $body$
begin
  -- OR
  assert     (true  or  false or  null),             &#39;assert failed&#39;;
  assert     not (false or  false or  false),          &#39;assert failed&#39;;
  assert     (false or  false or  null)   is null,     &#39;assert failed&#39;;

  -- AND
  assert     (true  and true  and true),            &#39;assert failed&#39;;
  assert     not (true  and true  and false),         &#39;assert failed&#39;;
  assert     (true  and true  and null)   is null,     &#39;assert failed&#39;;
end;
$body$;
</code></pre></div>
<p>下一个DO块是对块的手动重写，它演示了OR和AND的用途，也相应地展示了ANY和ALL的语义。</p>
<div class="highlight"><pre><span></span><code>do $body$
begin
  -- ANY
  assert     (true = any (array[true,  false, null ]::boolean[])),         &#39;assert failed&#39;;
  assert not (true = any (array[false, false, false]::boolean[])),         &#39;assert failed&#39;;
  assert     (true = any (array[false, false, null ]::boolean[])) is null, &#39;assert failed&#39;;

  -- ALL
  assert     (true = all (array[true,  true,  true ]::boolean[])),         &#39;assert failed&#39;;
  assert not (true = all (array[true,  true,  false]::boolean[])),         &#39;assert failed&#39;;
  assert     (true = all (array[true,  true,  null ]::boolean[])) is null, &#39;assert failed&#39;;
end;
$body$;
</code></pre></div>
<p>= ANY在功能上等同于IN（但当RHS是数组时，IN是非法语法），而 =ALL在功能上没有类似等价的。
例如如下示例：</p>
<div class="highlight"><pre><span></span><code>select (
    42 = any (array[17, 42, 53])
    and
    42 in (17, 42, 53)
  )::text as b;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>  b
------
 true
</code></pre></div>
<p>注意，在这里，“（17，42，53）”不是一个结构化记录，因为在它前面加了IN。相反，在下面的示例中，“（17,42,53）”是一个结构化记录：</p>
<div class="highlight"><pre><span></span><code>with v as (select (17, 42, 53) as r)
select pg_typeof(r)::text from v;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> pg_typeof
-----------
 record
</code></pre></div>
<p>由于直接使用“（17，42，53）”作为SELECT列表项。因此，如下会导致语法错误：</p>
<div class="highlight"><pre><span></span><code>with v as (select (1, 2, 3, 4) as r)
select 1 in r from v;
</code></pre></div>
<p>2）特别需求场景
本小节解释如下：当LHS元素和RHS数组中的一个，或全部为NULL时；当LHS或RHS都不为NULL，并且RHS数组的基数为零时。</p>
<ul>
<li>如果LHS元素或RHS数组为NULL，则ANY结果为NULL，ALL结果也为NULL。</li>
<li>如果LHS元素不是NULL，RHS数组不是NULL，并且RHS数组有零个元素，那么ANY结果为FALSE。</li>
<li>如果LHS元素不是NULL，RHS数组不是NULL，并且RHS数组有零个元素，则ALL结果为TRUE。 </li>
</ul>
<h6 id="_33">## <em>示例</em></h6>
<p>以下示例显示了单元素数组、复合元素数组和DOMAIN值元素数组的使用。
1）单元素数组</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  v1 constant int := 1;
  v2 constant int := 2;
  v3 constant int := 3;
  v4 constant int := 4;
  v5 constant int := 5;
  v6 constant int := null;

  arr1 constant int[] := array[v1, v1, v1, v1];
  arr2 constant int[] := array[v1, v1, v1, v2];
  arr3 constant int[] := array[v1, v2, v3, v4];
  arr4 constant int[] := array[v1, v1, v1, null];
  arr5 constant int[] := null;

  -- Notice that an array with zero elements is nevertheless NOT NULL.
  arr6 constant int[] not null := &#39;{}&#39;;

  b01 constant boolean not null :=     v1 = all (arr1);
  b02 constant boolean not null := not  v1 = all (arr3);
  b03 constant boolean not null := not  v1 = all (arr2);
  b04 constant boolean not null :=     v1 = any (arr3);
  b05 constant boolean not null := not  v5 = any (arr3);

  b06 constant boolean not null :=      v1 = any (arr4);
  b07 constant boolean not null :=     (v5 = any (arr4)) is null;
  b08 constant boolean not null :=     (v1 = all (arr4)) is null;

  b09 constant boolean not null :=     (v1 = any (arr5)) is null;
  b10 constant boolean not null :=     (v6 = any (arr1)) is null;
  b11 constant boolean not null :=     (v1 = all (arr5)) is null;
  b12 constant boolean not null :=     (v6 = all (arr1)) is null;

  b13 constant boolean not null :=  not (v1 = any (arr6));
  b14 constant boolean not null :=     (v1 = all (arr6));
begin
  assert
    (b01 and b02 and b03 and b04 and b05 and b06 and b07 and b08
         and b09 and b10 and b11 and b12 and b13 and b14),
  &#39;assert failed&#39;;
end;
$body$;
</code></pre></div>
<p>下面是一个从上面的代码中派生的示例，它使用二维数组代替一维数组。但为了提高可读性，删除了一些测试。其余测试的结果没有变化，因为这些结果仅取决于数组的实际元素，而不取决于其几何结构。</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  v1 constant int := 1;
  v2 constant int := 2;
  v3 constant int := 3;
  v4 constant int := 4;
  v5 constant int := 5;

  arr1 constant int[] := array[array[v1, v1], array[v1, v1]];
  arr2 constant int[] := array[array[v1, v2], array[v3, v4]];
  arr3 constant int[] := array[array[v1, v1], array[v1, null]];

  b1 constant boolean not null :=     v1 = all (arr1);
  b2 constant boolean not null := not  v1 = all (arr2);
  b3 constant boolean not null :=     v1 = any (arr2);
  b4 constant boolean not null := not  v5 = any (arr2);

  b5 constant boolean not null :=     v1 = any (arr3);
  b6 constant boolean not null :=     (v5 = any (arr3)) is null;
  b7 constant boolean not null :=     (v1 = all (arr3)) is null;
begin
  assert
    (b1 and b2 and b3 and b4 and b5 and b6 and b7),
  &#39;assert failed&#39;;
end;
$body$;
</code></pre></div>
<p>2）复合元素数组（row类型）
该代码是通过将int替换为“rt”，并相应地更改了给“v1”到“v5”的值分配。同样，为了提高可读性，删除了一些测试。其余代码的其余部分与第一个示例中的对应代码相同。</p>
<div class="highlight"><pre><span></span><code>drop type if exists rt;
create type rt as (a int, b text);

do $body$
declare
  v1 constant rt := (0, 1);
  v2 constant rt := (2, 3);
  v3 constant rt := (4, 5);
  v4 constant rt := (6, 7);
  v5 constant rt := (8, 9);

  arr1 constant rt[] := array[v1, v1, v1, v1];
  arr2 constant rt[] := array[v1, v2, v3, v4];
  arr3 constant rt[] := array[v1, v1, v1, null::rt];

  b1 constant boolean not null :=     v1 = all (arr1);
  b2 constant boolean not null := not v1 = all (arr2);
  b3 constant boolean not null :=     v1 = any (arr2);
  b4 constant boolean not null := not v5 = any (arr2);

  b5 constant boolean not null :=     v1 = any (arr3);
  b6 constant boolean not null :=    (v5 = any (arr3)) is null;
  b7 constant boolean not null :=    (v1 = all (arr3)) is null;
begin
  assert
    (b1 and b2 and b3 and b4 and b5 and b6 and b7),
  &#39;assert failed&#39;;
end;
$body$;
</code></pre></div>
<p>3）DOMAIN值元素数组
首先，考虑以下两个示例：</p>
<div class="highlight"><pre><span></span><code>drop domain if exists d1_t;
create domain d1_t as int
default 42 constraint d1_t_chk check(value &gt;= 17);

drop domain if exists d2_t;
create domain d2_t as int[];
</code></pre></div>
<p>很明显，“d1_t”的值，是int的一种特殊类型。但是“d2_t”的值呢？是一种特殊的数组？最重要的是，“d2_t”不符合任意数组的条件，相反，它符合任何元素的条件。此代码示例强调了这一点：</p>
<div class="highlight"><pre><span></span><code>create or replace procedure p(i in anyelement)
  language plpgsql
as $body$
begin
  raise info &#39;%&#39;, pg_typeof(i);
end;
$body$;

call p(53::d1_t);

call p(&#39;{1, 2}&#39;::d2_t);
</code></pre></div>
<p>第一个call，返回如下信息：</p>
<div class="highlight"><pre><span></span><code>INFO:  d1_t
</code></pre></div>
<p>第二个call，返回如下信息：</p>
<div class="highlight"><pre><span></span><code>INFO:  d2_t
</code></pre></div>
<p>再次修改代码，用“int_arr_t”替换，相应地更改了“v1”到“v5”的值分配。同样，为了提高可读性，删除了一些测试。其余代码的其余部分与第一个示例中的对应代码相同。</p>
<div class="highlight"><pre><span></span><code>drop domain if exists int_arr_t;
create domain int_arr_t as int[];

do $body$
declare
  v1 constant int_arr_t := array[1, 1];
  v2 constant int_arr_t := array[2, 3];
  v3 constant int_arr_t := array[4, 5];
  v4 constant int_arr_t := array[5, 7];
  v5 constant int_arr_t := array[8, 9];

  arr1 constant int_arr_t[] := array[v1, v1, v1, v1];
  arr2 constant int_arr_t[] := array[v1, v2, v3, v4];
  arr3 constant int_arr_t[] := array[v1, v1, v1, null::int_arr_t];

  b1 constant boolean not null :=     v1 = all (arr1);
  b2 constant boolean not null := not v1 = all (arr2);
  b3 constant boolean not null :=     v1 = any (arr2);
  b4 constant boolean not null := not v5 = any (arr2);

  b5 constant boolean not null :=     v1 = any (arr3);
  b6 constant boolean not null :=    (v5 = any (arr3)) is null;
  b7 constant boolean not null :=    (v1 = all (arr3)) is null;
begin
  assert
    (b1 and b2 and b3 and b4 and b5 and b6 and b7),
  &#39;assert failed&#39;;
end;
$body$;
</code></pre></div>
<p>4）数组的元素彼此相同的测试
这个示例，展示了数组的元素是否彼此相同的测试，而不需要知道它们的值或数组维度的任何信息。</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  arr constant int[] not null := &#39;
    [2:3][4:6][7:10]={
      {
        {42,42,42,42},{42,42,42,42},{42,42,42,42}
      },
      {
        {42,42,42,42},{42,42,42,42},{42,42,42,42}
      }
    }&#39;::int[];

   val constant int not null := (
    select unnest(arr) limit 1);

  b99 boolean not null := val = all (arr);
begin
  assert b99, &#39;assert failed&#39;;
end;
$body$;
</code></pre></div>
<p>5）使用不等式的比较</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  v1 constant int := 1;
  v2 constant int := 2;
  v3 constant int := 3;
  v4 constant int := 4;
  v5 constant int := 5;

  arr1 constant int[] := array[v1, v2, v3, v4];

  b01 constant boolean not null := not (v5  = any (arr1));
  b02 constant boolean not null :=    v5 &lt;&gt; all (arr1);
  b03 constant boolean not null :=    v2  &gt; any (arr1);
  b04 constant boolean not null := not (v2  &gt; all (arr1));
  b05 constant boolean not null := not (v4  &lt; any (arr1));
  b06 constant boolean not null :=    v2  &lt; any (arr1);
  b07 constant boolean not null := not (v5 &lt;= any (arr1));
  b08 constant boolean not null :=    v4 &gt;= all (arr1);
  b09 constant boolean not null :=    v5  &gt; all (arr1);

begin
  assert
    (b01 and b02 and b03 and b04 and b05 and b06 and b07 and b08 and b09),
  &#39;assert failed&#39;;
end;
$body$;
</code></pre></div>
<h6 id="_34"><strong>比较运算符</strong></h6>
<table>
<thead>
<tr>
<th>运算符</th>
<th>1-d only?</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td></td>
<td>如果LHS和RHS数组相等，则返回TRUE。</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td></td>
<td>如果LHS和RHS数组不相等，则返回TRUE。</td>
</tr>
<tr>
<td>&gt;</td>
<td></td>
<td>如果LHS数组大于RHS数组，则返回TRUE。</td>
</tr>
<tr>
<td>&gt;=</td>
<td></td>
<td>如果LHS数组大于或等于RHS数组，则返回TRUE。</td>
</tr>
<tr>
<td>&lt;=</td>
<td></td>
<td>如果LHS数组小于或等于RHS数组，则返回TRUE。</td>
</tr>
<tr>
<td>&lt;</td>
<td></td>
<td>如果LHS数组小于RHS数组，则返回TRUE。</td>
</tr>
<tr>
<td>@&gt;</td>
<td></td>
<td>如果LHS数组包含RHS数组，也就是说，如果在LHS数组的不同值中找到RHS数组中的每个不同值，则返回TRUE。</td>
</tr>
<tr>
<td>&lt;@</td>
<td></td>
<td>如果RHS数组包含LHS数组，也就是说，如果在RHS数组的不同值中找到LHS数组中的每个不同值，则返回TRUE。</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td></td>
<td>如果LHS和RHS数组重叠，即如果它们至少有一个共同值，则返回TRUE</td>
</tr>
</tbody>
</table>
<h6 id="_35"># 概述</h6>
<p>目的：每个比较运算符，根据LHS和RHS数组之间的特定比较测试的结果，返回TRUE或FALSE。</p>
<p>用法：这些操作符具有相同的用法</p>
<p>输入值:       anyarray, anyarray
返回值:      boolean</p>
<p>注意：这些运算符要求LHS和RHS数组具有相同的数据类型。这是标量比较的相同规则。然而，它们并不要求数组具有相同的几何属性。规则定义，属性中的一个，或多个之间的差异，并不意味着不允许进行比较。相反，LHS数组可能被认为小于，或大于RHS数组。因此，理解比较算法是至关重要的。</p>
<p>比较标准
这些是比较两个数组值的算法的独特特征：</p>
<ul>
<li>实际值，按行主顺序成对比较</li>
<li>基数</li>
<li>维度的数量</li>
<li>每个维度上的下界。</li>
</ul>
<p>在这些比较中有一个明确的优先次序。简单地说，首先进行值比较。然后，只有在没有检测到差异的情况下，才进行几何特性的比较。</p>
<p>值的成对比较
第一个比较测试，按行主顺序扫描每个LHS和RHS数组中的值，并进行成对比较。值得注意的是，当非null数组值，与null值成对比较时，非null值被认为小于null值。</p>
<h6 id="_36"># 示例</h6>
<p>1）= 和 &lt;&gt;  操作符</p>
<ul>
<li>如果LHS和RHS数组相等，则 = 运算符返回TRUE。</li>
<li>如果LHS和RHS数组不相等，则 &lt;&gt; 运算符返回TRUE。 </li>
</ul>
<p>= 运算符的示例：</p>
<div class="highlight"><pre><span></span><code>with
  v as (
    select
      (select array[&#39;a&#39;, &#39;b&#39;, null, &#39;d&#39;]::text[]) as a1,
      (select      &#39;{a,   b,  null,  d}&#39;::text[]) as a2
  )
select (a1 = a2)::text as &quot;EQUALITY comparison result&quot;
from v;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> EQUALITY comparison result
----------------------------
 true
</code></pre></div>
<p>&lt;&gt; 运算符的示例：</p>
<div class="highlight"><pre><span></span><code>with
  v as (
    select
      (select array[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;,  &#39;d&#39;]::text[]) as a1,
      (select      &#39;{a,   b,  null,  d}&#39;::text[]) as a2
  )
select (a1 &lt;&gt; a2)::text as &quot;INEQUALITY comparison result&quot;
from v;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> INEQUALITY comparison result
------------------------------
 true
</code></pre></div>
<p>2） &gt; 与 &gt;= 与 &lt;= 与 &lt; 操作符
这四个运算符实现了常见的不等式比较 </p>
<ul>
<li>如果LHS数组大于RHS数组，则 &gt; 运算符返回TRUE。</li>
<li>如果LHS数组大于或等于RHS数组，则 &gt;= 运算符返回TRUE。</li>
<li>如果LHS数组小于或等于RHS数组，则 &lt;= 运算符返回TRUE。</li>
<li>如果LHS数组小于RHS数组，则 &lt; 运算符返回TRUE。
  下面仅仅给出 &lt; 运算符的示例：</li>
</ul>
<div class="highlight"><pre><span></span><code>with
  v as (
    select
      (select array[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;,  &#39;d&#39;]::text[]) as a1,
      (select array[&#39;a&#39;, &#39;b&#39;, &#39;e&#39;,  &#39;d&#39;]::text[]) as a2,
      (select      &#39;{a,   b,  null,  d}&#39;::text[]) as a3
  )
select
  (a1 &lt; a2)::text as &quot;&#39;LESS THAN&#39; comparison result 1&quot;,
  (a1 &lt; a3)::text as &quot;&#39;LESS THAN&#39; comparison result 2&quot;
from v;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &#39;LESS THAN&#39; comparison result 1 | &#39;LESS THAN&#39; comparison result 2
------------------------------------------+---------------------------------------------
 true                         | true
</code></pre></div>
<p>3） @&gt; 与 &lt;@ 操作符
如果LHS数组包含RHS数组，也就是说，如果RHS数组中的每个不同值都是在LHS数组的不同值中找到的，则 @&gt; 运算符返回TRUE；反之，则 &lt;@ 运算符返回TRUE。 </p>
<div class="highlight"><pre><span></span><code>with
  v as (
    select
      (select array[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;,  &#39;d&#39;]::text[]) as a1,
      (select array[&#39;a&#39;,      &#39;c&#39;      ]::text[]) as a2
  )
select
  (a1 @&gt; a2)::text as &quot;CONTAINS comparison result&quot;,
  (a2 &lt;@ a1)::text as &quot;&#39;IS CONTAINED BY&#39; comparison result&quot;
from v;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> CONTAINS comparison result | &#39;IS CONTAINED BY&#39; comparison result
----------------------------------------+-------------------------------------------------
 true                       | true
</code></pre></div>
<p>4）&amp;&amp; 运算符
如果LHS和RHS数组至少有一个共同值，则 &amp;&amp; 运算符返回TRUE。</p>
<div class="highlight"><pre><span></span><code>with
  v as (
    select
      (select array[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;,  &#39;d&#39;]::text[]) as a1,
      (select array[&#39;d&#39;, &#39;e&#39;, &#39;f&#39;,  &#39;g&#39;]::text[]) as a2
  )
select
  (a1 &amp;&amp; a2)::text as &quot;&#39;a1 OVERLAPS a2&#39; comparison result&quot;,
  (a2 &amp;&amp; a1)::text as &quot;&#39;a2 OVERLAPS a1&#39; comparison result&quot;
from v;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &#39;a1 OVERLAPS a2&#39; comparison result | &#39;a2 OVERLAPS a1&#39; comparison result
------------------------------------------------+----------------------------------------------
 true                            | true
</code></pre></div>
<p>5）以下是两个完整的示例</p>
<p>示例1：</p>
<div class="highlight"><pre><span></span><code>-- Any two arrays can be compared without error if they have the same data type.
do $body$
begin
  ------------------------------------------------------------------------------
  -- Illustrate &quot;IS NOT DISTINCT FROM&quot; semantics.
  declare
    v1 constant int := 1;
    v2 constant int := 1;
    n1 constant int := null;
    n2 constant int := null;
  begin
    assert
      (v1 = v2)                    and
      (v1 is not distinct from v2) and

      ((n1 = n2) is null)          and
      (n1 is not distinct from n2),
    &#39;unexpected&#39;;
  end;

  ------------------------------------------------------------------------------
  -- Basic demonstration of equaliy when the geom. properties of
  -- the two arrays are identical.
  -- Shows that pairwise comparison uses &quot;IS NOT DISTINCT FROM&quot; semantics and NOT
  -- the conventional NULL semantics used when scalars are compared.
  declare
    a constant int[] := &#39;{10, null, 30}&#39;;
    b constant int[] := &#39;{10, null, 30}&#39;; -- Identical to a.
  begin
    assert
      (a = b),
    &#39;&quot;a = b&quot; assert failed&#39;;

    -- Because of this, there&#39;s no need ever to write this.
    assert
      (a is not distinct from b),
    &#39;&quot;a is not distinct from b&quot; assert failed&#39;;
  end;

  ------------------------------------------------------------------------------
  -- Basic demonstration of inequality when the geometric properties of
  -- the two arrays are identical.
  -- When the first difference is encountered in row-major order, the comparison
  -- is made. Other differences are irrelevant.
  declare
    a constant int[] := &#39;{10, 20, 30}&#39;;
    b constant int[] := &#39;{10, 19, 31}&#39;;
  begin
    assert
      (a &lt;&gt; b) and
      (a &gt;  b) and
      (a &gt;= b) and
      (b &lt;= a) and
      (b &lt;  a) ,
    &#39;&quot;a &gt; b&quot; assert failed&#39;;
  end;

  ------------------------------------------------------------------------------
  -- Demonstration of inequality when the geometric properties of
  -- the two arrays are identical.
  -- Here, the first pairwise difference is NOT NULL versus NULL.
  declare
    a constant int[] := &#39;{10, 20,   30}&#39;;
    b constant int[] := &#39;{10, null, 29}&#39;;
  begin
    -- Bizarrely, a NOT NULL value counts as LESS THAN a NULL value in the
    -- pairwise comparison.
    assert
      (a &lt;&gt; b) and
      (a &lt;  b),
    &#39;&quot;a &lt; b&quot; assert failed&#39;;

    -- Again, because of this, there&#39;s no need ever to write this.
    assert
      (a is distinct from b) ,
    &#39;&quot;a is distinct from b&quot; assert failed&#39;;
  end;

  ------------------------------------------------------------------------------
  -- Extreme demonstration of priority.
  -- c has just a single value and d has several.
  -- c has one dimension and d has two.
  -- c&#39;s first lower bound is less than d&#39;s first lower.
  -- d&#39;s second lower bound is greater than one, but is presumably irrelevant.
  -- But c&#39;s first value is GREATER THAN d&#39;s first value,
  -- scanning in row-major order.
  --
  -- Pairwise value comparison has the hoghest priority.
  -- therefore c is deemed to be GREATER THAN d.

  declare
    c constant int[] := &#39;{2}&#39;;

    -- Notice that d&#39;s first value is at [2][3].
    d constant int[] := &#39;[2:3][3:4]={{1, 2}, {3, 3}}&#39;;

  begin
    assert
      cardinality(c) &lt; cardinality(d),
    &#39;&quot;cardinality(c) &lt; cardinality(d)&quot; assert failed&#39;;

    assert
      array_ndims(c) &lt; array_ndims(d),
    &#39;&quot;ndims(c) &lt; ndims(d)&quot; assert failed&#39;;
    assert
      array_lower(c, 1) &lt; array_lower(d, 1),
    &#39;&quot;lower(c, 1) &lt; lower(d, 1)&quot; assert failed&#39;;

    assert
      c[1] &gt; d[2][3],
    &#39;&quot;c[1] &gt; d[2][3]&quot; assert failed&#39;;

   assert
     c &gt; d,
   &#39;&quot;c &gt; d&quot; assert failed&#39;;
  end;

  ------------------------------------------------------------------------------
  -- Pairwise comparison is equal are far as it is feasible.
  -- e&#39;s ndims &lt; f&#39;s.
  -- e&#39;s lb-1 &lt; f&#39;s.
  -- BUT e&#39;s cardinality &gt; f&#39;s.
  -- Cardinality has highest priority among the geom. propoerties,
  -- so e is deemed to be GREATER THAN f.
  declare
    e constant int[] := &#39;{10, 20, 30, 40, 50, 60, 70}&#39;;
    f constant int[] := &#39;[2:3][3:5]={{10, 20, 30}, {40, 50, 60}}&#39;;
  begin
    assert
      e[1] = f[2][3] and
      e[2] = f[2][4] and
      e[3] = f[2][5] and
      e[4] = f[3][3] and
      e[5] = f[3][4] and
      e[6] = f[3][5] ,
    &#39;&quot;e-to-f&quot; eqality test, as far as feasible, assert failed&#39;;

    assert
      array_ndims(e) &lt; array_ndims(f),
    &#39;&quot;ndims(e) &lt; ndims(f)&quot; assert failed&#39;;

    assert
      array_lower(e, 1) &lt; array_lower(f, 1),
    &#39;&quot;lower(e, 1) &lt; lower(f, 1)&quot; assert failed&#39;;

    assert
      cardinality(e) &gt; cardinality(f),
    &#39;&quot;cardinality(e) &gt; cardinality(f)&quot; assert failed&#39;;

    assert
      (e &gt; f) ,
    &#39;e &gt; f assert failed&#39;;
  end;

  ------------------------------------------------------------------------------
  -- g&#39;s cardinality = h&#39;s.
  -- So pairwise comparison is feasible for all values, and is equal.
  -- g&#39;s ndims &gt; h&#39;s.
  -- g&#39;s lb-1 &lt; h&#39;s.
  -- Ndims has higher priority among ndims and lower bounds,
  -- so g is deemed to be GREATER THAN h.
  declare
    g constant int[] := &#39;{{10, 20, 30}, {40, 50, 60}}&#39;;
    h constant int[] := &#39;[2:7]={10, 20, 30, 40, 50, 60}&#39;;
  begin
    assert
      cardinality(g) = cardinality(h),
    &#39;&quot;cardinality(g) = cardinality(h)&quot; assert failed&#39;;

    assert
      g[1][1] = h[2] and
      g[1][2] = h[3] and
      g[1][3] = h[4] and
      g[2][1] = h[5] and
      g[2][2] = h[6] and
      g[2][3] = h[7] ,
    &#39;&quot;g-to-h&quot; eqality test assert failed&#39;;

    assert
      array_ndims(g) &gt; array_ndims(h),
    &#39;&quot;ndims(g) &gt; ndims(h)&quot; assert failed&#39;;

    assert
      array_lower(g, 1) &lt; array_lower(h, 1),
    &#39;&quot;lower(g, 1) &lt; lower(h, 1)&quot; assert failed&#39;;

    assert
      (g &gt; h) ,
    &#39;&quot;g &gt; h&quot; assert failed&#39;;
  end;

  ------------------------------------------------------------------------------
  declare
    i constant int[] := &#39;[5:6][4:6]={{10, 20, 30}, {40, 50, 60}}&#39;;
    j constant int[] := &#39;[3:4][6:8]={{10, 20, 30}, {40, 50, 60}}&#39;;
  begin
    assert
      cardinality(i) = cardinality(j),
    &#39;&quot;cardinality(i) = cardinality(j)&quot; assert failed&#39;;

    assert
      i[5][4] = j[3][6] and
      i[5][5] = j[3][7] and
      i[5][6] = j[3][8] and
      i[6][4] = j[4][6] and
      i[6][5] = j[4][7] and
      i[6][6] = j[4][8] ,
    &#39;&quot;i-to-j&quot; eqality test assert failed&#39;;

    assert
      array_ndims(i) = array_ndims(j),
    &#39;&quot;ndims(i) = ndims(j)&quot; assert failed&#39;;

    assert
      array_lower(i, 1) &gt; array_lower(j, 1),
    &#39;&quot;lower(i, 1) &gt; lower(j, 1)&quot; assert failed&#39;;

    assert
      (i &gt; j) ,
    &#39;&quot;i &gt; j&quot; assert failed&#39;;
  end;

  ------------------------------------------------------------------------------
end;
$body$;
</code></pre></div>
<p>示例2：</p>
<div class="highlight"><pre><span></span><code>-- Any two arrays can be compared without error if they have the same data type.
-- Insensitive to the geometric properties.
do $body$
declare
  a constant int[] := &#39;[2:3][4:5]={{10, 20}, {30, 40}}&#39;;
  b constant int[] := &#39;[5:6]={20, 30}&#39;;
  c constant int[] := &#39;[6:9]={40, 50, 70, 70}&#39;;
  d constant int[] := &#39;[2:4]={50, 60, 70}&#39;;
begin
  assert
    -- Containment
    (b @&gt; b) and
    (b &lt;@ a) and

    -- Overlap.
    -- The definition of the semantics makes the LHS, RHS order immaterial.
    (a &amp;&amp; c) and
    (c &amp;&amp; a) and

    -- a and d have NO values in common.
    not (a &amp;&amp; d),
  &#39;unexpected&#39;;
end;
$body$;
</code></pre></div>
<h6 id="_37"><strong>切片运算符</strong></h6>
<table>
<thead>
<tr>
<th>运算符</th>
<th>1-d only?</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_slice运算符">[lb1:ub1]...[lbN:ubN]</a></td>
<td></td>
<td>返回一个新数组，其长度是通过沿每个维度指定切片的下界和上界来定义的。这些指定的切片边界不能超过源数组的边界。新数组具有与源数组相同的维度，并且在每个轴上其下界为1。</td>
</tr>
</tbody>
</table>
<h6 id="slice_2"># slice运算符</h6>
<p>目的：返回一个新数组，其长度是通过指定切片沿每个维度的下限和上限来定义的。 </p>
<p>语法：
输入值:       [lb_1:ub_1] ... [lb_N:ub_N]anyarray
返回值:      anyarray
注意：</p>
<ul>
<li>必须为输入数组的N个维度中的每一个指定切片的下限和上限作为int值。</li>
<li>指定的切片边界不能超过源数组的边界。</li>
<li>新数组具有与源数组相同的维度，并且其下界在每个轴上为1。 </li>
</ul>
<p>示例如下：</p>
<div class="highlight"><pre><span></span><code>create table t(k int primary key, arr text[]);

insert into t(k, arr)
values (1, &#39;
  [2:4][3:6][4:5]=
  {
    {
      {a,b}, {c,d}, {e,f}, {g,h}
    },
    {
      {i,j}, {k,l}, {m,n}, {o,p}
    },
    {
      {q,r}, {s,t}, {u,v}, {w,x}
    }
  }
  &#39;::text[]);

select arr as &quot;old value of arr&quot; from t where k = 1;

select
  array_lower(arr, 1) as &quot;lb-1&quot;,
  array_upper(arr, 1) as &quot;ub-1&quot;,
  array_lower(arr, 2) as &quot;lb-2&quot;,
  array_upper(arr, 2) as &quot;ub-2&quot;,
  array_lower(arr, 3) as &quot;lb-3&quot;,
  array_upper(arr, 3) as &quot;ub-3&quot;
from t where k = 1;
</code></pre></div>
<p>分别返回信息如下：</p>
<div class="highlight"><pre><span></span><code> lb-1 | ub-1 | lb-2 | ub-2 | lb-3 | ub-3
------+------+------+------+-----+------
   2 |   4 |   3 |   6 |   4 |   5
</code></pre></div>
<p>与</p>
<div class="highlight"><pre><span></span><code>                     old value of arr
-------------------------------------------------------------------------------------------------
 [2:4][3:6][4:5]={{{a,b},{c,d},{e,f},{g,h}},{{i,j},{k,l},{m,n},{o,p}},{{q,r},{s,t},{u,v},{w,x}}}
</code></pre></div>
<p>现在进行如下切片：</p>
<div class="highlight"><pre><span></span><code>update t
set arr = arr[2:3][4:5][3:4]
where k = 1;

select arr as &quot;new value of arr&quot; from t where k = 1;

select
  array_lower(arr, 1) as &quot;lb-1&quot;,
  array_upper(arr, 1) as &quot;ub-1&quot;,
  array_lower(arr, 2) as &quot;lb-2&quot;,
  array_upper(arr, 2) as &quot;ub-2&quot;,
  array_lower(arr, 3) as &quot;lb-3&quot;,
  array_upper(arr, 3) as &quot;ub-3&quot;
from t where k = 1;
</code></pre></div>
<p>分别返回信息如下：</p>
<div class="highlight"><pre><span></span><code>   new value of arr
-------------------------------
 {{{c},{e}},{{k},{m}}}
</code></pre></div>
<p>与：</p>
<div class="highlight"><pre><span></span><code> lb-1 | ub-1 | lb-2 | ub-2 | lb-3 | ub-3
------+------+------+------+-----+------
   1 |   2 |   1 |   2 |   1 |    1
</code></pre></div>
<p>可以看到，返回的下界都是1</p>
<h6 id="_38"><strong>连接函数和运算符</strong></h6>
<p>这些函数要求两个数组具有相同的数据类型和兼容的维度。</p>
<table>
<thead>
<tr>
<th>函数和运算符</th>
<th>1-d only?</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_array_cat()">array_cat()</a></td>
<td></td>
<td>返回两个兼容的任意数组值的串联。</td>
</tr>
<tr>
<td><a href="#_array_append()">array_append()</a></td>
<td></td>
<td>向一个数组的末端追加一个元素值。</td>
</tr>
<tr>
<td><a href="#_array_prepend()">array_prepend()</a></td>
<td></td>
<td>向一个数组的首部追加一个元素</td>
</tr>
</tbody>
</table>
<h6 id="array_cat"># array_cat()</h6>
<p>目的：返回两个兼容的任意数组值的串联。</p>
<p>语法：</p>
<p>输入值:              anyarray, anyarray
返回值:             anyarray</p>
<p>注意：DO块表明 || 运算符能够实现array_cat()函数的全部功能。</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  arr_1 constant int[] := &#39;{1, 2, 3}&#39;::int[];
  arr_2 constant int[] := &#39;{4, 5, 6}&#39;::int[];
  val constant int := 5;
  workaround constant int[] := array[val];
begin
  assert
    array_cat(arr_1, arr_2)      = arr_1||arr_2 and
    array_cat(arr_1, workaround) = arr_1||val   ,
  &#39;unexpected&#39;;
end;
$body$;
</code></pre></div>
<h6 id="array_append"># array_append()</h6>
<p>目的：向一个数组的末端追加一个元素值。</p>
<p>语法：
输入值:              anyarray, anyelement
返回值:             anyarray</p>
<p>注意：DO块表明 || 运算符能够实现array_append()函数的全部功能，值兼容。</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  arr constant int[] := &#39;{1, 2, 3, 4}&#39;::int[];
  val constant int := 5;
  workaround constant int[] := array[val];
begin
  assert
    array_append(arr, val) = arr||val                   and
    array_append(arr, val) = array_cat(arr, workaround) ,
  &#39;unexpected&#39;;
end;
$body$;
</code></pre></div>
<h6 id="array_prepend"># array_prepend()</h6>
<p>目的：向一个数组的首部追加一个元素</p>
<p>语法：
输入值:              anyelement, anyarray
返回值:             anyarray</p>
<p>注意：DO块表明 || 运算符能够实现array_prepend()函数的全部功能，值兼容。</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  arr constant int[] := &#39;{1, 2, 3, 4}&#39;::int[];
  val constant int := 5;
  workaround constant int[] := array[val];
begin
  assert
    array_prepend(val, arr) = val||arr                   and
    array_prepend(val, arr) = array_cat(workaround, arr) ,
  &#39;unexpected&#39;;
end;
$body$;
</code></pre></div>
<p>以下两个示例展示了一维数组，与多维数组的应用：</p>
<p>示例一（一维数组）：</p>
<div class="highlight"><pre><span></span><code>create type rt as (f1 int, f2 text);

do $body$
declare
  arr constant rt[] := array[(3, &#39;c&#39;)::rt, (4, &#39;d&#39;)::rt, (5, &#39;e&#39;)::rt];

  prepend_row  constant rt := (0, &#39;z&#39;)::rt;
  prepend_arr  constant rt[] := array[(1, &#39;a&#39;)::rt, (2, &#39;b&#39;)::rt];
  append_row   constant rt := (6, &#39;f&#39;)::rt;

  cat_result   constant rt[] := prepend_row||prepend_arr||arr||append_row;

  expected_result constant rt[] :=
    array[(0, &#39;z&#39;)::rt, (1, &#39;a&#39;)::rt, (2, &#39;b&#39;)::rt, (3, &#39;c&#39;)::rt,
         (4, &#39;d&#39;)::rt, (5, &#39;e&#39;)::rt, (6, &#39;f&#39;)::rt];

begin
  assert
    (cat_result   = expected_result),
  &#39;unexpected&#39;;
end;
$body$;
</code></pre></div>
<p>示例二（多维数组）：</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  -- arr_1 and arr_2 are demensionally compatible.
  -- Its&#39;s OK for array_length(*, 1) to differ.
  -- But array_length(*, 1) must be the same.
  arr_1 constant int[] :=
    array[
       array[11, 12, 13],
       array[21, 22, 23]
    ];

  arr_2 constant int[] :=
    array[
       array[31, 32, 33],
       array[41, 42, 43],
       array[51, 52, 53]
    ];

  -- Notice that this is a 1-d array.
  -- Its lenth is the same as that of arr_1
  -- along arr_1&#39;s SECOND dimension.
  arr_3 constant int[] := array[31, 32, 33];

  -- Notice that bad_arr is dimensionally INCOMPATIBLE with arr_1:
  -- they have different lengths along their SECOND major dimension.
  bad_arr constant int[] :=
    array[
       array[61, 62, 63, 64],
       array[71, 72, 73, 74],
       array[81, 82, 83, 84]
    ];

  expected_cat_1 constant int[] :=
    array[
       array[11, 12, 13],
       array[21, 22, 23],
       array[31, 32, 33],
       array[41, 42, 43],
       array[51, 52, 53]
    ];

  expected_cat_2 constant int[] :=
    array[
       array[11, 12, 13],
       array[21, 22, 23],
       array[31, 32, 33]
    ];
begin
  assert
    arr_1||arr_2 = expected_cat_1 and
    arr_1||arr_3 = expected_cat_2,
  &#39;unexpected&#39;;

  declare
    a int[];
  begin
    -- ERROR: cannot concatenate incompatible arrays.
    a := arr_1||bad_arr;
  exception
    when array_subscript_error then null;
  end;
end;
$body$;
</code></pre></div>
<h6 id="_39"><strong>更改函数和运算符</strong></h6>
<table>
<thead>
<tr>
<th>函数和运算符</th>
<th>1-d only?</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_array_replace()">array_replace()</a></td>
<td></td>
<td>将每一个等于给定值的数组元素替换成一个新值</td>
</tr>
<tr>
<td><a href="#_arr[idx_1]...[idx_N]:=val">arr[idx_1]...[idx_N] := val</a></td>
<td></td>
<td>更新数组值</td>
</tr>
<tr>
<td><a href="#_array_remove()">array_remove()</a></td>
<td>1-d</td>
<td>从数组中移除所有等于给定值的所有元素</td>
</tr>
</tbody>
</table>
<h6 id="array_replace"># array_replace()</h6>
<p>本小节中描述的每一种方法，使用array_replace()函数，与显式设置数组值，都可以用于更改数组中的值。但这两种方法有如下的不同点：</p>
<ul>
<li>array_replace()将所有与指定值匹配的值更改为相同的新值，而不考虑它们在数组中的地址。</li>
<li>设置数组值，则仅对当前值进行更改。 </li>
</ul>
<p>目的：将每一个等于给定值的数组元素替换成一个新值</p>
<p>语法：</p>
<p>输入值:       anyarray, anyelement, anyelement
返回值:      anyarray</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>create type rt as (f1 int, f2 text);
create table t(k int primary key, arr rt[]);
insert into t(k, arr)
values (1, &#39;{&quot;(1,rabbit)&quot;,&quot;(2,hare)&quot;,&quot;(3,squirrel)&quot;,&quot;(4,horse)&quot;}&#39;::rt[]);

select arr as &quot;old value of arr&quot; from t where k = 1;

update t
set arr = array_replace(arr, &#39;(3,squirrel)&#39;, &#39;(3,bobcat)&#39;)
where k = 1;

select arr as &quot;new value of arr&quot; from t where k = 1;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>                   old value of arr
------------------------------------------------------
 {&quot;(1,rabbit)&quot;,&quot;(2,hare)&quot;,&quot;(3,squirrel)&quot;,&quot;(4,horse)&quot;}

                  new value of arr
----------------------------------------------------
 {&quot;(1,rabbit)&quot;,&quot;(2,hare)&quot;,&quot;(3,bobcat)&quot;,&quot;(4,horse)&quot;}
</code></pre></div>
<p>如下是更多的，针对不同情况的演示示例：</p>
<p>示例一（一维数组的基本数据类型）：</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  old_val constant int := 42;
  new_val constant int := 17;

  arr constant int[] :=
    array[1, old_val, 3, 4, 5, old_val, 6, 7];

  expected_modified_arr constant int[] :=
    array[1, new_val, 3, 4, 5, new_val, 6, 7];
begin
  assert
    array_replace(arr, old_val, new_val) = expected_modified_arr,
  &#39;unexpected&#39;;
end;
$body$;
</code></pre></div>
<p>示例二（一维数组的row类型）：</p>
<div class="highlight"><pre><span></span><code>create type rt as (f1 int, f2 text);

do $body$
declare
  old_val constant rt := (42, &#39;x&#39;);
  new_val constant rt := (17, &#39;y&#39;);

  arr constant rt[] :=
    array[(1, &#39;a&#39;)::rt, old_val, (1, &#39;a&#39;)::rt, (2, &#39;b&#39;)::rt, (3, &#39;c&#39;)::rt,
                        old_val, (4, &#39;d&#39;)::rt, (5, &#39;e&#39;)::rt];

  expected_modified_arr constant rt[] :=
    array[(1, &#39;a&#39;)::rt, new_val, (1, &#39;a&#39;)::rt, (2, &#39;b&#39;)::rt, (3, &#39;c&#39;)::rt,
                        new_val, (4, &#39;d&#39;)::rt, (5, &#39;e&#39;)::rt];
begin
  assert
    array_replace(arr, old_val, new_val) = expected_modified_arr,
  &#39;unexpected&#39;;
end;
$body$;
</code></pre></div>
<p>示例三（二维数组的基本数据类型）：</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  old_val constant int := 22;
  new_val constant int := 97;

  arr int[] :=
    array[
       array[11, 12],
       array[11, old_val],
       array[32, 33]
    ];

  expected_modified_arr constant int[] :=
    array[
       array[11, 12],
       array[11, new_val],
       array[32, 33]
    ];
begin
  arr := array_replace(arr, old_val, new_val);

  assert
    arr = expected_modified_arr,
  &#39;unexpected&#39;;
end;
$body$;
</code></pre></div>
<h6 id="arridx_1idx_n-val"># arr[idx_1]...[idx_N] := val</h6>
<p>目的：更新数组值</p>
<p>语法：
input/output value: anyarray, "vector of index values"</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>create table t(k int primary key, arr int[]);

insert into t(k, arr) values (1,  &#39;{1, 2, 3, 4}&#39;);

update t set arr[2] = 42 where k = 1;

select arr from t where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>    arr
------------
 {1,42,3,4}
</code></pre></div>
<p>如下是更多的，针对不同情况的演示示例：</p>
<p>示例一（基本数据类型）：</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  old_val constant int := 42;
  new_val constant int := 17;

  arr int[] :=                            array[1, 2, old_val, 4];
  expected_modified_arr constant int[] := array[1, 2, new_val, 4];
  old_arr constant int[] := arr;
begin
  arr[3] := new_val;
  assert
    old_arr =               &#39;{1, 2, 42, 4}&#39; and
    expected_modified_arr = &#39;{1, 2, 17, 4}&#39; and
    arr = expected_modified_arr,
  &#39;unexpected&#39;;
end;
$body$;
</code></pre></div>
<p>示例二（record类型）：</p>
<div class="highlight"><pre><span></span><code>create type rt as (f1 int, f2 text);

do $body$
declare
  old_val constant rt := (42, &#39;x&#39;);
  new_val constant rt := (17, &#39;y&#39;);

  arr rt[] :=
    array[(1, &#39;a&#39;)::rt, old_val, (1, &#39;a&#39;)::rt, (2, &#39;b&#39;)::rt, (3, &#39;c&#39;)::rt,
                        old_val, (4, &#39;d&#39;)::rt, (5, &#39;e&#39;)::rt];

  expected_modified_arr constant rt[] :=
    array[(1, &#39;a&#39;)::rt, new_val, (1, &#39;a&#39;)::rt, (2, &#39;b&#39;)::rt, (3, &#39;c&#39;)::rt,
                        new_val, (4, &#39;d&#39;)::rt, (5, &#39;e&#39;)::rt];

  old_arr constant rt[] := arr;
begin
  arr[2] := new_val;
  arr[6] := new_val;

  assert
    old_arr =
      &#39;{&quot;(1,a)&quot;,&quot;(42,x)&quot;,&quot;(1,a)&quot;,&quot;(2,b)&quot;,&quot;(3,c)&quot;,&quot;(42,x)&quot;,&quot;(4,d)&quot;,&quot;(5,e)&quot;}&#39; and
    expected_modified_arr =
      &#39;{&quot;(1,a)&quot;,&quot;(17,y)&quot;,&quot;(1,a)&quot;,&quot;(2,b)&quot;,&quot;(3,c)&quot;,&quot;(17,y)&quot;,&quot;(4,d)&quot;,&quot;(5,e)&quot;}&#39; and
    arr = expected_modified_arr,
  &#39;unexpected&#39;;
end;
$body$;
</code></pre></div>
<p>示例三（二维数组的基本数据类型）：</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  old_val constant int[] := array[21, 22, 23, 24];
  new_val constant int[] := array[81, 82, 83, 84];

  arr int[] :=
    array[
       array[11, 12, 13, 14],
       old_val,
       array[31, 32, 33, 34]
    ];

  expected_modified_arr constant int[] :=
    array[
       array[11, 12, 13, 14],
       new_val,
       array[31, 32, 33, 34]
    ];

  len_1 constant int := array_length(arr, 1);
  len_2 constant int := array_length(arr, 2);
begin
  assert
    (len_1 = 3) and (len_2 = 4),
  &#39;unexpected&#39;;

  -- OK to extract a slice. But, even though it&#39;s tempting to picture this as one row,
  -- it is nevertheless a 2-d array with &quot;array_length(arr, 1)&quot; equal to 1.
  assert
    arr[2:2][1:4] = array[old_val],
  &#39;unexpected&#39;;

  -- You cannot use the slice notation to specify the target of an assignment.
  -- So this
  --   arr[2:2][1:4] = array[new_val];
  -- causes a compilation error.

  -- Similarly, this is meaningless. (But it doesn&#39;t cause a compilation error.)
  -- Because it&#39;s a 2-d array, its values (individual values or slices) must be
  -- addressed using two indexes or two slice ranges.
  assert
    arr[2] is null,
  &#39;unexpected&#39;;

  -- Change the individual, addressable, values one by one.
  for j in array_lower(arr, 2)..array_upper(arr, 2) loop
    arr[2][j] := new_val[j];
  end loop;

  assert
    arr = expected_modified_arr,
  &#39;unexpected&#39;;
end;
$body$;
</code></pre></div>
<h6 id="array_remove"># array_remove()</h6>
<p>目的：从数组中移除所有等于给定值的所有元素</p>
<p>语法：</p>
<p>输入值:       anyarray, anyelement
返回值:      anyarray</p>
<p>注意：此函数要求要从中删除值的数组是一维的数组。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>create table t(k int primary key, arr int[]);
insert into t(k, arr)
values (1, &#39;{1, 2, 2, 2, 5, 6}&#39;::int[]);

select arr as &quot;old value of arr&quot; from t where k = 1;

update t
set arr = array_remove(arr, 2)
where k = 1;

select arr as &quot;new value of arr&quot; from t where k = 1;
</code></pre></div>
<p>分别返回如下信息：</p>
<div class="highlight"><pre><span></span><code> old value of arr
------------------
 {1,2,2,2,5,6}

 new value of arr
------------------
 {1,5,6}
</code></pre></div>
<h6 id="_40"><strong>转换函数</strong></h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>1-d only?</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_array_to_string()">array_to_string()</a></td>
<td></td>
<td>返回一个文本值，该值是通过每个数组值来计算的，通过::text类型转换，按行主顺序遍历这些值，并在每个数组值之间使用提供的分隔符。</td>
</tr>
</tbody>
</table>
<h6 id="array_to_string"># array_to_string()</h6>
<p>目的：返回一个文本值，该值是通过每个数组值来计算的，通过::text类型转换，按行主顺序遍历这些值，并在每个数组值之间使用提供的分隔符。</p>
<p>语法：
输入值:       anyarray, text [, text]
返回值:      text</p>
<div class="highlight"><pre><span></span><code>create type rt as (f1 int, f2 text);
create table t(k int primary key, arr rt[]);
insert into t(k, arr) values(1,
  array[
    array[
      array[(1, &#39;a&#39;)::rt, (2, null)::rt, null, (3, &#39;c&#39;)::rt]
    ]
  ]::rt[]
);

select arr::text from t where k = 1;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>                arr
-----------------------------------
 {{{&quot;(1,a)&quot;,&quot;(2,)&quot;,NULL,&quot;(3,c)&quot;}}}
</code></pre></div>
<p>接下来，执行如下脚本：</p>
<div class="highlight"><pre><span></span><code>select
  array_to_string(
    arr,     -- the input array
    &#39; | &#39;)   -- the delimiter
from t
where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>   array_to_string
----------------------
 (1,a) | (2,) | (3,c)
</code></pre></div>
<p>注意：第三个NULL数组值并没有显示。这意味着逗号和右括号分隔符之间没有任何字符。 </p>
<p>继续执行如下脚本：</p>
<div class="highlight"><pre><span></span><code>select
  array_to_string(
    arr,     -- the input array
    &#39; | &#39;,   -- the delimiter
    &#39;?&#39;)     -- the null indicator
from t
where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>     array_to_string
--------------------------
 (1,a) | (2,) | ? | (3,c)
</code></pre></div>
<p>第三个数组值现在用 ? 显示，但是，事实上，第二个数组值中的“f2”为NULL这一点并不没有用 ? 显示。换句话说，这种可视化NULL的技术仅在顶级数组值的粒度上应用，而当这些值是复合值时，并不会在这些值内应用。 </p>
<h6 id="_41"><strong>表函数</strong></h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>1-d only?</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_unnest()">unnest()</a></td>
<td></td>
<td>将一个数组扩展成一组行在SELECT语句的FROM子句中使用。简单重载接受单个任意数组值，并返回一个集合。重载接受任意数组值的可变列表，并返回具有多个列的集合，其中每个列依次具有相应的简单重载的输出。</td>
</tr>
<tr>
<td><a href="#_generate_subscripts()">generate_subscripts()</a></td>
<td></td>
<td>在SELECT语句的FROM子句中使用。返回沿指定数组的指定维度的索引值。</td>
</tr>
</tbody>
</table>
<h6 id="unnest_1"># unnest()</h6>
<p>此函数有两个重载函数。</p>
<h6 id="unnest_2">## <em>unnest() 重载函数一</em></h6>
<p>目的：将单个数组中的值转换为SQL表。</p>
<p>语法：</p>
<p>输入值:       anyarray
返回值:      SETOF anyelement</p>
<p>unnest的输入是一个数组，在SQL语句中，设置bsqlsh变量“result_arr”，参见array_agg()的代码示例，必须引起来它，并将其类型转换为“rt[]”。这可以通过\set 元命令来完成，如下所示：</p>
<div class="highlight"><pre><span></span><code>\set unnest_arg &#39;\&#39;&#39;:result_arr&#39;\&#39;::rt[]&#39;
\echo :unnest_arg
</code></pre></div>
<p>\echo 元命令显示以下内容：</p>
<div class="highlight"><pre><span></span><code>&#39;{&quot;(1,dog)&quot;,&quot;(2,cat)&quot;,&quot;(3,ant)&quot;}&#39;::rt[]
</code></pre></div>
<p>完整示例如下：</p>
<div class="highlight"><pre><span></span><code>create type rt as (f1 int, f2 text);

with tab as (
  values
    (1::int, &#39;dog&#39;::text),
    (2::int, &#39;cat&#39;::text),
    (3::int, &#39;ant&#39;::text))
select array_agg((column1, column2)::rt order by column1) as arr
from tab;

\gset result_
\echo :result_arr

\set unnest_arg &#39;\&#39;&#39;:result_arr&#39;\&#39;::rt[]&#39;
\echo :unnest_arg

with
  rows as (
    select unnest(:unnest_arg) as rec)
select
  (rec).f1,
  (rec).f2
from rows
order by 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> f1 |  f2
---+-----
 1 | dog
 2 | cat
 3 | ant
</code></pre></div>
<h6 id="unnest_3">## <em>unnest() 重载函数二</em></h6>
<p>目的：将数组的可变列表中的值转换为SQL表，该表的每一列都是相应输入数组值的集合。此重载只能在子查询的FROM子句中使用。每个输入数组可能具有不同的类型和不同的基数。基数最大的输入数组决定了输出行的数量。那些基数较小的输入数组的行在末尾用NULL填充。可选的WITH ORDINALITY 子句添加了一个对行进行编号的列。 </p>
<p>语法：</p>
<p>输入值:       <variadic list of> anyarray
返回值:      many coordinated columns of SETOF anyelement</p>
<p>示例如下：</p>
<div class="highlight"><pre><span></span><code>create type rt as (a int, b text);

\pset null &#39;&lt;is null&gt;&#39;
select *
from unnest(
  array[1, 2],
  array[10, 20, 30, 45, 50],
  array[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],
  array[(1, &#39;p&#39;)::rt, (2, &#39;q&#39;)::rt, (3, &#39;r&#39;)::rt, (4, &#39;s&#39;)::rt]
)
with ordinality
as result(arr1, arr2, arr3, arr4_a, arr4_n, n);
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>   arr1  | arr2  |   arr3    |  arr4_a   |  arr4_n   |  n
-------------+-------+--------------+--------------+--------------+-----
       1 |  10 | a          |         1 | p         | 1
       2 |  20 | b          |         2 | q         | 2
 &lt;is null&gt; |  30 | c          |         3 | r         | 3
 &lt;is null&gt; |  45 | d          |         4 | s         | 4
 &lt;is null&gt; |  50 | &lt;is null&gt;    | &lt;is null&gt;   | &lt;is null&gt;  | 5
</code></pre></div>
<h6 id="generate_subscripts"># generate_subscripts()</h6>
<p>目的：在SELECT语句的FROM子句中使用。返回沿指定数组的指定维度的索引值。</p>
<p>语法：</p>
<p>输入值:       anyarray, integer, boolean
返回值:      SETOF integer</p>
<p>第二个输入参数指定应该沿其生成索引值的维度。第三个可选的输入参数控制值的顺序。默认值FALSE表示从索引下界到索引上界按升序生成索引值；值TRUE意味着按照从索引上界到索引下界的降序生成索引值。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>drop function if exists arr() cascade;
create function arr()
  returns int[]
  language sql
as $body$
  select array[17, 42, 53, 67]::int[];
$body$;

select generate_subscripts(arr(), 1) as subscripts;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> subscripts 
------------
        1
        2
        3
        4
</code></pre></div>
<div class="highlight"><pre><span></span><code>select generate_subscripts(arr(), 1, true) as subscripts;
</code></pre></div>
<p>则返回信息如下：</p>
<div class="highlight"><pre><span></span><code> subscripts 
------------
        4
        3
        2
        1
</code></pre></div>
<h4 id="binary"><strong>Binary</strong></h4>
<p>使用BYTEA数据类型表示字节的二进制字符串（八位字节）。二进制串明确允许存储零值的字节和不可打印的字节（通常是位于十进制范围32到126之外的字节）。
描述：</p>
<ul>
<li>BYTEA用于声明一个二进制实体。</li>
</ul>
<div class="highlight"><pre><span></span><code>type_specification ::= BYTEA
</code></pre></div>
<ul>
<li>转义输入可用于输入二进制数据。</li>
</ul>
<div class="highlight"><pre><span></span><code>select E&#39;\\001&#39;::bytea
</code></pre></div>
<p>Bytea字节默认被输出为hex格式。如果你把bytea_output改为escape，“不可打印的”字节会被转换成与之等效的三位八进制值并且前置一个反斜线。大部分“可打印的”字节被输出为它们在客户端字符集中的标准表示形式，例如：</p>
<div class="highlight"><pre><span></span><code>SET bytea_output = &#39;escape&#39;;

select &#39;abc \153\154\155 \052\251\124&#39;::bytea;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>abc klm *\251T
</code></pre></div>
<p>十进制值为92（反斜线）的字节在输出时被双写，如下表格所示：</p>
<table>
<thead>
<tr>
<th>十进制字节值</th>
<th>描述</th>
<th>转义的输出表示</th>
<th>示例</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>92</td>
<td>反斜线</td>
<td>\\</td>
<td>'\134'::bytea</td>
<td>\\</td>
</tr>
<tr>
<td>0到31和127到255</td>
<td>“不可打印的”字节</td>
<td>\xxx（八进制值）</td>
<td>'\001'::bytea</td>
<td>\001</td>
</tr>
<tr>
<td>32到126</td>
<td>“可打印的”字节</td>
<td>客户端字符集表示</td>
<td>'\176'::bytea</td>
<td>~</td>
</tr>
</tbody>
</table>
<h5 id="_42"><strong>函数和操作符</strong></h5>
<h6 id="_43"><strong>操作符</strong></h6>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_||">||</a></td>
<td>连接两个二进制字符串。</td>
</tr>
</tbody>
</table>
<h6 id="9412111"># 9.4.1.2.1.1.1 ||</h6>
<p>目的：连接两个二进制字符串。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;\x123456&#39;::bytea || &#39;\x789a00bcde&#39;::bytea;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>\x123456789a00bcde
</code></pre></div>
<h6 id="_44"><strong>函数</strong></h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_bit_length()">bit_length()</a></td>
<td>返回二进制字符串中的位数</td>
</tr>
<tr>
<td><a href="#_octet_length()">octet_length()</a></td>
<td>返回二进制字符串中的字节数。</td>
</tr>
<tr>
<td><a href="#_overlay(string placing string from int [for int])">overlay(string placing string from int [for int])</a></td>
<td>将bytes的子字符串替换为newsubstring，该子字符串从start字节开始，并以count字节扩展。 如果忽略了count，则默认为newsubstring的长度。</td>
</tr>
<tr>
<td><a href="#_position(substring in string)">position(substring in string)</a></td>
<td>返回指定的substring在bytes内的起始索引，如果不存在，则为零。</td>
</tr>
<tr>
<td><a href="#_substring(string [from int] [for int])">substring(string [from int] [for int])</a></td>
<td>提取bytes从start字节开始的子字符串，如果指定了，并且在count字节之后停止，如果指定了的话。 至少提供start和count中的一个。</td>
</tr>
<tr>
<td><a href="#_trim([both] bytes from string)">trim([both] bytes from string)</a></td>
<td>从开始和结束处，删除只包含字节的最长字符串。</td>
</tr>
<tr>
<td><a href="#_btrim()">btrim()</a></td>
<td>从开始和结束处删除只包含出现的字节的最长字符串。</td>
</tr>
<tr>
<td><a href="#_decode()">decode()</a></td>
<td>从文本表示中解码二进制数据;支持的format值与encode相同。</td>
</tr>
<tr>
<td><a href="#_encode()">encode()</a></td>
<td>将二进制数据编码成文本表示；支持的format值为： base64, escape, hex。</td>
</tr>
<tr>
<td><a href="#_get_bit()">get_bit()</a></td>
<td>从二进制字符串中提取bit。</td>
</tr>
<tr>
<td><a href="#_get_byte()">get_byte()</a></td>
<td>从二进制字符串中提取字节。</td>
</tr>
<tr>
<td><a href="#_length()">length()</a></td>
<td>返回二进制字符串中的字节数。</td>
</tr>
<tr>
<td><a href="#_length()_1">length ()</a></td>
<td>返回二进制字符串中的字符数，假设它是给定encoding中的文本。</td>
</tr>
<tr>
<td><a href="#_md5()">md5()</a></td>
<td>计算二进制字符串的MD5 hash，结果以十六进制形式写入。</td>
</tr>
<tr>
<td><a href="#_set_bit()">set_bit()</a></td>
<td>设置二进制字符串中bit位。</td>
</tr>
<tr>
<td><a href="#_set_byte()">set_byte()</a></td>
<td>设置二进制字符串中的字节。</td>
</tr>
<tr>
<td><a href="#_sha224()">sha224()</a></td>
<td>计算二进制字符串的 SHA-224 hash。</td>
</tr>
<tr>
<td><a href="#_sha256()">sha256()</a></td>
<td>计算二进制字符串的 SHA-256 hash。</td>
</tr>
<tr>
<td><a href="#_sha384()">sha384()</a></td>
<td>计算二进制字符串的 SHA-384hash。</td>
</tr>
<tr>
<td><a href="#_sha512()">sha512()</a></td>
<td>计算二进制字符串的 SHA-512hash。</td>
</tr>
<tr>
<td><a href="#_substr()">substr()</a></td>
<td>从start字节开始提取bytes的子字符串，并扩展为count字节，如果这是指定的。</td>
</tr>
</tbody>
</table>
<h6 id="bit_length"># bit_length()</h6>
<p>目的：返回二进制字符串中的位数，8 倍于 octet_length</p>
<p>语法：</p>
<p>输入值:      bytea
返回值:      integer  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select bit_length(&#39;\x123456&#39;::bytea);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>24
</code></pre></div>
<h6 id="octet_length"># octet_length()</h6>
<p>目的：返回二进制字符串中的字节数。</p>
<p>语法：</p>
<p>输入值:    bytea<br />
返回值:    integer  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select octet_length(&#39;\x123456&#39;::bytea);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>3
</code></pre></div>
<h6 id="overlaystring-placing-string-from-int-for-int"># overlay(string placing string from int [for int])</h6>
<p>目的：将bytes的子字符串替换为newsubstring，该子字符串从start字节开始，并以count字节扩展。 如果忽略了count，则默认为newsubstring的长度。</p>
<p>语法：</p>
<p>输入值:     string placing string from int [for int] 
返回值:     bytea </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select overlay(&#39;\x1234567890&#39;::bytea placing &#39;\002\003&#39;::bytea from 2 for 3);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>\x12020390
</code></pre></div>
<h6 id="positionsubstring-in-string"># position(substring in string)</h6>
<p>目的：返回指定的substring在bytes内的起始索引，如果不存在，则为零。</p>
<p>语法：</p>
<p>输入值:     substring in string 
返回值:     integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select position(&#39;\x5678&#39;::bytea in &#39;\x1234567890&#39;::bytea);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>3
</code></pre></div>
<h6 id="substringstring-from-int-for-int"># substring(string [from int] [for int])</h6>
<p>目的：提取bytes从start字节开始的子字符串，如果指定了，并且在count字节之后停止，如果指定了的话。 至少提供start和count中的一个。</p>
<p>语法：</p>
<p>输入值:      string [from int] [for int]
返回值:      bytea</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select substring(&#39;Th\000omas&#39;::bytea from 2 for 3); 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>\x68006f
</code></pre></div>
<h6 id="trimboth-bytes-from-string"># trim([both] bytes from string)</h6>
<p>目的：从开始和结束处，删除只包含字节的最长字符串。</p>
<p>语法：</p>
<p>输入值:      [both] bytes from string
返回值:      bytea</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select trim(&#39;\x9012&#39;::bytea from &#39;\x1234567890&#39;::bytea); 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>\x345678
</code></pre></div>
<h6 id="btrim"># btrim()</h6>
<p>目的：从开始和结束处删除只包含出现的字节的最长字符串</p>
<p>语法：</p>
<p>输入值:     bytea, bytea 
返回值:     bytea </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select btrim(&#39;\x1234567890&#39;::bytea, &#39;\x9012&#39;::bytea); 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>\x345678
</code></pre></div>
<h6 id="decode"># decode()</h6>
<p>目的：从文本表示中解码二进制数据;支持的format值与encode相同。</p>
<p>语法：</p>
<p>输入值:     text, text 
返回值:     bytea </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select decode(&#39;MTIzAAE=&#39;, &#39;base64&#39;);  
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>\x3132330001
</code></pre></div>
<h6 id="encode"># encode()</h6>
<p>目的：将二进制数据编码成文本表示；支持的format值为： base64, escape, hex.</p>
<p>语法：</p>
<p>输入值:     bytea, text 
返回值:     text </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select encode(&#39;123\000\001&#39;, &#39;base64&#39;); 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>MTIzAAE=
</code></pre></div>
<h6 id="get_bit"># get_bit()</h6>
<p>目的：从二进制字符串中提取bit 。</p>
<p>语法：</p>
<p>输入值:      bytea, integer
返回值:      integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select get_bit(&#39;\x1234567890&#39;::bytea, 30);  
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>1
</code></pre></div>
<h6 id="get_byte"># get_byte()</h6>
<p>目的：从二进制字符串中提取字节。</p>
<p>语法：</p>
<p>输入值:      bytea, integer
返回值:      integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select get_byte(&#39;\x1234567890&#39;::bytea, 4);  
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>144
</code></pre></div>
<h6 id="length"># length()</h6>
<p>目的：返回二进制字符串中的字节数。</p>
<p>语法：</p>
<p>输入值:      bytea
返回值:      integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select length(&#39;\x1234567890&#39;::bytea); 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>5
</code></pre></div>
<h6 id="length_1"># length()</h6>
<p>目的：返回二进制字符串中的字符数，假设它是给定encoding中的文本。</p>
<p>语法：</p>
<p>输入值:      bytea, name 
返回值:      integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select length(&#39;jose&#39;::bytea, &#39;UTF8&#39;); 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>4
</code></pre></div>
<h6 id="md5"># md5()</h6>
<p>目的：计算二进制字符串的MD5 hash，结果以十六进制形式写入。</p>
<p>语法：</p>
<p>输入值:     bytea 
返回值:     text </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select md5(&#39;Th\000omas&#39;::bytea); 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>8ab2d3c9689aaf18b4958c334c82d8b1
</code></pre></div>
<h6 id="set_bit"># set_bit()</h6>
<p>目的：设置二进制字符串中bit位。</p>
<p>语法：</p>
<p>输入值:      bytea, integer, integer
返回值:      bytea</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select set_bit(&#39;\x1234567890&#39;::bytea, 30, 0);  
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>\x1234563890
</code></pre></div>
<h6 id="set_byte"># set_byte()</h6>
<p>目的：设置二进制字符串中的字节。</p>
<p>语法：</p>
<p>输入值:      bytea, integer, integer
返回值:      bytea</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select set_byte(&#39;\x1234567890&#39;::bytea, 4, 64);  
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>\x1234567840
</code></pre></div>
<h6 id="sha224"># sha224()</h6>
<p>目的：计算二进制字符串的 SHA-224 hash。</p>
<p>语法：
输入值:      bytea
返回值:      bytea</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select sha224(&#39;abc&#39;::bytea);  
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>\x23097d223405d8228642a477bda255b32aadbce4bda0b3f7e36c9da7
</code></pre></div>
<h6 id="sha256"># sha256()</h6>
<p>目的：计算二进制字符串的 SHA-256 hash。</p>
<p>语法：</p>
<p>输入值:     bytea 
返回值:     bytea </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select sha256(&#39;abc&#39;::bytea);  
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>\xba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad
</code></pre></div>
<h6 id="sha384"># sha384()</h6>
<p>目的：计算二进制字符串的 SHA-384hash。</p>
<p>语法：</p>
<p>输入值:     bytea 
返回值:     bytea </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select sha384(&#39;abc&#39;::bytea);  
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>\xcb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7
</code></pre></div>
<h6 id="sha512"># sha512()</h6>
<p>目的：计算二进制字符串的 SHA-512hash。</p>
<p>语法：</p>
<p>输入值:      bytea
返回值:      bytea</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select sha512(&#39;abc&#39;::bytea); 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>\xddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f
</code></pre></div>
<h6 id="substr"># substr()</h6>
<p>目的：从start字节开始提取bytes的子字符串，并扩展为count字节，如果这是指定的。</p>
<p>语法：</p>
<p>输入值:      bytea, integer, integer
返回值:      bytea</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select substr(&#39;\x1234567890&#39;::bytea, 3, 2); 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>\x5678
</code></pre></div>
<h4 id="boolean"><strong>Boolean</strong></h4>
<p>BOOLEAN数据类型表示三种不同的状态：TRUE、FALSE或NULL。</p>
<p>描述：</p>
<p>type_specification ::= { BOOLEAN | BOOL }
literal ::= { TRUE  | true | 't' | 'y' | 'yes' | 'on' | 1 |
          FALSE | false| 'f' | 'n' | 'no' | 'off' | 0 }</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test1 (a boolean, b text);
INSERT INTO test1 VALUES (TRUE, &#39;sic est&#39;);
INSERT INTO test1 VALUES (FALSE, &#39;non est&#39;);
select * FROM test1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> a |    b
---+---------
 t | sic est
 f | non est
</code></pre></div>
<div class="highlight"><pre><span></span><code>select * FROM test1 WHERE a;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> a |    b
---+---------
 t | sic est
</code></pre></div>
<h4 id="character"><strong>Character</strong></h4>
<p>基于字符的数据类型用于指定Unicode字符字符串的数据。
可用的一般用途的字符类型如下表格所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>1字节的字符</td>
</tr>
<tr>
<td>character(n), char(n)</td>
<td>固定长度（n）的字符串，空格填充</td>
</tr>
<tr>
<td>character varying(n), varchar(n)</td>
<td>具有最大限制的可变长度（n）的字符串</td>
</tr>
<tr>
<td>varchar</td>
<td>无限长度的变长的字符串</td>
</tr>
<tr>
<td>text</td>
<td>无限长度的变长的字符串</td>
</tr>
</tbody>
</table>
<p>描述：
text_literal ::= " ' " [ '' | letter ...] " ' "</p>
<p>这里：</p>
<ul>
<li>单引号必须转义为（''）。</li>
<li>letter是除单引号（[^']）以外的任何字符。</li>
<li>基于字符的数据类型可以是PRIMARY KEY的一部分。</li>
<li>字符数据类型的值是可转换的，并且可与非文本数据类型进行比较。</li>
</ul>
<p>SQL定义了两种基本的字符类型： character varying(n)和character(n)， 其中n是一个正整数。两种类型都可以存储最多n个字符长的串。试图存储更长的串到这些类型的列里会产生一个错误， 除非超出长度的字符都是空白，这种情况下该串将被截断为最大长度。 如果要存储的串比声明的长度短，类型为character的值将会用空白填满；而类型为character varying的值将只是存储短些的串。
如果我们明确地把一个值类型成character varying(n)或者character(n)， 那么超长的值将被截断成n个字符，而不会抛出错误（这也是SQL标准的要求）。
varchar(n)和char(n)的概念分别是character varying(n)和character(n)的别名。没有长度声明词的character等效于character(1)。
另外，提供text类型，它可以存储任何长度的串。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES (&#39;ok&#39;);
INSERT INTO test2 VALUES (&#39;good      &#39;);
INSERT INTO test2 VALUES (&#39;too long&#39;);
ERROR:  value too long for type character varying(5)
INSERT INTO test2 VALUES (&#39;too long&#39;::varchar(5)); -- explicit truncation
select b, char_length(b) FROM test2;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>   b   | char_length 
-------+-------------
 good  |         5
 ok    |         2
 too l   |        5
</code></pre></div>
<h5 id="_45"><strong>函数和操作符</strong></h5>
<h6 id="_46"><strong>操作符和函数</strong></h6>
<table>
<thead>
<tr>
<th>操作符和函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_string||string">string || string</a></td>
<td>字符串连接</td>
</tr>
<tr>
<td>[string || non-string or non-string || string](#_string||non-string or non-string</td>
<td></td>
</tr>
<tr>
<td><a href="#_bit_length(string)">bit_length()</a></td>
<td>字符串中的位数</td>
</tr>
<tr>
<td><a href="#_char_length(string) 与 character_length(string)">char_length() 与character_length()</a></td>
<td>字符串中的字符数</td>
</tr>
<tr>
<td><a href="#_lower(string)">lower()</a></td>
<td>将字符串转换为小写</td>
</tr>
<tr>
<td><a href="#_octet_length(string)">octet_length()</a></td>
<td>字符串中的字节数</td>
</tr>
<tr>
<td><a href="#_overlay(string placing string from int [for int])">overlay(string placing string from int [for int])</a></td>
<td>替换子字符串</td>
</tr>
<tr>
<td><a href="#_position(substring in string)">position(substring in string)</a></td>
<td>指定子字符串的位置</td>
</tr>
<tr>
<td><a href="#_substring(string [from int] [for int])">substring(string [from int] [for int])</a></td>
<td>提取子字符串</td>
</tr>
<tr>
<td><a href="#_substring(string from pattern)">substring(string from pattern)</a></td>
<td>提取与POSIX正则表达式匹配的子字符串。</td>
</tr>
<tr>
<td><a href="#_substring(string from pattern for escape)">substring(string from pattern for escape)</a></td>
<td>提取与SQL正则表达式匹配的子字符串。</td>
</tr>
<tr>
<td>[trim([leading</td>
<td>trailing</td>
</tr>
<tr>
<td>[trim([leading</td>
<td>trailing</td>
</tr>
<tr>
<td><a href="#_upper(string)">upper()</a></td>
<td>将字符串转换为大写</td>
</tr>
<tr>
<td><a href="#_ascii(string)">ascii()</a></td>
<td>参数的第一个字符的ASCII代码。</td>
</tr>
<tr>
<td><a href="#_btrim(string text [, characters text])">btrim(string text [, characters text])</a></td>
<td>从string的开头或结尾删除最长的只包含characters（默认是一个空格）的字符串</td>
</tr>
<tr>
<td><a href="#_chr(int)">chr()</a></td>
<td>返回给定代码的字符。</td>
</tr>
<tr>
<td>[concat ( val1 "any" [, val2 "any" [, ...] ] )](#_concat ( val1 )</td>
<td>连接所有参数的文本表示。空参数被忽略。</td>
</tr>
<tr>
<td>[concat_ws ( sep text, val1 "any" [, val2 "any" [, ...] ] )](#_concat_ws ( sep text, val1 )</td>
<td>用分隔符连接除第一个参数外的所有参数。第一个参数用作分隔符字符串，不应为NULL。其他NULL参数将被忽略。</td>
</tr>
<tr>
<td><a href="#_convert_to(string text, dest_encoding name)">convert_to(string text, dest_encoding name)</a></td>
<td>将字符串转换为dest_encoding。</td>
</tr>
<tr>
<td>[format(formatstr text [, formatarg "any" [, ...] ])](#_format(formatstr text [, formatarg )</td>
<td>根据格式字符串对参数进行格式化。</td>
</tr>
<tr>
<td><a href="#_initcap ( text )">initcap ()</a></td>
<td>将每个单词的第一个字母转换为大写，其余字母转换为小写。单词是由非字母数字字符分隔的字母数字字符序列。</td>
</tr>
<tr>
<td><a href="#_left ( string text, n integer )">left ()</a></td>
<td>以字符串返回第一个 n 字符，或在 n 为负时, 返回最后</td>
</tr>
<tr>
<td><a href="#_length ( text )">length ()</a></td>
<td>返回字符串中的字符数。</td>
</tr>
<tr>
<td><a href="#_lpad ( string text, length integer [, fill text ] )">lpad ()</a></td>
<td>将string扩展为长度length，通过前置字符fill（默认空格）。 如果string已经超过length那么它将被截断（在右侧）。</td>
</tr>
<tr>
<td><a href="#_ltrim ( string text [, characters text ] )">ltrim ()</a></td>
<td>从string开始删除包含characters（默认空格）中仅包含字符的最长字符串。</td>
</tr>
<tr>
<td><a href="#_md5 ( text )">md5 ()</a></td>
<td>计算参数的 MD5 hash ，结果以十六进制形式写入。</td>
</tr>
<tr>
<td><a href="#_parse_ident ( qualified_identifier text [, strict_mode boolean DEFAULT true ] )">parse_ident ( qualified_identifier text [, strict_mode boolean DEFAULT true ] )</a></td>
<td>将qualified_identifier拆分为一个标识符数组，删除单个标识符的任何引用。</td>
</tr>
<tr>
<td><a href="#_pg_client_encoding ( )">pg_client_encoding ( )</a></td>
<td>返回当前客户端编码名称。</td>
</tr>
<tr>
<td><a href="#_quote_ident ( text )">quote_ident ()</a></td>
<td>返回适合引用的给定字符串，作为SQL语句字符串中的标识符。</td>
</tr>
<tr>
<td><a href="#_quote_literal ( text )">quote_literal ()</a></td>
<td>返回在SQL语句字符串中适当引用的给定字符串，用作字符串文字使用。</td>
</tr>
<tr>
<td><a href="#_quote_literal ( anyelement )">quote_literal ()</a></td>
<td>将给定的值转换为文本，然后将其作为字面量引用。 内嵌的单引号和反斜杠被适当地翻倍。</td>
</tr>
<tr>
<td><a href="#_quote_nullable ( text )">quote_nullable ()</a></td>
<td>返回在SQL语句字符串中适当引用的给定字符串文字</td>
</tr>
<tr>
<td><a href="#_quote_nullable ( anyelement )">quote_nullable ()</a></td>
<td>将给定值转换为文本，然后将其作为字面量引用</td>
</tr>
<tr>
<td><a href="#_regexp_match ( string text, pattern text [, flags text ] )">regexp_match ()</a></td>
<td>返回从POSIX正则表达式到string的第一个匹配中捕获的子字符串</td>
</tr>
<tr>
<td><a href="#_regexp_matches ( string text, pattern text [, flags text ] )">regexp_matches ()</a></td>
<td>返回通过将POSIX正则表达式与string匹配而捕获的子字符串</td>
</tr>
<tr>
<td><a href="#_regexp_replace ( string text, pattern text, replacement text [, flags text ] )">regexp_replace ()</a></td>
<td>替换匹配POSIX正则表达式的子字符串</td>
</tr>
<tr>
<td><a href="#_regexp_split_to_array ( string text, pattern text [, flags text ] )">regexp_split_to_array ()</a></td>
<td>使用POSIX正则表达式作为分隔符拆分string</td>
</tr>
<tr>
<td><a href="#_regexp_split_to_table ( string text, pattern text [, flags text ] )">regexp_split_to_table ()</a></td>
<td>使用POSIX正则表达式作为分隔符拆分string</td>
</tr>
<tr>
<td><a href="#_repeat ( string text, number integer )">repeat ()</a></td>
<td>重复string指定number的次数。</td>
</tr>
<tr>
<td><a href="#_replace ( string text, from text, to text )">replace ()</a></td>
<td>将string 中当前的子串替换</td>
</tr>
<tr>
<td><a href="#_reverse ( text )">reverse ()</a></td>
<td>颠倒字符串中字符的顺序。</td>
</tr>
<tr>
<td><a href="#_right ( string text, n integer )">right ()</a>)</td>
<td>返回字符串中的最后n个字符，或者在n&gt;为负时，返回除了前面的</td>
</tr>
<tr>
<td><a href="#_rpad ( string text, length integer [, fill text ] )">rpad ()</a>)</td>
<td>扩展 string 到长度 length，通过追加fill 字符(默认为空格). 如果string 已经比 length 长，则截断它。</td>
</tr>
<tr>
<td><a href="#_rtrim ( string text [, characters text ] )">rtrim ()</a></td>
<td>从string末尾删除包含characters（默认为空格）中仅包含字符的最长字符串。</td>
</tr>
<tr>
<td><a href="#_split_part ( string text, delimiter text, n integer )">split_part ()</a></td>
<td>在delimiter出现时拆分string，并且返回第n个字段(从一计数)。</td>
</tr>
<tr>
<td><a href="#_strpos ( string text, substring text )">strpos ()</a></td>
<td>返回在string中指定的substring的起始索引,如果不存在则为零。</td>
</tr>
<tr>
<td><a href="#_substr ( string text, start integer [, count integer ] )">substr ()</a></td>
<td>提取string从start字符开始的子字符串，并扩展count字符，如果指定了的话。</td>
</tr>
<tr>
<td><a href="#_starts_with ( string text, prefix text )">starts_with ()</a></td>
<td>如果 string 以 prefix开始就返回真。</td>
</tr>
<tr>
<td><a href="#_to_ascii ()">to_ascii ()</a></td>
<td>将string从另一个编码中转换为ASCII，该编码可按名称或编号标识。</td>
</tr>
<tr>
<td><a href="#_to_hex ()">to_hex ()</a></td>
<td>将数字转换为其相应的十六进制表示形式。</td>
</tr>
<tr>
<td><a href="#_translate ()">translate ()</a></td>
<td>将string中与from集合中匹配的每个字符替换为to集合中相应的字符。</td>
</tr>
</tbody>
</table>
<h6 id="string-string"># string || string</h6>
<p>目的：字符串连接</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;Hello&#39; || &#39; World&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>Hello World
</code></pre></div>
<h6 id="string-non-string-or-non-string-string"># string || non-string or non-string || string</h6>
<p>目的：字符串与非字符串连接</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;Value: &#39; || 42;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> Value: 42
</code></pre></div>
<h6 id="bit_length_1"># bit_length()</h6>
<p>目的：字符串中的位数</p>
<p>语法：</p>
<p>输入值:      text
返回值:      integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select bit_length(&#39;jose&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>32
</code></pre></div>
<h6 id="char_length-character_length"># char_length() 与 character_length()</h6>
<p>目的：字符串中的字符数</p>
<p>语法：</p>
<p>输入值:      text
返回值:      integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select char_length(&#39;jose&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>4
</code></pre></div>
<h6 id="lower"># lower()</h6>
<p>目的：将字符串转换为小写</p>
<p>语法：</p>
<p>输入值:      text
返回值:      text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select lower(&#39;TOM&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>tom
</code></pre></div>
<h6 id="octet_length_1"># octet_length()</h6>
<p>目的：字符串中的字节数</p>
<p>语法：</p>
<p>输入值:      text
返回值:      integer</p>
<p>或者</p>
<p>输入值:      character
返回值:      integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select octet_length(&#39;jose&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>4
</code></pre></div>
<h6 id="overlaystring-placing-string-from-int-for-int_1"># overlay(string placing string from int [for int])</h6>
<p>目的：替换子字符串</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select overlay(&#39;Txxxxas&#39; placing &#39;hom&#39; from 2 for 4);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>Thomas
</code></pre></div>
<h6 id="positionsubstring-in-string_1"># position(substring in string)</h6>
<p>目的：指定子字符串的位置 </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select position(&#39;om&#39; in &#39;Thomas&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>3
</code></pre></div>
<h6 id="substringstring-from-int-for-int_1"># substring(string [from int] [for int])</h6>
<p>目的：提取子字符串</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select substring(&#39;Thomas&#39; from 2 for 3);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>hom
</code></pre></div>
<h6 id="substringstring-from-pattern"># substring(string from pattern)</h6>
<p>目的：提取与POSIX正则表达式匹配的子字符串。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select substring(&#39;Thomas&#39; from &#39;...$&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>mas
</code></pre></div>
<h6 id="substringstring-from-pattern-for-escape"># substring(string from pattern for escape)</h6>
<p>目的：提取与SQL正则表达式匹配的子字符串。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select substring(&#39;Thomas&#39; from &#39;%#&quot;o_a#&quot;_&#39; for &#39;#&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>oma
</code></pre></div>
<h6 id="trimleading-trailing-both-characters-from-string"># trim([leading | trailing | both] [characters] from string)</h6>
<p>目的：从字符串的开始、结束或两端（两者都是默认值）的字符（默认情况下为空格）中，删除仅包含字符的最长字符串</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select trim(both &#39;xyz&#39; from &#39;yxTomxx&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>Tom
</code></pre></div>
<h6 id="trimleading-trailing-both-from-string-characters"># trim([leading | trailing | both] [from] string [, characters] )</h6>
<p>目的：trim()的非标准语法</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select trim(both from &#39;yxTomxx&#39;, &#39;xyz&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>Tom
</code></pre></div>
<h6 id="upper"># upper()</h6>
<p>目的：将字符串转换为大写</p>
<p>语法：</p>
<p>输入值:      text
返回值:      text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select upper(&#39;tom&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>TOM
</code></pre></div>
<h6 id="ascii"># ascii()</h6>
<p>目的：参数的第一个字符的ASCII代码。对于UTF8，返回字符的Unicode。对于其他多字节编码，参数必须是ASCII字符。 </p>
<p>语法：</p>
<p>输入值:      text
返回值:      integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ascii(&#39;x&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>120
</code></pre></div>
<h6 id="btrimstring-text-characters-text"># btrim(string text [, characters text])</h6>
<p>目的：从string的开头或结尾删除最长的只包含characters（默认是一个空格）的字符串 </p>
<p>语法：</p>
<p>输入值:      text, text
返回值:      text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select btrim(&#39;xyxtrimyyx&#39;, &#39;xyz&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>trim
</code></pre></div>
<h6 id="chr"># chr()</h6>
<p>目的：返回给定代码的字符。在UTF8编码中该参数被视作一个Unicode代码点。 在其他多字节编码中该参数必须指定一个ASCII字符。 chr(0) 字符不被允许，因为文本数据类型不能存储这种字符。</p>
<p>语法：</p>
<p>输入值:      text
返回值:      text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select chr(65);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>A
</code></pre></div>
<h6 id="concat-val1-any-val2-any"># concat ( val1 "any" [, val2 "any" [, ...] ] )</h6>
<p>目的：连接所有参数的文本表示。空参数被忽略。</p>
<p>语法：</p>
<p>输入值:      VARIADIC "any" 
返回值:      text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select concat(&#39;abcde&#39;, 2, NULL, 22);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>abcde222
</code></pre></div>
<h6 id="concat_ws-sep-text-val1-any-val2-any"># concat_ws ( sep text, val1 "any" [, val2 "any" [, ...] ] )</h6>
<p>目的：用分隔符连接除第一个参数外的所有参数。第一个参数用作分隔符字符串，不应为NULL。其他NULL参数将被忽略。</p>
<p>语法：</p>
<p>输入值:      text, VARIADIC "any" 
返回值:      text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select concat_ws(&#39;,&#39;, &#39;abcde&#39;, 2, NULL, 22);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>abcde,2,22
</code></pre></div>
<h6 id="convert_tostring-text-dest_encoding-name"># convert_to(string text, dest_encoding name)</h6>
<p>目的：将字符串转换为dest_encoding。</p>
<p>语法：</p>
<p>输入值:      text, name 
返回值:      bytea</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select convert_to(&#39;some text&#39;, &#39;UTF8&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> \x736f6d652074657874
</code></pre></div>
<h6 id="formatformatstr-text-formatarg-any"># format(formatstr text [, formatarg "any" [, ...] ])</h6>
<p>目的：根据格式字符串对参数进行格式化。</p>
<p>语法：</p>
<p>输入值:      text, VARIADIC "any"
返回值:      text</p>
<p>formatstr是一个格式字符串，它指定了结果应该如何被格式化。格式字符串中的文本被直接复制到结果中，除了使用格式说明符的地方。格式说明符在字符串中扮演着占位符的角色，它定义后续的函数参数如何被格式化及插入到结果中。每一个formatarg参数会被根据其数据类型的常规输出规则转换为文本，并接着根据格式说明符被格式化和插入到结果字符串中。</p>
<p>格式说明符由一个%字符开始并且有这样的形式</p>
<p>%[position][flags][width]type
其中的各组件域是：</p>
<p>position（可选）
一个形式为n\$的字符串，其中n是要打印的参数的索引。索引 1 表示formatstr之后的第一个参数。如果position被忽略，默认会使用序列中的下一个参数。</p>
<p>flags（可选）
控制格式说明符的输出如何被格式化的附加选项。当前唯一支持的标志是一个负号（-），它将导致格式说明符的输出会被左对齐（left-justified）。除非width域也被指定，否者这个域不会产生任何效果。</p>
<p>width（可选）
指定用于显示格式说明符输出的最小字符数。输出将被在左部或右部（取决于-标志）用空格填充以保证充满该宽度。太小的宽度设置不会导致输出被截断，但是会被简单地忽略。宽度可以使用下列形式之一指定：一个正整数；一个星号（*）表示使用下一个函数参数作为宽度；或者一个形式为*n\$的字符串表示使用第n个函数参数作为宽度。</p>
<p>如果宽度来自于一个函数参数，则参数在被格式说明符的值使用之前就被消耗掉了。如果宽度参数是负值，结果会在长度为abs(width)的域中被左对齐（如果-标志被指定）。</p>
<p>type（必需）
格式转换的类型，用于产生格式说明符的输出。支持下面的类型：</p>
<p>s将参数值格式化为一个简单字符串。一个控制被视为一个空字符串。</p>
<p>I将参数值视作 SQL 标识符，并在必要时用双写引号包围它。如果参数为空，将会是一个错误（等效于quote_ident）。</p>
<p>L将参数值引用为 SQL 文字。一个空值将被显示为不带引号的字符串NULL（等效于quote_nullable）。</p>
<p>除了以上所述的格式说明符之外，要输出一个文字形式的%字符，可以使用特殊序列%%。</p>
<p>下面有一些基本的格式转换的示例：</p>
<div class="highlight"><pre><span></span><code>select format(&#39;Hello %s&#39;, &#39;World&#39;);
</code></pre></div>
<p>结果：Hello World</p>
<div class="highlight"><pre><span></span><code>select format(&#39;Testing %s, %s, %s, %%&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;);
</code></pre></div>
<p>结果：Testing one, two, three, %</p>
<div class="highlight"><pre><span></span><code>select format(&#39;INSERT INTO %I VALUES(%L)&#39;, &#39;Foo bar&#39;, E&#39;O\&#39;Reilly&#39;);
</code></pre></div>
<p>结果：INSERT INTO "Foo bar" VALUES('O''Reilly')</p>
<div class="highlight"><pre><span></span><code>select format(&#39;INSERT INTO %I VALUES(%L)&#39;, &#39;locations&#39;, &#39;C:\Program Files&#39;);
</code></pre></div>
<p>结果：INSERT INTO locations VALUES(E'C:\\Program Files')</p>
<p>下面是使用width域和-标志的示例：</p>
<div class="highlight"><pre><span></span><code>select format(&#39;|%10s|&#39;, &#39;foo&#39;);
</code></pre></div>
<p>结果：|       foo|</p>
<div class="highlight"><pre><span></span><code>select format(&#39;|%-10s|&#39;, &#39;foo&#39;);
</code></pre></div>
<p>结果：|foo       |</p>
<div class="highlight"><pre><span></span><code>select format(&#39;|%*s|&#39;, 10, &#39;foo&#39;);
</code></pre></div>
<p>结果：|       foo|</p>
<div class="highlight"><pre><span></span><code>select format(&#39;|%*s|&#39;, -10, &#39;foo&#39;);
</code></pre></div>
<p>结果：|foo       |</p>
<div class="highlight"><pre><span></span><code>select format(&#39;|%-*s|&#39;, 10, &#39;foo&#39;);
</code></pre></div>
<p>结果：|foo       |</p>
<div class="highlight"><pre><span></span><code>select format(&#39;|%-*s|&#39;, -10, &#39;foo&#39;);
</code></pre></div>
<table>
<thead>
<tr>
<th>结果：</th>
<th>foo</th>
</tr>
</thead>
<tbody>
<tr>
<td>这些示例展示了position域的示例：</td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code>select format(&#39;Testing %3$s, %2$s, %1$s&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;);
</code></pre></div>
<p>结果：Testing three, two, one</p>
<div class="highlight"><pre><span></span><code>select format(&#39;|%*2$s|&#39;, &#39;foo&#39;, 10, &#39;bar&#39;);
</code></pre></div>
<p>结果：|       bar|</p>
<div class="highlight"><pre><span></span><code>select format(&#39;|%1$*2$s|&#39;, &#39;foo&#39;, 10, &#39;bar&#39;);
</code></pre></div>
<p>结果：|       foo|</p>
<h6 id="initcap"># initcap()</h6>
<p>目的：将每个单词的第一个字母转换为大写，其余字母转换为小写。单词是由非字母数字字符分隔的字母数字字符序列。</p>
<p>语法：</p>
<p>输入值:      text
返回值:      text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select initcap(&#39;hi THOMAS&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> Hi Thomas
</code></pre></div>
<h6 id="left"># left()</h6>
<p>目的：以字符串返回第一个 n 字符，或在 n 为负时, 返回最后 |n| 个字符之外的全部字符。</p>
<p>语法：</p>
<p>输入值:    text, integer   <br />
返回值:    text  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select left(&#39;abcde&#39;, 2);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>ab
</code></pre></div>
<h6 id="length_2"># length()</h6>
<p>目的：返回字符串中的字符数。</p>
<p>语法：</p>
<p>输入值:   text  <br />
返回值:   integer   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select length(&#39;jose&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>4
</code></pre></div>
<h6 id="lpad"># lpad()</h6>
<p>目的：将string扩展为长度length，通过前置字符fill（默认空格）。 如果string已经超过length那么它将被截断（在右侧）。</p>
<p>语法：</p>
<p>输入值:    text, integer, text  <br />
返回值:    text    </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select lpad(&#39;hi&#39;, 5, &#39;xy&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>xyxhi
</code></pre></div>
<h6 id="ltrim"># ltrim()</h6>
<p>目的：从string开始删除包含characters（默认空格）中仅包含字符的最长字符串。</p>
<p>语法：</p>
<p>输入值:  text, text    <br />
返回值:  text    </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ltrim(&#39;zzzytest&#39;, &#39;xyz&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>test
</code></pre></div>
<h6 id="md5_1"># md5()</h6>
<p>目的：计算参数的 MD5 hash ，结果以十六进制形式写入。</p>
<p>语法：</p>
<p>输入值:  text   <br />
返回值:  text    </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select md5(&#39;abc&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>900150983cd24fb0d6963f7d28e17f72
</code></pre></div>
<h6 id="parse_ident-qualified_identifier-text-strict_mode-boolean-default-true"># parse_ident ( qualified_identifier text [, strict_mode boolean DEFAULT true ] )</h6>
<p>目的：将qualified_identifier拆分为一个标识符数组，删除单个标识符的任何引用。 默认情况下，最后一个标识符之后的额外字符被视为错误；但是，如果第二个参数为false，则忽略这些额外的字符。 （这种行为对于解析类似函数的对象的名称有作用。） 请注意，此函数不会截断超长标识符。如果你想截断，你可以把结果给到name[]。</p>
<p>语法：</p>
<p>输入值:  str text, strict boolean DEFAULT true   <br />
返回值:  text[]     </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select parse_ident(&#39;&quot;SomeSchema&quot;.someTable&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>{SomeSchema,sometable}
</code></pre></div>
<h6 id="pg_client_encoding"># pg_client_encoding()</h6>
<p>目的：返回当前客户端编码名称。</p>
<p>语法：</p>
<p>返回值:    name  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_client_encoding();
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>UTF8
</code></pre></div>
<h6 id="quote_ident"># quote_ident()</h6>
<p>目的：返回适合引用的给定字符串，作为SQL语句字符串中的标识符。 只有在必要的情况下才添加引号(例如，如果字符串包含非标识符字符或将被大小写折叠)。 嵌入的引号被适当地加双引号。</p>
<p>语法：</p>
<p>输入值:    text 
返回值:    text  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select quote_ident(&#39;Foo bar&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&quot;Foo bar&quot;
</code></pre></div>
<h6 id="quote_literal"># quote_literal()</h6>
<p>目的：返回在SQL语句字符串中适当引用的给定字符串，用作字符串文字使用。 嵌入式单引号和反斜线适当的翻倍(转双引号或双斜线)。 请注意，quote_literal返回无效输入；如果这个参数可能为空，quote_nullable通常更合适。</p>
<p>语法：</p>
<p>输入值:    text <br />
返回值:   text   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select quote_literal(E&#39;O\&#39;Reilly&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;O&#39;&#39;Reilly&#39;
</code></pre></div>
<h6 id="quote_literal_1"># quote_literal()</h6>
<p>目的：将给定的值转换为文本，然后将其作为字面量引用。 内嵌的单引号和反斜杠被适当地翻倍。</p>
<p>语法：</p>
<p>输入值:     anyelement<br />
返回值:     text    </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select quote_literal(42.5);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;42.5&#39;
</code></pre></div>
<h6 id="quote_nullable"># quote_nullable()</h6>
<p>目的：返回在SQL语句字符串中适当引用的给定字符串文字;或者，如果参数为null，则返回NULL。 内嵌的单引号和反斜杠被适当地翻倍。</p>
<p>语法：</p>
<p>输入值:    text<br />
返回值:    text </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select quote_nullable(NULL);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>NULL
</code></pre></div>
<h6 id="quote_nullable_1"># quote_nullable()</h6>
<p>目的：将给定值转换为文本，然后将其作为字面量引用；或者，如果参数为null，则返回NULL。 内嵌的单引号和反斜杠被适当地翻倍。</p>
<p>语法：</p>
<p>输入值:   anyelement <br />
返回值:   text    </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select quote_nullable(42.5);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;42.5&#39;
</code></pre></div>
<h6 id="regexp_match"># regexp_match()</h6>
<p>目的：返回从POSIX正则表达式到string的第一个匹配中捕获的子字符串</p>
<p>语法：</p>
<p>输入值:    text, text, text<br />
返回值:    text[]  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select regexp_match(&#39;foobarbequebaz&#39;, &#39;(bar)(beque)&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> {bar,beque}
</code></pre></div>
<h6 id="regexp_matches"># regexp_matches()</h6>
<p>目的：返回通过将POSIX正则表达式与string匹配而捕获的子字符串</p>
<p>语法：</p>
<p>输入值:  text, text, text  <br />
返回值:  SETOF text[]    </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select regexp_matches(&#39;foobarbequebaz&#39;, &#39;ba.&#39;, &#39;g&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> {bar}
 {baz}
</code></pre></div>
<h6 id="regexp_replace"># regexp_replace()</h6>
<p>目的：替换匹配POSIX正则表达式的子字符串</p>
<p>语法：</p>
<p>输入值:   text, text, text, text  <br />
返回值:   text   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select regexp_replace(&#39;Thomas&#39;, &#39;.[mN]a.&#39;, &#39;M&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> ThM
</code></pre></div>
<h6 id="regexp_split_to_array"># regexp_split_to_array()</h6>
<p>目的：使用POSIX正则表达式作为分隔符拆分string</p>
<p>语法：</p>
<p>输入值:   text, text, text <br />
返回值:   text[]     </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select regexp_split_to_array(&#39;hello world&#39;, &#39;\s+&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>{hello,world}
</code></pre></div>
<h6 id="regexp_split_to_table"># regexp_split_to_table()</h6>
<p>目的：使用POSIX正则表达式作为分隔符拆分string</p>
<p>语法：</p>
<p>输入值:   text, text, text <br />
返回值:   SETOF text   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select regexp_split_to_table(&#39;hello world&#39;, &#39;\s+&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> hello
 world
</code></pre></div>
<h6 id="repeat"># repeat()</h6>
<p>目的：重复string指定number的次数。</p>
<p>语法：</p>
<p>输入值:   text, integer <br />
返回值:   text   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select repeat(&#39;Pg&#39;, 4);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>PgPgPgPg
</code></pre></div>
<h6 id="replace"># replace()</h6>
<p>目的：将string 中当前的子串替换</p>
<p>语法：</p>
<p>输入值:   text, text, text    <br />
返回值:   text   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select replace(&#39;abcdefabcdef&#39;, &#39;cd&#39;, &#39;XX&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>abXXefabXXef
</code></pre></div>
<h6 id="reverse"># reverse()</h6>
<p>目的：颠倒字符串中字符的顺序。</p>
<p>语法：</p>
<p>输入值:   text<br />
返回值:   text   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select reverse(&#39;abcde&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>edcba
</code></pre></div>
<h6 id="right"># right()</h6>
<p>目的：返回字符串中的最后n个字符，或者在n&gt;为负时，返回除了前面的|n|字符之外的所有字符。</p>
<p>语法：</p>
<p>输入值:   text, integer
返回值:   text   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select right(&#39;abcde&#39;, 2) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>de
</code></pre></div>
<h6 id="rpad"># rpad()</h6>
<p>目的：扩展 string 到长度 length，通过追加fill 字符(默认为空格). 如果string 已经比 length 长，则截断它。</p>
<p>语法：</p>
<p>输入值:    text, integer, text
返回值:    text   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select rpad(&#39;hi&#39;, 5, &#39;xy&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>hixyx
</code></pre></div>
<h6 id="rtrim"># rtrim()</h6>
<p>目的：从string末尾删除包含characters（默认为空格）中仅包含字符的最长字符串。</p>
<p>语法：</p>
<p>输入值:    text, text
返回值:    text   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select rtrim(&#39;testxxzx&#39;, &#39;xyz&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>test
</code></pre></div>
<h6 id="split_part"># split_part()</h6>
<p>目的：在delimiter出现时拆分string，并且返回第n个字段(从一计数)。</p>
<p>语法：</p>
<p>输入值:    text, text, integer
返回值:    text   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select split_part(&#39;abc~@~def~@~ghi&#39;, &#39;~@~&#39;, 2);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>def
</code></pre></div>
<h6 id="strpos"># strpos()</h6>
<p>目的：返回在string中指定的substring的起始索引,如果不存在则为零。</p>
<p>语法：</p>
<p>输入值:    text, text
返回值:   integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select strpos(&#39;high&#39;, &#39;ig&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2
</code></pre></div>
<h6 id="substr_1"># substr()</h6>
<p>目的：提取string从start字符开始的子字符串，并扩展count字符，如果指定了的话。</p>
<p>语法：</p>
<p>输入值:   text, integer, integer
返回值:   text   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select substr(&#39;alphabet&#39;, 3, 2);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>ph
</code></pre></div>
<h6 id="starts_with"># starts_with()</h6>
<p>目的：如果 string 以 prefix开始就返回真。</p>
<p>语法：</p>
<p>输入值:    text, text
返回值:    boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select starts_with(&#39;alphabet&#39;, &#39;alph&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="to_ascii"># to_ascii()</h6>
<p>目的：将string从另一个编码中转换为ASCII，该编码可按名称或编号标识。如果encoding被省略，则假定数据库编码（这在实践中是唯一有用的案例）。转换主要包括降音。 转换仅支持来自 LATIN1、LATIN2、LATIN9、 和 WIN1250 的编码</p>
<p>语法：</p>
<p>输入值:   text<br />
返回值:   text  </p>
<p>或者</p>
<p>输入值:   text, integer
返回值:   text  </p>
<p>或者</p>
<p>输入值:   text, name
返回值:   text  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select to_ascii(&#39;abc&#39;,&#39;LATIN1&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>abc
</code></pre></div>
<h6 id="to_hex"># to_hex()</h6>
<p>目的：将数字转换为其相应的十六进制表示形式。</p>
<p>语法：</p>
<p>输入值:    bigint
返回值:    text   </p>
<p>或者</p>
<p>输入值:    integer
返回值:    text   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select to_hex(2147483647);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>7fffffff
</code></pre></div>
<h6 id="translate"># translate()</h6>
<p>目的：将string中与from集合中匹配的每个字符替换为to集合中相应的字符。 如果from长于to，from中出现的额外字符被删除。</p>
<p>语法：</p>
<p>输入值:    text, text, text
返回值:    text   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select translate(&#39;12345&#39;, &#39;143&#39;, &#39;ax&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>a2x5
</code></pre></div>
<h4 id="datetime"><strong>date与time</strong></h4>
<h5 id="_47"><strong>概要</strong></h5>
<p>BSQL支持以下数据类型的值，这些值表示日期、时间、日期和时间，或持续时间。这些数据类型将被统称为日期-时间数据类型，如下表格所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储</th>
<th>描述</th>
<th>最小值</th>
<th>最大值</th>
<th>解析度</th>
</tr>
</thead>
<tbody>
<tr>
<td>date</td>
<td>4字节</td>
<td>日期（没有一天中的时间）</td>
<td>4713 BC</td>
<td>5874897 AD</td>
<td>1日</td>
</tr>
<tr>
<td>time [ (p) ]</td>
<td>8字节</td>
<td>一天中的时间（无日期）</td>
<td>00:00:00</td>
<td>24:00:00</td>
<td>1微秒</td>
</tr>
<tr>
<td>timestamp [ (p) ]</td>
<td>12字节</td>
<td>包括日期和时间</td>
<td>4713 BC</td>
<td>294276 AD</td>
<td>1微秒</td>
</tr>
<tr>
<td>timestamptz [(p)]</td>
<td>12字节</td>
<td>包括日期和时间</td>
<td>4713 BC</td>
<td>294276 AD</td>
<td>1微秒</td>
</tr>
<tr>
<td>interval</td>
<td>16字节</td>
<td>时间间隔</td>
<td></td>
<td></td>
<td>1微秒</td>
</tr>
<tr>
<td>timetz [(p)]</td>
<td></td>
<td>不推荐使用</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>可选的 (p) 限定符，其中p是0..6中的整数值，以微秒为单位指定记录值的精度。（它对内部表示的大小没有影响。）仅在区间声明中有效的可选字段限定符，请参见区间数据类型。   <br />
timestamptz 是一个别名，被接受为timestamp with time zone的一种简写，由PostgreSQL定义并由BSQL继承，SQL标准将其拼写为带时区的时间戳。不加修饰的timestamp由SQL标准定义，并且可以选择性地拼写为不带时区的timestamp，也适用于timetz和time。</p>
<p>注：避免使用“timetz”数据类型。 
PostgreSQL文档建议不要使用timetz（又称带时区的时间）数据类型： 
带时区的数据类型时间是由SQL标准定义的，但该定义显示的属性导致有用性受到质疑。在大多数情况下，日期、（普通）时间、（纯）时间戳和时间戳的组合，应该提供任何应用程序可能需要的完整的日期-时间功能范围。 </p>
<p>特殊值
为了方便，PostgreSQL和BSQL支持一些特殊日期/时间输入值，如下表所示。这些值中infinity和-infinity被在系统内部以特殊方式表示并且将被原封不动地显示。但是其他的仅仅只是概念上的速写，当被读到的时候会被转换为正常的日期/时间值（特殊地，now及相关串在被读到时立刻被转换到一个指定的时间值）。在作为常量在SQL命令中使用时，所有这些值需要被包括在单引号内。请参见PostgreSQL文档<a href="#DATATYPE-DATETIME-SPECIAL-VALUES">Special Values</a></p>
<table>
<thead>
<tr>
<th>输入串</th>
<th>合法类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>'epoch'</td>
<td>date, timestamp</td>
<td>1970-01-01 00:00:00+00（Unix系统时间0）</td>
</tr>
<tr>
<td>'infinity'</td>
<td>date, timestamp, timestamptz</td>
<td>比任何其他时间戳都晚</td>
</tr>
<tr>
<td>'-infinity'</td>
<td>date, timestamp</td>
<td>比任何其他时间戳都早</td>
</tr>
<tr>
<td>'now'</td>
<td>date, time, timestamp</td>
<td>当前事务的开始时间</td>
</tr>
<tr>
<td>'today'</td>
<td>date, timestamp</td>
<td>今日午夜 (00:00)</td>
</tr>
<tr>
<td>'tomorrow'</td>
<td>date, timestamp</td>
<td>明日午夜 (00:00)</td>
</tr>
<tr>
<td>'yesterday'</td>
<td>date, timestamp</td>
<td>昨日午夜 (00:00)</td>
</tr>
<tr>
<td>'allballs'</td>
<td>time</td>
<td>00:00:00.00 UTC</td>
</tr>
</tbody>
</table>
<p>注：除了“infinity”和“-infinity”，请避免使用所有这些特殊常量。而且，即使是针对与“infinity”和“-infinity”，也并不是适用于所有地方，例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;infinity&#39;::timestamptz - clock_timestamp();
</code></pre></div>
<p>会报告错误信息：cannot subtract infinite timestamps</p>
<p>同样，select 'infinity'::interval;
也会报告错误信息：invalid input syntax for type interval: "infinity"</p>
<h5 id="date"><strong>date</strong></h5>
<p>数据类型为date的值，表示本地某个时刻（年、月和日）的日期。
日期的输入可以接受几乎任何合理的格式，包括 ISO 8601、SQL-兼容的、传统POSTGRES的和其他的形式。对于一些格式，日期输入里的日、月和年的顺序会让人混淆， 并且支持指定所预期的这些域的顺序。把DateStyle参数设置为MDY，就是选择“月－日－年”的解释，设置为DMY就是 “日－月－年”，而YMD是 “年－月－日”。</p>
<p>请记住任何日期或者时间的文字输入需要由单引号包围，就象一个文本字符串一样。</p>
<p>如下表中示例展示了可能的日期输入：</p>
<table>
<thead>
<tr>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1999-01-08</td>
<td>ISO 8601; 任何模式下的1月8日（推荐格式）</td>
</tr>
<tr>
<td>January 8, 1999</td>
<td>在任何datestyle输入模式下都无歧义</td>
</tr>
<tr>
<td>1/8/1999</td>
<td>MDY模式中的1月8日；DMY模式中的8月1日</td>
</tr>
<tr>
<td>1/18/1999</td>
<td>MDY模式中的1月18日；在其他模式中被拒绝</td>
</tr>
<tr>
<td>01/02/03</td>
<td>MDY模式中的2003年1月2日；DMY模式中的2003年2月1日； YMD模式中的2001年2月3日</td>
</tr>
<tr>
<td>1999-Jan-08</td>
<td>任何模式下的1月8日</td>
</tr>
<tr>
<td>Jan-08-1999</td>
<td>任何模式下的1月8日</td>
</tr>
<tr>
<td>08-Jan-1999</td>
<td>任何模式下的1月8日</td>
</tr>
<tr>
<td>99-Jan-08</td>
<td>YMD模式中的1月8日，否则错误</td>
</tr>
<tr>
<td>08-Jan-99</td>
<td>1月8日，在YMD模式中错误</td>
</tr>
<tr>
<td>Jan-08-99</td>
<td>1月8日，在YMD模式中错误</td>
</tr>
<tr>
<td>19990108</td>
<td>ISO 8601; 任何模式中的1999年1月8日</td>
</tr>
<tr>
<td>990108</td>
<td>ISO 8601; 任何模式中的1999年1月8日</td>
</tr>
<tr>
<td>1999.008</td>
<td>年和一年中的天数</td>
</tr>
<tr>
<td>J2451187</td>
<td>儒略日期</td>
</tr>
<tr>
<td>January 8, 99 BC</td>
<td>公元前99年</td>
</tr>
</tbody>
</table>
<p>时间的输出格式可以设成四种风格之一： ISO 8601、SQL（Ingres）、传统的POSTGRES（Unix的date格式）或 German 。缺省是ISO格式（ISO标准要求使用 ISO 8601 格式。）。下表显示了每种输出风格的示例：</p>
<table>
<thead>
<tr>
<th>风格声明</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>ISO</td>
<td>ISO 8601, SQL标准</td>
<td>1997-12-17</td>
</tr>
<tr>
<td>SQL</td>
<td>传统风格</td>
<td>12/17/1997</td>
</tr>
<tr>
<td>Postgres</td>
<td>原始风格</td>
<td>Wed Dec 17</td>
</tr>
<tr>
<td>German</td>
<td>地区风格</td>
<td>17.12.1997</td>
</tr>
</tbody>
</table>
<p>SQL和POSTGRES风格中，如果DMY域顺序被指定，“日”将出现在“月”之前，否则“月”出现在“日”之前。示例如下表所示：</p>
<table>
<thead>
<tr>
<th>datestyle设置</th>
<th>输入顺序</th>
<th>示例输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>SQL, DMY</td>
<td>日/月/年</td>
<td>17/12/1997 15:37:16.00 CET</td>
</tr>
<tr>
<td>SQL, MDY</td>
<td>月/日/年</td>
<td>12/17/1997 07:37:16.00 PST</td>
</tr>
<tr>
<td>Postgres, DMY</td>
<td>日/月/年</td>
<td>Wed 17 Dec 07:37:16 1997 PST</td>
</tr>
</tbody>
</table>
<p>请注意，从另一个日期值中减去一个日期会产生一个整数值：两个指定日期之间的天数，该值对公历闰年敏感。例如：</p>
<div class="highlight"><pre><span></span><code>select pg_typeof(&#39;2019-02-14&#39;::date - &#39;2018-02-14&#39;::date)::text as &quot;data type of difference between dates&quot;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> data type of difference between dates
----------------------------------------------
 Integer
</code></pre></div>
<h5 id="time"><strong>time</strong></h5>
<p>数据类型为time的值，表示本地某个时刻的时间，小时和分钟为整数值，秒为微秒精度的实数值。
time类型可细分为是time [ (p) ] without time zone和time [ (p) ] with time zone。 只写time等效于time without time zone。 
这些类型的有效输入，是由当日时间后面跟着可选的时区组成，见下表示例所示。
如果在time without time zone的输入中指定了时区，那么它会被忽略。也可以指定一个日期，但是它也会被忽略，除非你使用了一个涉及到夏令时规则的时区，例如America/New_York。在这种情况下，为了判断是应用了标准时间还是夏令时时间，要求指定该日期。适当的时区偏移被记录在time with time zone值中。</p>
<p>有效时间输入示例： </p>
<table>
<thead>
<tr>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>04:05:06.789</td>
<td>ISO 8601</td>
</tr>
<tr>
<td>04:05:06</td>
<td>ISO 8601</td>
</tr>
<tr>
<td>04:05</td>
<td>ISO 8601</td>
</tr>
<tr>
<td>040506</td>
<td>ISO 8601</td>
</tr>
<tr>
<td>04:05 AM</td>
<td>和04:05一样，AM并不影响值</td>
</tr>
<tr>
<td>04:05 PM</td>
<td>和16:05一样，输入的小时必须为 &lt;= 12</td>
</tr>
<tr>
<td>04:05:06.789-8</td>
<td>ISO 8601</td>
</tr>
<tr>
<td>04:05:06-08:00</td>
<td>ISO 8601</td>
</tr>
<tr>
<td>04:05-08:00</td>
<td>ISO 8601</td>
</tr>
<tr>
<td>040506-08</td>
<td>ISO 8601</td>
</tr>
<tr>
<td>04:05:06 PST</td>
<td>缩写指定的时区</td>
</tr>
<tr>
<td>2003-04-12 04:05:06 America/New_York</td>
<td>全名指定的时区</td>
</tr>
</tbody>
</table>
<p>有效时区输入示例：</p>
<table>
<thead>
<tr>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PST</td>
<td>缩写（太平洋标准时间）</td>
</tr>
<tr>
<td>America/New_York</td>
<td>完整时区名</td>
</tr>
<tr>
<td>PST8PDT</td>
<td>POSIX风格的时区声明</td>
</tr>
<tr>
<td>-8:00</td>
<td>PST的ISO-8601偏移</td>
</tr>
<tr>
<td>-800</td>
<td>PST的ISO-8601偏移</td>
</tr>
<tr>
<td>-8</td>
<td>PST的ISO-8601偏移</td>
</tr>
<tr>
<td>zulu</td>
<td>UTC的军方缩写</td>
</tr>
<tr>
<td>z</td>
<td>zulu的短形式</td>
</tr>
</tbody>
</table>
<p>由于时间值对时区一无所知，他们也对夏令时制度一无所知：每天都应该从午夜（含）开始，一直持续到下一个午夜（不含）结束。见下例所示：</p>
<div class="highlight"><pre><span></span><code>select
  (&#39;00:00:00.000000&#39;::time)::text as &quot;starting midnight&quot;,
  (&#39;23:59:59.999999&#39;::time)::text as &quot;just before ending midnight&quot;,
  (&#39;24:00:00.000000&#39;::time)::text as &quot;ending midnight&quot;;
</code></pre></div>
<p>事实上，存在一个小小的烦恼，就是这两个time（'00:00:00.000000'，'24:00:00.000000'）并不相等，见下例所示 ：</p>
<div class="highlight"><pre><span></span><code> select (
  &#39;00:00:00.000000&#39;::time =
  &#39;24:00:00.000000&#39;::time
  )::text;
</code></pre></div>
<p>结果返回false。由于时间值不包含日期信息，您需要定义并公布辅助应用程序语义，以将24:00:00解释为特定日期的结束，而不是前一天的开始，如下进一步展示：</p>
<div class="highlight"><pre><span></span><code>select
  (&#39;02:00:00&#39;::time - &#39;01:00:00&#39;::time)::text as &quot;interval 1&quot;,
  (&#39;24:00:00&#39;::time - &#39;00:00:00&#39;::time)::text as &quot;interval 2&quot;,
  justify_hours(&#39;24:00:00&#39;::time - &#39;00:00:00&#39;::time)::text as &quot;interval 3&quot;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> interval 1 | interval 2 | interval 3
------------+------------+------------
 01:00:00   | 24:00:00   | 1 day
</code></pre></div>
<p>这里还有另一个烦恼：在日期值中添加间隔值可能会导致环绕。见下例所示 ：</p>
<div class="highlight"><pre><span></span><code>select &#39;24:00:00&#39;::time + &#39;1 second&#39;::interval;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 00:00:01
</code></pre></div>
<h5 id="utc"><strong>时区和UTC偏移</strong></h5>
<h6 id="_48"><strong>时区</strong></h6>
<p>时区和时区习惯不仅仅受地球几何形状的影响，还受到政治决定的影响。 到了19世纪，全球的时区变得稍微标准化了些，但是还是易于遭受随意的修改，部分是因为夏时制规则。
SQL标准在日期和时间类型和功能上有一些奇怪的混淆。两个显而易见的问题是：</p>
<ul>
<li>尽管date类型与时区没有联系，而time类型却可以有。 然而，现实世界的时区只有在与时间和日期都关联时才有意义， 因为偏移（时差）可能因为实行类似夏时制这样的制度而在一年里有所变化。</li>
<li>缺省的时区会指定一个到UTC的数字常量偏移（时差）。因此，当跨DST边界做日期/时间算术时， 我们根本不可能适应于夏时制时间。</li>
</ul>
<p>为了克服这些困难，我们建议在使用时区的时候，使用那些同时包含日期和时间的日期/时间类型。我们不建议使用类型 time with time zone。 假设你用于任何类型的本地时区都只包含日期或时间。</p>
<p>在系统内部，所有时区相关的日期和时间都用UTC存储。它们在被显示给客户端之前，会被转换成由TimeZone配置参数指定的本地时间。</p>
<p>允许你使用三种不同形式指定时区：</p>
<ul>
<li>
<p>一个完整的时区名字，例如America/New_York。能被识别的时区名字被列在pg_timezone_names视图中。用广泛使用的 IANA 时区数据来实现该目的，因此相同的时区名字也可以在其他软件中被识别。</p>
</li>
<li>
<p>一个时区缩写，例如PST。这样一种声明仅仅定义了到UTC的一个特定偏移，而不像完整时区名那样指出整套夏令时转换规则。 能被识别的缩写被列在pg_timezone_abbrevs视图中。 你不能将配置参数TimeZone或log_timezone设置成一个时区缩写，但是你可以在日期/时间输入值和AT TIME ZONE操作符中使用时区缩写。</p>
</li>
</ul>
<p>除了时区名和缩写，接受POSIX-风格的时区规范。 这个选项通常不优先用于指定时区，但是，如果没有合适的IANA时区条目，这可能是必要的。</p>
<p>简而言之，在缩写和全称之间是有不同的：缩写表示从UTC开始的一个特定偏移量， 而很多全称表示一个本地夏令时规则并且因此具有两种可能的UTC偏移量。例如， 2014-06-04 12:00 America/New_York表示纽约本地时间的中午， 这个特殊的日期是东部夏令时间（UTC-4）。因此2014-06-04 12:00 EDT 指定的是同一个时间点。但是2014-06-04 12:00 EST指定东部标准时间的 中午（UTC-5），不管在那个日期夏令时是否生效。</p>
<p>更要命的是，某些行政区已经使用相同的时区缩写在不同的时间表示不同的 UTC 偏移量。例如， 在莫斯科MSK在某些年份表示 UTC+3 而在另一些年份表示 UTC+4。 根据指定的日期它们到底表示什么（或者最近表示什么） 来解释这种缩写。但是，正如上面的EST示例所示，这并不是必须和那一天的本地 标准时间相同。</p>
<p>在所有情况下，时区名及其缩写都是大小写不敏感的。</p>
<p>TimeZone配置参数可以在文件postgresql.conf中被设置。同时也有一些特殊的方法来设置它。</p>
<p>SQL命令SET TIME ZONE为会话设置时区。它是SET TIMEZONE TO的另一种拼写，它更加符合SQL的语法。</p>
<p>“timezone”和“time zone”这两种拼写形式都出现在SQL语法中。例如，set timezone = <arg>和set time zone <arg> 都是合法的。</p>
<p>AiSQL 中包含有两个相关的目录视图，用下面SQL可以获取：</p>
<div class="highlight"><pre><span></span><code>select table_name as &quot;name&quot;
from information_schema.views
where lower(table_schema) = &#39;pg_catalog&#39;
and (
  lower(table_name) like &#39;%zone%&#39; or
  lower(table_name) like &#39;%time%&#39;)
order by 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> pg_timezone_abbrevs
 pg_timezone_names
</code></pre></div>
<p>pg_timezone_names视图不一定明确地告诉您，特定时区是否遵守夏令时。但对于这样做的时区，当夏令时生效时，is_dst的值将为true。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select is_dst from pg_timezone_names where name =&#39;America/Los_Angeles&#39;;
</code></pre></div>
<p>信息返回如下：</p>
<div class="highlight"><pre><span></span><code> is_dst 
--------
 t
</code></pre></div>
<p>接下来：</p>
<div class="highlight"><pre><span></span><code>set timezone = &#39;America/Los_Angeles&#39;;
select
  current_setting(&#39;timezone&#39;)                                     as &quot;timezone&quot;,
  to_char(&#39;2021-01-01 12:00:00 UTC&#39;::timestamptz, &#39;TZH:TZM : TZ&#39;) as &quot;January regime&quot;,
  to_char(&#39;2021-07-01 12:00:00 UTC&#39;::timestamptz, &#39;TZH:TZM : TZ&#39;) as &quot;July regime&quot;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>      timezone       | January regime | July regime
-----------------------------+-------------------+----------------
 America/Los_Angeles | -08 : PST      | -07 : PDT
</code></pre></div>
<p>创建如下函数：</p>
<div class="highlight"><pre><span></span><code>drop function if exists jan_and_jul_tz_abbrevs_and_offsets() cascade;

create function jan_and_jul_tz_abbrevs_and_offsets()
  returns table(
  name        text,
  jan_abbrev  text,
  jul_abbrev  text,
  jan_offset  interval,
  jul_offset  interval)
  language plpgsql
as $body$
declare
  set_timezone constant text not null := $$set timezone = &#39;%s&#39;$$;
  tz_set                text not null := &#39;&#39;;
  tz_on_entry           text not null := &#39;&#39;;
begin
  show timezone into tz_on_entry;

  for tz_set in (
    select pg_timezone_names.name as a
    from pg_timezone_names
  ) loop
    execute format(set_timezone, tz_set);
    select
      current_setting(&#39;timezone&#39;),
      to_char(&#39;2021-01-01 12:00:00 UTC&#39;::timestamptz, &#39;TZ&#39;),
      to_char(&#39;2021-07-01 12:00:00 UTC&#39;::timestamptz, &#39;TZ&#39;),
      to_char(&#39;2021-01-01 12:00:00 UTC&#39;::timestamptz, &#39;TZH:TZM&#39;)::interval,
      to_char(&#39;2021-07-01 12:00:00 UTC&#39;::timestamptz, &#39;TZH:TZM&#39;)::interval
    into
      name,
      jan_abbrev,
      jul_abbrev,
      jan_offset,
      jul_offset;
    return next;
  end loop;

  execute format(set_timezone, tz_on_entry);
end;
$body$;
</code></pre></div>
<p>执行如下：</p>
<div class="highlight"><pre><span></span><code>select
  name,
  jan_abbrev,
  jul_abbrev,
  lpad(jan_offset::text, 9) as jan_offset,
  lpad(jul_offset::text, 9) as jul_offset
from jan_and_jul_tz_abbrevs_and_offsets()
where
name = &#39;America/Los_Angeles&#39; or name = &#39;Europe/London&#39;
order by name;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>        name         | jan_abbrev | jul_abbrev | jan_offset | jul_offset
---------------------+------------+------------+------------+------------
 America/Los_Angeles | PST        | PDT        | -08:00:00  | -07:00:00
 Europe/London       | GMT        | BST        |  00:00:00  |  01:00:00
</code></pre></div>
<p>这两个视图的区别在于：</p>
<ul>
<li>pg_timezone_names从其关键字name映射到缩写和utc_offset，它们的值在夏令时和标准时间段通常不同，映射在任何特定日期都是唯一的。</li>
<li>pg_timezone_abbrevs从其关键字abbrev映射到一个固定的、唯一的utc_offset值。当时区遵循夏令时时，它有两个不同的缩写：一个用于夏令时时段，另一个用于标准时段。</li>
<li>pg_timezone_names.abbrev和pg_timezone_abbevs.abbrev列记录了不同类型的事实。</li>
</ul>
<h6 id="utc_1"><strong>UTC偏移</strong></h6>
<p>所有可能的操作都不可避免地在指定的UTC偏移量的上下文中执行，因为TimeZone会话设置的默认方案确保这永远不是零长度的文本值或null。（请参阅使用会话环境参数TimeZone指定UTC偏移量一节。）TimeZone设置可以将UTC偏移量直接指定为间隔值，也可以通过标识时区间接指定。
但是，只有三个操作对设置敏感：
将timestamp 转换为timestamptz 。
将timestamptz 转换为timestamp 。
向timestamptz 添加或者减去间隔值。 </p>
<h6 id="utc_2"># 指定UTC偏移的四种方法</h6>
<ul>
<li>直接作为区间值
  要为会话的“时区”设置指定间隔值，必须使用set time zone＜arg＞语法，而不是set timezone= <arg> 语法。例如：</li>
</ul>
<div class="highlight"><pre><span></span><code>set time zone interval &#39;-7 hours&#39;;
</code></pre></div>
<p>请注意，在此语法上下文中，只能使用类型名称构造函数指定间隔值。请试着使用以下：</p>
<div class="highlight"><pre><span></span><code>set time zone &#39;-7 hours&#39;::interval;

set time zone make_interval(hours =&gt; -7);
</code></pre></div>
<p>均会报告语法错误。</p>
<p>但是，at time zone运算符允许任何任意的区间表达式。示例如下：</p>
<div class="highlight"><pre><span></span><code>select &#39;2021-05-27 12:00:00&#39;::timestamp at time zone (make_interval(hours=&gt;5) + make_interval(mins=&gt;45));
</code></pre></div>
<p>您还可以在时间戳文本的文本中指定间隔值。但在这里，您仅仅使用带有::interval  类型转换的文本。示例如下：</p>
<div class="highlight"><pre><span></span><code>select &#39;2021-05-27 12:00:00 -03:15:00&#39;::timestamptz;
</code></pre></div>
<ul>
<li>直接使用POSIX语法
  该语法在PostgreSQL文档中进行了描述，详细内容请参见PostgreSQL文档相关部分。它允许您指定两个UTC偏移值，一个用于标准时间，另一个用于夏令时间，以及“向前跳跃”和“向后后退”时刻。你极不可能需要使用它，因为如今，地球上的任何地方都属于一个经典命名的时区，该时区是当前理解的夏令时规则的关键，从不确定的过去到不确定的未来。PostgreSQL和AiSQL服务器可以访问这些规则。（来源是所谓的tz数据库。）如果改变了任何规则，那么tz数据库就会更新，新规则就会被采用到PostgreSQL和AiSQL的配置数据中。
  在显示时区，设置为显式间隔值后，执行show timezone，会使用POSIX语法返回报告，尽管这是一种不指定夏令时转换的简单形式。执行如下示例：</li>
</ul>
<div class="highlight"><pre><span></span><code>set time zone interval &#39;-07:30:00&#39;;
show timezone;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&lt;-07:30&gt;+07:30
</code></pre></div>
<p>再试着执行如下：</p>
<div class="highlight"><pre><span></span><code>set timezone = &#39;&lt;-07:30&gt;+07:30&#39;;
show timezone;
</code></pre></div>
<p>返回与上例相同信息，结果完全一样。事实证明，几乎任何包含一个或多个数字的字符串都可以被解释为POSIX语法。试着执行如下：</p>
<div class="highlight"><pre><span></span><code>set timezone = &#39;FooBar5&#39;;
show timezone;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> TimeZone
----------
 FOOBAR5
</code></pre></div>
<p>现在，您可以很容易地确认的一点就是，在如下：pg_timezone_names.name，pg_timezone_names.abbrev或者 pg_timezone_abbrevs.abbrev中都没有找到FOOBAR5。</p>
<p>现在看看这有什么效果，如下所示：</p>
<div class="highlight"><pre><span></span><code>\set bare_date_time &#39;\&#39;2021-04-15 12:00:00\&#39;&#39;
select :bare_date_time::timestamptz;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 2021-04-15 12:00:00-05
</code></pre></div>
<p>POSIX取正数表示格林尼治子午线以西。然而，PostgreSQL显示UTC偏移量的约定是将其显示为负值，参见ISO 8601，似乎是绝大多数更常见的约定。互联网搜索似乎总是显示格林尼治以西UTC偏移值为负的地方的时区。试试这个： </p>
<div class="highlight"><pre><span></span><code>set time zone interval &#39;-5 hours&#39;;
select :bare_date_time::timestamptz;
</code></pre></div>
<p>这里，PostgreSQL约定用于指定UTC偏移值。使用相同的：bare_date_time，结果2021-04-15 12:00:00-05与时区设置为FooBar5时的结果相同。</p>
<p>接下来，再试试如下：</p>
<div class="highlight"><pre><span></span><code>set timezone = &#39;Foo5Bar&#39;;
select :bare_date_time::timestamptz;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2021-04-15 12:00:00-04
</code></pre></div>
<p>时区设置为FooBar5时，将2021-04-15 12:00:00强制转换为timestamptz 的结果具有负五小时的UTC偏移值。但当时区设置为Foo5Bar时，将相同的timestamp 值强制转换为timestamptz的结果是UTC偏移值为负4小时。您可以猜测，当给出夏令时规则的最简洁规范，在POSIX文本的最后一位数字（至少在本例中）时，这与POSIX编码夏令时规则的方式有关，也与定义的默认值有关（在本例中，夏令时“向前跳”一个小时）。</p>
<ul>
<li>间接使用时区名称 
  这绝大多数是首选方法，因为只有这样，才能根据名称在tz数据库的内部，表示指向的夏令时规则，自动映射UTC偏移值。</li>
<li>间接使用时区缩写
  避免使用这种方法。尽管这种方法是合法的，但AiSQL强烈建议您避免使用它。</li>
</ul>
<h6 id="utc_3"># 使用UTC偏移量的三个语法上下文</h6>
<ul>
<li>设置环境变量TimeZone
  1）可以在postgresql.conf文件中设置，也可以以PostgreSQL文档的 Server Configuration中描述的任何其他标准方式设置。当未设置PGTZ环境变量时，这在新启动的会话中显示为“TimeZone”会话参数的值。
  2）可以使用PGTZ环境变量进行设置。libpq客户端在连接时，向服务端发送一个set time zone命令。这将覆盖postgresql.conf中的值，这样它也会在新启动的会话中显示为“TimeZone”会话参数的值。
  3）可以在正在进行的会话中，使用通用set timezone=<text literal>语法进行设置，此语法不允许文本表达式。或者，也可以使用特定于时区的set time zone interval＜arg＞语法进行设置。这种拼写还允许设置时区间隔＜text literal＞（注意：文本表达式非法）。此外，它唯一允许set time zone interval＜interval literal＞语法；值得注意的是，只允许使用间隔值的这种语法。 </li>
</ul>
<p>示例如下：</p>
<div class="highlight"><pre><span></span><code>set timezone = &#39;America/New_York&#39;;

set time zone &#39;Asia/Tehran&#39;;

set time zone interval &#39;1 hour&#39;;
</code></pre></div>
<p>注意：如果在pg_timezone_names中找不到提供的文本，则会尝试将其解析为POSIX语法。结果可能会让你大吃一惊。试着执行下面这个示例： </p>
<div class="highlight"><pre><span></span><code>deallocate all;
prepare stmt as
select &#39;2008-07-01 13:00 America/Los_Angeles&#39;::timestamptz;

set timezone = &#39;America/Los_Angeles&#39;;
execute stmt;

set timezone = &#39;-07:00&#39;;
execute stmt;

set timezone = &#39;Foo-7&#39;;
execute stmt;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 2008-07-01 13:00:00-07

 2008-07-02 03:00:00+07

 2008-07-02 03:00:00+07
</code></pre></div>
<ul>
<li>使用at time zone运算符指定UTC偏移量
  运算符的合法操作数是文本表达式或区间表达式，运算符语法与函数timezone()的语义是相同的。
  以下是四种语法变体的示例：</li>
</ul>
<div class="highlight"><pre><span></span><code>drop function if exists timezone_name() cascade;
create function timezone_name()
  returns text
  language plpgsql
as $body$
begin
  -- Some logic would go here. Just return a manifest constant for this demo.
  return &#39;Europe/Amsterdam&#39;;
end;
$body$;

select make_timestamp(2021, 6, 1, 12, 13, 19) at time zone timezone_name();

select timezone(timezone_name(), make_timestamp(2021, 6, 1, 12, 13, 19));

select make_timestamptz(2021, 6, 1, 12, 13, 19, &#39;Europe/Helsinki&#39;) at time zone make_interval(hours=&gt;4, mins=&gt;30);

select timezone(make_interval(hours=&gt;4, mins=&gt;30), make_timestamptz(2021, 6, 1, 12, 13, 19, &#39;Europe/Helsinki&#39;));
</code></pre></div>
<ul>
<li>在timestamptz 文本定义，或者函数make_timestamptz()的'timezone' 参数的文本中，显式指定UTC偏移量。
  时间戳文本可以是一个表达式。以下是一个示例：</li>
</ul>
<div class="highlight"><pre><span></span><code>select (&#39;1984-04-01 13:00 &#39;||timezone_name())::timestamptz; 
</code></pre></div>
<p>这里也有一种可能性，用嵌入的数字来解释文本值。试试如下示例：</p>
<div class="highlight"><pre><span></span><code>set timezone = &#39;America/Los_Angeles&#39;;
\x on
with c as (select &#39;2008-07-01 13:00&#39; as ts)
select
  (select ((select ts from c)||&#39; America/Los_Angeles&#39;)::timestamptz) as &quot;Spelling &#39;LA&#39; timezone in text&quot;,
  (select ((select ts from c)||&#39; -07:00&#39;             )::timestamptz) as &quot;Attempting to specify the PDT offset&quot;,
  (select ((select ts from c)||&#39; Foo99&#39;              )::timestamptz) as &quot;Specifying &#39;Foo99&#39;&quot;;
\x off
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>Spelling &#39;LA&#39; timezone in text          | 2008-07-01 13:00:00-07
Attempting to specify the PDT offset    | 2008-07-01 13:00:00-07
Specifying &#39;Foo99&#39;                   | 2008-07-05 09:00:00-07
</code></pre></div>
<h5 id="timestamptimestamptz"><strong>timestamp与timestamptz</strong></h5>
<p>普通timestamp 数据和timestamptz 数据都具有相同的内部表示。您可以将其想象为从参考时刻（1970年1月1日12:00，UTC）开始的实际秒数（以微秒为精度）。extract(epoch from t) 函数会返回这个数字，其中t是timestamp 或timestamptz 值。此外，对于这两种数据类型，结果与会话的当前时区设置无关。</p>
<h6 id="timestamp_1"><strong>timestamp</strong></h6>
<p>timestamp 值表示本地时间制度中某个时刻的日期和时间。无论是在创建timestamp 值时，还是在读取该值时，都不存在时区敏感性。因此，这样的值表示某个未指定位置的时刻，就像显示日期的钟表一样。您可以将时间戳值想象为从某个历元开始到当前时刻的微秒数。
因为没有时区敏感性，所以对夏令时制度也没有敏感性：每天从午夜（含）到下一个午夜（不含）。PostgresSQL和BSQL不支持闰秒，然而，当您指定timestamp 值时，允许将“24:00:00”作为时间值，将其作为一天中的时间组件。试着执行如下示例：</p>
<div class="highlight"><pre><span></span><code>select
  (&#39;2021-02-14 00:00:00.000000&#39;::timestamp)::text as &quot;starting midnight&quot;,
  (&#39;2021-02-14 23:59:59.999999&#39;::timestamp)::text as &quot;just before ending midnight&quot;,
  (&#39;2021-02-14 24:00:00.000000&#39;::timestamp)::text as &quot;ending midnight&quot;;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>  starting midnight  | just before ending midnight |   ending midnight
---------------------+-----------------------------+---------------------
 2021-02-14 00:00:00 | 2021-02-14 23:59:59.999999  | 2021-02-15 00:00:00
</code></pre></div>
<p>接下来，执行如下：</p>
<div class="highlight"><pre><span></span><code>select
  (&#39;2021-02-14 24:00:00&#39;::timestamp - &#39;2021-02-14 00:00:00&#39;::timestamp)::text as &quot;the interval&quot;;
</code></pre></div>
<p>可以看到返回如下信息：</p>
<div class="highlight"><pre><span></span><code> the interval
--------------
 1 day
</code></pre></div>
<h6 id="timestamptz"><strong>timestamptz</strong></h6>
<p>timestamptz 值表示绝对时间。因此，这样的值可以确定地表示为UTC时区中的当地时间，或者更仔细地说，表示为相对于UTC时间标准偏移量为“0秒”::interval 的当地时间。
尽管实际的timestamp 值和实际的timestamptz 值的表示是相同的，但由于值的元数据的差异，timestamp 值与timestamptz 的语义以及解释是不同的。</p>
<p>指定timestamptz 值时，还必须指定UTC偏移量。一旦记录了timestamptz 值（例如，在具有该数据类型的表列中），就不记得记录时的偏移量了。当传入值被标准化为UTC时，该信息将被完全消耗掉。</p>
<p>当timestamptz 值转换为要显示的文本值时，隐式使用::text类型转换，或显式使用to_char() 内置函数，转换会规范化日期-时间组件，以便显示相对于当前时区指定的UTC偏移量的本地时间。</p>
<p>UTC偏移量可以隐式指定（使用会话的当前时区设置），也可以在timestamptz 文本中显式指定，或者使用 at time zone运算符。此外，偏移量的指定可以是显式的，作为间隔值，或者隐式的使用时区的名称。当时区观察到夏令时时，其名称表示标准时间段和夏季时间段期间的不同偏移。</p>
<p>示例如下：</p>
<div class="highlight"><pre><span></span><code>drop table if exists t cascade;
create table t(k int primary key, v timestamptz not null);

-- This setting has no effect on the inserted value.
set timezone = &#39;Europe/Paris&#39;;
insert into t(k, v) values(1, &#39;2021-02-14 13:30:35+03:00&#39;::timestamptz);

set timezone = &#39;America/Los_Angeles&#39;;
select v::text as &quot;timestamptz value&quot; from t where k = 1;

set timezone = &#39;Asia/Shanghai&#39;;
select v::text as &quot;timestamptz value&quot; from t where k = 1;
</code></pre></div>
<p>分别返回如下信息：</p>
<div class="highlight"><pre><span></span><code>2021-02-14 02:30:35-08

2021-02-14 18:30:35+08
</code></pre></div>
<h6 id="_49"><strong>夏令时</strong></h6>
<p>如下演示了夏令时的示例：</p>
<p>美国承认夏令时。它将于2021年3月14日02:00在“America/Los_Angeles”区域开始。观看根据夏令时开始/结束时刻，自动调整的时钟（如智能手机上的时钟）的功能。从01:59:59到03:00:00。如下：</p>
<div class="highlight"><pre><span></span><code>set timezone = &#39;America/Los_Angeles&#39;;
select
  &#39;2021-03-14 01:30:00 America/Los_Angeles&#39;::timestamptz as &quot;before&quot;,
  &#39;2021-03-14 02:30:00 America/Los_Angeles&#39;::timestamptz as &quot;wierd&quot;,
  &#39;2021-03-14 03:30:00 America/Los_Angeles&#39;::timestamptz as &quot;after&quot;;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>         before         |         wierd          |         after
------------------------+------------------------+------------------------
 2021-03-14 01:30:00-08 | 2021-03-14 03:30:00-07 | 2021-03-14 03:30:00-07
</code></pre></div>
<p>别名为“weird”的列中的值很怪异，因为“2021-03-14 02:30:00”不存在。</p>
<p>America/Los_Angeles时区的夏令时将于2021年11月7日02:00:00结束。它从“01:59:59”回落到“01:00:00”。这意味着，例如，11月7日的“01:30:00”是不明确的。如果你在11月6日星期六晚上给室友打电话，说你要到凌晨，可能是一点半左右才能回家，他们不会知道你的意思，因为时钟会把这个时间读两次。请试着执行如下：</p>
<div class="highlight"><pre><span></span><code>set timezone = &#39;America/Los_Angeles&#39;;
select
  to_char(&#39;2021-11-07 08:30:00 UTC&#39;::timestamptz, &#39;hh24:mi:ss TZ (OF)&#39;) as &quot;1st 1:30&quot;,
  to_char(&#39;2021-11-07 09:30:00 UTC&#39;::timestamptz, &#39;hh24:mi:ss TZ (OF)&#39;) as &quot;2nd 1:30&quot;;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>      1st 1:30      |      2nd 1:30
----------------------------+------------------------
 01:30:00 PDT (-07)  | 01:30:00 PST (-08)
</code></pre></div>
<p>因此，你必须告诉他们，你将以下面一种方式回来：</p>
<ul>
<li>或者在大约01:30 PDT（或者大约01:30PST）</li>
<li>或等效地在夏令时回退时刻前约01:30（或夏令时回退时刻后01:30）</li>
<li>或在约01:30UTC-7（或约01:30UTC-8）</li>
<li>或者甚至在大约八点半UTC（或者九点半UTC）。</li>
</ul>
<p>遵守夏令时的这种奇怪（但在逻辑上不可避免）的后果，意味着你也必须在另一个方向上小心。请试着执行如下：</p>
<div class="highlight"><pre><span></span><code>select
  to_char((&#39;2021-11-07 01:30:00 America/Los_Angeles&#39;::timestamptz) at time zone &#39;UTC&#39;, &#39;hh24:mi:ss&#39;) as &quot;Ambiguous&quot;;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code> Ambiguous
-----------
 09:30:00
</code></pre></div>
<p>PostgreSQL（以及BSQL）通过约定来解决歧义：选择较晚的时刻。明确表达你的意思以避免歧义： </p>
<div class="highlight"><pre><span></span><code>set timezone = &#39;UTC&#39;;
select
  to_char(&#39;2021-11-07 01:30:00 -07:00&#39;::timestamptz, &#39;hh24:mi:ss TZ&#39;) as &quot;Before fallback&quot;,
  to_char(&#39;2021-11-07 01:30:00 -08:00&#39;::timestamptz, &#39;hh24:mi:ss TZ&#39;) as &quot;After fallback&quot;;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code> Before fallback | After fallback
--------------------+-------------------
 08:30:00 UTC  | 09:30:00 UTC
</code></pre></div>
<p>或者，可以这样做：</p>
<div class="highlight"><pre><span></span><code>set timezone = &#39;America/Los_Angeles&#39;;
select
  to_char(&#39;2021-11-07 01:30:00 -07:00&#39;::timestamptz, &#39;hh24:mi:ss TZ&#39;) as &quot;Before fallback&quot;,
  to_char(&#39;2021-11-07 01:30:00 -08:00&#39;::timestamptz, &#39;hh24:mi:ss TZ&#39;) as &quot;After fallback&quot;;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code> Before fallback | After fallback
---------------------+----------------
 01:30:00 PDT  | 01:30:00 PST
</code></pre></div>
<h5 id="interval"><strong>interval</strong></h5>
<p>interval值可以使用下列语法书写：</p>
<p>[@] quantity unit [quantity unit...] [direction]</p>
<p>其中quantity是一个数字（很可能是有符号的）； unit是毫秒、 millisecond、second、 minute、hour、day、 week、month、year、 decade、century、millennium 或者缩写或者这些单位的复数； direction可以是ago或者为空。At符号（@）是一个可选的噪声。不同单位的数量通过合适的符号计数被隐式地添加。ago对所有域求反。如果IntervalStyle被设置为postgres_verbose，该语法也被用于间隔输出。</p>
<p>日、小时、分钟和秒的数量可以不适用显式的单位标记指定。例如，'1 12:59:10'被读作'1 day 12 hours 59 min 10 sec'。同样，一个年和月的组合可以使用一个横线指定，例如'200-10'被读作'200年10个月'（这些较短的形式事实上是SQL标准唯一许可的形式，并且在IntervalStyle被设置为sql_standard时用于输出）。</p>
<p>间隔值也可以被写成 ISO 8601 时间间隔，使用该标准4.4.3.2小节的“带标志符的格式”或者4.4.3.3小节的“替代格式”。带标志符的格式看起来像这样：</p>
<p>P quantity unit [ quantity unit ...] [ T [ quantity unit ...]]</p>
<p>该串必须以一个P开始，并且可以包括一个引入当日时间单位的T。可用的单位缩写在下表中给出。单位可以被忽略，并且可以以任何顺序指定，但是小于一天的单位必须出现在T之后。特别地，M的含义取决于它出现在T之前还是之后。</p>
<p>ISO 8601 间隔单位缩写</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月（在日期部分中）</td>
</tr>
<tr>
<td>W</td>
<td>周</td>
</tr>
<tr>
<td>D</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>小时</td>
</tr>
<tr>
<td>M</td>
<td>分钟 (在时间部分中）</td>
</tr>
<tr>
<td>S</td>
<td>秒</td>
</tr>
</tbody>
</table>
<p>如果使用替代格式：</p>
<p>P [ years-months-days ] [ T hours:minutes:seconds ]</p>
<p>串必须以P开始，并且一个T分隔间隔的日期和时间部分。其值按照类似于 ISO 8601日期的数字给出。</p>
<p>在用一个域声明书写一个间隔常量时，或者为一个用域声明定义的间隔列赋予一个串时，对于为标记的量的解释依赖于域。例如INTERVAL '1' YEAR被解读成1年，而INTERVAL '1'表示1秒。同样，域声明允许的最后一个有效域“右边”的域值会被无声地丢弃掉。例如书写INTERVAL '1 day 2:03:04' HOUR TO MINUTE将会导致丢弃秒域，而不是日域。</p>
<p>根据SQL标准，一个间隔值的所有域都必须由相同的符号，这样一个领头的负号将会应用到所有域；例如在间隔文字'-1 2:03:04'中的负号会被应用于日、小时、分钟和秒部分。允许域具有不同的符号，并且在习惯上认为以文本表示的每个域具有独立的符号，因此在这个示例中小时、分钟和秒部分被认为是正值。如果IntervalStyle被设置为sql_standard，则一个领头的符号将被认为是应用于所有域（但是仅当没有额外符号出现）。否则将使用传统的解释。为了避免混淆，我们推荐在任何域为负值时为每一个域都附加一个显式的符号。</p>
<p>在冗长的输入格式中，以及在更紧凑输入格式的某些域中，域值可以有分数部分；例如'1.5 week'或'01:02:03.45'。这样的输入被转换为合适的月数、日数和秒数用于存储。当这样会导致月和日中的分数时，分数被加到低序域中，使用的转换因子是1月=30日和1日=24小时。例如，'1.5 month'会变成1月和15日。只有秒总是在输出时被显示为分数。</p>
<p>下表展示了一些有效interval输入的示例。</p>
<table>
<thead>
<tr>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1-2</td>
<td>SQL标准格式：1年2个月</td>
</tr>
<tr>
<td>3 4:05:06</td>
<td>SQL标准格式：3日4小时5分钟6秒</td>
</tr>
<tr>
<td>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</td>
<td>1年2个月3日4小时5分钟6秒钟</td>
</tr>
<tr>
<td>P1Y2M3DT4H5M6S</td>
<td>带标志符的”ISO 8601 格式：含义同上</td>
</tr>
<tr>
<td>P0001-02-03T04:05:06</td>
<td>ISO 8601 的“替代格式”：含义同上</td>
</tr>
</tbody>
</table>
<h5 id="_50"><strong>时间/日期函数</strong></h5>
<h6 id="_51"><strong>创建函数</strong></h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_make_date()">make_date()</a></td>
<td>从年、月和日字段创建日期</td>
</tr>
<tr>
<td><a href="#_make_time()">make_time()</a></td>
<td>从小时、分钟和秒字段创建时间</td>
</tr>
<tr>
<td><a href="#_make_timestamp()">make_timestamp()</a></td>
<td>从年、月、日、小时、分钟和秒字段创建时间戳</td>
</tr>
<tr>
<td><a href="#_make_timestamptz()">make_timestamptz()</a></td>
<td>从年，月，日，小时，分钟和秒字段，结合时区创建时间戳；如果没有指定timezone，则使用当前时区</td>
</tr>
<tr>
<td><a href="#_to_timestamp()">to_timestamp()</a></td>
<td>将Unix纪元转换为带时区的时间戳(从1970-01-01 00:00:00+00开始的秒)</td>
</tr>
<tr>
<td><a href="#_make_interval()">make_interval()</a></td>
<td>从年、月、周、日、小时、分钟和秒字段创建时间间隔，每个字段默认为0</td>
</tr>
</tbody>
</table>
<h6 id="make_date"># make_date()</h6>
<p>目的：从年、月和日字段创建日期。</p>
<p>语法：</p>
<p>输入值:       year integer, month integer, day integer
返回值:      date</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>with c as (
  select make_date(year=&gt;2019, month=&gt;4, day=&gt;22) as d)
select pg_typeof(d)::text as &quot;type&quot;, d::text from c;             
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code> type |     d
------+------------
 date | 2019-04-22
</code></pre></div>
<p>使用负值的年份来产生BC结果，例如：</p>
<div class="highlight"><pre><span></span><code>with c as (
  select make_date(year=&gt;-10, month=&gt;1, day=&gt;31) as d)
select pg_typeof(d)::text as &quot;type&quot;, d::text from c;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code> type |       d
------+---------------
 date | 0010-01-31 BC
</code></pre></div>
<p>如果您指定了一个不存在的日期（例如零年或2月30日），则会出现以下错误： </p>
<div class="highlight"><pre><span></span><code> ERROR:  date field value out of range
</code></pre></div>
<h6 id="make_time"># make_time()</h6>
<p>目的：从小时、分钟和秒字段创建时间</p>
<p>语法：</p>
<p>输入值:      hour integer, min integer, sec double precision
返回值:      time without time zone</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>with c as (
  select make_time(hour=&gt;13, min=&gt;25, sec=&gt;20.123456) as t)
select pg_typeof(t)::text as &quot;type&quot;, t::text from c;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>          type       |        t
------------------------------+--------------------
 time without time zone | 13:25:20.123456
</code></pre></div>
<p>如果您指定了一个不存在的时间（例如，25:00:00），则会出现以下错误：</p>
<div class="highlight"><pre><span></span><code>ERROR:  time field value out of range
</code></pre></div>
<h6 id="make_timestamp"># make_timestamp()</h6>
<p>目的：从年、月、日、小时、分钟和秒字段创建时间戳</p>
<p>语法：</p>
<p>输入值:      year integer, month integer, mday integer, hour integer, min integer, sec double precision
返回值:      timestamp without time zone</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code> with c as (
  select make_timestamp(year=&gt;2019, month=&gt;4, mday=&gt;22, hour=&gt;13, min=&gt;25, sec=&gt;20.123456) as ts)
select pg_typeof(ts)::text as &quot;type&quot;, ts::text from c;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>            type         |             ts
-------------------------------------+----------------------------------
 timestamp without time zone | 2019-04-22 13:25:20.123456
</code></pre></div>
<h6 id="make_timestamptz"># make_timestamptz()</h6>
<p>目的：从年，月，日，小时，分钟和秒字段，结合时区创建时间戳；如果没有指定timezone，则使用当前时区</p>
<p>语法：</p>
<p>输入值:      year integer, month integer, mday integer, hour integer, min integer, sec double precision , [timezone text]</p>
<p>返回值:      timestamp with time zone</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>set timezone = &#39;UTC&#39;;
with c as (
  select make_timestamptz(year=&gt;2019, month=&gt;6, mday=&gt;22, hour=&gt;13, min=&gt;25, sec=&gt;20.123456, timezone=&gt;&#39;Europe/Helsinki&#39;) as tstz)
select pg_typeof(tstz)::text as &quot;type&quot;, tstz::text from c;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>           type         |             tstz
-----------------------------------+----------------------------------------
 timestamp with time zone  | 2019-06-22 10:25:20.123456+00
</code></pre></div>
<h6 id="to_timestamp"># to_timestamp()</h6>
<p>目的：将Unix纪元转换为带时区的时间戳(从1970-01-01 00:00:00+00开始的秒)</p>
<p>to_timestamp()函数有两个重载，都返回一个时间戳值。</p>
<p>语法：</p>
<p>输入值:       double precision
返回值:      timestamp with time zone</p>
<p>或者：</p>
<p>输入值:       text, text
返回值:      timestamp with time zone</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>set timezone = &#39;UTC&#39;;
with c as (
  -- 100 days after the start of the Unix epoch.
  select to_timestamp((60*60*24*1000)::double precision) as t)
select pg_typeof(t)::text as &quot;type&quot;, t::text from c;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>           type        |           t
---------------------------------+----------------------------
 timestamp with time zone | 1972-09-27 00:00:00+00
</code></pre></div>
<h6 id="make_interval"># make_interval()</h6>
<p>目的：从年、月、周、日、小时、分钟和秒字段创建时间间隔，每个字段默认为0</p>
<p>语法：</p>
<p>输入值:        years integer, months integer, weeks integer, days integer, hours integer, mins integer, secs double precision
返回值:      interval         </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>with c as (
  select make_interval(secs=&gt;250000.123456) as i)
select pg_typeof(i)::text as &quot;type&quot;, i::text from c;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>   type  |        i
------------+-----------------
 interval | 69:26:40.123456
</code></pre></div>
<h6 id="_52"><strong>操作函数</strong></h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_date_trunc()">date_trunc()</a></td>
<td>按照指定的粒度截断date_time值</td>
</tr>
<tr>
<td><a href="#_justify_days()">justify_days()</a></td>
<td>调整间隔，使得30天时间周期表示为月</td>
</tr>
<tr>
<td><a href="#_justify_hours()">justify_hours()</a></td>
<td>调整时间间隔，使得24小时时间周期表示为日</td>
</tr>
<tr>
<td><a href="#_justify_interval()">justify_interval()</a></td>
<td>使用 justify_days 和 justify_hours调整时间间隔</td>
</tr>
</tbody>
</table>
<h6 id="date_trunc"># date_trunc()</h6>
<p>目的：按照指定的粒度截断date_time值</p>
<p>date_trunc()函数有三个重载。</p>
<p>语法：</p>
<p>输入值:       text, interval
返回值:      interval     </p>
<p>或者</p>
<p>输入值:       text, timestamp with time zone
返回值:      interval     </p>
<p>或者</p>
<p>输入值:       text, timestamp without time zone
返回值:      interval     </p>
<p>第一个参数text的有效值为：
microseconds
milliseconds
second
minute
hour
day
week
month
quarter
year
decade
century
millennium</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>set timezone = &#39;UTC&#39;;
with c as (
  select date_trunc(&#39;year&#39;, &#39;2021-07-19&#39;::date) as v)
select pg_typeof(v)::text as &quot;type&quot;, v::text from c;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>           type        |           v
--------------------------------+--------------------------------
 timestamp with time zone | 2021-01-01 00:00:00+00
</code></pre></div>
<p>当输入值的类型为timestamp with time zone时。截断是针对特定时区进行的。 例如，截断为day，产生的值是 是该区域的午夜。 默认情况下，截断是在以下方面进行的 到当前的TimeZone设置，但在当前的 可以提供可选的time_zone参数。以指定不同的时区。 </p>
<p>当处理timestamp without time zone 或interval输入时，不能指定时区。 这些总是按表面值来处理。</p>
<p>示例 (假设当地时区为 America/New_York):</p>
<div class="highlight"><pre><span></span><code>select date_trunc(&#39;hour&#39;, TIMESTAMP &#39;2001-02-16 20:38:40&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>     date_trunc      
---------------------------
 2001-02-16 20:00:00
</code></pre></div>
<div class="highlight"><pre><span></span><code>select date_trunc(&#39;year&#39;, TIMESTAMP &#39;2001-02-16 20:38:40&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>     date_trunc      
---------------------------
 2001-01-01 00:00:00
</code></pre></div>
<div class="highlight"><pre><span></span><code>select date_trunc(&#39;day&#39;, TIMESTAMP WITH TIME ZONE &#39;2001-02-16 20:38:40+00&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>       date_trunc       
------------------------------
 2001-02-16 00:00:00-05
</code></pre></div>
<div class="highlight"><pre><span></span><code>select date_trunc(&#39;hour&#39;, INTERVAL &#39;3 days 02:47:33&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>   date_trunc    
---------------------
 3 days 02:00:00
</code></pre></div>
<h6 id="justify_days"># justify_days()</h6>
<p>目的：调整间隔，使得30天时间周期表示为月
justify_days()函数，通过减去30天周期的适当整数，来“标准化”[mm, dd, ss]表示的dd字段的值，从而得到的dd值小于30天（但不小于零）。使用一个30天周期与1个月相同的规则，将减去的30天周期转换为月，并添加到mm字段的值中。</p>
<p>语法：</p>
<p>输入值:       interval       <br />
返回值:      interval  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select justify_days(&#39;4 months 31 days&#39;::interval); 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>5 mons 1 day
</code></pre></div>
<h6 id="justify_hours"># justify_hours()</h6>
<p>目的：调整时间间隔，使得24小时时间周期表示为日</p>
<p>语法：</p>
<p>输入值:       interval       <br />
返回值:      interval         </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select justify_hours(&#39;4 days 25 hours&#39;::interval);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>5 days 01:00:00
</code></pre></div>
<h6 id="justify_interval"># justify_interval()</h6>
<p>目的：使用 justify_days 和 justify_hours调整时间间隔；</p>
<p>语法：</p>
<p>输入值:       interval       <br />
返回值:      interval         </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select justify_interval(&#39;4 months 31 days 25 hours&#39;::interval);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>5 mons 2 days 01:00:00
</code></pre></div>
<h6 id="_53"><strong>当前日期/时间函数</strong></h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_current_date">current_date</a></td>
<td>当前日期(当前事务的开始）</td>
</tr>
<tr>
<td><a href="#_current_time()">current_time()</a></td>
<td>一天中的当前时间(当前事务的开始）</td>
</tr>
<tr>
<td><a href="#_current_timestamp">current_timestamp()</a></td>
<td>当前日期和时间(当前事务的开始)；</td>
</tr>
<tr>
<td><a href="#_localtime()">localtime()</a></td>
<td>一天中当前时间(当前事务的开始）</td>
</tr>
<tr>
<td><a href="#_localtimestamp()">localtimestamp()</a></td>
<td>当前日期和时间(当前事务的开始）</td>
</tr>
<tr>
<td><a href="#_transaction_timestamp()">transaction_timestamp()</a></td>
<td>当前日期和时间(当前事务的开始)</td>
</tr>
<tr>
<td><a href="#_now()">now()</a></td>
<td>当前日期和时间(当前事务的开始)；</td>
</tr>
<tr>
<td><a href="#_statement_timestamp()">statement_timestamp()</a></td>
<td>当前日期和时间(当前语句的开始)</td>
</tr>
<tr>
<td><a href="#_clock_timestamp()">clock_timestamp()</a></td>
<td>当前日期和时间（在语句执行期间变化）</td>
</tr>
<tr>
<td><a href="#_timeofday()">timeofday()</a></td>
<td>当前的日期和时间（类似 clock_timestamp, 但是采用 text 字符串）</td>
</tr>
</tbody>
</table>
<h6 id="current_date"># current_date</h6>
<p>目的：返回当前日期(当前事务的开始），它在同一事务内的连续调用中返回相同的值。 </p>
<p>语法：</p>
<p>返回值:      date</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select current_date;
</code></pre></div>
<h6 id="current_time"># current_time()</h6>
<p>目的：一天中的当前时间(当前事务的开始），它在同一事务内的连续调用中返回相同的值，值带时区。可以有选择地接受一个精度参数，返回指定小数位的精度秒值。如果没有精度参数，结果将被给予所能得到的全部精度。</p>
<p>语法：</p>
<p>输入值:       precision
返回值:      timetz</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select current_time;

select current_time(2);
</code></pre></div>
<h6 id="current_timestamp"># current_timestamp</h6>
<p>目的：当前日期和时间(当前事务的开始)，它在同一事务内的连续调用中返回相同的值，值带时区。可以有选择地接受一个精度参数，返回指定小数位的精度秒值。如果没有精度参数，结果将被给予所能得到的全部精度。</p>
<p>语法：</p>
<p>输入值:       precision
返回值:      timestamptz</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select current_timestamp;

select current_timestamp(2);
</code></pre></div>
<h6 id="localtime"># localtime()</h6>
<p>目的：返回一天中当前时间(当前事务的开始），它在同一事务内的连续调用中返回相同的值，值不带时区。可以有选择地接受一个精度参数，返回指定小数位的精度秒值。如果没有精度参数，结果将被给予所能得到的全部精度。</p>
<p>语法：</p>
<p>输入值:       precision
返回值:      time</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select localtime;

select localtime(2);
</code></pre></div>
<h6 id="localtimestamp"># localtimestamp()</h6>
<p>目的：当前日期和时间(当前事务的开始），它在同一事务内的连续调用中返回相同的值，值不带时区。可以有选择地接受一个精度参数，返回指定小数位的精度秒值。如果没有精度参数，结果将被给予所能得到的全部精度。</p>
<p>语法：</p>
<p>输入值:       precision
返回值:      timestamp</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select localtimestamp;

select localtimestamp(2);
</code></pre></div>
<h6 id="transaction_timestamp"># transaction_timestamp()</h6>
<p>目的：当前日期和时间(当前事务的开始)，它在同一事务内的连续调用中返回相同的值，值带时区。可以有选择地接受一个精度参数，返回指定小数位的精度秒值。如果没有精度参数，结果将被给予所能得到的全部精度。</p>
<p>transaction_timestamp()等价于CURRENT_TIMESTAMP</p>
<p>语法：</p>
<p>返回值:      timestamptz</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select transaction_timestamp();
</code></pre></div>
<h6 id="now"># now()</h6>
<p>目的：当前日期和时间(当前事务的开始)，它在同一事务内的连续调用中返回相同的值，值带时区。可以有选择地接受一个精度参数，返回指定小数位的精度秒值。如果没有精度参数，结果将被给予所能得到的全部精度。</p>
<p>now()等效于transaction_timestamp()。</p>
<p>语法：</p>
<p>返回值:      timestamptz</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select now();
</code></pre></div>
<h6 id="statement_timestamp"># statement_timestamp()</h6>
<p>目的：当前日期和时间(当前语句的开始)，返回当前语句的开始时刻（更准确的说是收到客户端最后一条命令的时间）。</p>
<p>语法：</p>
<p>返回值:      timestamptz</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select statement_timestamp();
</code></pre></div>
<h6 id="clock_timestamp"># clock_timestamp()</h6>
<p>目的：当前日期和时间（在语句执行期间变化），clock_timestamp()返回真正的当前时间，值带时区，它的值甚至在同一条 SQL 命令中都会变化。</p>
<p>语法：</p>
<p>返回值:      timestamptz</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select clock_timestamp();
</code></pre></div>
<h6 id="timeofday"># timeofday()</h6>
<p>目的：和clock_timestamp()相似，timeofday()也返回真实的当前时间，但是它的结果是一个格式化的text串，而不是timestamp with time zone值。 </p>
<p>语法：</p>
<p>返回值:      text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select timeofday();
</code></pre></div>
<h6 id="_54"><strong>延时执行函数</strong></h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_pg_sleep()">pg_sleep()</a></td>
<td>使当前会话的进程休眠，直到过去给定的秒数。可以指定几分之一秒的延迟。</td>
</tr>
<tr>
<td><a href="#_pg_sleep_for()">pg_sleep_for()</a></td>
<td>允许将睡眠时间指定为时间间隔。</td>
</tr>
<tr>
<td><a href="#_pg_sleep_until()">pg_sleep_until()</a></td>
<td>用于需要特定的唤醒时间。</td>
</tr>
</tbody>
</table>
<h6 id="pg_sleep"># pg_sleep()</h6>
<p>目的：使当前会话的进程休眠，直到过去给定的秒数。可以指定几分之一秒的延迟。</p>
<p>语法：</p>
<p>输入值:       double  precision
返回值:      void</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_sleep(1.5);
</code></pre></div>
<h6 id="pg_sleep_for"># pg_sleep_for()</h6>
<p>目的：允许将睡眠时间指定为时间间隔。</p>
<p>语法：</p>
<p>输入值:       interval
返回值:      void</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_sleep_for(&#39;5 minutes&#39;);
</code></pre></div>
<h6 id="pg_sleep_until"># pg_sleep_until()</h6>
<p>目的：用于需要特定的唤醒时间。</p>
<p>语法：</p>
<p>输入值:       timestamp with time zone 
返回值:      void</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_sleep_until(&#39;tomorrow 03:00&#39;);
</code></pre></div>
<h6 id="_55"><strong>其它函数和操作符</strong></h6>
<table>
<thead>
<tr>
<th>函数和操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_isfinite()">isfinite()</a></td>
<td>测试有限日期，时间戳，时间间隔</td>
</tr>
<tr>
<td><a href="#_age()">age()</a></td>
<td>减去参数，生成一个使用年和月，而不是只用日的结果</td>
</tr>
<tr>
<td><a href="#_timezone()">timezone()</a></td>
<td>效果与在使用set时区指定所需时区后，从一种数据类型到另一种使用简单的类型转换相同</td>
</tr>
<tr>
<td><a href="#_extract() / date_part()">extract() / date_part()</a></td>
<td>从日期/时间值中抽取子域</td>
</tr>
<tr>
<td><a href="#_OVERLAPS">OVERLAPS</a></td>
<td>支持 SQL 操作符OVERLAPS：(start1, end1) OVERLAPS (start2, end2)(start1, length1) OVERLAPS (start2, length2) 这个表达式在两个时间域（用它们的端点定义）重叠的时候得到真，当它们不重叠时得到假。</td>
</tr>
</tbody>
</table>
<h6 id="isfinite"># isfinite()</h6>
<p>目的：测试有限日期，时间戳，时间间隔</p>
<p>语法：</p>
<p>输入值:      abstime
 | date
 | interval 
| timestamp with time zone 
| timestamp without time zone
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select isfinite(date &#39;2001-02-16&#39;);

select isfinite(timestamp &#39;infinity&#39;);

select isfinite(interval &#39;4 hours&#39;);
</code></pre></div>
<h6 id="age"># age()</h6>
<p>目的：减去参数，生成一个使用年和月，而不是只用日的结果。</p>
<p>语法：</p>
<p>输入值:  timestamp without time zone, timestamp without time zone 
          |  timestamp with time zone, timestamp with time zone
          |  timestamp without time zone
          |  timestamp with time zone
返回值:  interval</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select  age(timestamp &#39;2001-04-10&#39;, timestamp &#39;1957-06-13&#39;);

select age(timestamp &#39;1957-06-13&#39;);
</code></pre></div>
<h6 id="timezone"># timezone()</h6>
<p>目的：效果与在使用set时区指定所需时区后，从一种数据类型到另一种使用简单的类型转换相同。</p>
<p>语法：</p>
<p>输入值:  interval, time with time zone<br />
返回值:  time with time zone</p>
<p>或者</p>
<p>输入值:  interval, timestamp with time zone<br />
返回值:  timestamp without time zone</p>
<p>或者</p>
<p>输入值:  interval, timestamp without time zone<br />
返回值:  timestamp with time zone</p>
<p>或者</p>
<p>输入值:  text, time with time zone<br />
返回值:  time with time zone</p>
<p>或者</p>
<p>输入值:  text, timestamp with time zone<br />
返回值:  timestamp without time zone</p>
<p>或者</p>
<p>输入值:  text, timestamp without time zone<br />
返回值:  timestamp with time zone</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>with c as (
  select &#39;2021-09-22 13:17:53.123456 Europe/Helsinki&#39;::timestamptz as tstz)
select
  (timezone(&#39;UTC&#39;,           tstz) = tstz at time zone &#39;UTC&#39;          )::text as &quot;with timezone given as text&quot;,
  (timezone(make_interval(), tstz) = tstz at time zone make_interval())::text as &quot;with timezone given as interval&quot;
from c;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> with timezone given as text | with timezone given as interval
-----------------------------------+---------------------------------------
 true                   | true
</code></pre></div>
<h6 id="extract-date_part"># extract() / date_part()</h6>
<p>目的：从日期/时间值中抽取子域，主要的用途是做计算性处理。对于用于显示的日期/时间值格式化，date_part函数等价于SQL标准函数extract。
两者使用语法为：</p>
<p>date_part('field', source)</p>
<p>EXTRACT(field FROM source)</p>
<p>source必须是一个类型 timestamp、time或interval的值表达式（类型为date的表达式将被造型为 timestamp，并且因此也可以被同样使用）。field是一个标识符或者字符串，它指定从源值中抽取的域。extract函数返回类型为double precision的值。有效的域名字见下表所示∶</p>
<table>
<thead>
<tr>
<th>域名</th>
<th>描述及示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>century</td>
<td>世纪select EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');</td>
</tr>
<tr>
<td>day</td>
<td>对于timestamp值，是（月份）里的日域（1–31）；对于interval值，是日数select EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');select EXTRACT(DAY FROM INTERVAL '40 days 1 minute');</td>
</tr>
<tr>
<td>decade</td>
<td>年份域除以10select EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');</td>
</tr>
<tr>
<td>dow</td>
<td>一周中的日，从周日（0）到周六（6）select EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');请注意，extract的一周中的日和to_char(..., 'D')函数不同。</td>
</tr>
<tr>
<td>doy</td>
<td>一年的第几天（1–365/366）select EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');</td>
</tr>
<tr>
<td>epoch</td>
<td>对于timestamp with time zone值， 是自 1970-01-01 00:00:00 UTC 以来的秒数（结果可能是负数）； 对于date and timestamp值，是自本地时间 1970-01-01 00:00:00 以来的描述；对于interval值，它是时间间隔的总秒数。select EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');select EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');</td>
</tr>
<tr>
<td>hour</td>
<td>小时域（0–23）select EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');</td>
</tr>
<tr>
<td>isodow</td>
<td>一周中的日，从周一（1）到周日（7）select EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');除了周日，这和dow相同。这符合ISO 8601 中一周中的日的编号。</td>
</tr>
<tr>
<td>isoyear</td>
<td>日期所落在的ISO 8601 周编号的年（不适用于间隔），每一个ISO 8601 周编号的年都开始于包含1月4日的那一周的周一select EXTRACT(ISOYEAR FROM DATE '2006-01-01');select EXTRACT(ISOYEAR FROM DATE '2006-01-02');</td>
</tr>
<tr>
<td>microseconds</td>
<td>秒域，包括小数部分，乘以 1,000,000。请注意它包括全部的秒select EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');</td>
</tr>
<tr>
<td>millennium</td>
<td>千年select EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');</td>
</tr>
<tr>
<td>milliseconds</td>
<td>秒域，包括小数部分，乘以 1000。请注意它包括完整的秒。select EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');</td>
</tr>
<tr>
<td>minute</td>
<td>分钟域（0–59）select EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');</td>
</tr>
<tr>
<td>month</td>
<td>对于timestamp值，它是一年里的月份数（1–12）； 对于interval值，它是月的数目，然后对 12 取模（0–11）select EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');select EXTRACT(MONTH FROM INTERVAL '2 years 13 months');</td>
</tr>
<tr>
<td>quarter</td>
<td>该天所在的该年的季度（1–4）select EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');</td>
</tr>
<tr>
<td>second</td>
<td>秒，包括任何小数秒。select EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');select EXTRACT(SECOND FROM TIME '17:12:28.5');</td>
</tr>
<tr>
<td>timezone</td>
<td>与 UTC 的时区偏移，以秒记。正数对应 UTC 东边的时区，负数对应 UTC 西边的时区。</td>
</tr>
<tr>
<td>timezone_hour</td>
<td>时区偏移的小时部分。</td>
</tr>
<tr>
<td>timezone_minute</td>
<td>时区偏移的分钟部分。</td>
</tr>
<tr>
<td>week</td>
<td>该天在所在的ISO 8601 周编号的年份里是第几周。根据定义， 一年的第一周包含该年的 1月 4 日并且 ISO 周从星期一开始。换句话说，一年的第一个星期四在第一周。在 ISO 周编号系统中，早的 1 月的日期可能位于前一年的第五十二或者第五十三周，而迟的 12 月的日期可能位于下一年的第一周。例如， 2005-01-01位于 2004 年的第五十三周，并且2006-01-01位于 2005 年的第五十二周，而2012-12-31位于 2013 年的第一周。我们推荐把isoyear域和week一起使用来得到一致的结果。select EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');</td>
</tr>
<tr>
<td>year</td>
<td>年份域。要记住这里没有0 AD，所以从AD年里抽取BC年应该小心处理。select EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');</td>
</tr>
<tr>
<td>julian</td>
<td>与日期或时间戳[tz]值相对应的儒略日期（间隔值不支持）。不是本地午夜的timestamp[tz]值会产生一个分数值。</td>
</tr>
</tbody>
</table>
<h6 id="overlaps"># OVERLAPS</h6>
<p>支持 SQL 操作符OVERLAPS：</p>
<p>(start1, end1) OVERLAPS (start2, end2)
(start1, length1) OVERLAPS (start2, length2)</p>
<p>这个表达式在两个时间域（用它们的端点定义）重叠的时候得到真，当它们不重叠时得到假。端点可以用一对日期、时间或者时间戳来指定；或者是用一个后面跟着一个间隔的日期、时间或时间戳来指定。当一对值被提供时，起点或终点都可以被写在前面，OVERLAPS会自动地把较早的值作为起点。每一个时间段被认为是表示半开的间隔start &lt;= time &lt; end，除非start和end相等，这种情况下它表示单个时间实例。例如这表示两个只有一个共同端点的时间段不重叠。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select (DATE &#39;2001-02-16&#39;, DATE &#39;2001-12-21&#39;) OVERLAPS
       (DATE &#39;2001-10-30&#39;, DATE &#39;2002-10-30&#39;);
</code></pre></div>
<h5 id="_56"><strong>格式化函数</strong></h5>
<p>本小结介绍所有日期时间的格式化功能，包括日期时间值格式化到文本值，和文本值格式化到日期时间值。</p>
<h6 id="_57"><strong>格式化函数</strong></h6>
<p>格式化函数提供一套强大的工具用于把各种数据类型 （日期/时间、整数、浮点、数字） 转换成格式化的字符串，以及反过来从格式化的字符串转换成指定的数据类型。下表列出了这些函数。
这些函数都遵循一个公共的调用规范： 第一个参数是待格式化的值，而第二个是一个定义输出或输入格式的模板。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>to_char()</td>
<td>根据给定的格式将时间戳，时间间隔转换为字符串。</td>
</tr>
<tr>
<td>to_date()</td>
<td>根据给定的格式将字符串转换为日期。</td>
</tr>
<tr>
<td>to_timestamp()</td>
<td>根据给定的格式将字符串转换为时间戳。</td>
</tr>
</tbody>
</table>
<h6 id="to_char"># to_char()</h6>
<p>目的：根据给定的格式将时间戳，时间间隔转换为字符串。to_char函数的有关时间，日期格式化的重载函数语法如下：</p>
<p>语法：</p>
<p>输入值:  interval, text<br />
返回值:  text</p>
<p>或者</p>
<p>输入值:  timestamp with time zone, text<br />
返回值:  text</p>
<p>或者</p>
<p>输入值:  timestamp without time zone, text<br />
返回值:  text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select to_char(timestamp &#39;2002-04-20 17:31:12.66&#39;, &#39;HH12:MI:SS&#39;);

select to_char(interval &#39;15h 2m 12s&#39;, &#39;HH24:MI:SS&#39;);
</code></pre></div>
<p>请注意，没有用于将日期值或时间值转换为文本值的重载。</p>
<h6 id="to_date"># to_date()</h6>
<p>目的：根据给定的格式将字符串转换为日期。</p>
<p>语法：</p>
<p>输入值:  text, text
返回值:  date  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select to_date(&#39;05 Dec 2000&#39;, &#39;DD Mon YYYY&#39;);
</code></pre></div>
<h6 id="to_timestamp_1"># to_timestamp()</h6>
<p>目的：根据给定的格式将字符串转换为时间戳。</p>
<p>语法：</p>
<p>输入值:  text, text 
返回值:  timestamp with time zone</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select to_timestamp(&#39;05 Dec 2000&#39;, &#39;DD Mon YYYY&#39;);
</code></pre></div>
<h6 id="-"><strong>日期-时间模板模式</strong></h6>
<p>下表列出了支持的不同模板模式。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>HH</td>
<td>一天中的小时(01–12)</td>
</tr>
<tr>
<td>HH12</td>
<td>一天中的小时(01–12)</td>
</tr>
<tr>
<td>HH24</td>
<td>一天中的小时 (00–23)</td>
</tr>
<tr>
<td>MI</td>
<td>分钟 (00–59)</td>
</tr>
<tr>
<td>SS</td>
<td>秒 (00–59)</td>
</tr>
<tr>
<td>MS</td>
<td>毫秒 (000–999)</td>
</tr>
<tr>
<td>US</td>
<td>微秒 (000000–999999)</td>
</tr>
<tr>
<td>SSSS</td>
<td>午夜后的秒 (0–86399)</td>
</tr>
<tr>
<td>AM, am, PM, pm</td>
<td>正午指示器（不带句号）</td>
</tr>
<tr>
<td>A.M., a.m., P.M. , p.m.</td>
<td>正午指示器（带句号）</td>
</tr>
<tr>
<td>Y,YYY</td>
<td>带逗号的年（4 位或者更多位） with comma</td>
</tr>
<tr>
<td>YYYY</td>
<td>年（4 位或者更多位）</td>
</tr>
<tr>
<td>YYY</td>
<td>年的最后 3 位数字</td>
</tr>
<tr>
<td>YY</td>
<td>年的最后 2 位数字</td>
</tr>
<tr>
<td>Y</td>
<td>年的最后 1 位数字</td>
</tr>
<tr>
<td>IYYY</td>
<td>ISO 8601 周编号方式的年（4 位或更多位）</td>
</tr>
<tr>
<td>IYY</td>
<td>ISO 8601 周编号方式的年的最后 3 位数字</td>
</tr>
<tr>
<td>IY</td>
<td>ISO 8601 周编号方式的年的最后 2 位数字</td>
</tr>
<tr>
<td>I</td>
<td>ISO 8601 周编号方式的年的最后 1 位数字</td>
</tr>
<tr>
<td>BC, bc, AD 或 ad</td>
<td>纪元指示器（不带句号）</td>
</tr>
<tr>
<td>B.C., b.c., A.D. 或 a.d.</td>
<td>纪元指示器（带句号）</td>
</tr>
<tr>
<td>MONTH</td>
<td>全大写形式的月名（空格补齐到 9 字符）</td>
</tr>
<tr>
<td>Month</td>
<td>全首字母大写形式的月名（空格补齐到 9 字符）</td>
</tr>
<tr>
<td>month</td>
<td>全小写形式的月名（空格补齐到 9 字符）</td>
</tr>
<tr>
<td>MON</td>
<td>简写大写形式的月名（英文 3 字符，本地化长度可变）</td>
</tr>
<tr>
<td>Mon</td>
<td>简写首字母大写形式的月名（英文 3 字符，本地化长度可变）</td>
</tr>
<tr>
<td>mon</td>
<td>简写的小写形式的月名（英文 3 字符，本地化长度可变）</td>
</tr>
<tr>
<td>MM</td>
<td>月编号 (01–12)</td>
</tr>
<tr>
<td>DAY</td>
<td>全大写形式的日名（空格补齐到 9 字符）</td>
</tr>
<tr>
<td>Day</td>
<td>全首字母大写形式的日名（空格补齐到 9 字符）</td>
</tr>
<tr>
<td>day</td>
<td>全小写形式的日名（空格补齐到 9 字符）</td>
</tr>
<tr>
<td>DY</td>
<td>简写大写形式的日名（英语 3 字符，本地化长度可变）</td>
</tr>
<tr>
<td>Dy</td>
<td>简写首字母大写形式的日名（英语 3 字符，本地化长度可变）</td>
</tr>
<tr>
<td>dy</td>
<td>简写的小写形式的日名（英语 3 字符，本地化长度可变）</td>
</tr>
<tr>
<td>DDD</td>
<td>一年中的日(001–366)</td>
</tr>
<tr>
<td>IDDD</td>
<td>ISO 8601周编号方式的年中的日（001–371;年的第1日时第一个ISO周的周一）</td>
</tr>
<tr>
<td>DD</td>
<td>月中的日 (01–31)</td>
</tr>
<tr>
<td>D</td>
<td>周中的日，周日 (1) 到周六 (7)</td>
</tr>
<tr>
<td>ID</td>
<td>周中的 ISO 8601 日，周一 (1) 到周日 (7)</td>
</tr>
<tr>
<td>W</td>
<td>月中的周 (1–5) （第一周从该月的第一天开始）</td>
</tr>
<tr>
<td>WW</td>
<td>年中的周数 (1–53) （第一周从该年的第一天开始）</td>
</tr>
<tr>
<td>IW</td>
<td>ISO 8601周编号方式的年中的周数(01–53; 新的一年的第一个周四在第一周)</td>
</tr>
<tr>
<td>CC</td>
<td>世纪（2 位数）（21 世纪开始于 2001-01-01）</td>
</tr>
<tr>
<td>J</td>
<td>儒略日（从午夜 UTC 的公元前 4714 年 11 月 24 日开始的整数日数）</td>
</tr>
<tr>
<td>Q</td>
<td>季度</td>
</tr>
<tr>
<td>RM</td>
<td>大写形式的罗马计数法的月 (I–XII; I=一月)</td>
</tr>
<tr>
<td>rm</td>
<td>小写形式的罗马计数法的月 (i–xii; i=一月)</td>
</tr>
<tr>
<td>TZ</td>
<td>大写形式的时区缩写（仅在to_char中支持）</td>
</tr>
<tr>
<td>tz</td>
<td>小写形式的时区缩写（仅在to_char中支持）</td>
</tr>
<tr>
<td>TZH</td>
<td>时区的小时</td>
</tr>
<tr>
<td>TZM</td>
<td>时区的分钟</td>
</tr>
<tr>
<td>OF</td>
<td>从UTC开始的时区偏移（仅在to_char中支持）</td>
</tr>
</tbody>
</table>
<p>修饰语可以被应用于模板模式来修改它们的行为。例如，FMMonth就是带着FM修饰语的Month模式。下表展示了可用于日期/时间格式化的修饰语模式。</p>
<table>
<thead>
<tr>
<th>修饰语</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>FM prefix</td>
<td>填充模式（抑制前导零和填充的空格）</td>
<td>FMMonth</td>
</tr>
<tr>
<td>TM prefix</td>
<td>翻译模式（基于lc_time使用本地化的日和月名）</td>
<td>TMMonth</td>
</tr>
<tr>
<td>TH suffix</td>
<td>大写形式的序数后缀</td>
<td>DDTH, e.g., 12TH</td>
</tr>
<tr>
<td>th suffix</td>
<td>小写形式的序数后缀</td>
<td>DDth, e.g., 12th</td>
</tr>
<tr>
<td>FX prefix</td>
<td>固定的格式化全局选项</td>
<td>FX Month DD Day</td>
</tr>
</tbody>
</table>
<p>日期/时间格式化的使用须知：</p>
<ul>
<li>FM修饰符
  FM抑制前导零和尾随空格，否则这些空格将被添加，以使输出为固定宽度。例如：</li>
</ul>
<div class="highlight"><pre><span></span><code>with c as (select &#39;0020-05-03 BC&#39;::timestamp as t)
  select
    to_char(t, &#39;MMth &quot;month (&quot;Month&quot;)&quot;, DDth &quot;day&quot;, YYYY AD&#39;)          as &quot;plain&quot;,
    to_char(t, &#39;FMMMth &quot;month (&quot;FMMonth&quot;)&quot;, FMDDth &quot;day&quot;, FMYYYY AD&#39;)  as &quot;using FM&quot;
from c;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>              plain                   |            using FM
-------------------------------------------------------+-----------------------------------------
05th month (May      ), 03rd day, 0020 BC | 5th month (May), 3rd day, 20 BC
</code></pre></div>
<ul>
<li>TM修饰符
  TM修饰符仅仅影响使用to_char()，以文本展示完整和缩写的日期和月份名称，因为这些字段不会影响到日期时间的结果值，所以to_date()和to_timestamp()会忽略TM。TM不仅决定了用于日、月名称和缩写的国家语言，而且还具有抑制尾随空格的副作用。请注意，TM对序数后缀的呈现方式没有影响。例如：</li>
</ul>
<div class="highlight"><pre><span></span><code>deallocate all;
prepare stmt as
select
  to_char(&#39;2021-02-01&#39;::timestamp, &#39;Day, ddth Month, y,yyy&#39;) as &quot;plain&quot;,
  to_char(&#39;2021-02-01&#39;::timestamp, &#39;TMDay, ddth TMMonth, y,yyy&#39;) as &quot;with TM&quot;;

set lc_time = &#39;ZH_CN.utf8&#39;;
execute stmt;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>              plain           |         with TM          
--------------------------------------------+----------------------------------
 Monday   , 01st February , 2,021 | 星期一, 01st 二月, 2,021
</code></pre></div>
<p>注：对于Unix操作系统，可以使用命令：locale -a来查看支持列表，来设置有效值。</p>
<ul>
<li>FX修饰符
  to_timestamp和to_date跳过了输入字符串开头和日期和时间值周围的多个空格，除非使用了FX选项。例如：</li>
</ul>
<div class="highlight"><pre><span></span><code>set timezone = &#39;UTC&#39;;
select to_timestamp(&#39;2000    JUN&#39;, &#39;YYYY MON&#39;)::text;
</code></pre></div>
<p>可以工作，返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2000-06-01 00:00:00+00
</code></pre></div>
<p>但是如下返回一个错误，因为to_timestamp只期望一个空格。</p>
<div class="highlight"><pre><span></span><code>set timezone = &#39;UTC&#39;;
select to_timestamp(&#39;2000    JUN&#39;, &#39;FXYYYY MON&#39;)::text;。
</code></pre></div>
<ul>
<li>只有YYY、YY或Y的模板模式
  使用to_date()和to_timestamp()，如果要转换的文本值中，假定的“years”子字符串少于四位数字，并且模板模式为YYY、YY或Y，则“years（年份）”子字符串用数字填充，以生成四位字符串，年份将被调整为最接近于 2020 年。</li>
</ul>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>with c as (
  select &#39;15-Jun-100&#39;::text as t1, &#39;15-Jun-999&#39;::text as t2)
select
  to_date(t1, &#39;dd-Mon-YYYY&#39;) ::text  as &quot;t1 using YYYY&quot;,
  to_date(t2, &#39;dd-Mon-YYYY&#39;) ::text  as &quot;t2 using YYYY&quot;,

  to_date(t1, &#39;dd-Mon-YYY&#39;)  ::text  as &quot;t1 using YYY&quot;,
  to_date(t2, &#39;dd-Mon-YYY&#39;)  ::text  as &quot;t2 using YYY&quot;
from c;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> t1 using YYYY | t2 using YYYY | t1 using YYY | t2 using YYY
---------------------+-------------------+-----------------+-----------------
 0100-06-15    | 0999-06-15    | 2100-06-15  | 1999-06-15 
</code></pre></div>
<p>请注意，如果您想将“6781123”::text解释为“0678-11-23”::date，这将带来挑战。试着执行如下示例：</p>
<div class="highlight"><pre><span></span><code>select
  to_date(&#39;6781123&#39;,   &#39;YYYYMMDD&#39;)   as &quot;1st try&quot;,
  to_date(&#39;6781123&#39;,   &#39;YYYMMDD&#39;)    as &quot;2nd try&quot;,
  to_date(&#39;678-11-23&#39;, &#39;YYYY-MM-DD&#39;) as &quot;workaround&quot;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>  1st try    |  2nd try  | workaround
----------------+--------------+---------------
 6781-12-03 | 1678-11-23 | 0678-11-23
</code></pre></div>
<p>无论是第一次，还是第二次尝试都不是你想要的东西。您唯一的选择是，要求输入解释为YYYY、MM和DD的子字符串之间有分隔符，如解决方法所示。</p>
<ul>
<li>解释“years”子字符串超过四位的文本值
  您可以使用to_date()和to_timestamp()将类似“21234-1123”的文本值与模板“YYYY-MMDD”进行正确转换。您还可以使用to_date()和to_timestamp()将类似“21231123”的文本值转换为模板“YYYYMMDD”，而不会出现错误。试着执行如下示例：</li>
</ul>
<div class="highlight"><pre><span></span><code>select
  to_date(&#39;21234-1123&#39;, &#39;YYYY-MMDD&#39;) ::text as d1,
  to_date(&#39;21231123&#39;, &#39;YYYYMMDD&#39;)    ::text as d2;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>      d1     |     d2
-------------------+--------------
  21234-11-23 | 2123-11-23
</code></pre></div>
<p>但是，您不能简单使用模板，使用to_date()和to_timestamp()来转换类似“212341123”的文本值。如下所示：</p>
<div class="highlight"><pre><span></span><code>select to_date(&#39;212341123&#39;, &#39;YYYYMMDD&#39;);
</code></pre></div>
<p>这将会返回如下错误信息：</p>
<div class="highlight"><pre><span></span><code>date/time field value out of range: &quot;212341123&quot;
</code></pre></div>
<p>即使用一个额外的Y把“YYYYMMDD”改成“YYYYYMDDD”，也仍然会报告如下错误信息： </p>
<div class="highlight"><pre><span></span><code>conflicting values for &quot;Y&quot; field in formatting string
This value contradicts a previous setting for the same field type.
</code></pre></div>
<p>您唯一的正确选择是，确保要转换的文本值中的“years”子字符串，以非数字字符结束，并且模板与之前使用的代码示例to_date('21234-1123'，'YYYY-MMDD')中的字符匹配。</p>
<ul>
<li>CC模板模式
  使用to_date()和to_timestamp()，可以接受CC模板模式，但如果存在YYYY、YYYY或Y、YYY模式，则会忽略该模式。如果CC与YY或Y模式一起使用，则计算结果为指定世纪中的年份。如果指定了世纪，但没有指定年份，则假定为世纪的第一年。 
  例如：</li>
</ul>
<div class="highlight"><pre><span></span><code>select
  to_date(&#39;19 2021&#39;, &#39;CC YYYY&#39;) as &quot;result 1&quot;,
  to_date(&#39;19 21&#39;, &#39;CC YY&#39;)     as &quot;result 2&quot;,
  to_date(&#39;19&#39;, &#39;CC&#39;)           as &quot;result 3&quot;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>  result 1   |  result 2   |  result 3
----------------+----------------+--------------
 2021-01-01 | 1821-01-01  | 1801-01-01
</code></pre></div>
<ul>
<li>普通文本
  在to_char模板里可以有普通文本，并且它们会被照字面输出。你可以把一个子串放到双引号里强迫它被解释成一个文本，即使它里面包含模板模式也如此。例如，在 '"Hello Year "YYYY'中，YYYY将被年份数据代替，但是Year中单独的Y不会。在to_date、to_number以及to_timestamp中，文本和双引号字符串会导致跳过该字符串中所包含的字符数量，例如"XX"会跳过两个输入字符（不管它们是不是XX）。
  例如：</li>
</ul>
<div class="highlight"><pre><span></span><code>select to_char(&#39;2021, 06-15&#39;::date, &#39;&quot;Hello Year &quot;YYYY on Dy ddth Mon&#39;) as d1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>               d1                
-----------------------------------------
 Hello Year 2021 on Tue 15th Jun
</code></pre></div>
<ul>
<li>输出里有双引号
  如果你想在输出里有双引号，那么你必须在它们前面放反斜线，例如 '\"YYYY Month\"'。不然，在双引号字符串外面的反斜线就不是特殊的。在双引号字符串内，反斜线会导致下一个字符被取其字面形式，不管它是什么字符（但是这没有特殊效果，除非下一个字符是一个双引号或者另一个反斜线）。
  例如：</li>
</ul>
<div class="highlight"><pre><span></span><code>select to_char(&#39;2021, 06-15&#39;::date, &#39;\&quot;Hello &quot;Y&quot;ear\&quot;YYYY on Dy ddth Mon&#39;) as d1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>                d1                
-------------------------------------------
 &quot;Hello Year&quot;2021 on Tue 15th Jun
</code></pre></div>
<ul>
<li>在to_timestamp和to_date中，负的年份被视为表示BC。 如果你同时写一个负的年份和一个显式的BC字段，你又会得到AD。第0年的输入被视为公元前1年。</li>
<li>在to_timestamp和to_date中，工作日名称或编号（DAY、D以及相关的字段类型）会被接受，但会为了计算结果的目的而忽略。季度（Q）字段也是一样。</li>
<li>在to_timestamp和to_date中，一个 ISO 8601 周编号的日期（与一个格里高利日期相区别）可以用两种方法之一被指定为to_timestamp和to_date：
  1）年、周编号和工作日：例如to_date('2006-42-4', 'IYYY-IW-ID')返回日期2006-10-19。如果你忽略工作日，它被假定为 1（周一）。
  2）年和一年中的日：例如to_date('2006-291', 'IYYY-IDDD')也返回2006-10-19。</li>
</ul>
<p>尝试使用一个混合了 ISO 8601 周编号和格里高利日期的域来输入一个日期是无意义的，并且将导致一个错误。在一个 ISO 周编号的年的环境下，一个“月”或“月中的日”的概念没有意义。在一个格里高利年的环境下，ISO 周没有意义。用户应当避免混合格里高利和 ISO 日期声明。</p>
<p>小心
虽然to_date将会拒绝混合使用格里高利和 ISO 周编号日期的域， to_char却不会，因为YYYY-MM-DD (IYYY-IDDD) 这种输出格式也会有用。但是避免写类似IYYY-MM-DD的东西，那会得到在起始年附近令人惊讶的结果。</p>
<ul>
<li>在to_timestamp中，毫秒（MS）和微秒（US）域都被用作小数点后的秒位。例如to_timestamp('12.3', 'SS.MS')不是 3 毫秒, 而是 300，因为该转换把它看做 12 + 0.3 秒。这意味着对于格式SS.MS而言，输入值12.3、12.30和12.300指定了相同数目的毫秒。要得到三毫秒，你必须使用 12.003，转换会把它看做 12 + 0.003 = 12.003 秒。</li>
</ul>
<p>下面是一个更复杂的示例∶to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')是 15 小时、12 分钟和 2 秒 + 20 毫秒 + 1230微秒 = 2.021230 秒。</p>
<ul>
<li>to_char(..., 'ID')的一周中日的编号匹配extract(isodow from ...)函数，但是to_char(..., 'D')不匹配extract(dow from ...)的日编号。</li>
<li>to_char(interval)格式化HH和HH12为显示在一个 12 小时的时钟上，即零小时和 36 小时输出为12，而HH24会输出完整的小时值，对于间隔它可以超过 23。</li>
</ul>
<h4 id="json"><strong>json</strong></h4>
<p>根据RFC 7159 中的说明，JSON 数据类型是用来存储 JSON（JavaScript Object Notation）数据的。
BSQL支持两种数据类型来表示JSON文档：json 和jsonb。这两种数据类型都拒绝任何不符合RFC 7159的JSON文档。json数据类型存储JSON 文档的文本表示。相反，jsonb数据类型以适当的内部格式存储子值的文档层次结构的解析表示。当然，将JSON文档存储为jsonb值比存储为JSON值需要更多的计算。当使用本节中描述的运算符和函数对子值进行运算时，将付出一定的成本。
json 和 jsonb数据类型接受几乎完全相同的值集合作为输入。 主要的实际区别之一是效率。json数据类型存储输入文本的精准拷贝，处理函数必须在每 次执行时必须重新解析该数据。而jsonb数据被存储在一种分解好的 二进制格式中，它在输入时要稍慢一些，因为需要做附加的转换。但是 jsonb在处理时要快很多，因为不需要解析。jsonb也支持索引，这也是一个令人瞩目的优势。
JSON是作为一种数据交换格式被发明的，最初是为了允许JavaScript程序中的任意复合值被序列化，作为文本传输，然后在另一个JavaScript程序中忠实地反序列化，以重新实例化原始复合值。后来，许多其他编程语言（现在包括SQL和PL/pgSQL）支持JSON的序列化和反序列化。此外，将JSON作为记录的持久表示存储在一个表中变得很常见，该表只有一个主键列和一个JSON或jsonb列，用于可以在符合关系模型的表设计中以经典方式表示的事实。这种模式最初出现在NoSQL数据库中，但现在它在SQL数据库中广泛存在。 </p>
<p>type_specification ::= { json | jsonb }</p>
<h5 id="_58"><strong>基本与复合数据类型</strong></h5>
<p>JSON可以表示四种基本数据类型和两种复合数据类型的值。
基本数据类型有字符串、数字、布尔值和null。没有办法声明JSON值的数据类型；相反，它是从表示的语法中出现的。
将其与SQL和PL/pgSQL进行比较。SQL从表中的列或记录中的字段的元数据中建立一个值的数据类型，该值被写入或读取。它还具有类型转换表示法，如::text或::boolean，用于建立SQL文本的数据类型。PL/pgSQL还支持类型转换表示法，并通过声明建立变量或形式参数的数据类型。在JSON类型系统中，null被定义为一种数据类型，而不是另一个数据类型的“值”。 
注意，JSON不能表示日期-时间值，除非是传统格式的字符串值。</p>
<p>两种复合数据类型是对象和数组。</p>
<h6 id="json_1"><strong>JSON字符串</strong></h6>
<p>JSON字符串值是一个由零、一或多个Unicode字符组成的序列，这些字符由“”字符括起来。示例如下所示：</p>
<p>'"Dog"'::jsonb
空字符串是合法的，并且与JSON null不同。 
' "" '::jsonb</p>
<p>大小写和空格是有意义的，字符串值中的特殊字符需要转义，如下： 
退格：\b
换页符：\f
换行符：\n
回车：\r
Tab：\t
双引号：\“
反斜线 ：\\</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code> &#39;&quot;\&quot;First line\&quot;\n\&quot;second line\&quot;&quot;&#39;::jsonb
</code></pre></div>
<h6 id="json_2"><strong>JSON数字</strong></h6>
<p>示例如下：</p>
<div class="highlight"><pre><span></span><code>&#39;17&#39;::jsonb

&#39;4.2&#39;::jsonb

&#39;2.99792E8&#39;::jsonb
</code></pre></div>
<p>注意：JSON没有区分整数和实数。</p>
<h6 id="json_3"><strong>JSON布尔型</strong></h6>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>&#39;true&#39;::jsonb

&#39;false&#39;::jsonb
</code></pre></div>
<h6 id="json-null"><strong>JSON null</strong></h6>
<p>null在JSON中是特殊的，因为它是自己的数据类型，只允许一个“值”。
例如：</p>
<div class="highlight"><pre><span></span><code>&#39;null&#39;::jsonb
</code></pre></div>
<h6 id="json_4"><strong>JSON对象</strong></h6>
<p>对象是一系列键值对，用逗号分隔，并用大括号括起来，顺序不重要，对象中的值不必具有彼此相同的数据类型。例如：</p>
<div class="highlight"><pre><span></span><code>&#39;{
  &quot;a 1&quot; : &quot;Abc&quot;,
  &quot;a 2&quot; : 42,
  &quot;a 3&quot; : true,
  &quot;a 4&quot; : null,
  &quot;a 5&quot; : {&quot;x&quot; : 1, &quot;y&quot;: &quot;Pqr&quot;}
}&#39;::jsonb
</code></pre></div>
<p>键区分大小写，并且键中的空白非常重要。它们甚至可以包含必须转义的字符。但是，如果键确实包含空格和特殊字符，则读取其值所需的语法可能会变得相当复杂。因此，应该尽量避免这种情况。
一个对象可以包含多个具有相同键的键值对，但是，并不推荐这样做。</p>
<h6 id="json_5"><strong>JSON数组</strong></h6>
<p>数组是一个未命名JSON值的有序列表，换句话说，顺序是定义的，并且重要。数组中的值不必具有彼此相同的数据类型。例如： </p>
<div class="highlight"><pre><span></span><code>&#39;[1, 2, &quot;Abc&quot;, true, false, null, {&quot;x&quot;: 17, &quot;y&quot;: 42}]&#39;::jsonb
</code></pre></div>
<p>注：数组中的值从0开始索引。</p>
<h6 id="json_6"><strong>复合JSON</strong></h6>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>{
  &quot;given_name&quot;         : &quot;Fred&quot;,
  &quot;family_name&quot;        : &quot;Smith&quot;,
  &quot;email_address&quot;      : &quot;fred@example.com&quot;,
  &quot;hire_date&quot;          : &quot;17-Jan-2015&quot;,
  &quot;job&quot;                : &quot;sales&quot;,
  &quot;base_annual_salary&quot; : 50000,
  &quot;commisission_rate&quot;  : 0.05,
  &quot;phones&quot;             : [&quot;+11234567890&quot;, &quot;+13216540987&quot;]
}
</code></pre></div>
<h5 id="json_7"><strong>在JSON列上创建索引和检查约束</strong></h5>
<p>通常，当JSON文档插入到表中时，该表将只有一个自填充的代理主键列和一个数据类型为jsonb的值列（如doc）。与选择json相比，选择jsonb允许使用更广泛的运算符和函数，并执行更加高效。
很可能每个文档都是一个JSON对象，并且所有文档都符合相同的结构定义。换句话说，每个对象都将具有相同的一组可能的键名（但有些可能缺失），并且每个键的值都具有相同的JSON数据类型。当一个数据类型是复合的时，同样的公共结构定义概念也将适用，将概念递归扩展到任意深度。下面是一个示例。为了减少混乱，主键没有定义为自填充。 </p>
<div class="highlight"><pre><span></span><code>create table books(k int primary key, doc jsonb not null);

insert into books(k, doc) values
  (1,
  &#39;{ &quot;ISBN&quot;    : 4582546494267,
     &quot;title&quot;   : &quot;Macbeth&quot;,
     &quot;author&quot;  : {&quot;given_name&quot;: &quot;William&quot;, &quot;family_name&quot;: &quot;Shakespeare&quot;},
     &quot;year&quot;    : 1623}&#39;),

  (2,
  &#39;{ &quot;ISBN&quot;    : 8760835734528,
     &quot;title&quot;   : &quot;Hamlet&quot;,
     &quot;author&quot;  : {&quot;given_name&quot;: &quot;William&quot;, &quot;family_name&quot;: &quot;Shakespeare&quot;},
     &quot;year&quot;    : 1603,
     &quot;editors&quot; : [&quot;Lysa&quot;, &quot;Elizabeth&quot;] }&#39;),

  (3,
  &#39;{ &quot;ISBN&quot;    : 7658956876542,
     &quot;title&quot;   : &quot;Oliver Twist&quot;,
     &quot;author&quot;  : {&quot;given_name&quot;: &quot;Charles&quot;, &quot;family_name&quot;: &quot;Dickens&quot;},
     &quot;year&quot;    : 1838,
     &quot;genre&quot;   : &quot;novel&quot;,
     &quot;editors&quot; : [&quot;Mark&quot;, &quot;Tony&quot;, &quot;Britney&quot;] }&#39;),
  (4,
  &#39;{ &quot;ISBN&quot;    : 9874563896457,
     &quot;title&quot;   : &quot;Great Expectations&quot;,
     &quot;author&quot;  : {&quot;family_name&quot;: &quot;Dickens&quot;},
     &quot;year&quot;    : 1950,
     &quot;genre&quot;   : &quot;novel&quot;,
     &quot;editors&quot; : [&quot;Robert&quot;, &quot;John&quot;, &quot;Melisa&quot;, &quot;Elizabeth&quot;] }&#39;),

  (5,
  &#39;{ &quot;ISBN&quot;    : 8647295405123,
     &quot;title&quot;   : &quot;A Brief History of Time&quot;,
     &quot;author&quot;  : {&quot;given_name&quot;: &quot;Stephen&quot;, &quot;family_name&quot;: &quot;Hawking&quot;},
     &quot;year&quot;    : 1988,
     &quot;genre&quot;   : &quot;science&quot;,
     &quot;editors&quot; : [&quot;Melisa&quot;, &quot;Mark&quot;, &quot;John&quot;, &quot;Fred&quot;, &quot;Jane&quot;] }&#39;),

  (6,
  &#39;{
    &quot;ISBN&quot;     : 6563973589123,
    &quot;year&quot;     : 1989,
    &quot;genre&quot;    : &quot;novel&quot;,
    &quot;title&quot;    : &quot;Joy Luck Club&quot;,
    &quot;author&quot;   : {&quot;given_name&quot;: &quot;Amy&quot;, &quot;family_name&quot;: &quot;Tan&quot;},
    &quot;editors&quot;  : [&quot;Ruilin&quot;, &quot;Aiping&quot;]}&#39;);
</code></pre></div>
<p>仔细观察一下，不难发现，有些行缺少了某些键。但是“k=6”的行包含所有键。</p>
<h6 id="_59"><strong>创建检查约束</strong></h6>
<p>以下创建约束：检查每个JSON文档都是一个对象 </p>
<div class="highlight"><pre><span></span><code>alter table books
add constraint books_doc_is_object
check (jsonb_typeof(doc) = &#39;object&#39;);
</code></pre></div>
<p>以下创建约束：检查ISBN始终定义为一个13位的正数 </p>
<div class="highlight"><pre><span></span><code>alter table books
add constraint books_isbn_is_positive_13_digit_number
check (
  (doc-&gt;&#39;ISBN&#39;) is not null
    and
  jsonb_typeof(doc-&gt;&#39;ISBN&#39;) = &#39;number&#39;
     and
  (doc-&gt;&gt;&#39;ISBN&#39;)::bigint &gt; 0
    and
  length(((doc-&gt;&gt;&#39;ISBN&#39;)::bigint)::text) = 13
);
</code></pre></div>
<p>请注意，如果键“ISBN”完全丢失，那么表达式doc-&gt;'ISBN'将生成真正的SQL NULL。但是文档的制作者可能已经决定，用键“ISBN”的特殊JSON值null来表示“没有关于这本书的ISBN的信息”。 </p>
<h6 id="_60"><strong>创建索引</strong></h6>
<p>从上面的表结构来看，当“ISBN”键的值具有唯一、NOT NULL的特性，则可以创建如下索引，来强化唯一性：</p>
<div class="highlight"><pre><span></span><code>create unique index books_isbn_unq
on books((doc-&gt;&gt;&#39;ISBN&#39;) hash);
</code></pre></div>
<p>您可能希望支持引用“year”键值的范围查询，如下所示： </p>
<div class="highlight"><pre><span></span><code>select
  (doc-&gt;&gt;&#39;ISBN&#39;)::bigint as year,
  doc-&gt;&gt;&#39;title&#39;          as title,
  (doc-&gt;&gt;&#39;year&#39;)::int    as year
from books
where (doc-&gt;&gt;&#39;year&#39;)::int &gt; 1850
order by 3;
</code></pre></div>
<p>则针对“year”键值，可以创建如下索引：</p>
<div class="highlight"><pre><span></span><code>create index books_year on books ((doc-&gt;&gt;&#39;year&#39;) asc)
where doc-&gt;&gt;&#39;year&#39; is not null;
</code></pre></div>
<h5 id="json_8"><strong>JSON函数和操作符</strong></h5>
<p>有两个简单的类型转换运算符，用于在符合RFC 7159的文本值和jsonb或json值之间进行转换，即通常重载的 = 运算符、12个专用json运算符和23个专用json函数。
大多数运算符都是重载的，因此它们可以同时用于json和jsonb值。
其中一些函数只有一个jsonb变量，还有一些函数只有json变量。函数名以jsonb_开头或以_jsonb结尾反映了这一点，相应地，json变体也是如此。之所以使用这种命名约定，而不是普通的重载，是因为当相同命名函数的形式参数规范不同时，BSQL可以区分它们，而当它们的返回类型不同时，则不能区分。某些用于特定目的的JSON函数的不同之处，仅在于返回json 值或jsonb值。
当一个运算符或函数，同时具有JSON值输入和JSON值输出时，jsonb变量接受jsonb输入并产生jsonb输出；相应地，json变量接受json输入并产生json输出。您可以使用bsqlsh \df元命令来查看JSON函数。
当一个运算符或函数，同时具有jsonb变量和json变量时，为减少混淆，则只描述jsonb变量，json变量的功能可以从jsonb功能的描述中被相似地予以理解。</p>
<h6 id="sqljson"><strong>转换SQL值到JSON值函数和操作符</strong></h6>
<table>
<thead>
<tr>
<th>函数和操作符</th>
<th>jsonb</th>
<th>json</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_::jsonb和::json和::text">::jsonb</a></td>
<td>是</td>
<td>是</td>
<td>::jsonb 将符合RFC 7159的SQL文本值类型转换为jsonb值。</td>
</tr>
<tr>
<td><a href="#_to_jsonb()">to_jsonb()</a></td>
<td>是</td>
<td>是</td>
<td>将允许JSON表示的任何基本或复合数据类型的单个SQL值，转换为语义等效的jsonb。</td>
</tr>
<tr>
<td><a href="#_row_to_json()">row_to_json()</a></td>
<td></td>
<td>是</td>
<td>将SQL记录转换为JSON对象。</td>
</tr>
<tr>
<td><a href="#_array_to_json()">array_to_json()</a></td>
<td></td>
<td>是</td>
<td>将SQL数组转换为JSON数组。</td>
</tr>
<tr>
<td><a href="#_jsonb_build_array()">jsonb_build_array()</a></td>
<td>是</td>
<td>是</td>
<td>根据可变参数列表构建可能异构类型的JSON数组。</td>
</tr>
<tr>
<td><a href="#_jsonb_build_object()">jsonb_build_object()</a></td>
<td>是</td>
<td>是</td>
<td>根据可变参数列表构建一个JSON对象。</td>
</tr>
<tr>
<td><a href="#_jsonb_object()">jsonb_object()</a></td>
<td>是</td>
<td>是</td>
<td>从文本数组构建JSON对象。</td>
</tr>
<tr>
<td><a href="#_jsonb_agg()">jsonb_agg()</a></td>
<td>是</td>
<td>是</td>
<td>收集所有输入值，包括空值，到一个JSON数组。</td>
</tr>
<tr>
<td><a href="#_jsonb_object_agg()">jsonb_object_agg()</a></td>
<td>是</td>
<td>是</td>
<td>将所有键/值对收集到一个JSON对象中。关键参数强制转换为文本；值参数按照to_json或to_jsonb进行转换。 值可以为空，但键不能为空。</td>
</tr>
</tbody>
</table>
<h6 id="jsonb-json-text"># ::jsonb和 ::json和 ::text</h6>
<p>目的：::jsonb 将符合RFC 7159的SQL文本值类型转换为jsonb值。</p>
<p>语法：</p>
<p>输入值:       jsonb
返回值:      text</p>
<p>注意：您可以对jsonb值和json值使用::text运算符；您可以对文本值和json值使用::jsonb运算符；您可以对jsonb值和文本值使用::json运算符。 </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;{&quot;a&quot;:1, &quot;b&quot;:2}&#39;::jsonb;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>      jsonb       
------------------
 {&quot;a&quot;: 1, &quot;b&quot;: 2}
</code></pre></div>
<h6 id="to_jsonb"># to_jsonb()</h6>
<p>目的：将允许JSON表示的任何基本或复合数据类型的单个SQL值，转换为语义等效的jsonb。</p>
<p>语法：</p>
<p>输入值:       anyelement
返回值:      jsonb</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select to_jsonb(row(42, &#39;Fred said &quot;Hi.&quot;&#39;::text));
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>               to_jsonb                
--------------------------------------------
 {&quot;f1&quot;: 42, &quot;f2&quot;: &quot;Fred said \&quot;Hi.\&quot;&quot;}
</code></pre></div>
<h6 id="row_to_json"># row_to_json()</h6>
<p>目的：将SQL记录转换为JSON对象。</p>
<p>语法：</p>
<p>输入值:       record
pretty:            boolean (optional)
返回值:      json</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select row_to_json(row(1,&#39;foo&#39;)) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>     row_to_json     
--------------------------
 {&quot;f1&quot;:1,&quot;f2&quot;:&quot;foo&quot;}
</code></pre></div>
<div class="highlight"><pre><span></span><code>select row_to_json(row(1,&#39;foo&#39;),true),row_to_json(row(1,&#39;foo&#39;),false) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> row_to_json  |     row_to_json     
-------------------+---------------------
 {&quot;f1&quot;:1,    + | {&quot;f1&quot;:1,&quot;f2&quot;:&quot;foo&quot;}
  &quot;f2&quot;:&quot;foo&quot;}  | 
</code></pre></div>
<h6 id="array_to_json"># array_to_json()</h6>
<p>目的：将SQL数组转换为JSON数组。</p>
<p>语法：</p>
<p>输入值:       anyarray
pretty:            boolean (optional)
返回值:      json</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select array_to_json(array[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> array_to_json 
---------------
 [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
</code></pre></div>
<div class="highlight"><pre><span></span><code>select array_to_json(array[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],true),array_to_json(array[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],false)  ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> array_to_json | array_to_json 
---------------+---------------
 [&quot;a&quot;,    + | [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
  &quot;b&quot;,    +| 
  &quot;c&quot;]     | 
</code></pre></div>
<h6 id="jsonb_build_array"># jsonb_build_array()</h6>
<p>目的：根据可变参数列表构建可能异构类型的JSON数组。</p>
<p>语法：</p>
<p>输入值:       VARIADIC "any"
返回值:      jsonb</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select jsonb_build_array(1, 2, &#39;foo&#39;, 4, 5) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>  jsonb_build_array  
---------------------
 [1, 2, &quot;foo&quot;, 4, 5]
</code></pre></div>
<h6 id="jsonb_build_object-json_build_object"># jsonb_build_object() 和 json_build_object()</h6>
<p>目的：根据可变参数列表构建一个JSON对象。</p>
<p>语法：</p>
<p>输入值:       VARIADIC "any"
返回值:      jsonb</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select jsonb_build_object(&#39;foo&#39;, 1, 2, row(3,&#39;bar&#39;));
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>           jsonb_build_object            
-----------------------------------------
 {&quot;2&quot;: {&quot;f1&quot;: 3, &quot;f2&quot;: &quot;bar&quot;}, &quot;foo&quot;: 1}
</code></pre></div>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select jsonb_build_object(&#39;a&#39;, 17,&#39;b&#39;, &#39;dog&#39;,&#39;c&#39;, true,&#39;d&#39;, (17::int, &#39;cat&#39;::text));
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>                       jsonb_build_object                       
----------------------------------------------------------------
 {&quot;a&quot;: 17, &quot;b&quot;: &quot;dog&quot;, &quot;c&quot;: true, &quot;d&quot;: {&quot;f1&quot;: 17, &quot;f2&quot;: &quot;cat&quot;}}
</code></pre></div>
<h6 id="jsonb_object-json_object"># jsonb_object() 和 json_object()</h6>
<p>目的：从文本数组构建JSON对象。该数组必须有两个维度，一个维度的成员数为偶数，在这种情况下，它们被视为交替的键/值对; 另一个维度的成员数为二维，每个内部数组恰好有两个元素，它们被视为键/值对。所有值都转换为JSON字符串。
此函数有三个重载</p>
<h6 id="_61">## <em>重载函数一</em></h6>
<p>语法：</p>
<p>输入值:      text[]
返回值:     jsonb</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select jsonb_object(array[&#39;a&#39;, &#39;17&#39;, &#39;b&#39;, $$&#39;Hello&#39;, you$$, &#39;c&#39;, &#39;true&#39;]);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>                 jsonb_object                  
-----------------------------------------------------
 {&quot;a&quot;: &quot;17&quot;, &quot;b&quot;: &quot;&#39;Hello&#39;, you&quot;, &quot;c&quot;: &quot;true&quot;}
</code></pre></div>
<h6 id="_62">## <em>重载函数二</em></h6>
<p>语法：</p>
<p>输入值:       text[][]
返回值:      jsonb</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select jsonb_object(array[array[&#39;a&#39;,  &#39;17&#39;], array[&#39;b&#39;,  $$&#39;Hello&#39;, you$$],array[&#39;c&#39;,  &#39;true&#39;]]);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>                 jsonb_object                  
-----------------------------------------------
 {&quot;a&quot;: &quot;17&quot;, &quot;b&quot;: &quot;&#39;Hello&#39;, you&quot;, &quot;c&quot;: &quot;true&quot;}
</code></pre></div>
<h6 id="_63">## <em>重载函数三</em></h6>
<p>语法：</p>
<p>输入值:       text[], text[] 
返回值:      jsonb</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select jsonb_object(array[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],array[&#39;17&#39;, $$&#39;Hello&#39;, you$$, &#39;true&#39;]);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>                 jsonb_object                  
-----------------------------------------------
 {&quot;a&quot;: &quot;17&quot;, &quot;b&quot;: &quot;&#39;Hello&#39;, you&quot;, &quot;c&quot;: &quot;true&quot;}
</code></pre></div>
<h6 id="jsonb_agg"># jsonb_agg()</h6>
<p>目的：这是一个聚合函数，收集所有输入值，包括空值，到一个JSON数组。</p>
<p>语法：</p>
<p>输入值:       SETOF anyelement
返回值:      jsonb</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code> with tab as (
    values
      (5::int,    &#39;ant&#39;::text),
      (2::int,    &#39;cat&#39;::text),
      (null::int, &#39;ant&#39;::text),
      (1::int,    &#39;dog&#39;::text),
      (4::int,     null::text))
  select
  json_agg((column1, column2)::rt order by column1 nulls first)
  from tab;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>        json_agg         
-------------------------------
 [{&quot;a&quot;:null,&quot;b&quot;:&quot;ant&quot;},  +
  {&quot;a&quot;:1,&quot;b&quot;:&quot;dog&quot;},   +
  {&quot;a&quot;:2,&quot;b&quot;:&quot;cat&quot;},    +
  {&quot;a&quot;:4,&quot;b&quot;:null},     +
  {&quot;a&quot;:5,&quot;b&quot;:&quot;ant&quot;}]
</code></pre></div>
<h6 id="jsonb_object_agg"># jsonb_object_agg()</h6>
<p>目的：这是一个聚合函数，将所有键/值对收集到一个JSON对象中。关键参数强制转换为文本；值参数按照to_json或to_jsonb进行转换。 值可以为空，但键不能为空。</p>
<p>语法：</p>
<p>输入值:       anyelement
返回值:      jsonb</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>  with tab as (
    values
      (&#39;f4&#39;::text, 4::int),
      (&#39;f1&#39;::text, 1::int),
      (&#39;f3&#39;::text, null::int),
      (&#39;f2&#39;::text, 2::int))
  select
    jsonb_object_agg(column1, column2)
  from tab;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>            jsonb_object_agg             
-----------------------------------------
 {&quot;f1&quot;: 1, &quot;f2&quot;: 2, &quot;f3&quot;: null, &quot;f4&quot;: 4}
</code></pre></div>
<p>需要注意的一点是：当一个键值对重复多次，会以最近指定的为准，例如：</p>
<div class="highlight"><pre><span></span><code> with tab as (
    values
      (&#39;f2&#39;::text, 4::int),
      (&#39;f7&#39;::text, 7::int),
      (&#39;f2&#39;::text, 1::int),
      (&#39;f2&#39;::text, null::int))
  select
    jsonb_object_agg(column1, column2)
  from tab;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>   jsonb_object_agg    
-------------------------
 {&quot;f2&quot;: null, &quot;f7&quot;: 7}
</code></pre></div>
<h6 id="jsonjson"><strong>转换JSON值到JSON值函数和操作符</strong></h6>
<table>
<thead>
<tr>
<th>函数和操作符</th>
<th>jsonb</th>
<th>json</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_-&gt;">-&gt;</a></td>
<td>是</td>
<td>是</td>
<td>用给定的键提取JSON对象字段，或者提取JSON数组的第n个元素(数组元素从0开始索引，但负整数从末尾开始计数)。  返回json或者jsonb值</td>
</tr>
<tr>
<td><a href="#_#&gt;">#&gt;</a></td>
<td>是</td>
<td>是</td>
<td>提取指定路径下的JSON子对象，路径元素可以是字段键或数组索引。</td>
</tr>
<tr>
<td><a href="#_||">||</a></td>
<td>是</td>
<td></td>
<td>连接两个jsonb值。</td>
</tr>
<tr>
<td><a href="#_-">-</a></td>
<td>是</td>
<td></td>
<td>从一个对象中删除键值对，或者从数组中删除一个值。</td>
</tr>
<tr>
<td><a href="#_#-">#-</a></td>
<td>是</td>
<td></td>
<td>删除指定路径上的字段或数组元素，路径元素可以是字段键或数组索引。</td>
</tr>
<tr>
<td><a href="#_jsonb_extract_path()">jsonb_extract_path()</a></td>
<td>是</td>
<td>是</td>
<td>在指定路径下提取JSON子对象。(这在功能上相当于#&gt;操作符，但在某些情况下，将路径写成可变参数列表会更方便)</td>
</tr>
<tr>
<td><a href="#_jsonb_strip_nulls()">jsonb_strip_nulls()</a></td>
<td>是</td>
<td>是</td>
<td>从给定的JSON值中删除所有具有空值的对象字段，递归地。非对象字段的空值是未受影响的。</td>
</tr>
<tr>
<td><a href="#_jsonb_set()">jsonb_set()</a></td>
<td>是</td>
<td></td>
<td>更改JSON的值，即JSON对象中现有键值对的值或JSON数组中现有索引处的值。</td>
</tr>
<tr>
<td><a href="#_jsonb_insert()">jsonb_insert()</a></td>
<td>是</td>
<td></td>
<td>插入一个值，该值可以是JSON对象中还不存在的键的值，也可以是在JSON数组的索引范围的末尾或开始之前。</td>
</tr>
</tbody>
</table>
<h6 id="-_1"># -&gt;</h6>
<p>目的：用给定的键提取JSON对象字段，或者提取JSON数组的第n个元素(数组元素从0开始索引，但负整数从末尾开始计数)。返回json或者jsonb值
注意：-&gt;运算符要求JSON值是对象或数组。键是一个SQL值。当key是SQL文本值时，它从对象中读取具有该key的键值对的JSON值。当键是SQL整数值时，它会从数组中读取该索引键处的JSON值。如果输入的JSON值是JSON，那么输出的JSON值就是JSON，相应地，如果输入的JSON值是jsonb。 </p>
<p>语法：</p>
<p>输入值s:       jsonb -&gt; [int | text] [ -&gt; [int | text] ]*
返回值:       jsonb</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;{&quot;a&quot;: 100, &quot;b&quot;: {&quot;x&quot;: 1, &quot;y&quot;: 19}, &quot;c&quot;: true}&#39;::jsonb -&gt; &#39;a&#39; as a
, &#39;{&quot;a&quot;: 100, &quot;b&quot;: {&quot;x&quot;: 1, &quot;y&quot;: 19}, &quot;c&quot;: true}&#39;::jsonb -&gt; &#39;b&#39; as b;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 100  |  {&quot;x&quot;: 1, &quot;y&quot;: 19}
</code></pre></div>
<h6 id="_64"># #&gt;</h6>
<p>目的：提取指定路径下的JSON子对象，路径元素可以是字段键或数组索引。</p>
<p>语法：</p>
<p>输入值:        jsonb #&gt; text[]
返回值:       jsonb</p>
<p>注：任意深度定位的JSON子值由其从最上面的JSON值开始的路径标识。通常，路径是由对象子值的键和数组子值的索引值的混合指定的。
请认真考虑如下示例：</p>
<div class="highlight"><pre><span></span><code>[
  1,
  {
    &quot;x&quot;: [
      1,
      true,
      {&quot;a&quot;: &quot;cat&quot;, &quot;b&quot;: &quot;dog&quot;},
      3.14159
    ],
    &quot;y&quot;: true
  },
  42
]
</code></pre></div>
<p>针对上例，分层分析如下：</p>
<ul>
<li>在最高层，它是一个由三个子值组成的数组。</li>
<li>在第二层中，第二个数组子值（即索引为1的值）是一个具有两个键值对的对象，称为“x”和“y”。</li>
<li>在第三层中，键“x”的子值是一个子值数组。</li>
<li>在第四层中，第三个数组子值（即索引为2的值）是一个具有两个键值对的对象，称为“a”和“b”。</li>
<li>在第五层中，键“b”的子值是基本数据类型字符串值“dog”。 
  因此，在如上分析之后，可以得出，JSON字符串值“dog”的路径就应为：</li>
</ul>
<p>-&gt; 1 -&gt; 'x' -&gt; 2 -&gt; 'b'</p>
<h1 id="_65">&gt;运算符是一种方便的语法简写，用于紧凑地指定长路径，因此：</h1>
<p>获取dog值的完整语法即为如下：</p>
<div class="highlight"><pre><span></span><code>select &#39;[
  1,
  {
    &quot;x&quot;: [
      1,
      true,
      {&quot;a&quot;: &quot;cat&quot;, &quot;b&quot;: &quot;dog&quot;},
      3.14159
    ],
    &quot;y&quot;: true
  },
  42
]&#39;::jsonb #&gt; array[&#39;1&#39;, &#39;x&#39;, &#39;2&#39;, &#39;b&#39;]::text[] as b;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &quot;dog&quot;
</code></pre></div>
<h6 id="_66"># ||</h6>
<p>目的：连接两个jsonb值。连接两个数组将生成一个包含每个输入的所有元素的数组。连接两个对象将生成一个包含它们键的并集的对象，当存在重复的键时取第二个对象的值。 所有其他情况都是通过将非数组输入转换为单个元素数组，然后按照两个数组的方式进行处理。 不递归操作:只有顶级数组或对象结构被合并。</p>
<p>语法：</p>
<p>输入值s:       jsonb || jsonb
返回值:       jsonb</p>
<p>请参考如下各种情况示例：</p>
<p>1）如果运算符的两边都是基本数据类型JSON值，则结果是这些值的数组，例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;17&#39;::jsonb || &#39;&quot;x&quot;&#39;::jsonb;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> [17, &quot;x&quot;]
</code></pre></div>
<p>2）如果一侧是基本数据类型JSON值，另一侧是数组，则结果是数组，例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;17&#39;::jsonb || &#39;[&quot;x&quot;, true]&#39;::jsonb;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> [17, &quot;x&quot;, true]
</code></pre></div>
<p>3）如果每一侧都是一个对象，并且RHS对象中没有任何键值对，与LHS对象中的任何键值对具有相同的键，则结果是一个存在所有键值对的对象，例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;{&quot;a&quot;: 1, &quot;b&quot;: 2}&#39;::jsonb || &#39;{&quot;p&quot;:17, &quot;q&quot;: 19}&#39;::jsonb;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;p&quot;: 17, &quot;q&quot;: 19}
</code></pre></div>
<p>4）如果RHS对象中任何键值对的键，与LHS对象中键值对的键冲突，则RHS对象的键值对保留，就像当这些对的键在单个对象中冲突时一样： </p>
<div class="highlight"><pre><span></span><code>select &#39;{&quot;a&quot;: 1, &quot;b&quot;: 2}&#39;::jsonb || &#39;{&quot;p&quot;:17, &quot;a&quot;: 19}&#39;::jsonb;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> {&quot;a&quot;: 19, &quot;b&quot;: 2, &quot;p&quot;: 17}
</code></pre></div>
<p>5）如果一侧是对象，另一侧是数组，则对象会成为数组中的值：</p>
<div class="highlight"><pre><span></span><code>select &#39;{&quot;a&quot;: 1, &quot;b&quot;: 2}&#39;::jsonb || &#39;[false, 42, null]&#39;::jsonb;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> [{&quot;a&quot;: 1, &quot;b&quot;: 2}, false, 42, null]
</code></pre></div>
<h6 id="-_2"># -</h6>
<p>目的：从JSON对象中删除键(以及它的值)，或从JSON数组中删除匹配的字符串值。</p>
<p>语法：</p>
<p>输入值s:       jsonb - [int | text]
返回值:       jsonb</p>
<p>1）从JSON对象中删除键(以及它的值)，例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;{&quot;a&quot;: &quot;x&quot;, &quot;b&quot;: &quot;y&quot;}&#39;::jsonb - &#39;a&#39;::text;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> {&quot;b&quot;: &quot;y&quot;}
</code></pre></div>
<p>2）删除多个键值对，例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;{&quot;a&quot;: &quot;p&quot;, &quot;b&quot;: &quot;q&quot;, &quot;c&quot;: &quot;r&quot;}&#39;::jsonb - array[&#39;a&#39;, &#39;c&#39;]::text[];
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> {&quot;b&quot;: &quot;q&quot;}
</code></pre></div>
<p>3）从数组中删除单个值，例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;[1, 2, 3, 4]&#39;::jsonb - 0;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> [2, 3, 4]
</code></pre></div>
<p>4）没有直接的方法从索引列表中的数组中删除几个值，类似于从具有对键列表的对象中删除几个键值对的能力。但可以通过如下方法，达到目的，例如：</p>
<div class="highlight"><pre><span></span><code>select ((&#39;[1, 2, 3, 4, 5, 7]&#39;::jsonb - 0) - 0 ) -0;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> [4, 5, 7]
</code></pre></div>
<h6 id="-_3"># #-</h6>
<p>目的：删除指定路径上的字段或数组元素，路径元素可以是字段键或数组索引。</p>
<p>语法：</p>
<p>输入值s:       jsonb - text[]
返回值:       jsonb</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;[&quot;a&quot;, {&quot;b&quot;:17, &quot;c&quot;: [&quot;dog&quot;, &quot;cat&quot;]}]&#39;::jsonb #- array[&#39;1&#39;, &#39;c&#39;, &#39;0&#39;]::text[];
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> [&quot;a&quot;, {&quot;b&quot;: 17, &quot;c&quot;: [&quot;cat&quot;]}]
</code></pre></div>
<h6 id="jsonb_extract_path-json_extract_path"># jsonb_extract_path() 和 json_extract_path()</h6>
<p>目的：在指定路径下提取JSON子对象。(这在功能上相当于#&gt;操作符，但在某些情况下，将路径写成可变参数列表会更方便。)</p>
<p>语法：</p>
<p>输入值:       jsonb, VARIADIC text
返回值:      jsonb</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select jsonb_extract_path(&#39;[1, {&quot;x&quot;: [1, true, {&quot;a&quot;: &quot;cat&quot;, &quot;b&quot;: &quot;dog&quot;}, 3.14159], &quot;y&quot;: true}, 42]&#39;::jsonb , &#39;1&#39;, &#39;x&#39;, &#39;2&#39;, &#39;b&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &quot;dog&quot;
</code></pre></div>
<h6 id="jsonb_strip_nulls-json_strip_nulls"># jsonb_strip_nulls 和 json_strip_nulls</h6>
<p>目的：从给定的JSON值中删除所有具有空值的对象字段，递归地。非对象字段的空值是未受影响的。</p>
<p>语法：</p>
<p>输入值:       jsonb
返回值:      jsonb</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select jsonb_strip_nulls(&#39;{&quot;a&quot;: 17,&quot;b&quot;: null,&quot;c&quot;: {&quot;x&quot;: null, &quot;y&quot;: &quot;dog&quot;},&quot;d&quot;: [42, null, &quot;cat&quot;]}&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> {&quot;a&quot;: 17, &quot;c&quot;: {&quot;y&quot;: &quot;dog&quot;}, &quot;d&quot;: [42, null, &quot;cat&quot;]}
</code></pre></div>
<h6 id="jsonb_set"># jsonb_set()</h6>
<p>目的：更改JSON的值，即JSON对象中现有键值对的值或JSON数组中现有索引处的值。返回target，将path指定的项替换为new_value， 如果create_if_missing为真(此为默认值)，并且path指定的项不存在，则添加new_value。 路径中的所有前面步骤都必须存在，否则将不加改变地返回target。 与面向路径操作符一样，负整数出现在JSON数组末尾的path计数中。 如果最后一个路径步骤是超出范围的数组索引，并且create_if_missing为真，那么如果索引为负，新值将添加到数组的开头，如果索引为正，则添加到数组的结尾。</p>
<p>语法：</p>
<p>jsonb_in:           jsonb
path:              text[]
replacement:        jsonb
create_if_missing:   boolean default true
返回值:        jsonb</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select jsonb_set(&#39;{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}&#39;,array[&#39;d&#39;],&#39;4&#39;,true);
</code></pre></div>
<p>或者</p>
<div class="highlight"><pre><span></span><code>select jsonb_set(jsonb_in =&gt; &#39;{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}&#39;,path =&gt; array[&#39;d&#39;],replacement =&gt; &#39;4&#39;,create_if_missing =&gt; true);
</code></pre></div>
<p>均返回信息如下：</p>
<div class="highlight"><pre><span></span><code> {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4}
</code></pre></div>
<h6 id="jsonb_insert"># jsonb_insert()</h6>
<p>目的：插入一个值，该值可以是JSON对象中还不存在的键的值，也可以是在JSON数组的索引范围的末尾或开始之前。</p>
<p>语法：</p>
<p>jsonb_in:         jsonb
path:            text[]
replacement:      jsonb
insert_after:       boolean default false
返回值:      jsonb</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select jsonb_insert(&#39;{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}&#39;,array[&#39;d&#39;],&#39;4&#39;,true);
</code></pre></div>
<p>或者</p>
<div class="highlight"><pre><span></span><code>select jsonb_insert(jsonb_in =&gt; &#39;{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}&#39;,path =&gt; array[&#39;d&#39;],replacement =&gt; &#39;4&#39;,insert_after =&gt; true);
</code></pre></div>
<p>均返回信息如下：</p>
<div class="highlight"><pre><span></span><code> {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4}
</code></pre></div>
<h6 id="jsonsql"><strong>转换JSON值到SQL值函数和操作符</strong></h6>
<table>
<thead>
<tr>
<th>函数和操作符</th>
<th>jsonb</th>
<th>json</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_::text">::text</a></td>
<td>是</td>
<td>是</td>
<td>将jsonb值类型转换为符合RFC 7159的SQL文本值。</td>
</tr>
<tr>
<td><a href="#_-&gt;&gt;">-&gt;&gt;</a></td>
<td>是</td>
<td>是</td>
<td>将指定的JSON值读取为文本值。</td>
</tr>
<tr>
<td><a href="#_#&gt;&gt;">#&gt;&gt;</a></td>
<td>是</td>
<td>是</td>
<td>将指定路径上的JSON子对象提取为text。</td>
</tr>
<tr>
<td><a href="#_jsonb_extract_path_text()">jsonb_extract_path_text()</a></td>
<td>是</td>
<td>是</td>
<td>将指定路径上的JSON子对象提取为文本。</td>
</tr>
<tr>
<td><a href="#_jsonb_populate_record()">jsonb_populate_record()</a></td>
<td>是</td>
<td>是</td>
<td>将JSON对象转换为等效的SQL记录。</td>
</tr>
<tr>
<td><a href="#_jsonb_populate_recordset()">jsonb_populate_recordset()</a></td>
<td>是</td>
<td>是</td>
<td>将JSON对象的同类JSON数组转换为等效的SQL记录集</td>
</tr>
<tr>
<td><a href="#_jsonb_to_record()">jsonb_to_record()</a></td>
<td>是</td>
<td>是</td>
<td>将JSON对象转换为等效的SQL记录。</td>
</tr>
<tr>
<td><a href="#_jsonb_to_recordset()">jsonb_to_recordset()</a></td>
<td>是</td>
<td>是</td>
<td>将JSON对象的同类JSON数组转换为等效的SQL记录集</td>
</tr>
<tr>
<td><a href="#_jsonb_array_elements()">jsonb_array_elements()</a></td>
<td>是</td>
<td>是</td>
<td>将JSON数组的JSON值转换为jsonb 值的SQL表。</td>
</tr>
<tr>
<td><a href="#_jsonb_array_elements_text()">jsonb_array_elements_text()</a></td>
<td>是</td>
<td>是</td>
<td>将JSON数组的JSON值转换为一个包含文本值的SQL表</td>
</tr>
<tr>
<td><a href="#_jsonb_each()">jsonb_each()</a></td>
<td>是</td>
<td>是</td>
<td>从JSON对象中创建一个包含列“key”和“value”的行集。</td>
</tr>
<tr>
<td><a href="#_jsonb_each_text()">jsonb_each_text()</a></td>
<td>是</td>
<td>是</td>
<td>从JSON对象中创建一个包含列“key”和“value”的文本行集</td>
</tr>
<tr>
<td><a href="#_jsonb_pretty()">jsonb_pretty()</a></td>
<td>是</td>
<td></td>
<td>将给定的JSON值转换为精美打印的，缩进的，便于阅读的文本</td>
</tr>
</tbody>
</table>
<h6 id="text_2"># ::text</h6>
<pre><code>目的：将jsonb值类型转换为符合RFC 7159的SQL文本值。
</code></pre>
<p>语法：</p>
<p>输入值:       jsonb
返回值:      text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;{&quot;a&quot;: 42, &quot;b&quot;: 17, &quot;a&quot;: 99}&#39;::jsonb::text;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> {&quot;a&quot;: 42, &quot;b&quot;: 17, &quot;a&quot;: 99}
</code></pre></div>
<h6 id="-_4"># -&gt;&gt;</h6>
<p>目的：将指定的JSON值读取为文本值。提取JSON数组的第n个元素，作为text；用给定的键提取JSON对象字段，作为text。</p>
<p>语法：
输入值s:       jsonb -&gt;&gt; [int | text] [ -&gt; [int | text] ]*
返回值:       text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;[1,2,3]&#39;::json -&gt;&gt; 2; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>3
</code></pre></div>
<div class="highlight"><pre><span></span><code>select &#39;{&quot;a&quot;:1,&quot;b&quot;:2}&#39;::json -&gt;&gt; &#39;b&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2
</code></pre></div>
<h6 id="_67"># #&gt;&gt;</h6>
<p>目的：将指定路径上的JSON子对象提取为text。</p>
<p>语法：</p>
<p>输入值:        jsonb #&gt;&gt;  text[]
返回值:       text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;{&quot;a&quot;: {&quot;b&quot;: [&quot;foo&quot;,&quot;bar&quot;]}}&#39;::json #&gt;&gt; &#39;{a,b,1}&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>bar
</code></pre></div>
<h6 id="jsonb_extract_path_text-json_extract_path_text"># jsonb_extract_path_text() 和 json_extract_path_text()</h6>
<p>目的：将指定路径上的JSON子对象提取为文本。(这在功能上等同于#&gt;&gt;操作符。)</p>
<p>语法：</p>
<p>输入值:       jsonb, VARIADIC text
返回值:      text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select jsonb_extract_path_text(&#39;{&quot;f2&quot;:{&quot;f3&quot;:100},&quot;f4&quot;:{&quot;f5&quot;:99,&quot;f6&quot;:&quot;foo&quot;}}&#39;, &#39;f4&#39;, &#39;f6&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> foo
</code></pre></div>
<h6 id="jsonb_populate_record-json_populate_record"># jsonb_populate_record() 和 json_populate_record()</h6>
<p>目的：将JSON对象转换为等效的SQL记录。JSON对象将被扫描，查找名称与输出行类型的列名匹配的字段，并将它们的值插入到输出的这些列中。 (不对应任何输出列名的字段将被忽略。)在典型的使用中，基本的值仅为NULL，这意味着任何不匹配任何对象字段的输出列都将被填充为空。 但是，如果base不为NULL，那么它包含的值将用于不匹配的列。</p>
<p>要将JSON值转换为输出列的SQL类型，需要按次序应用以下规则:
在所有情况下，JSON空值都会转换为SQL空值。</p>
<p>如果输出列的类型是json或jsonb，则会精确地重制JSON值。
如果输出列是复合(行)类型，且JSON值是JSON对象，则该对象的字段将转换为输出行类型的列，通过这些规则的递归应用程序。</p>
<p>同样，如果输出列是数组类型，而JSON值是JSON数组，则通过这些规则的递归应用程序将JSON数组的元素转换为输出数组的元素。</p>
<p>否则，如果JSON值是字符串，则将字符串的内容提供给输入转换函数，用以确定列的数据类型。
否则，JSON值的普通文本表示将被提供给输入转换函数，以确定列的数据类型。</p>
<p>虽然下面的示例使用一个常量JSON值，典型的用法是在查询的FROM子句中从另一个表侧面地引用json或jsonb列。 在FROM子句中编写json_populate_record是一种很好的实践，因为提取的所有列都可以使用，而不需要重复的函数调用。</p>
<p>语法：</p>
<p>输入值:       anyelement, jsonb
返回值:      anyelement</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>create type subrowtype as (d int, e text); 

create type myrowtype as (a int, b text[], c subrowtype);

select * 
from json_populate_record(null::myrowtype, &#39;{&quot;a&quot;: 1, &quot;b&quot;: [&quot;2&quot;, &quot;a b&quot;], &quot;c&quot;: {&quot;d&quot;: 4, &quot;e&quot;: &quot;a b c&quot;}, &quot;x&quot;: &quot;foo&quot;}&#39;) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> a |   b    |      c      
---+-----------+-------------
 1 | {2,&quot;a b&quot;} | (4,&quot;a b c&quot;)
</code></pre></div>
<h6 id="jsonb_populate_recordset-json_populate_recordset"># jsonb_populate_recordset() 和 json_populate_recordset()</h6>
<p>目的：将JSON对象的同类JSON数组转换为等效的SQL记录集。
每个都要求提供的JSON值是一个数组，每个数组的值都是一个与指定的SQL记录兼容的对象，该记录被定义为一个类型，该类型的名称通过函数的第一个形式参数使用代理NULL传递：type_identifier。JSON值通过第二个形式参数传递。结果是指定类型的一组记录（即一个表）。</p>
<p>语法：</p>
<p>输入值:       anyelement, jsonb
返回值:      SETOF anyelement</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>create type twoints as (a int, b int);

select * 
from json_populate_recordset(null::twoints, &#39;[{&quot;a&quot;: 1, &quot;b&quot;: 2},{&quot;b&quot;: 4, &quot;a&quot;: 3},{&quot;a&quot;: 5, &quot;c&quot;: 6},{&quot;b&quot;: 7, &quot;d&quot;: 8},{&quot;c&quot;: 9, &quot;d&quot;: 0}]&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> a | b 
---+---
 1 | 2
 3 | 4
 5 |  
   | 7
   |  
</code></pre></div>
<h6 id="jsonb_to_record-json_to_record"># jsonb_to_record() 和 json_to_record()</h6>
<p>目的：将JSON对象转换为等效的SQL记录。</p>
<p>语法：</p>
<p>输入值:       jsonb
返回值:      record</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>create type myrowtype as (a int, b text);

select * 
 from json_to_record(&#39;{&quot;a&quot;:1,&quot;b&quot;:[1,2,3],&quot;c&quot;:[1,2,3],&quot;e&quot;:&quot;bar&quot;,&quot;r&quot;: {&quot;a&quot;: 123, &quot;b&quot;: &quot;a b c&quot;}}&#39;) as x(a int, b text, c int[], d text, r myrowtype);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> a |  b    |   c   | d |     r       
---+---------+---------+---+---------------
 1 | [1,2,3] | {1,2,3} |   | (123,&quot;a b c&quot;)
</code></pre></div>
<h6 id="jsonb_to_recordset-json_to_recordset"># jsonb_to_recordset() 和 json_to_recordset()</h6>
<p>目的：将JSON对象的同类JSON数组转换为等效的SQL记录集。</p>
<p>语法：</p>
<p>输入值:       jsonb
返回值:      SETOF record</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select * 
from jsonb_to_recordset(&#39;[{&quot;a&quot;:1,&quot;b&quot;:&quot;foo&quot;}, {&quot;a&quot;:&quot;2&quot;,&quot;c&quot;:&quot;bar&quot;}]&#39;) as x(a int, b text);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> a |  b  
---+-----
 1 | foo
 2 | 
</code></pre></div>
<h6 id="jsonb_array_elements-json_array_elements"># jsonb_array_elements() 和 json_array_elements()</h6>
<p>目的：将JSON数组的JSON值转换为jsonb 值的SQL表。</p>
<p>语法：</p>
<p>输入值:       jsonb
返回值:      SETOF jsonb</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select * 
from jsonb_array_elements(&#39;[&quot;cat&quot;, &quot;dog house&quot;, 42, true, {&quot;x&quot;: 17}, null]&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &quot;cat&quot;
 &quot;dog house&quot;
 42
 true
 {&quot;x&quot;: 17}
 null
</code></pre></div>
<h6 id="jsonb_array_elements_text-json_array_elements_text"># jsonb_array_elements_text() 和 json_array_elements_text()</h6>
<p>目的：将JSON数组的JSON值转换为一个包含文本值的SQL表。</p>
<p>语法：</p>
<p>输入值:       jsonb
返回值:      SETOF text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select * 
from jsonb_array_elements_text(&#39;[&quot;cat&quot;, &quot;dog house&quot;, 42, true, {&quot;x&quot;: 17}]&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &quot;cat&quot;
 &quot;dog house&quot;
 42
 true
 {&quot;x&quot;: 17}
</code></pre></div>
<h6 id="jsonb_each-json_each"># jsonb_each() 和 json_each()</h6>
<p>目的：从JSON对象中创建一个包含列“key”和“value”的行集。</p>
<p>语法：</p>
<p>输入值:       jsonb
返回值:      SETOF (text, jsonb)</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select key, value 
from jsonb_each(&#39;{&quot;a&quot;: 17, &quot;b&quot;: &quot;dog&quot;, &quot;c&quot;: true, &quot;d&quot;: {&quot;a&quot;: 17, &quot;b&quot;: &quot;cat&quot;}}&#39;::jsonb);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> key |         value         
-----+-----------------------
 a   | 17
 b   | dog
 c   | true
 d   | {&quot;a&quot;: 17, &quot;b&quot;: &quot;cat&quot;}
</code></pre></div>
<h6 id="jsonb_each_text-json_each_text"># jsonb_each_text() 和 json_each_text()</h6>
<p>目的：从JSON对象中创建一个包含列“key”和“value”的文本行集。</p>
<p>语法：</p>
<p>输入值:       jsonb
返回值:      SETOF (text, text)</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select key, value 
from jsonb_each_text(&#39;{&quot;a&quot;: 17, &quot;b&quot;: &quot;dog&quot;, &quot;c&quot;: true, &quot;d&quot;: {&quot;a&quot;: 17, &quot;b&quot;: &quot;cat&quot;}}&#39;::jsonb);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> key |         value         
-----+-----------------------
 a   | 17
 b   | dog
 c   | true
 d   | {&quot;a&quot;: 17, &quot;b&quot;: &quot;cat&quot;}
</code></pre></div>
<h6 id="jsonb_pretty"># jsonb_pretty()</h6>
<p>目的：将给定的JSON值转换为精美打印的，缩进的，便于阅读的文本。</p>
<p>语法：</p>
<p>输入值:       jsonb
返回值:      text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select jsonb_pretty(&#39;[{&quot;f1&quot;:1,&quot;f2&quot;:null}, 2]&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> [                 +
     {             +
         &quot;f1&quot;: 1,    +
         &quot;f2&quot;: null  +
     },            +
     2            +
 ]
</code></pre></div>
<h6 id="json_9"><strong>获取JSON值属性函数和操作符</strong></h6>
<table>
<thead>
<tr>
<th>函数和操作符</th>
<th>jsonb</th>
<th>json</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_=">=</a></td>
<td>是</td>
<td></td>
<td>测试两个jsonb值是否相等。</td>
</tr>
<tr>
<td><a href="#_@&gt; and &lt;@">@&gt; 和&lt;@</a></td>
<td>是</td>
<td></td>
<td>@&gt;运算符测试左侧的JSON值是否包含右侧的JSON值。&lt;@运算符测试右侧的JSON值是否包含左侧的JSON值。</td>
</tr>
<tr>
<td><a href="#_?">?</a></td>
<td>是</td>
<td></td>
<td>文本字符串是否作为JSON值中的顶级键或数组元素存在</td>
</tr>
<tr>
<td>[?</td>
<td>](#_?</td>
<td>)</td>
<td>是</td>
</tr>
<tr>
<td><a href="#_?&amp;">?&amp;</a></td>
<td>是</td>
<td></td>
<td>文本数组中的所有字符串都作为顶级键或数组元素存在?</td>
</tr>
<tr>
<td><a href="#_jsonb_array_length()">jsonb_array_length()</a></td>
<td>是</td>
<td></td>
<td>返回顶级JSON数组中的元素数量。</td>
</tr>
<tr>
<td><a href="#_jsonb_typeof()">jsonb_typeof()</a></td>
<td>是</td>
<td></td>
<td>以文本字符串形式返回顶级JSON值的类型。</td>
</tr>
<tr>
<td><a href="#_jsonb_object_keys()">jsonb_object_keys()</a></td>
<td>是</td>
<td></td>
<td>返回顶级JSON对象中的键集合。</td>
</tr>
</tbody>
</table>
<h6 id="_68"># =</h6>
<p>目的：测试两个jsonb值是否相等。</p>
<p>注：如果您需要测试两个json值是否相等，那么您必须使用::text 进行类型转换。</p>
<p>语法：</p>
<p>输入值s:       jsonb = jsonb
返回值:       boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]&#39;::jsonb=&#39;[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]&#39;::jsonb;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_69"># @&gt; 和 &lt;@</h6>
<p>目的：@&gt;运算符测试左侧的JSON值是否包含右侧的JSON值。&lt;@运算符测试右侧的JSON值是否包含左侧的JSON值。 </p>
<p>语法：
输入值s:       jsonb @&gt; jsonb
返回值:       boolean</p>
<p>或者：</p>
<p>输入值s:       jsonb &lt;@ jsonb
返回值:       boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;{&quot;a&quot;: 1, &quot;b&quot;: 2}&#39;::jsonb @&gt; &#39;{&quot;b&quot; :2}&#39;::jsonb;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_70"># ?</h6>
<p>目的：文本字符串是否作为JSON值中的顶级键或数组元素存在?</p>
<p>语法：</p>
<p>输入值s:       jsonb ? text
返回值:       boolean</p>
<p>如果是顶级键，示例：</p>
<div class="highlight"><pre><span></span><code>select &#39;{&quot;a&quot;: &quot;x&quot;, &quot;b&quot;: &quot;y&quot;}&#39;::jsonb ? &#39;a&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<p>如果是非顶级键，示例如下：</p>
<div class="highlight"><pre><span></span><code>select &#39;[1, {&quot;a&quot;: &quot;x&quot;, &quot;b&quot;: &quot;y&quot;}]&#39;::jsonb ? &#39;a&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>f
</code></pre></div>
<p>数组元素示例：</p>
<div class="highlight"><pre><span></span><code>select &#39;[&quot;cat&quot;, &quot;dog&quot;, &quot;from&quot;]&#39;::jsonb ? &#39;dog&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_71"># ?|</h6>
<p>目的：文本数组中的至少一个字符串，是否作为顶级键或数组元素存在?</p>
<p>语法：</p>
<p>输入值s:       jsonb ?| text[]
返回值:       boolean</p>
<p>至少一个键存在，例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;{&quot;a&quot;: &quot;x&quot;, &quot;b&quot;: &quot;y&quot;, &quot;c&quot;: &quot;z&quot;}&#39;::jsonb ?| array[&#39;a&#39;, &#39;p&#39;]::text[];
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<p>至少一个数组元素存在，例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#39;::jsonb ?| array[&#39;a&#39;, &#39;p&#39;]::text[];
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_72"># ?&amp;</h6>
<p>目的：文本数组中的所有字符串都作为顶级键或数组元素存在?</p>
<p>语法：
输入值s:       jsonb ?&amp; text[]
返回值:       boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;{&quot;a&quot;: &quot;w&quot;, &quot;b&quot;: &quot;x&quot;, &quot;c&quot;: &quot;y&quot;, &quot;d&quot;: &quot;z&quot;}&#39; ::jsonb ?&amp; array[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]::text[];
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<p>所有数组元素存在，例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#39;::jsonb ?&amp; array[&#39;a&#39;, &#39;b&#39;]::text[];
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="jsonb_array_length-json_array_length"># jsonb_array_length() 和 json_array_length()</h6>
<p>目的：返回顶级JSON数组中的元素数量。
注意：要求提供的JSON值是一个数组
语法：</p>
<p>输入值:       jsonb
返回值:      integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select json_array_length(&#39;[&quot;a&quot;, 42, true, null]&#39;) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>4
</code></pre></div>
<h6 id="jsonb_typeof-json_typeof"># jsonb_typeof() 和 json_typeof()</h6>
<p>目的：以文本字符串形式返回顶级JSON值的类型。可能的类型有object, array,string, number,boolean, 和 null。</p>
<p>语法：</p>
<p>输入值:       jsonb
返回值:      text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select jsonb_typeof(&#39;{&quot;a&quot;: 17, &quot;b&quot;: &quot;x&quot;, &quot;c&quot;: true}&#39;::jsonb);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>object
</code></pre></div>
<h6 id="jsonb_object_keys-json_object_keys"># jsonb_object_keys() 和 json_object_keys()</h6>
<p>目的：返回顶级JSON对象中的键集合。</p>
<p>语法：</p>
<p>输入值:       jsonb
返回值:      SETOF text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select jsonb_object_keys( &#39;{&quot;b&quot;: 1, &quot;c&quot;: true, &quot;a&quot;: {&quot;p&quot;:1, &quot;q&quot;: 2}}&#39;::jsonb);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> a
 b
 c
</code></pre></div>
<h4 id="money"><strong>Money</strong></h4>
<p>MONEY数据类型表示分数具有固定精度的货币。  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Money</td>
<td>8字节</td>
<td>-92233720368547758.08</td>
<td>+92233720368547758.07</td>
</tr>
</tbody>
</table>
<p>描述：</p>
<p>type_specification ::= MONEY</p>
<p>为了避免精度损失，在应用计算之前，可以将MONEY值强制转换为NUMERIC类型。</p>
<h4 id="_73"><strong>数字类型</strong></h4>
<p>BSQL支持不同取值范围和精度的整数、浮点数和定点数，下表列出了所有可用类型。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储</th>
<th>描述</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>bigint</td>
<td>8字节</td>
<td>大范围整数</td>
<td>-9223372036854775808 到+9223372036854775807</td>
</tr>
<tr>
<td>decimal</td>
<td>可变</td>
<td>用户指定精度，精确</td>
<td>最高小数点前131072位，以及小数点后16383位</td>
</tr>
<tr>
<td>double precision</td>
<td>8字节</td>
<td>可变精度，不精确</td>
<td>15位十进制精度</td>
</tr>
<tr>
<td>integer</td>
<td>4字节</td>
<td>整数的典型选择</td>
<td>-2147483648 到 +2147483647</td>
</tr>
<tr>
<td>numeric</td>
<td>可变</td>
<td>用户指定精度，精确</td>
<td>最高小数点前131072位，以及小数点后16383位</td>
</tr>
<tr>
<td>real</td>
<td>4字节</td>
<td>可变精度，不精确</td>
<td>6位十进制精度</td>
</tr>
<tr>
<td>smallint</td>
<td>2字节</td>
<td>小范围整数</td>
<td>-32768 to +32767</td>
</tr>
<tr>
<td>smallserial</td>
<td>2字节</td>
<td>自动增加的小整数</td>
<td>1到32767</td>
</tr>
<tr>
<td>serial</td>
<td>4字节</td>
<td>自动增加的整数</td>
<td>1到2147483647</td>
</tr>
<tr>
<td>bigserial</td>
<td>8字节</td>
<td>自动增长的大整数</td>
<td>1到9223372036854775807</td>
</tr>
</tbody>
</table>
<h5 id="integers"><strong>Integers</strong></h5>
<p>类型smallint、integer和bigint存储各种范围的全部是数字的数，也就是没有小数部分的数字。试图存储超出范围以外的值将导致一个错误。</p>
<p>常用的类型是integer，因为它提供了在范围、存储空间和性能之间的最佳平衡。一般只有在磁盘空间紧张的时候才使用 smallint类型，而只有在integer的范围不够的时候才使用bigint。
SQL只声明了整数类型integer（或int）、smallint和bigint。类型int2、int4和int8都是扩展，也在许多其它SQL数据库系统中使用。</p>
<p>以下关键字用于为不同的约束指定整数类型的列，包括其值范围。</p>
<p>type_specification ::= SMALLINT | INT | INTEGER | BIGINT
integer_literal ::= [ + | - ] digit [ { digit | , } ... ]</p>
<h5 id="_74"><strong>浮点类型</strong></h5>
<p>以下关键字用于为不同的约束指定浮点类型的列，包括其值范围。</p>
<p>type_specification ::= { FLOAT | DOUBLE PRECISION | REAL }
floating_point_literal ::= non_integer_fixed_point_literal | "NaN" | "Infinity" | "-Infinity"</p>
<p>除了普通的数字值之外，浮点类型还有几个特殊值：</p>
<p>Infinity
-Infinity
NaN
这些分别代表 IEEE 754 特殊值“infinity”、“negative infinity”以及“not-a-number”， 如果在 SQL 命令里把这些数值当作常量写，你必须在它们周围放上单引号，例如UPDATE table SET x = '-Infinity'。 在输入时，这些字符串是以大小写不敏感的方式识别的。</p>
<h5 id="_75"><strong>任意精度数字</strong></h5>
<p>以下关键字用于为不同约束，指定一列精确的用户指定精度类型，包括其值范围。 </p>
<p>type_specification ::= { DEC | DECIMAL | NUMERIC }
fixed_point_literal ::= [ + | - ] { digit [ digit ...] '.' [ digit ...] | '.' digit [ digit ...] }</p>
<p>一个numeric的precision（精度）是整个数中有效位的总数，也就是小数点两边的位数。numeric的scale（小数位数）是小数部分的数字位数，也就是小数点右边的部分。因此数字 23.5141 的精度为6而小数位数为4。可以认为整数的小数位数为零。</p>
<p>numeric列的最大精度和最大小数位数都是可以配置的。要声明一个类型为numeric的列，你可以用下面的语法：
NUMERIC(precision, scale)</p>
<p>精度必须为正数，小数位数可以为零或者正数</p>
<h4 id="_76"><strong>范围类型</strong></h4>
<p>BSQL支持六种内置范围数据类型。
int4range — integer的范围
int8range — bigint的范围
numrange — numeric的范围
tsrange — 不带时区的 timestamp的范围
tstzrange — 带时区的 timestamp的范围
daterange — date的范围</p>
<p>范围数据类型的基础数据类型必须是可排序的。六种内置范围数据类型中的每一种，都满足这一要求。范围值由较小的起始值和较大的结束值定义组成。</p>
<h5 id="bsql_1"><strong>BSQL中的范围值</strong></h5>
<p>范围值可以指定为文字，也可以使用构造函数。如下示例演示：
首先，创建一个表如下：</p>
<div class="highlight"><pre><span></span><code>create table t(k int primary key, r1 tsrange, r2 tsrange);
</code></pre></div>
<h6 id="_77"><strong>使用文字指定范围值</strong></h6>
<p>使用文字指定所有范围数据类型的范围值。文本值定义如下：</p>
<ul>
<li>以一个左括号或一个左方括号开头。</li>
<li>紧跟是下界的::text类型转换表示，一个逗号，然后是上界的::text类型转换表示。</li>
<li>以右括号或右方括号结束。
  例如：</li>
</ul>
<div class="highlight"><pre><span></span><code>insert into t(k, r1, r2)
values (
  1,
  &#39;[2010-01-01 14:30, 2010-01-01 15:30)&#39;,
  &#39;(2010-01-01 15:00, 2010-01-01 16:00]&#39;);
</code></pre></div>
<h6 id="tsrange"><strong>使用构造函数指定“tsrange”值</strong></h6>
<p>每一种范围类型都有一个与其同名的构造器函数。使用构造器函数常常比写一个范围文字常数更方便，因为它避免了对界限值的额外引用。构造器函数接受两个或三个参数。两个参数的形式以标准的形式构造一个范围（下界是包含的，上界是排除的），而三个参数的形式按照第三个参数指定的界限形式构造一个范围。第三个参数必须是下列字符串之一： “()”、 “(]”、 “[)”或者 “[]”。当在没有为第三个形式参数提供值的情况下调用构造函数时，将使用值“[）”。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>insert into t(k, r1, r2)
values (
  2,
  tsrange(
    make_timestamp(2010, 1, 1, 14, 30, 0.0),
    make_timestamp(2010, 1, 1, 15, 30, 0.0)
    ),
  tsrange(
    make_timestamp(2010, 1, 1, 15, 0, 0.0),
    make_timestamp(2010, 1, 1, 16, 0, 0.0),
    &#39;(]&#39;));
</code></pre></div>
<h6 id="_78"><strong>无界的范围</strong></h6>
<p>范围值的下界和上界中的一个或两个都可以设置为表示语义“无界”。PostgreSQL文档交替使用“unbounded”和“infinite”来表示这样的范围。AiSQL建议始终使用“unbounded”一词，并避免使用“infinite”一词。 </p>
<ul>
<li>当使用文字定义范围值时，只需省略该值，就可以将下界或上界指定为无边界，如下所示：</li>
</ul>
<div class="highlight"><pre><span></span><code>select (&#39;(, 5]&#39;::int4range)::text;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (,6)
</code></pre></div>
<p>请注意，不允许使用空格：为了表示下界是无边界的，开头标点符号和逗号之间必须没有空格；为了表示上界是无边界的，逗号和结束标点符号之间不能有空格。 </p>
<ul>
<li>当使用构造函数定义范围值时，通过使用NULL将下界或上界指定为无边界，如下所示：</li>
</ul>
<div class="highlight"><pre><span></span><code>select int4range(null, 5, &#39;(]&#39;) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (,6)
</code></pre></div>
<p>您可以使用如下布尔函数lower_inf()和upper_info()测试“unbounded”状态： </p>
<div class="highlight"><pre><span></span><code>with a as (select &#39;(,)&#39;::int4range as v)
select lower_inf(v)::text, upper_inf(v)::text from a;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> lower_inf | upper_inf 
-----------+-----------
  true     | true
</code></pre></div>
<p>注意：一些数据类型，例如timestamp，支持一个特殊的infinity 值，该值也可以用于定义范围。示例如下：</p>
<div class="highlight"><pre><span></span><code>select
  (&#39;infinity&#39;::timestamp)             ::text as &quot;infinity timestamp&quot;,
  (&#39;[2020-01-01, infinity]&#39;::tsrange) ::text as &quot;infinity upper bound tsrange&quot;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> infinity timestamp |   infinity upper bound tsrange
--------------------+----------------------------------
 infinity           | [&quot;2020-01-01 00:00:00&quot;,infinity]
</code></pre></div>
<p>然而，上界等于正无穷大的范围与在该端无边界的范围不同。这同样适用于下界等于负无穷大的范围。请看如下两个示例：</p>
<div class="highlight"><pre><span></span><code>select (upper_inf(&#39;[2020-01-01, infinity]&#39;::tsrange))::text ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> false
</code></pre></div>
<p>再例如：</p>
<div class="highlight"><pre><span></span><code>select (
    tsrange(&#39;2020-01-01&#39;::timestamp, &#39;infinity&#39;::timestamp)
    =
    tsrange(&#39;2020-01-01&#39;::timestamp, null      ::timestamp)
  )::text;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> false
</code></pre></div>
<p>注：AiSQL建议始终通过省略值（在文字中）或使用NULL（在构造函数中）来指定无边界绑定。
使用特殊值infinity会带来以下缺点： </p>
<ul>
<li>并不是所有内置范围数据类型的底层数据类型都支持infinity 概念。事实上，只有date、timestamp 和timestamptz （在内置范围数据类型的类中）才支持infinity 。</li>
<li>语义不清楚。当相应的界限设置为（负或正）infinity 时，lower_inf()和upper_inf()函数返回false。相应地，一对范围值，其中一个边界设置为正常值，而另一个边界设置为infinity 或“unbounded”，则比较结果为不相等。 </li>
</ul>
<h5 id="_79"><strong>对范围值和基础数据类型的值的操作</strong></h5>
<p>您可以查找单个范围值是否为空，或者两个范围值是否相交；您可以将一个新的范围值导出为两个范围值的交集；并且您可以查明基础数据类型的值是否包含在范围值内。</p>
<h6 id="_80"><strong>范围值是否为空</strong></h6>
<p>基于前面的表及其表数据，执行如下：</p>
<div class="highlight"><pre><span></span><code>select isempty(r1)::text from t where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>false
</code></pre></div>
<p>继续执行如下：</p>
<div class="highlight"><pre><span></span><code>select isempty(numrange(1.5, 1.5, &#39;[)&#39;))::text;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>true
</code></pre></div>
<p>再试着执行如下：</p>
<div class="highlight"><pre><span></span><code>select (numrange(1.5, 1.5, &#39;[)&#39;) = &#39;empty&#39;::numrange)::text as &quot;is empty?&quot;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>true
</code></pre></div>
<p>换句话说，“empty”::＜some range data type＞表示该范围数据类型的特殊“empty range”值。</p>
<h6 id="_81"><strong>两个范围值是否相交</strong></h6>
<p>执行如下示例：</p>
<div class="highlight"><pre><span></span><code>select (numrange(1.0, 2.0) &amp;&amp; numrange(1.5, 2.5))::text as &quot;range values intersect?&quot;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>true
</code></pre></div>
<h6 id="_82"><strong>生成一个新的范围值作为两个范围值的交集</strong></h6>
<p>执行如下示例：</p>
<div class="highlight"><pre><span></span><code>select (numrange(1.0, 2.0) * numrange(1.5, 2.5))::text as &quot;the intersection&quot;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>[1.5,2.0)
</code></pre></div>
<p>如果 * range交集运算符的两个操作数不相交，则结果为空范围，如下所示：</p>
<div class="highlight"><pre><span></span><code>select (numrange(1.0, 2.0) * numrange(3.0, 4.0))::text as &quot;the intersection&quot;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> empty
</code></pre></div>
<h6 id="_83"><strong>是包含在范围内的范围的基础数据类型的值</strong></h6>
<p>执行如下示例：</p>
<div class="highlight"><pre><span></span><code>select (17::int &lt;@ int4range(11, 42))::text;
</code></pre></div>
<p>或者</p>
<div class="highlight"><pre><span></span><code>select (int4range(11, 42) @&gt; 17::int)::text;
</code></pre></div>
<p>均返回信息如下：</p>
<div class="highlight"><pre><span></span><code> true
</code></pre></div>
<h5 id="_84"><strong>离散范围数据类型及其文字的规范形式</strong></h5>
<p>int4range、int8range和daterange数据类型的底层数据类型是离散的：int4和int8只容纳精确的整数步长；而日期只能容纳整天的步长。这意味着包容界和排他性界的定义，导致了以不同方式定义相同范围的可能性。考虑将3作为其下界，将7作为其上界的int范围。它可以用四种不同的方式书写：</p>
<div class="highlight"><pre><span></span><code>create table t(
  k int primary key,
  r1 int4range not null,
  r2 int4range not null,
  r3 int4range not null,
  r4 int4range not null);

insert into t(k, r1, r2, r3, r4) values(1, &#39;[3, 8)&#39;, &#39;[3, 7]&#39;, &#39;(2, 8)&#39;, &#39;(2, 7]&#39;);

select (
  (select r1 = r2 from t where k = 1) and
  (select r1 = r3 from t where k = 1) and
  (select r1 = r4 from t where k = 1)
  )::text as &quot;all the same?&quot;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> true
</code></pre></div>
<p>再试着执行如下：</p>
<div class="highlight"><pre><span></span><code>select r1::text, r2::text, r3::text, r4::text from t where k = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>  r1  |  r2   |  r3  |  r4   
--------+--------+--------+-------
 [3,8) | [3,8)  | [3,8)  | [3,8)
</code></pre></div>
<p>正如上面返回的结果所看到的，“r1”、“r2”、“r3”和“r4”的值是相同的。</p>
<h5 id="_85"><strong>范围输入/输出</strong></h5>
<p>一个范围值的输入必须遵循下列模式之一：
(lower-bound,upper-bound)
(lower-bound,upper-bound]
[lower-bound,upper-bound)
[lower-bound,upper-bound]
Empty</p>
<p>圆括号或方括号指示上下界是否为排除的或者包含的。注意最后一个模式是empty，它表示一个空范围（一个不包含点的范围）。</p>
<p>lower-bound可以是作为 subtype 的合法输入的一个字符串，或者是空表示没有下界。同样，upper-bound可以是作为 subtype 的合法输入的一个字符串，或者是空表示没有上界。</p>
<p>每个界限值可以使用"（双引号）字符引用。如果界限值包含圆括号、方括号、逗号、双引号或反斜线时，这样做是必须的，因为否则那些字符会被认作范围语法的一部分。要把一个双引号或反斜线放在一个被引用的界限值中，就在它前面放一个反斜线（还有，在一个双引号引用的界限值中的一对双引号表示一个双引号字符，这与 SQL 字符串中的单引号规则类似）。此外，你可以避免引用并且使用反斜线转义来保护所有数据字符，否则它们会被当做返回语法的一部分。还有，要写一个是空字符串的界限值，则可以写成""，因为什么都不写表示一个无限界限。</p>
<h5 id="_86"><strong>函数和操作符</strong></h5>
<h6 id="_87"><strong>操作符</strong></h6>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_=_1">=</a></td>
<td>是否相等</td>
</tr>
<tr>
<td><a href="#_&lt;&gt;">&lt;&gt;</a></td>
<td>是否不相等</td>
</tr>
<tr>
<td><a href="#_&lt;">&lt;</a></td>
<td>是否小于</td>
</tr>
<tr>
<td><a href="#_&gt;">&gt;</a></td>
<td>是否大于</td>
</tr>
<tr>
<td><a href="#_&lt;=">&lt;=</a></td>
<td>是否小于或等于</td>
</tr>
<tr>
<td><a href="#_&gt;=">&gt;=</a></td>
<td>是否大于或等于</td>
</tr>
<tr>
<td><a href="#_@&gt;">@&gt;</a></td>
<td>第一个范围中是否包含第二个范围</td>
</tr>
<tr>
<td><a href="#_@&gt;_1">@&gt;</a></td>
<td>第一个范围中是否包含元素</td>
</tr>
<tr>
<td><a href="#_&lt;@">&lt;@</a></td>
<td>第一个范围是否包含在第二个(范围)中</td>
</tr>
<tr>
<td><a href="#_&lt;@_1">&lt;@</a></td>
<td>元素是否包含在范围内</td>
</tr>
<tr>
<td><a href="#_&amp;&amp;">&amp;&amp;</a></td>
<td>范围是否重叠，也就是说，是否有相同的元素</td>
</tr>
<tr>
<td><a href="#_&lt;&lt;">&lt;&lt;</a></td>
<td>第一个范围是否严格地在第二个(范围)的左侧</td>
</tr>
<tr>
<td><a href="#_&gt;&gt;">&gt;&gt;</a></td>
<td>第一个范围是否严格符合第二个(范围)</td>
</tr>
<tr>
<td><a href="#_&amp;&lt;">&amp;&lt;</a></td>
<td>第一个范围是否没有扩展到第二个(范围)的右侧</td>
</tr>
<tr>
<td><a href="#_&amp;&gt;">&amp;&gt;</a></td>
<td>第一个范围是否没有扩展到第二个(范围)的左侧</td>
</tr>
<tr>
<td>[-</td>
<td>-](#_-</td>
</tr>
<tr>
<td><a href="#_+">+</a></td>
<td>计算范围的并集。</td>
</tr>
<tr>
<td><a href="#_*">*</a></td>
<td>计算范围的交集。</td>
</tr>
<tr>
<td><a href="#_-_1">-</a></td>
<td>计算范围的差异。</td>
</tr>
</tbody>
</table>
<h6 id="_88"># =</h6>
<p>目的：是否相等</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select int4range(1,5) = &#39;[1,4]&#39;::int4range;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t 
</code></pre></div>
<h6 id="_89"># &lt;&gt;</h6>
<p>目的：是否不相等</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select numrange(1.1,2.2) &lt;&gt; numrange(1.1,2.3);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_90"># &lt;</h6>
<p>目的：是否小于</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select int4range(1,10) &lt; int4range(2,3);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_91"># &gt;</h6>
<p>目的：是否大于</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select int4range(1,10) &gt; int4range(1,5);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_92"># &lt;=</h6>
<p>目的：是否小于或等于</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select numrange(1.1,2.2) &lt;= numrange(1.1,2.2);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_93"># &gt;=</h6>
<p>目的：是否大于或等于</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select numrange(1.1,2.2) &gt;= numrange(1.1,2.0);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_94"># @&gt;</h6>
<p>目的：第一个范围中是否包含第二个范围</p>
<p>语法：</p>
<p>anyrange @&gt; anyrange → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select int4range(2,4) @&gt; int4range(2,3);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_95"># @&gt;</h6>
<p>目的：第一个范围中是否包含元素</p>
<p>语法：</p>
<p>anyrange @&gt; anyelement → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;[2011-01-01,2011-03-01)&#39;::tsrange @&gt; &#39;2011-01-10&#39;::timestamp;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_96"># &lt;@</h6>
<p>目的：第一个范围是否包含在第二个(范围)中</p>
<p>语法：</p>
<p>anyrange &lt;@ anyrange → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select int4range(2,4) &lt;@ int4range(1,7);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_97"># &lt;@</h6>
<p>目的：元素是否包含在范围内</p>
<p>语法：</p>
<p>anyelement &lt;@ anyrange → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select 42 &lt;@ int4range(1,7);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>f
</code></pre></div>
<h6 id="_98"># &amp;&amp;</h6>
<p>目的：范围是否重叠，也就是说，是否有相同的元素</p>
<p>语法：</p>
<p>anyrange &amp;&amp; anyrange → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select int8range(3,7) &amp;&amp; int8range(4,12);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_99"># &lt;&lt;</h6>
<p>目的：第一个范围是否严格地在第二个(范围)的左侧</p>
<p>语法：</p>
<p>anyrange &lt;&lt; anyrange → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select int8range(1,10) &lt;&lt; int8range(100,110);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_100"># &gt;&gt;</h6>
<p>目的：第一个范围是否严格符合第二个(范围)</p>
<p>语法：</p>
<p>anyrange &gt;&gt; anyrange → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select int8range(50,60) &gt;&gt; int8range(20,30);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_101"># &amp;&lt;</h6>
<p>目的：第一个范围是否没有扩展到第二个(范围)的右侧</p>
<p>语法：</p>
<p>anyrange &amp;&lt; anyrange → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select int8range(1,20) &amp;&lt; int8range(18,20);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_102"># &amp;&gt;</h6>
<p>目的：第一个范围是否没有扩展到第二个(范围)的左侧</p>
<p>语法：</p>
<p>anyrange &amp;&gt; anyrange → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select int8range(7,20) &amp;&gt; int8range(5,10);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="-_5"># -|-</h6>
<p>目的：范围是否相邻</p>
<p>语法：</p>
<p>anyrange -|- anyrange → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select numrange(1.1,2.2) -|- numrange(2.2,3.3);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_103"># +</h6>
<p>目的：计算范围的并集。</p>
<p>语法：</p>
<p>anyrange + anyrange → anyrange</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select numrange(5,15) + numrange(10,20);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> [5,20)
</code></pre></div>
<h6 id="_104"># *</h6>
<p>目的：计算范围的交集。</p>
<p>语法：</p>
<p>anyrange * anyrange → anyrange</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select int8range(5,15) * int8range(10,20);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>[10,15)
</code></pre></div>
<h6 id="-_6"># -</h6>
<p>目的：计算范围的差异。</p>
<p>语法：</p>
<p>anyrange - anyrange → anyrange</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select int8range(5,15) - int8range(10,20);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>[5,10)
</code></pre></div>
<h6 id="_105"><strong>函数</strong></h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_lower()_1">lower()</a></td>
<td>提取范围的下界</td>
</tr>
<tr>
<td><a href="#_upper()_1">upper()</a></td>
<td>提取范围的上界</td>
</tr>
<tr>
<td><a href="#_isempty()">isempty()</a></td>
<td>范围是否为空</td>
</tr>
<tr>
<td><a href="#_lower_inc()">lower_inc()</a></td>
<td>范围的下界是否包含在内</td>
</tr>
<tr>
<td><a href="#_upper_inc()">upper_inc()</a></td>
<td>范围的上界是否包含在内</td>
</tr>
<tr>
<td><a href="#_lower_inf()">lower_inf()</a></td>
<td>范围的下界是否无限</td>
</tr>
<tr>
<td><a href="#_upper_inf()">upper_inf()</a></td>
<td>范围的上界是否无限</td>
</tr>
<tr>
<td><a href="#_range_merge()">range_merge()</a></td>
<td>计算包含两个给定范围的最小范围</td>
</tr>
</tbody>
</table>
<h6 id="lower_1"># lower()</h6>
<p>目的：提取范围的下界，如果范围为空或下界为无限，则为NULL。</p>
<p>语法：</p>
<p>输入值:    anyrange
返回值:    anyelement</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select lower(numrange(1.1,2.2));
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>1.1
</code></pre></div>
<h6 id="upper_1"># upper()</h6>
<p>目的：提取范围的上界，如果范围为空或上界为无限，则为NULL。</p>
<p>语法：</p>
<p>输入值:    anyrange
返回值:    anyelement</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select upper(numrange(1.1,2.2));
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2.2
</code></pre></div>
<h6 id="isempty"># isempty()</h6>
<p>目的：范围是否为空</p>
<p>语法：</p>
<p>输入值:  anyrange<br />
返回值:  boolean  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select isempty(numrange(1.1,2.2));
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>f
</code></pre></div>
<h6 id="lower_inc"># lower_inc()</h6>
<p>目的：范围的下界是否包含在内</p>
<p>语法：</p>
<p>输入值:  anyrange<br />
返回值:  boolean  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select lower_inc(numrange(1.1,2.2));
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="upper_inc"># upper_inc()</h6>
<p>目的：范围的上界是否包含在内</p>
<p>语法：</p>
<p>输入值:  anyrange<br />
返回值:  boolean   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select upper_inc(numrange(1.1,2.2));
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>f
</code></pre></div>
<h6 id="lower_inf"># lower_inf()</h6>
<p>目的：范围的下界是否无限</p>
<p>语法：</p>
<p>输入值:  anyrange<br />
返回值:  boolean   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select lower_inf(&#39;(,)&#39;::daterange);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="upper_inf"># upper_inf()</h6>
<p>目的：范围的上界是否无限</p>
<p>语法：</p>
<p>输入值:  anyrange<br />
返回值:  boolean    </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select upper_inf(&#39;(,)&#39;::daterange);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="range_merge"># range_merge()</h6>
<p>目的：计算包含两个给定范围的最小范围。</p>
<p>语法：</p>
<p>输入值:   anyrange, anyrange 
返回值:   anyrange </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select range_merge(&#39;[1,2)&#39;::int4range, &#39;[3,4)&#39;::int4range);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>[1,4)
</code></pre></div>
<h4 id="serial"><strong>Serial</strong></h4>
<p>SMALLSERIAL、SERIAL和BIGSERIAL分别是SMALLINT、INTEGER和BIGINT序列的简短表示法。 
type_specification ::= SMALLSERIAL | SERIAL | BIGSERIAL</p>
<p>注：</p>
<ul>
<li>serial 类型的列会自动递增。</li>
<li>serial 并不意味着在列上创建了索引。</li>
</ul>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE t (id SERIAL);
</code></pre></div>
<h4 id="uuid"><strong>UUID</strong></h4>
<p>UUID数据类型表示通用唯一标识符（UUID）。对于分布式系统，这些标识符相比序列生成器而言提供了一种很好的唯一性保障，序列生成器只能在一个数据库中保证唯一。</p>
<p>type_specification ::= UUID</p>
<p>一个UUID被写成一个小写十六进制位的序列，该序列被连字符分隔成多个组：首先是一个8位组，接下来是三个4位组，最后是一个12位组。总共的32位（十六进制位）表示了128个二进制位。一个标准形式的UUID类似于：
a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11</p>
<p>也接受另一种输入形式： 使用大写位、标准格式被花括号包围、忽略某些或者全部连字符、在任意4位组后面增加一个连字符。例如：
A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}
a0eebc999c0b4ef8bb6d6bb9bd380a11
a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}</p>
<p>输出总是采用标准形式。</p>
<h4 id="_106"><strong>枚举类型</strong></h4>
<p>枚举（enum）类型是由一个静态、值的有序集合构成的数据类型。它们等效于很多编程语言所支持的enum类型。枚举类型的一个示例可以是一周中的日期，或者一个数据的状态值集合。</p>
<h5 id="_107"><strong>枚举类型的声明</strong></h5>
<p>枚举类型可以使用CREATE TYPE命令创建，例如：</p>
<div class="highlight"><pre><span></span><code>CREATE TYPE mood AS ENUM (&#39;sad&#39;, &#39;ok&#39;, &#39;happy&#39;);
</code></pre></div>
<p>一旦被创建，枚举类型可以像很多其他类型一样在表和函数定义中使用：</p>
<div class="highlight"><pre><span></span><code>CREATE TYPE mood AS ENUM (&#39;sad&#39;, &#39;ok&#39;, &#39;happy&#39;);
CREATE TABLE person (
    name text,
    current_mood mood
);

INSERT INTO person VALUES (&#39;Moe&#39;, &#39;happy&#39;);

select * FROM person WHERE current_mood = &#39;happy&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> name | current_mood
------+--------------
 Moe  | happy
</code></pre></div>
<h5 id="_108"><strong>排序</strong></h5>
<p>一个枚举类型的值的排序是该类型被创建时所列出的值的顺序。枚举类型的所有标准的比较操作符以及相关聚集函数都被支持。例如：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO person VALUES (&#39;Larry&#39;, &#39;sad&#39;);
INSERT INTO person VALUES (&#39;Curly&#39;, &#39;ok&#39;);
select * FROM person WHERE current_mood &gt; &#39;sad&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> name  | current_mood
-----------+------------------
 Moe   | happy
 Curly  | ok

select * FROM person WHERE current_mood &gt; &#39;sad&#39; ORDER BY current_mood;
</code></pre></div>
<p>返回信息如下：
 name  | current_mood</p>
<div class="highlight"><pre><span></span><code>-----------+----------------
 Curly  | ok
 Moe   | happy
</code></pre></div>
<div class="highlight"><pre><span></span><code>select name
FROM person
WHERE current_mood = (select MIN(current_mood) FROM person);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> Larry
</code></pre></div>
<h5 id="_109"><strong>类型安全性</strong></h5>
<p>每一种枚举数据类型都是独立的并且不能和其他枚举类型相比较。看这样一个示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TYPE happiness AS ENUM (&#39;happy&#39;, &#39;very happy&#39;, &#39;ecstatic&#39;);
CREATE TABLE holidays (
    num_weeks integer,
    happiness happiness
);
INSERT INTO holidays(num_weeks,happiness) VALUES (4, &#39;happy&#39;);
INSERT INTO holidays(num_weeks,happiness) VALUES (6, &#39;very happy&#39;);
INSERT INTO holidays(num_weeks,happiness) VALUES (8, &#39;ecstatic&#39;);
INSERT INTO holidays(num_weeks,happiness) VALUES (2, &#39;sad&#39;);
</code></pre></div>
<p>返回错误信息如下：</p>
<div class="highlight"><pre><span></span><code>ERROR:  invalid 输入值 for enum happiness: &quot;sad&quot;
</code></pre></div>
<div class="highlight"><pre><span></span><code>select person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood = holidays.happiness;
</code></pre></div>
<p>返回错误信息如下：</p>
<div class="highlight"><pre><span></span><code>ERROR:  operator does not exist: mood = happiness
</code></pre></div>
<p>如果你确实需要做这样的事情，你可以写一个自定义的操作符或者在查询中加上显式造型：</p>
<div class="highlight"><pre><span></span><code>select person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood::text = holidays.happiness::text;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> name | num_weeks
---------+--------------
 Moe  |         4
</code></pre></div>
<p>枚举标签是大小写敏感的，因此'happy'与'HAPPY'是不同的。标签中的空格也是有意义的。</p>
<p>尽管枚举类型的主要目的是用于值的静态集合，但也有方法在现有枚举类型中增加新值和重命名值（见ALTER TYPE）。不能从枚举类型中去除现有的值，也不能更改这些值的排序顺序，如果要那样做可以删除并且重建枚举类型。</p>
<h5 id="_110"><strong>函数</strong></h5>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_enum_first()">enum_first()</a></td>
<td>返回输入枚举类型的第一个值。</td>
</tr>
<tr>
<td><a href="#_enum_last()">enum_last()</a></td>
<td>返回输入枚举类型的最后一个值。</td>
</tr>
<tr>
<td><a href="#_enum_range()">enum_range()</a></td>
<td>将输入枚举类型的所有值作为一个有序的数组返回。</td>
</tr>
<tr>
<td><a href="#_enum_range()_1">enum_range()</a></td>
<td>以一个数组返回在给定两个枚举值之间的范围。值必须来自相同的枚举类型。 如果第一个参数为空，其结果将从枚举类型的第一个值开始。如果第二参数为空，其结果将以枚举类型的最后一个值结束。</td>
</tr>
</tbody>
</table>
<p>假定一个枚举类型被创建为：</p>
<div class="highlight"><pre><span></span><code>CREATE TYPE rainbow AS ENUM (&#39;red&#39;, &#39;orange&#39;, &#39;yellow&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;purple&#39;);
</code></pre></div>
<h6 id="enum_first"># enum_first()</h6>
<p>目的：返回输入枚举类型的第一个值。</p>
<p>语法：</p>
<p>输入值:    anyenum <br />
返回值:    anyenum  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select enum_first(null::rainbow);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>red
</code></pre></div>
<h6 id="enum_last"># enum_last()</h6>
<p>目的：返回输入枚举类型的最后一个值。</p>
<p>语法：</p>
<p>输入值:    anyenum <br />
返回值:    anyenum  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select enum_last(null::rainbow);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>purple
</code></pre></div>
<h6 id="enum_range"># enum_range()</h6>
<p>目的：将输入枚举类型的所有值作为一个有序的数组返回。</p>
<p>语法：</p>
<p>输入值:    anyarray <br />
返回值:    anyenum  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select enum_range(null::rainbow);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> {red,orange,yellow,green,blue,purple}
</code></pre></div>
<h6 id="enum_range_1"># enum_range()</h6>
<p>目的：以一个数组返回在给定两个枚举值之间的范围。值必须来自相同的枚举类型。 如果第一个参数为空，其结果将从枚举类型的第一个值开始。如果第二参数为空，其结果将以枚举类型的最后一个值结束。</p>
<p>语法：</p>
<p>输入值:       anyenum, anyenum
返回值:       anyarray</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select enum_range(&#39;orange&#39;::rainbow, &#39;green&#39;::rainbow);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>{orange,yellow,green}
</code></pre></div>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select enum_range(NULL, &#39;green&#39;::rainbow);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>{red,orange,yellow,green}
</code></pre></div>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select enum_range(&#39;orange&#39;::rainbow, NULL);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>{orange,yellow,green,blue,purple}
</code></pre></div>
<h4 id="_111"><strong>几何类型</strong></h4>
<p>几何数据类型表示二维的空间物体，主要包含如下：</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>存储尺寸</th>
<th>表示</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>point</td>
<td>16字节</td>
<td>平面上的点</td>
<td>(x,y)</td>
</tr>
<tr>
<td>line</td>
<td>32字节</td>
<td>无限长的线</td>
<td>{A,B,C}</td>
</tr>
<tr>
<td>lseg</td>
<td>32字节</td>
<td>有限线段</td>
<td>((x1,y1),(x2,y2))</td>
</tr>
<tr>
<td>box</td>
<td>32字节</td>
<td>矩形框</td>
<td>((x1,y1),(x2,y2))</td>
</tr>
<tr>
<td>path</td>
<td>16+16n字节</td>
<td>封闭路径（类似于多边形）</td>
<td>((x1,y1),...)</td>
</tr>
<tr>
<td>path</td>
<td>16+16n字节</td>
<td>开放路径</td>
<td>[(x1,y1),...]</td>
</tr>
<tr>
<td>polygon</td>
<td>40+16n字节</td>
<td>多边形（类似于封闭路径）</td>
<td>((x1,y1),...)</td>
</tr>
<tr>
<td>circle</td>
<td>24字节</td>
<td>圆</td>
<td>&lt;(x,y),r&gt;（中心点和半径）</td>
</tr>
</tbody>
</table>
<h5 id="_112"><strong>点</strong></h5>
<p>点是几何类型的基本二维构造块。用下面的语法描述point类型的值：</p>
<p>( x , y )
  x , y
其中x和y分别是坐标，都是浮点数。</p>
<p>点使用第一种语法输出。</p>
<h5 id="_113"><strong>线</strong></h5>
<p>线由线性方程Ax + By + C = 0 表示，其中A和B都不为零。类型line 的值采用以下形式输入和输出：
{ A, B, C }</p>
<p>另外，还可以用下列任一形式输入：
[ ( x1 , y1 ) , ( x2 , y2 ) ]
( ( x1 , y1 ) , ( x2 , y2 ) )
  ( x1 , y1 ) , ( x2 , y2 )
    x1 , y1   ,   x2 , y2</p>
<p>其中 (x1,y1) 和 (x2,y2) 是线上不同的两点。</p>
<h5 id="_114"><strong>线段</strong></h5>
<p>线段用一对线段的端点来表示。lseg类型的值用下面的语法声明：
[ ( x1 , y1 ) , ( x2 , y2 ) ]
( ( x1 , y1 ) , ( x2 , y2 ) )
  ( x1 , y1 ) , ( x2 , y2 )
   x1 , y1  ,  x2 , y2
其中(x1,y1) 和 (x2,y2) 是线段的端点。</p>
<p>线段使用第一种语法输出。</p>
<h5 id="_115"><strong>矩形</strong></h5>
<p>矩形用其对角的点对表示。box类型的值使用下面的语法指定：
( ( x1 , y1 ) , ( x2 , y2 ) )
  ( x1 , y1 ) , ( x2 , y2 )
    x1 , y1   ,   x2 , y2
其中(x1,y1) 和 (x2,y2) 是矩形的对角点。</p>
<p>矩形使用第二种语法输出。</p>
<p>在输入时可以提供任意两个对角，但是值将根据需要被按顺序记录为右上角和左下角。</p>
<h5 id="_116"><strong>路径</strong></h5>
<p>路径由一系列连接的点组成。路径可能是开放的，也就是认为列表中第一个点和最后一个点没有被连接起来；也可能是封闭的，这时认为第一个和最后一个点被连接起来。</p>
<p>path类型的值用下面的语法声明：
[ ( x1 , y1 ) , ... , ( xn , yn ) ]
( ( x1 , y1 ) , ... , ( xn , yn ) )
  ( x1 , y1 ) , ... , ( xn , yn )
  ( x1 , y1   , ... ,   xn , yn )
   x1 , y1   , ... ,   xn , yn
其中的点是组成路径的线段的端点。方括弧（[]）表示一个开放的路径，圆括弧（()）表示一个封闭的路径。如第三种到第五种语法所示，当最外面的圆括号被忽略时，路径将被假定为封闭。</p>
<p>路径的输出使用第一种或第二种语法。</p>
<h5 id="_117"><strong>多边形</strong></h5>
<p>多边形由一系列点代表（多边形的顶点）。多边形和封闭路径很像，但是存储方式不一样，而且有自己的一套支持习惯。</p>
<p>polygon类型的值用下列语法声明：
( ( x1 , y1 ) , ... , ( xn , yn ) )
  ( x1 , y1 ) , ... , ( xn , yn )
  ( x1 , y1   , ... ,   xn , yn )
    x1 , y1   , ... ,   xn , yn
其中的点是组成多边形边界的线段的端点。</p>
<p>多边形的输出使用第一种语法。</p>
<h5 id="_118"><strong>圆</strong></h5>
<p>圆由一个圆心和一个半径代表。circle类型的值用下面的语法指定：</p>
<p>&lt; ( x , y ) , r &gt;
( ( x , y ) , r )
  ( x , y ) , r
    x , y , r</p>
<p>其中(x,y)是圆心，而r是圆的半径。</p>
<p>圆的输出用第一种语法。</p>
<h5 id="_119"><strong>函数和操作符</strong></h5>
<h6 id="_120"><strong>操作符</strong></h6>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_+">+</a></td>
<td>平移</td>
</tr>
<tr>
<td><a href="#_+_1">+</a></td>
<td>连接两个打开的路径（如果其中一个路径关闭，则返回NULL）。</td>
</tr>
<tr>
<td><a href="#_-_1">-</a></td>
<td>平移</td>
</tr>
<tr>
<td><a href="#_*">*</a></td>
<td>缩放/旋转</td>
</tr>
<tr>
<td><a href="#_/">/</a></td>
<td>缩放/旋转</td>
</tr>
<tr>
<td><a href="#_#">#</a></td>
<td>相交的矩形</td>
</tr>
<tr>
<td><a href="#_#_1">#</a></td>
<td>路径或多边形中的点数</td>
</tr>
<tr>
<td><a href="#_@-@">@-@</a></td>
<td>计算总长度</td>
</tr>
<tr>
<td><a href="#_@@">@@</a></td>
<td>计算中心点</td>
</tr>
<tr>
<td><a href="#_##">##</a></td>
<td>计算第二个对象上离第一个对象最近的点。</td>
</tr>
<tr>
<td><a href="#_&lt;-&gt;">&lt;-&gt;</a></td>
<td>计算对象之间的距离</td>
</tr>
<tr>
<td><a href="#_&amp;&amp;">&amp;&amp;</a></td>
<td>是否重叠（只要有一个公共点就为真）</td>
</tr>
<tr>
<td><a href="#_&lt;&lt;">&lt;&lt;</a></td>
<td>第一个对象是否严格地落在第二个对象左侧</td>
</tr>
<tr>
<td><a href="#_&gt;&gt;">&gt;&gt;</a></td>
<td>第一个对象是否严格地落在第二个对象右侧。</td>
</tr>
<tr>
<td><a href="#_&amp;&lt;">&amp;&lt;</a></td>
<td>第一个对象不延伸到第二个对象的右边吗？</td>
</tr>
<tr>
<td><a href="#_&amp;&gt;">&amp;&gt;</a></td>
<td>第一个对象不延伸到第二个对象的左边吗？</td>
</tr>
<tr>
<td>[&lt;&lt;</td>
<td>](#_&lt;&lt;</td>
</tr>
<tr>
<td>[</td>
<td>&gt;&gt;](#_</td>
</tr>
<tr>
<td>[&amp;&lt;</td>
<td>](#_&amp;&lt;</td>
</tr>
<tr>
<td>[</td>
<td>&amp;&gt;](#_</td>
</tr>
<tr>
<td><a href="#_&lt;^">&lt;^</a></td>
<td>在下面（允许相切）？</td>
</tr>
<tr>
<td><a href="#_&gt;^">&gt;^</a></td>
<td>在上面（允许相切）？</td>
</tr>
<tr>
<td><a href="#_?#">?#</a></td>
<td>相交？</td>
</tr>
<tr>
<td><a href="#_?-">?-</a></td>
<td>水平？</td>
</tr>
<tr>
<td><a href="#_?-_1">?-</a></td>
<td>水平对齐？</td>
</tr>
<tr>
<td>[?</td>
<td>](#_?</td>
</tr>
<tr>
<td>[?</td>
<td>](#_?</td>
</tr>
<tr>
<td>[?-</td>
<td>](#_?-</td>
</tr>
<tr>
<td>[?</td>
<td></td>
</tr>
<tr>
<td><a href="#_@&gt;">@&gt;</a></td>
<td>第一个对象是否包含第二个对象。</td>
</tr>
<tr>
<td><a href="#_&lt;@">&lt;@</a></td>
<td>第一个对象是否包含在第二个中还是第二个上</td>
</tr>
<tr>
<td><a href="#_~=">~=</a></td>
<td>这些物体是否一样</td>
</tr>
</tbody>
</table>
<h6 id="_121"># +</h6>
<p>目的：平移，将第二个点的坐标与第一个参数的每个点的坐标相加，从而执行平移。可用于point，box，path，circle。</p>
<p>语法：</p>
<p>geometric_type + point → geometric_type</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select box &#39;((0,0),(1,1))&#39; + point &#39;(2,0)&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (3,3),(2,2)
</code></pre></div>
<h6 id="_122"># +</h6>
<p>目的：连接两个打开的路径（如果其中一个路径关闭，则返回NULL）。</p>
<p>语法：</p>
<p>path + path → path</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select path &#39;[(0,0),(1,1)]&#39; + path &#39;[(2,2),(3,3),(4,4)]&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>[(0,0),(1,1),(2,2),(3,3),(4,4)]
</code></pre></div>
<h6 id="-_7"># -</h6>
<p>目的：平移，从第一个自变量的每个点的坐标中减去第二个点的坐标，从而执行平移。可用于point，box，path，circle。</p>
<p>语法：</p>
<p>geometric_type - point → geometric_type</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select box &#39;((3,3),(2,2))&#39; - point &#39;(2,2)&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (1,1),(0,0)
</code></pre></div>
<h6 id="_123"># *</h6>
<p>目的：缩放/旋转，将第一个自变量的每个点乘以第二个点（将一个点视为由实部和虚部表示的复数，并执行标准复数乘法）。如果将第二个点解释为向量，这相当于按向量的长度缩放对象的大小和与原点的距离，并按向量与x轴的角度绕原点逆时针旋转。可用于point，box，path，circle。 </p>
<p>语法：</p>
<p>geometric_type * point → geometric_type</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select box &#39;((0,0),(1,1))&#39; * point &#39;(2,0)&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (2,2),(0,0)
</code></pre></div>
<h6 id="_124"># /</h6>
<p>目的：缩放/旋转，将第一个自变量的每个点除以第二个点（将一个点视为由实部和虚部表示的复数，并执行标准复数除法）。如果将第二个点解释为向量，这相当于将对象的大小和距原点的距离向下缩放向量的长度，并将其绕原点顺时针旋转向量与x轴的角度。可用于point，box，path，circle。 </p>
<p>语法：</p>
<p>geometric_type / point → geometric_type</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select box &#39;((0,0),(2,2))&#39; / point &#39;(2,0)&#39;; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (1,1),(0,0)
</code></pre></div>
<h6 id="_125">#</h6>
<p>目的：相交的矩形</p>
<p>语法：</p>
<p>box # box → box</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select box &#39;((1,-1),(-1,1))&#39; # box &#39;((1,1),(-2,-2))&#39;; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (1,1),(-1,-1)
</code></pre></div>
<h6 id="_126">#</h6>
<p>目的：路径或多边形中的点数，适用于path，polygon。</p>
<p>语法：</p>
<p># geometric_type → integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select # path &#39;((1,0),(0,1),(-1,0))&#39;; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>3
</code></pre></div>
<h6 id="-_8"># @-@</h6>
<p>目的：计算总长度。可用于lseg，path。 </p>
<p>语法：</p>
<p>@-@ geometric_type → double precision</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select @-@ path &#39;((0,0),(1,0))&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2
</code></pre></div>
<h6 id="_127"># @@</h6>
<p>目的：计算中心点。可用于box，lseg，polygon，circle。</p>
<p>语法：</p>
<p>@@ geometric_type → point</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select @@ circle &#39;((0,0),10)&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (0,0)
</code></pre></div>
<h6 id="_128">#</h6>
<p>目的：计算第二个对象上离第一个对象最近的点。可用于以下类型对：(point, box)，(point, lseg)，(point, line)，(lseg, box)，(lseg, lseg)，(line, lseg)。</p>
<p>语法：</p>
<p>geometric_type ## geometric_type → point</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select point &#39;(0,0)&#39; ## lseg &#39;((2,0),(0,2))&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (1,1)
</code></pre></div>
<h6 id="-_9"># &lt;-&gt;</h6>
<p>目的：计算对象之间的距离。适用于除多边形外的所有几何类型，适用于点与另一几何类型的所有组合，以及这些附加类型对：(box, lseg), (lseg, line), (polygon, circle)。</p>
<p>语法：</p>
<p>geometric_type &lt;-&gt; geometric_type → double precision</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select circle &#39;((0,0),1)&#39; &lt;-&gt; circle &#39;((5,0),1)&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>3
</code></pre></div>
<h6 id="_129"># &amp;&amp;</h6>
<p>目的：是否重叠（只要有一个公共点就为真）。可用于：box， polygon，circle。</p>
<p>语法：</p>
<p>geometric_type &amp;&amp; geometric_type → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select box &#39;((0,0),(1,1))&#39; &amp;&amp; box &#39;((0,0),(2,2))&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_130"># &lt;&lt;</h6>
<p>目的：第一个对象是否严格地落在第二个对象左侧。可用于：point， box， polygon， circle。</p>
<p>语法：</p>
<p>geometric_type &lt;&lt; geometric_type → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select circle &#39;((0,0),1)&#39; &lt;&lt; circle &#39;((5,0),1)&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_131"># &gt;&gt;</h6>
<p>目的：第一个对象是否严格地落在第二个对象右侧。可用于：point， box， polygon， circle。</p>
<p>语法：</p>
<p>geometric_type &gt;&gt; geometric_type → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select circle &#39;((5,0),1)&#39; &gt;&gt; circle &#39;((0,0),1)&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_132"># &amp;&lt;</h6>
<p>目的：第一个对象不延伸到第二个对象的右边吗？适用于box，polygon，circle。</p>
<p>语法：</p>
<p>geometric_type &amp;&lt; geometric_type → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select  box &#39;((0,0),(1,1))&#39; &amp;&lt; box &#39;((0,0),(2,2))&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_133"># &amp;&gt;</h6>
<p>目的：第一个对象不延伸到第二个对象的左边吗？适用于box，polygon，circle。</p>
<p>语法：</p>
<p>geometric_type &amp;&gt; geometric_type → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select  box &#39;((0,0),(3,3))&#39; &amp;&gt; box &#39;((0,0),(2,2))&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_134"># &lt;&lt;|</h6>
<p>目的：严格在下？可用于：point， box， polygon， circle。</p>
<p>语法：</p>
<p>geometric_type &lt;&lt;| geometric_type → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select box &#39;((0,0),(3,3))&#39; &lt;&lt;| box &#39;((3,4),(5,5))&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_135"># |&gt;&gt;</h6>
<p>目的：严格在上？可用于：point， box， polygon， circle。</p>
<p>语法：</p>
<p>geometric_type |&gt;&gt; geometric_type → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select box &#39;((3,4),(5,5))&#39; |&gt;&gt; box &#39;((0,0),(3,3))&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_136"># &amp;&lt;|</h6>
<p>目的：没有延展到上面？可用于：box， polygon， circle。</p>
<p>语法：</p>
<p>geometric_type &amp;&lt;| geometric_type → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select box &#39;((0,0),(1,1))&#39; &amp;&lt;| box &#39;((0,0),(2,2))&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_137"># |&amp;&gt;</h6>
<p>目的：没有延展到下面？可用于：box， polygon， circle。</p>
<p>语法：</p>
<p>geometric_type |&amp;&gt; geometric_type → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select box &#39;((0,0),(3,3))&#39; |&amp;&gt; box &#39;((0,0),(2,2))&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_138"># &lt;^</h6>
<p>目的：在下面（允许相切）？</p>
<p>语法：</p>
<p>box &lt;^ box → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select box &#39;((1,1),(0,0))&#39; &lt;^ box &#39;((2,2),(1,1))&#39; ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_139"># &gt;^</h6>
<p>目的：在上面（允许相切）？</p>
<p>语法：</p>
<p>box &gt;^ box → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select box &#39;((2,2),(1,1))&#39; &gt;^ box &#39;((1,1),(0,0))&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_140"># ?</h6>
<p>目的：相交？可用于以下类型对： (box, box)， (lseg, box)， (lseg, lseg)， (lseg, line)， (line, box)， (line, line)， (path, path)。</p>
<p>语法：</p>
<p>geometric_type ?# geometric_type → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select  lseg &#39;((-1,0),(1,0))&#39; ?# box &#39;((-2,-2),(2,2))&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="-_10"># ?-</h6>
<p>目的：水平？</p>
<p>语法：</p>
<p>?- line → boolean</p>
<p>?- lseg → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ?- lseg &#39;((-1,0),(1,0))&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="-_11"># ?-</h6>
<p>目的：水平对齐？（即具有相同的y坐标）</p>
<p>语法：</p>
<p>point ?- point → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select point &#39;(1,0)&#39; ?- point &#39;(0,0)&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_141"># ?|</h6>
<p>目的：垂直？
语法：</p>
<p>?| line → boolean</p>
<p>?| lseg → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ?| lseg &#39;((-1,0),(1,0))&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>f
</code></pre></div>
<h6 id="_142"># ?|</h6>
<p>目的：垂直对齐？（即具有相同的x坐标）</p>
<p>语法：</p>
<p>point ?| point → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select point &#39;(0,1)&#39; ?| point &#39;(0,0)&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="-_12"># ?-|</h6>
<p>目的：相互垂直？</p>
<p>语法：</p>
<p>line ?-| line → boolean</p>
<p>lseg ?-| lseg → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select lseg &#39;((0,0),(0,1))&#39; ?-| lseg &#39;((0,0),(1,0))&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_143"># ?||</h6>
<p>目的：平行？</p>
<p>语法：</p>
<p>line ?|| line → boolean</p>
<p>lseg ?|| lseg → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select lseg &#39;((-1,0),(1,0))&#39; ?|| lseg &#39;((-1,2),(1,2))&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_144"># @&gt;</h6>
<p>目的：第一个对象是否包含第二个对象。可用于以下类型对：(box, point)，(box, box)， (path, point)， (polygon, point)， (polygon, polygon)，(circle, point)， (circle, circle)。</p>
<p>语法：</p>
<p>geometric_type @&gt; geometric_type → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select circle &#39;((0,0),2)&#39; @&gt; point &#39;(1,1)&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_145"># &lt;@</h6>
<p>目的：第一个对象是否包含在第二个中还是第二个上。可用于以下类型对： (point, box)， (point, lseg)， (point, line)， (point, path)， (point, polygon)， (point, circle)， (box, box)， (lseg, box)， (lseg, line)， (polygon, polygon)， (circle, circle)。</p>
<p>语法：</p>
<p>geometric_type &lt;@ geometric_type → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select point &#39;(1,1)&#39; &lt;@ circle &#39;((0,0),2)&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_146"># ~=</h6>
<p>目的：这些物体是否一样，可用于point， box， polygon， circle。</p>
<p>语法：</p>
<p>geometric_type ~= geometric_type → boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select polygon &#39;((0,0),(1,1))&#39; ~= polygon &#39;((1,1),(0,0))&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_147"><strong>函数</strong></h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_area()">area()</a></td>
<td>计算面积</td>
</tr>
<tr>
<td><a href="#_center()">center()</a></td>
<td>计算中心点</td>
</tr>
<tr>
<td><a href="#_diagonal()">diagonal()</a></td>
<td>将长方体的对角线提取为线段</td>
</tr>
<tr>
<td><a href="#_diameter()">diameter()</a></td>
<td>计算圆的直径</td>
</tr>
<tr>
<td><a href="#_height()">height()</a></td>
<td>计算矩形的垂直大小。</td>
</tr>
<tr>
<td><a href="#_isclosed()">isclosed()</a></td>
<td>路径是否闭合</td>
</tr>
<tr>
<td><a href="#_isopen()">isopen()</a></td>
<td>路径是否开放</td>
</tr>
<tr>
<td><a href="#_length()">length()</a></td>
<td>计算长度</td>
</tr>
<tr>
<td><a href="#_npoints()">npoints()</a></td>
<td>计算点的数量</td>
</tr>
<tr>
<td><a href="#_pclose()">pclose()</a></td>
<td>将路径转换为闭合形式。</td>
</tr>
<tr>
<td><a href="#_popen()">popen()</a></td>
<td>将路径转换成开放形式。</td>
</tr>
<tr>
<td><a href="#_radius()">radius()</a></td>
<td>计算圆的半径</td>
</tr>
<tr>
<td><a href="#_width()">width()</a></td>
<td>计算矩形的水平尺寸</td>
</tr>
</tbody>
</table>
<h6 id="area"># area()</h6>
<p>目的：计算面积。可用于box， path， circle。路径输入必须是闭合的，否则返回NULL。此外，如果路径是自相交的，则结果可能毫无意义。适应于：box， path，circle。</p>
<p>语法：</p>
<p>输入值:       geometric_type
返回值:      double precision</p>
<p>示例一：</p>
<div class="highlight"><pre><span></span><code>select area(box &#39;(2,2),(0,0)&#39;) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>4
</code></pre></div>
<p>示例二：</p>
<div class="highlight"><pre><span></span><code>select area(path &#39;((0,0),(0,4),(4,0))&#39;) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>8
</code></pre></div>
<p>示例三：</p>
<div class="highlight"><pre><span></span><code>select area(path &#39;[(0,0),(0,4),(4,0)]&#39;) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&lt;null&gt;
</code></pre></div>
<h6 id="center"># center()</h6>
<p>目的：计算中心点。适应于：box，circle。</p>
<p>语法：</p>
<p>输入值:       geometric_type
返回值:      point</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select center(box &#39;(1,2),(0,0)&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>(0.5,1)
</code></pre></div>
<h6 id="diagonal"># diagonal()</h6>
<p>目的：将长方体的对角线提取为线段（与lseg(box)相同）。</p>
<p>语法：</p>
<p>输入值:       box
返回值:      lseg</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select diagonal(box &#39;(1,2),(0,0)&#39;) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>[(1,2),(0,0)]
</code></pre></div>
<h6 id="diameter"># diameter()</h6>
<p>目的：计算圆的直径</p>
<p>语法：</p>
<p>输入值:       circle
返回值:      double precision</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select diameter(circle &#39;&lt;(0,0),2&gt;&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>4
</code></pre></div>
<h6 id="height"># height()</h6>
<p>目的：计算矩形的垂直大小。</p>
<p>语法：</p>
<p>输入值:       box
返回值:      double precision</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select height(box &#39;(1,2),(0,0)&#39;) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2
</code></pre></div>
<h6 id="isclosed"># isclosed()</h6>
<p>目的：路径是否闭合</p>
<p>语法：</p>
<p>输入值:   path  <br />
返回值:  boolean    </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select isclosed(path &#39;((0,0),(1,1),(2,0))&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="isopen"># isopen()</h6>
<p>目的：路径是否开放</p>
<p>语法：</p>
<p>输入值:    path     <br />
返回值:   boolean   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select isopen(path &#39;[(0,0),(1,1),(2,0)]&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="length_3"># length()</h6>
<p>目的：计算长度，适用于lseg，path。</p>
<p>语法：</p>
<p>输入值:    geometric_type <br />
返回值:    double precision  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select length(path &#39;((-1,0),(1,0))&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>4
</code></pre></div>
<h6 id="npoints"># npoints()</h6>
<p>目的：计算点的数量，适用于path，polygon。</p>
<p>语法：</p>
<p>输入值:   geometric_type  <br />
返回值:  integer    </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select npoints(path &#39;[(0,0),(1,1),(2,0)]&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>3
</code></pre></div>
<h6 id="pclose"># pclose()</h6>
<p>目的：将路径转换为闭合形式。</p>
<p>语法：</p>
<p>输入值:   path  <br />
返回值:   path   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pclose(path &#39;[(0,0),(1,1),(2,0)]&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>((0,0),(1,1),(2,0))
</code></pre></div>
<h6 id="popen"># popen()</h6>
<p>目的：将路径转换成开放形式。</p>
<p>语法：</p>
<p>输入值:   path      <br />
返回值:   path      </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select popen(path &#39;((0,0),(1,1),(2,0))&#39;) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>[(0,0),(1,1),(2,0)]
</code></pre></div>
<h6 id="radius"># radius()</h6>
<p>目的：</p>
<p>语法：</p>
<p>输入值:       circle
返回值:      double precision</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select radius(circle &#39;&lt;(0,0),2&gt;&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2
</code></pre></div>
<h6 id="width"># width()</h6>
<p>目的：计算矩形的水平尺寸</p>
<p>语法：</p>
<p>输入值:     box<br />
返回值:    double precision  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select width(box &#39;(1,2),(0,0)&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>1
</code></pre></div>
<h6 id="_148"><strong>几何类型转换函数</strong></h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_box(circle)">box(circle)</a></td>
<td>计算框中内刻的圆形。</td>
</tr>
<tr>
<td><a href="#_box(point)">box(point)</a></td>
<td>将点转换为空框。</td>
</tr>
<tr>
<td><a href="#_box(point,?point)">box(point, point)</a></td>
<td>将任意两个角点转换为框。</td>
</tr>
<tr>
<td><a href="#_box(polygon)">box(polygon)</a></td>
<td>计算多边形的边界框。</td>
</tr>
<tr>
<td><a href="#_bound_box(box,?box?)">bound_box(box, box)</a></td>
<td>计算两个矩形的边界框。</td>
</tr>
<tr>
<td><a href="#_circle(box)">circle(box)</a></td>
<td>矩形到圆</td>
</tr>
<tr>
<td><a href="#_circle(point,?double precision)">circle(point, double precision)</a></td>
<td>中心和半径到圆</td>
</tr>
<tr>
<td><a href="#_circle(polygon)">circle(polygon)</a></td>
<td>多边形到圆</td>
</tr>
<tr>
<td><a href="#_line(point,?point)">line(point, point)</a></td>
<td>点到线</td>
</tr>
<tr>
<td><a href="#_lseg(box)">lseg(box)</a></td>
<td>矩形对角线到线段</td>
</tr>
<tr>
<td><a href="#_lseg(point,?point)">lseg(point, point)</a></td>
<td>点到线段</td>
</tr>
<tr>
<td><a href="#_path(polygon)">path(polygon)</a></td>
<td>多边形到路径</td>
</tr>
<tr>
<td><a href="#_point(box)">point(box)</a></td>
<td>矩形的中心</td>
</tr>
<tr>
<td><a href="#_point(circle)">point(circle)</a></td>
<td>圆的中心</td>
</tr>
<tr>
<td><a href="#_point(double precision,?double precision)">point(double precision, double precision)</a></td>
<td>构造点</td>
</tr>
<tr>
<td><a href="#_point(lseg)">point(lseg)</a></td>
<td>线段的中心</td>
</tr>
<tr>
<td><a href="#_point(polygon)">point(polygon)</a></td>
<td>多边形的中心</td>
</tr>
<tr>
<td><a href="#_polygon(box)">polygon(box)</a></td>
<td>矩形到4点多边形</td>
</tr>
<tr>
<td><a href="#_polygon(circle)">polygon(circle)</a></td>
<td>圆到12点多边形</td>
</tr>
<tr>
<td><a href="#_polygon(npts,?circle)">polygon(npts, circle)</a></td>
<td>点到npts点多边形</td>
</tr>
<tr>
<td><a href="#_polygon(path)">polygon(path)</a></td>
<td>路径到多边形</td>
</tr>
</tbody>
</table>
<h6 id="boxcircle"># box(circle)</h6>
<p>目的：计算框中内刻的圆形。</p>
<p>语法：</p>
<p>输入值:     circle
返回值:    box</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select box(circle &#39;&lt;(0,0),2&gt;&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (1.41421356237309,1.41421356237309),(-1.41421356237309,-1.41421356237309)
</code></pre></div>
<h6 id="boxpoint"># box(point)</h6>
<p>目的：将点转换为空框。</p>
<p>语法：</p>
<p>输入值:     point
返回值:    box</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select box(point &#39;(1,0)&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (1,0),(1,0)
</code></pre></div>
<h6 id="boxpoint-point"># box(point, point)</h6>
<p>目的：将任意两个角点转换为框。</p>
<p>语法：</p>
<p>输入值:     point, point
返回值:    box</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select box(point &#39;(0,1)&#39;, point &#39;(1,0)&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (1,0),(1,0)
</code></pre></div>
<h6 id="boxpolygon"># box(polygon)</h6>
<p>目的：计算多边形的边界框。</p>
<p>语法：</p>
<p>输入值:     polygon
返回值:    box</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select box(polygon &#39;((0,0),(1,1),(2,0))&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>(2,1),(0,0)
</code></pre></div>
<h6 id="bound_boxbox-box"># bound_box(box, box )</h6>
<p>目的：计算两个矩形的边界框。</p>
<p>语法：</p>
<p>输入值:     box, box
返回值:    box</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select bound_box(box &#39;((0,0),(1,1))&#39;, box &#39;((3,3),(4,4))&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>(4,4),(0,0)
</code></pre></div>
<h6 id="circlebox"># circle(box)</h6>
<p>目的：矩形到圆</p>
<p>语法：</p>
<p>输入值:     box
返回值:    circle</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select circle(box &#39;((0,0),(1,1))&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &lt;(0.5,0.5),0.707106781186548&gt;
</code></pre></div>
<h6 id="circlepoint-double-precision"># circle(point, double precision)</h6>
<p>目的：中心和半径到圆</p>
<p>语法：</p>
<p>输入值:     point, double precision
返回值:    circle</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select circle(point &#39;(0,0)&#39;, 2.0);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &lt;(0,0),2&gt;
</code></pre></div>
<h6 id="circlepolygon"># circle(polygon)</h6>
<p>目的：多边形到圆</p>
<p>语法：</p>
<p>输入值:     polygon
返回值:    circle</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select circle(polygon &#39;((0,0),(1,1),(2,0))&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &lt;(1,0.333333333333333),0.924950591148529&gt;
</code></pre></div>
<h6 id="linepoint-point"># line(point, point)</h6>
<p>目的：点到线</p>
<p>语法：</p>
<p>输入值:     point, point
返回值:    line</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select line(point &#39;(-1,0)&#39;, point &#39;(1,0)&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> {0,-1,0}
</code></pre></div>
<h6 id="lsegbox"># lseg(box)</h6>
<p>目的：矩形对角线到线段</p>
<p>语法：</p>
<p>输入值:     box
返回值:    lseg</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select lseg(box &#39;((-1,0),(1,0))&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> [(1,0),(-1,0)]
</code></pre></div>
<h6 id="lsegpoint-point"># lseg(point, point)</h6>
<p>目的：点到线段</p>
<p>语法：</p>
<p>输入值:    point, point 
返回值:    lseg</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select lseg(point &#39;(-1,0)&#39;, point &#39;(1,0)&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> [(1,0),(-1,0)]
</code></pre></div>
<h6 id="pathpolygon"># path(polygon)</h6>
<p>目的：多边形到路径</p>
<p>语法：</p>
<p>输入值:     polygon
返回值:    path</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select path(polygon &#39;((0,0),(1,1),(2,0))&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> ((0,0),(1,1),(2,0))
</code></pre></div>
<h6 id="pointbox"># point(box)</h6>
<p>目的：矩形的中心</p>
<p>语法：</p>
<p>输入值:     box
返回值:    point</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select point(box &#39;((-1,0),(1,0))&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>(0,0)
</code></pre></div>
<h6 id="pointcircle"># point(circle)</h6>
<p>目的：圆的中心</p>
<p>语法：</p>
<p>输入值:     circle
返回值:    point</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select point(circle &#39;((0,0),2.0)&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>(0,0)
</code></pre></div>
<h6 id="pointdouble-precision-double-precision"># point(double precision, double precision)</h6>
<p>目的：构造点</p>
<p>语法：</p>
<p>输入值:     double precision, double precision
返回值:    point</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select point(23.4, -44.5);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>(23.4,-44.5)
</code></pre></div>
<h6 id="pointlseg"># point(lseg)</h6>
<p>目的：线段的中心</p>
<p>语法：</p>
<p>输入值:     lseg
返回值:    point</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select point(lseg &#39;((-1,0),(1,0))&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (0,0)
</code></pre></div>
<h6 id="pointpolygon"># point(polygon)</h6>
<p>目的：多边形的中心</p>
<p>语法：</p>
<p>输入值:     polygon
返回值:    point</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select point(polygon &#39;((0,0),(1,1),(2,0))&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (1,0.333333333333333)
</code></pre></div>
<h6 id="polygonbox"># polygon(box)</h6>
<p>目的：矩形到4点多边形</p>
<p>语法：</p>
<p>输入值:    box 
返回值:    polygon</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select polygon(box &#39;((0,0),(1,1))&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> ((0,0),(0,1),(1,1),(1,0))
</code></pre></div>
<h6 id="polygoncircle"># polygon(circle)</h6>
<p>目的：圆到12点多边形</p>
<p>语法：</p>
<p>输入值:     circle
返回值:    polygon</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select polygon(circle &#39;((0,0),2.0)&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> ((-2,0),(-1.73205080756888,1),(-1,1.73205080756888),(-1.22464679914735e-16,2),(1,1.73205080756888),(1.73205080756888,1),(2,2.44929359829471e-16),(1.73205080756888,-0.999999999999999),(1,-1.73205080756888),(3.67394039744206e-16,-2),(-0.999999999999999,-1.73205080756888),(-1.73205080756888,-1))
</code></pre></div>
<h6 id="polygonnpts-circle"># polygon(npts, circle)</h6>
<p>目的：点到npts点多边形</p>
<p>语法：</p>
<p>输入值:     integer, circle
返回值:    polygon</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select polygon(12, circle &#39;((0,0),2.0)&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> ((-2,0),(-1.73205080756888,1),(-1,1.73205080756888),(-1.22464679914735e-16,2),(1,1.73205080756888),(1.73205080756888,1)
,(2,2.44929359829471e-16),(1.73205080756888,-0.999999999999999),(1,-1.73205080756888),(3.67394039744206e-16,-2),(-0.9999
99999999999,-1.73205080756888),(-1.73205080756888,-1))
</code></pre></div>
<h6 id="polygonpath"># polygon(path)</h6>
<p>目的：路径到多边形</p>
<p>语法：</p>
<p>输入值:     path
返回值:    polygon</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select polygon(path &#39;((0,0),(1,1),(2,0))&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> ((0,0),(1,1),(2,0))
</code></pre></div>
<h4 id="_149"><strong>网络地址类型</strong></h4>
<p>AiSQL提供用于存储 IPv4、IPv6 和 MAC 地址的数据类型，如下表所示。</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>存储尺寸</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>cidr</td>
<td>7或19字节</td>
<td>IPv4和IPv6网络</td>
</tr>
<tr>
<td>inet</td>
<td>7或19字节</td>
<td>IPv4和IPv6主机以及网络</td>
</tr>
<tr>
<td>macaddr</td>
<td>6字节</td>
<td>MAC地址</td>
</tr>
<tr>
<td>macaddr8</td>
<td>8字节</td>
<td>MAC地址（EUI-64格式）</td>
</tr>
</tbody>
</table>
<h5 id="inet"><strong>inet</strong></h5>
<p>inet在一个数据域里保存一个 IPv4 或 IPv6 主机地址，以及一个可选的它的子网。 子网由主机地址中表示的网络地址位数表示（“网络掩码”）。 如果网络掩码为 32 并且地址是 IPv4 ，那么该值不表示任何子网，只是一台主机。在 IPv6 中地址长度是 128 位，因此 128 位指定一个唯一的主机地址。 请注意如果你想只接受网络地址，你应该使用cidr类型而不是inet。</p>
<p>该类型的输入格式是地址/y，其中地址是一个 IPv4 或者 IPv6 地址，y是网络掩码的位数。 如果/y部分省略， 则网络掩码对 IPv4 取为 32，对 IPv6 取为 128，所以该值表示只有一台主机。在显示时，如果/y部分指定一个单台主机，它将不会被显示出来。</p>
<h5 id="cidr"><strong>cidr</strong></h5>
<p>cidr类型保存一个 IPv4 或 IPv6 网络地址声明。其输入和输出遵循无类的互联网域路由（Classless Internet Domain Routing）习惯。 声明一个网络的格式是地址/y，其中address是最低位地址，表现为 IPv4 或 IPv6 网络地址而y是网络掩码的位数。 如果省略y， 那么掩码部分用旧的有类的网络编号系统进行计算，否则它将至少大到足以包括写在输入中的所有字节。 声明一个在其指定的掩码右边置了位的网络地址会导致错误。
cidr类型输入示例：</p>
<table>
<thead>
<tr>
<th>cidr输入</th>
<th>cidr输出</th>
<th>abbrev(cidr)</th>
</tr>
</thead>
<tbody>
<tr>
<td>192.168.100.128/25</td>
<td>192.168.100.128/25</td>
<td>192.168.100.128/25</td>
</tr>
<tr>
<td>192.168/24</td>
<td>192.168.0.0/24</td>
<td>192.168.0/24</td>
</tr>
<tr>
<td>192.168/25</td>
<td>192.168.0.0/25</td>
<td>192.168.0.0/25</td>
</tr>
<tr>
<td>192.168.1</td>
<td>192.168.1.0/24</td>
<td>192.168.1/24</td>
</tr>
<tr>
<td>192.168</td>
<td>192.168.0.0/24</td>
<td>192.168.0/24</td>
</tr>
<tr>
<td>128.1</td>
<td>128.1.0.0/16</td>
<td>128.1/16</td>
</tr>
<tr>
<td>128</td>
<td>128.0.0.0/16</td>
<td>128.0/16</td>
</tr>
<tr>
<td>128.1.2</td>
<td>128.1.2.0/24</td>
<td>128.1.2/24</td>
</tr>
<tr>
<td>10.1.2</td>
<td>10.1.2.0/24</td>
<td>10.1.2/24</td>
</tr>
<tr>
<td>10.1</td>
<td>10.1.0.0/16</td>
<td>10.1/16</td>
</tr>
<tr>
<td>10</td>
<td>10.0.0.0/8</td>
<td>10/8</td>
</tr>
<tr>
<td>10.1.2.3/32</td>
<td>10.1.2.3/32</td>
<td>10.1.2.3/32</td>
</tr>
<tr>
<td>2001:4f8:3:ba::/64</td>
<td>2001:4f8:3:ba::/64</td>
<td>2001:4f8:3:ba/64</td>
</tr>
<tr>
<td>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</td>
<td>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</td>
<td>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</td>
</tr>
<tr>
<td>::ffff:1.2.3.0/120</td>
<td>::ffff:1.2.3.0/120</td>
<td>::ffff:1.2.3/120</td>
</tr>
<tr>
<td>::ffff:1.2.3.0/128</td>
<td>::ffff:1.2.3.0/128</td>
<td>::ffff:1.2.3.0/128</td>
</tr>
</tbody>
</table>
<h5 id="macaddr"><strong>macaddr</strong></h5>
<p>macaddr类型存储 MAC 地址，也就是以太网卡硬件地址 （尽管 MAC 地址还用于其它用途）。可以接受下列格式的输入：</p>
<p>'08:00:2b:01:02:03'
'08-00-2b-01-02-03'
'08002b:010203'
'08002b-010203'
'0800.2b01.0203'
'0800-2b01-0203'
'08002b010203'
这些示例指定的都是同一个地址。对于位a到f，大小写都可以接受。输出总是使用展示的第一种形式。</p>
<p>IEEE Std 802-2001 指定第二种展示的形式（带有连字符）作为MAC地址的标准形式，并且指定第一种形式（带有分号）作为位翻转的记号，因此 08-00-2b-01-02-03 = 01:00:4D:08:04:0C。这种习惯目前已经被广泛地忽略，并且它只与废弃的网络协议（如令牌环）相关。PostgreSQL 没有对位翻转做任何规定，并且所有可接受的格式都使用标准的LSB顺序。
剩下的五种输入格式不属于任何标准。</p>
<h5 id="macaddr8"><strong>macaddr8</strong></h5>
<p>macaddr8类型以EUI-64格式存储MAC地址，例如以太网卡的硬件地址（尽管MAC地址也被用于其他目的）。这种类型可以接受6字节和8字节长度的MAC地址，并且将它们存储为8字节长度的格式。以6字节格式给出的MAC地址被存储为8字节长度格式的方式是吧第4和第5字节分别设置为FF和FE。 注意IPv6使用一种修改过的EUI-64格式，其中从EUI-48转换过来后的第7位应该被设置为一。函数macaddr8_set7bit被用来做这种修改。 一般而言，任何由16进制数（字节边界上）对构成的输入（可以由':'、'-'或者'.'统一地分隔）都会被接受。16进制数的数量必须是16（8字节）或者12（6字节）。前导和拖尾的空格会被忽略。 下面是可以被接受的输入格式的示例：
'08:00:2b:01:02:03:04:05'
'08-00-2b-01-02-03-04-05'
'08002b:0102030405'
'08002b-0102030405'
'0800.2b01.0203.0405'
'0800-2b01-0203-0405'
'08002b01:02030405'
'08002b0102030405'</p>
<p>这些示例都指定相同的地址。数字a到f的大小写形式都被接受。输出总是以上面显示的第一种形式。
上述的后六种输入格式不属于任何标准。</p>
<p>要把EUI-48格式的传统48位MAC地址转换成修改版EUI-64格式（包括在IPv6地址中作为主机部分），可以使用下面的macaddr8_set7bit：
例如：</p>
<div class="highlight"><pre><span></span><code>select macaddr8_set7bit(&#39;08:00:2b:01:02:03&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>  0a:00:2b:ff:fe:01:02:03
</code></pre></div>
<h5 id="_150"><strong>函数和操作符</strong></h5>
<h6 id="_151"><strong>操作符</strong></h6>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_&lt;">&lt;</a></td>
<td>是否小于</td>
</tr>
<tr>
<td><a href="#_&lt;=">&lt;=</a></td>
<td>是否小于或等于</td>
</tr>
<tr>
<td><a href="#_=_1">=</a></td>
<td>是否等于</td>
</tr>
<tr>
<td><a href="#_&gt;=">&gt;=</a></td>
<td>是否大于或等于</td>
</tr>
<tr>
<td><a href="#_&gt;">&gt;</a></td>
<td>是否大于</td>
</tr>
<tr>
<td><a href="#_&lt;&gt;">&lt;&gt;</a></td>
<td>是否不相等</td>
</tr>
<tr>
<td><a href="#_&lt;&lt;_1">&lt;&lt;</a></td>
<td>子网是否包含在子网中</td>
</tr>
<tr>
<td><a href="#_&lt;&lt;=">&lt;&lt;=</a></td>
<td>子网是否包含或等于子网</td>
</tr>
<tr>
<td><a href="#_&gt;&gt;_1">&gt;&gt;</a></td>
<td>子网是否包含子网</td>
</tr>
<tr>
<td><a href="#_&gt;&gt;=">&gt;&gt;=</a></td>
<td>子网是否包含或等于子网</td>
</tr>
<tr>
<td><a href="#_&amp;&amp;_1">&amp;&amp;</a></td>
<td>是否一个子网包含或等于另一个子网</td>
</tr>
<tr>
<td><a href="#_~">~</a></td>
<td>按位取反</td>
</tr>
<tr>
<td><a href="#_&amp;">&amp;</a></td>
<td>按位取与</td>
</tr>
<tr>
<td>[</td>
<td>](#_</td>
</tr>
<tr>
<td><a href="#_+_2">+</a></td>
<td>向地址添加偏移量</td>
</tr>
<tr>
<td><a href="#_-_2">-</a></td>
<td>从地址中减去偏移量。</td>
</tr>
<tr>
<td><a href="#_-_3">-</a></td>
<td>计算两个地址的差值。</td>
</tr>
</tbody>
</table>
<h6 id="_152"># &lt;</h6>
<p>目的：是否小于</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet &#39;192.168.1.5&#39; &lt; inet &#39;192.168.1.6&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_153"># &lt;=</h6>
<p>目的：是否小于或等于</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet &#39;192.168.1.5&#39; &lt;= inet &#39;192.168.1.5&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_154"># =</h6>
<p>目的：是否等于</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet &#39;192.168.1.5&#39; = inet &#39;192.168.1.5&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_155"># &gt;=</h6>
<p>目的：是否大于或等于</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet &#39;192.168.1.5&#39; &gt;= inet &#39;192.168.1.5&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_156"># &gt;</h6>
<p>目的：是否大于</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet &#39;192.168.1.5&#39; &gt; inet &#39;192.168.1.4&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_157"># &lt;&gt;</h6>
<p>目的：是否不相等</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet &#39;192.168.1.5&#39; &lt;&gt; inet &#39;192.168.1.4&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_158"># &lt;&lt;</h6>
<p>目的：子网是否包含在子网中</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet &#39;192.168.1.5&#39; &lt;&lt; inet &#39;192.168.1/24&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_159"># &lt;&lt;=</h6>
<p>目的：子网是否包含或等于子网</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet &#39;192.168.1/24&#39; &lt;&lt;= inet &#39;192.168.1/24&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_160"># &gt;&gt;</h6>
<p>目的：子网是否包含子网</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet &#39;192.168.1/24&#39; &gt;&gt; inet &#39;192.168.1.5&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_161"># &gt;&gt;=</h6>
<p>目的：子网是否包含或等于子网</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet &#39;192.168.1/24&#39; &gt;&gt;= inet &#39;192.168.1/24&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<div class="highlight"><pre><span></span><code>####### &amp;&amp;
目的：是否一个子网包含或等于另一个子网
</code></pre></div>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet &#39;192.168.1/24&#39; &amp;&amp; inet &#39;192.168.1.80/28&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_162"># ~</h6>
<p>目的：按位取反 </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ~ inet &#39;192.168.1.6&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>63.87.254.249
</code></pre></div>
<h6 id="_163"># &amp;</h6>
<p>目的：按位取与 </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet &#39;192.168.1.6&#39; &amp; inet &#39;0.0.0.255&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>0.0.0.6
</code></pre></div>
<h6 id="_164"># |</h6>
<p>目的：按位取或 </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet &#39;192.168.1.6&#39; | inet &#39;0.0.0.255&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>192.168.1.255
</code></pre></div>
<h6 id="_165"># +</h6>
<p>目的：向地址添加偏移量</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet &#39;192.168.1.6&#39; + 25;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>192.168.1.31
</code></pre></div>
<h6 id="-_13"># -</h6>
<p>目的：从地址中减去偏移量。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet &#39;192.168.1.43&#39; - 36;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>192.168.1.7
</code></pre></div>
<h6 id="-_14"># -</h6>
<p>目的：计算两个地址的差值。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet &#39;192.168.1.43&#39; - inet &#39;192.168.1.19&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>24
</code></pre></div>
<h6 id="_166"><strong>函数</strong></h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_abbrev(inet)">abbrev(inet)</a></td>
<td>缩写显示格式为文本</td>
</tr>
<tr>
<td><a href="#_abbrev(cidr)">abbrev(cidr)</a></td>
<td>缩写显示格式为文本</td>
</tr>
<tr>
<td><a href="#_broadcast(inet)">broadcast(inet)</a></td>
<td>网络广播地址</td>
</tr>
<tr>
<td><a href="#_family(inet)">family(inet)</a></td>
<td>提取地址家族；4用于IPv4，6用于IPv6</td>
</tr>
<tr>
<td><a href="#_host(inet)">host(inet)</a></td>
<td>将IP地址提取为文本</td>
</tr>
<tr>
<td><a href="#_hostmask(inet)">hostmask(inet)</a></td>
<td>构造网络的主机掩码</td>
</tr>
<tr>
<td><a href="#_masklen(inet)">masklen(inet)</a></td>
<td>提取网络掩码长度</td>
</tr>
<tr>
<td><a href="#_netmask(inet)">netmask(inet)</a></td>
<td>为网络构建网络掩码</td>
</tr>
<tr>
<td><a href="#_network(inet)">network(inet)</a></td>
<td>提取地址的网络部分</td>
</tr>
<tr>
<td><a href="#_set_masklen(inet, int)">set_masklen(inet, int)</a></td>
<td>为inet值设置网络掩码长度</td>
</tr>
<tr>
<td><a href="#_set_masklen(cidr, int)">set_masklen(cidr, int)</a></td>
<td>为cidr值设置网络掩码长度</td>
</tr>
<tr>
<td><a href="#_text(inet)">text(inet)</a></td>
<td>将IP地址和网络掩码长度提取为文本</td>
</tr>
<tr>
<td><a href="#_inet_same_family(inet, inet)">inet_same_family(inet, inet)</a></td>
<td>这些地址是否来自同一个家族</td>
</tr>
<tr>
<td><a href="#_inet_merge(inet, inet)">inet_merge(inet, inet)</a></td>
<td>两个给定网络的最小网络</td>
</tr>
<tr>
<td><a href="#_trunc(macaddr)">trunc(macaddr)</a></td>
<td>返回最后3个字节设置为零的MAC地址</td>
</tr>
<tr>
<td><a href="#_trunc(macaddr8)">trunc(macaddr8)</a></td>
<td>返回最后5个字节设置为零的MAC地址</td>
</tr>
<tr>
<td><a href="#_macaddr8_set7bit(macaddr8)">macaddr8_set7bit(macaddr8)</a></td>
<td>将第7位设置为1，也称为修改的EUI-64，以包含在IPv6地址中</td>
</tr>
</tbody>
</table>
<h6 id="abbrevinet"># abbrev(inet)</h6>
<p>目的：缩写显示格式为文本。</p>
<p>语法：</p>
<p>输入值:    inet 
返回值:    text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select abbrev(inet &#39;10.1.0.0/16&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>10.1.0.0/16
</code></pre></div>
<h6 id="abbrevcidr"># abbrev(cidr)</h6>
<p>目的：缩写显示格式为文本。</p>
<p>语法：</p>
<p>输入值:  cidr <br />
返回值:  text  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select abbrev(cidr &#39;10.1.0.0/16&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>10.1/16
</code></pre></div>
<h6 id="broadcastinet"># broadcast(inet)</h6>
<p>目的：网络广播地址。</p>
<p>语法：</p>
<p>输入值:  inet <br />
返回值:  inet  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select broadcast(&#39;192.168.1.5/24&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 192.168.1.255/24
</code></pre></div>
<h6 id="familyinet"># family(inet)</h6>
<p>目的：提取地址家族；4用于IPv4，6用于IPv6。</p>
<p>语法：</p>
<p>输入值:    inet 
返回值:   integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select family(&#39;::1&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>6
</code></pre></div>
<h6 id="hostinet"># host(inet)</h6>
<p>目的：将IP地址提取为文本。</p>
<p>语法：</p>
<p>输入值:    inet 
返回值:    text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select host(&#39;192.168.1.5/24&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>192.168.1.5
</code></pre></div>
<h6 id="hostmaskinet"># hostmask(inet)</h6>
<p>目的：构造网络的主机掩码。</p>
<p>语法：</p>
<p>输入值:   inet<br />
返回值:  inet  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select hostmask(&#39;192.168.23.20/30&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>0.0.0.3
</code></pre></div>
<h6 id="maskleninet"># masklen(inet)</h6>
<p>目的：提取网络掩码长度 。</p>
<p>语法：</p>
<p>输入值:   integer<br />
返回值:   inet </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select masklen(&#39;192.168.1.5/24&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>24
</code></pre></div>
<h6 id="netmaskinet"># netmask(inet)</h6>
<p>目的：为网络构建网络掩码。</p>
<p>语法：</p>
<p>输入值:   inet<br />
返回值:  inet  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select netmask(&#39;192.168.1.5/24&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 255.255.255.0
</code></pre></div>
<h6 id="networkinet"># network(inet)</h6>
<p>目的：提取地址的网络部分。</p>
<p>语法：</p>
<p>输入值:   inet<br />
返回值:   cidr</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select network(&#39;192.168.1.5/24&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 192.168.1.0/24
</code></pre></div>
<h6 id="set_maskleninet-int"># set_masklen(inet, int)</h6>
<p>目的：为inet值设置网络掩码长度。</p>
<p>语法：</p>
<p>输入值:    inet
返回值:   inet, integer </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select set_masklen(&#39;192.168.1.5/24&#39;, 16);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>192.168.1.5/16
</code></pre></div>
<h6 id="set_masklencidr-int"># set_masklen(cidr, int)</h6>
<p>目的：为cidr值设置网络掩码长度。</p>
<p>语法：</p>
<p>输入值:   cidr<br />
返回值:  cidr, integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select set_masklen(&#39;192.168.1.0/24&#39;::cidr, 16);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>192.168.0.0/16
</code></pre></div>
<h6 id="textinet"># text(inet)</h6>
<p>目的：将IP地址和网络掩码长度提取为文本 。</p>
<p>语法：</p>
<p>输入值:    inet 
返回值:    text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select text(inet &#39;192.168.1.5&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 192.168.1.5/32
</code></pre></div>
<h6 id="inet_same_familyinet-inet"># inet_same_family(inet, inet)</h6>
<p>目的：这些地址是否来自同一个家族 </p>
<p>语法：</p>
<p>输入值:  inet, inet <br />
返回值:  boolean  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet_same_family(&#39;192.168.1.5/24&#39;, &#39;::1&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>f
</code></pre></div>
<h6 id="inet_mergeinet-inet"># inet_merge(inet, inet)</h6>
<p>目的：两个给定网络的最小网络。</p>
<p>语法：</p>
<p>输入值:   inet, inet<br />
返回值:  cidr  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet_merge(&#39;192.168.1.5/24&#39;, &#39;192.168.2.5/24&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>192.168.0.0/22
</code></pre></div>
<h6 id="truncmacaddr"># trunc(macaddr)</h6>
<p>目的：返回最后3个字节设置为零的MAC地址。</p>
<p>语法：</p>
<p>输入值:   macaddr<br />
返回值:  macaddr</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select trunc(macaddr &#39;12:34:56:78:90:ab&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 12:34:56:00:00:00
</code></pre></div>
<h6 id="truncmacaddr8"># trunc(macaddr8)</h6>
<p>目的：返回最后5个字节设置为零的MAC地址。</p>
<p>语法：</p>
<p>输入值:   macaddr8
返回值:  macaddr8</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select trunc(macaddr8 &#39;12:34:56:78:90:ab:cd:ef&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 12:34:56:00:00:00:00:00
</code></pre></div>
<h6 id="macaddr8_set7bitmacaddr8"># macaddr8_set7bit(macaddr8)</h6>
<p>目的：将第7位设置为1，也称为修改的EUI-64，以包含在IPv6地址中。</p>
<p>语法：</p>
<p>输入值:   macaddr8
返回值:  macaddr8</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select macaddr8_set7bit(macaddr8 &#39;00:34:56:ab:cd:ef&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>02:34:56:ff:fe:ab:cd:ef
</code></pre></div>
<h4 id="_167"><strong>位串类型</strong></h4>
<p>位串就是一串 1 和 0 的串。它们可以用于存储和可视化位掩码。有两种类型的 SQL 位类型：bit(n)和bit varying(n)，其中 n是一个正整数。</p>
<p>bit类型的数据必须准确匹配长度n; 试图存储短些或者长一些的位串都是错误的。bit varying数据是最长n的变长类型，更长的串会被拒绝。写一个没有长度的bit等效于 bit(1)，没有长度的bit varying意味着没有长度限制。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B&#39;101&#39;, B&#39;00&#39;);
INSERT INTO test VALUES (B&#39;10&#39;, B&#39;101&#39;);
</code></pre></div>
<p>第二条INSERT语句，会报告如下错误：</p>
<div class="highlight"><pre><span></span><code>bit string length 2 does not match type bit(3)
</code></pre></div>
<h5 id="_168"><strong>函数和操作符</strong></h5>
<h6 id="_169"><strong>操作符</strong></h6>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与（输入的长度必须相等）</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>#</td>
<td>按位异或 （输入的长度必须相等）</td>
</tr>
<tr>
<td>~</td>
<td>按位求反</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>按位左移（字符串长度被保留）</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>按位右移（字符串长度被保留）</td>
</tr>
</tbody>
</table>
<h6 id="_170"># ||</h6>
<p>目的：连接</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select B&#39;10001&#39; || B&#39;011&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>10001011
</code></pre></div>
<h6 id="_171"># &amp;</h6>
<p>目的：按位与（输入的长度必须相等）</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select B&#39;10001&#39; &amp; B&#39;01101&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>00001
</code></pre></div>
<h6 id="_172"># |</h6>
<p>目的：按位或 （输入的长度必须相等）</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select B&#39;10001&#39; | B&#39;01101&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>11101
</code></pre></div>
<h6 id="_173">#</h6>
<p>目的：按位异或 （输入的长度必须相等）</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select B&#39;10001&#39; # B&#39;01101&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>11100
</code></pre></div>
<h6 id="_174"># ~</h6>
<p>目的：按位求反</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ~ B&#39;10001&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>01110
</code></pre></div>
<h6 id="_175"># &lt;&lt;</h6>
<p>目的：按位左移（字符串长度被保留）</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select B&#39;10001&#39; &lt;&lt; 3;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>01000
</code></pre></div>
<h6 id="_176"># &gt;&gt;</h6>
<p>目的：按位右移（字符串长度被保留）</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select B&#39;10001&#39; &gt;&gt; 2;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>00100
</code></pre></div>
<h6 id="_177"><strong>函数</strong></h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_bit_length (bit)">bit_length (bit)</a></td>
<td>返回位字符串中的位数。</td>
</tr>
<tr>
<td><a href="#_length ( bit )">length ( bit )</a></td>
<td>返回位字符串中的位数。</td>
</tr>
<tr>
<td><a href="#_octet_length ( bit )">octet_length ( bit )</a></td>
<td>返回位字符串中的字节数。</td>
</tr>
<tr>
<td><a href="#_overlay ( bits bit PLACING newsubstring bit FROM start integer [ FOR count integer ] )">overlay ( bits bit PLACING newsubstring bit FROM start integer [ FOR count integer ] )</a></td>
<td>替换从start位开始的bits的子字符串，并将newsubstring扩展count位。 如果count被省略，默认为newsubstring的长度。</td>
</tr>
<tr>
<td><a href="#_position ( substring bit IN bits bit )">position ( substring bit IN bits bit )</a></td>
<td>按返回指定substring的起始索引，以bits为单位，如果不存在则返回0。</td>
</tr>
<tr>
<td><a href="#_substring ( bits bit [ FROM start integer ] [ FOR count integer ] )">substring ( bits bit [ FROM start integer ] [ FOR count integer ] )</a></td>
<td>如果指定了起始位，则提取从start位开始的bits的子字符串，如果指定了计数位，则在count位之后停止。 start和count至少提供一个。</td>
</tr>
<tr>
<td><a href="#_get_bit ( bits bit, n integer )">get_bit ( bits bit, n integer )</a></td>
<td>从位字符串中提取第n位；第一个(最左)位为第0位。</td>
</tr>
<tr>
<td><a href="#_set_bit ( bits bit, n integer, newvalue integer )">set_bit ( bits bit, n integer, newvalue integer )</a></td>
<td>将位字符串中的第n位设置为newvalue；第一个(最左)位是第0位。</td>
</tr>
</tbody>
</table>
<h6 id="bit_length-bit"># bit_length (bit)</h6>
<p>目的：返回位字符串中的位数。</p>
<p>语法：</p>
<p>输入值:   bit
返回值:  integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select bit_length(B&#39;10111&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 5
</code></pre></div>
<h6 id="length-bit"># length ( bit )</h6>
<p>目的：返回位字符串中的位数。</p>
<p>语法：</p>
<p>输入值:   bit
返回值:  integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select length(B&#39;10111&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 5
</code></pre></div>
<h6 id="octet_length-bit"># octet_length ( bit )</h6>
<p>目的：返回位字符串中的字节数。</p>
<p>语法：</p>
<p>输入值:   bit
返回值:  integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select octet_length(B&#39;1011111011&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 2
</code></pre></div>
<h6 id="overlay-bits-bit-placing-newsubstring-bit-from-start-integer-for-count-integer"># overlay ( bits bit PLACING newsubstring bit FROM start integer [ FOR count integer ] )</h6>
<p>目的：替换从start位开始的bits的子字符串，并将newsubstring扩展count位。 如果count被省略，默认为newsubstring的长度。</p>
<p>语法：</p>
<p>输入值:   bits bit PLACING newsubstring bit FROM start integer [ FOR count integer ]
返回值:  bit</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select overlay(B&#39;01010101010101010&#39; placing B&#39;11111&#39; from 2 for 3);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 0111110101010101010
</code></pre></div>
<h6 id="position-substring-bit-in-bits-bit"># position ( substring bit IN bits bit )</h6>
<p>目的：按返回指定substring的起始索引，以bits为单位，如果不存在则返回0。</p>
<p>语法：</p>
<p>输入值:   substring bit IN bits bit
返回值:  integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select position(B&#39;010&#39; in B&#39;000001101011&#39;) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 8
</code></pre></div>
<h6 id="substring-bits-bit-from-start-integer-for-count-integer"># substring ( bits bit [ FROM start integer ] [ FOR count integer ] )</h6>
<p>目的：如果指定了起始位，则提取从start位开始的bits的子字符串，如果指定了计数位，则在count位之后停止。 start和count至少提供一个。</p>
<p>语法：</p>
<p>输入值:   bits bit [ FROM start integer ] [ FOR count integer ] 
返回值:  bit</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select substring(B&#39;110010111111&#39; from 3 for 2);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 00
</code></pre></div>
<h6 id="get_bit-bits-bit-n-integer"># get_bit ( bits bit, n integer )</h6>
<p>目的：从位字符串中提取第n位；第一个(最左)位为第0位。</p>
<p>语法：</p>
<p>输入值:   bit, integer
返回值:  integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select get_bit(B&#39;101010101010101010&#39;, 6);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 1
</code></pre></div>
<h6 id="set_bit-bits-bit-n-integer-newvalue-integer"># set_bit ( bits bit, n integer, newvalue integer )</h6>
<p>目的：将位字符串中的第n位设置为newvalue；第一个(最左)位是第0位。</p>
<p>语法：</p>
<p>输入值:   bit, integer, integer
返回值:  bit</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select set_bit(B&#39;101010101010101010&#39;, 6, 0);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 101010001010101010
</code></pre></div>
<h4 id="_178"><strong>文本搜索类型</strong></h4>
<p>BSQL提供两种数据类型，它们被设计用来支持全文搜索，全文搜索是一种在自然语言的文档集合中搜索以定位那些最匹配一个查询的文档的活动。tsvector类型表示一个为文本搜索优化的形式下的文档，tsquery类型表示一个文本查询。</p>
<h5 id="tsvector"><strong>tsvector</strong></h5>
<p>一个tsvector值是一个排序的可区分词位的列表，词位是被正规化合并了同一个词的不同变种的词。排序和去重是在输入期间自动完成的，如下例所示：</p>
<div class="highlight"><pre><span></span><code>select &#39;a fat cat sat on a mat and ate a fat rat&#39;::tsvector;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &#39;a&#39; &#39;and&#39; &#39;ate&#39; &#39;cat&#39; &#39;fat&#39; &#39;mat&#39; &#39;on&#39; &#39;rat&#39; &#39;sat&#39;
</code></pre></div>
<p>要表示包含空白或标点的词位，将它们用引号包围：</p>
<div class="highlight"><pre><span></span><code>select $$the lexeme &#39;    &#39; contains spaces$$::tsvector;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &#39;    &#39; &#39;contains&#39; &#39;lexeme&#39; &#39;spaces&#39; &#39;the&#39;
</code></pre></div>
<p>（我们在这个示例中使用美元符号包围的串文字并且下一个用来避免在文字中包含双引号记号产生的混淆）。嵌入的引号和反斜线必须被双写：</p>
<div class="highlight"><pre><span></span><code>select $$the lexeme &#39;Joe&#39;&#39;s&#39; contains a quote$$::tsvector;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &#39;Joe&#39;&#39;s&#39; &#39;a&#39; &#39;contains&#39; &#39;lexeme&#39; &#39;quote&#39; &#39;the&#39;
</code></pre></div>
<p>可选的，整数位置可以被附加给词位：</p>
<div class="highlight"><pre><span></span><code>select &#39;a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12&#39;::tsvector;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &#39;a&#39;:1,6,10 &#39;and&#39;:8 &#39;ate&#39;:9 &#39;cat&#39;:3 &#39;fat&#39;:2,11 &#39;mat&#39;:7 &#39;on&#39;:5 &#39;rat&#39;:12 &#39;sat&#39;:4
</code></pre></div>
<p>一个位置通常表示源词在文档中的定位。位置信息可以被用于邻近排名。位置值可以从 1 到 16383。对于相同的词位出现的重复位置将被丢弃。</p>
<p>具有位置的词位可以进一步地被标注一个权重，它可以是A、 B、C或D。 D是默认值并且因此在输出中不会显示：</p>
<div class="highlight"><pre><span></span><code>select &#39;a:1A fat:2B,4C cat:5D&#39;::tsvector;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &#39;a&#39;:1A &#39;cat&#39;:5 &#39;fat&#39;:2B,4C
</code></pre></div>
<p>权重通常被用来反映文档结构，例如将主题词标记成与正文词不同。文本搜索排名函数可以为不同的权重标记器分配不同的优先级。</p>
<p>了解tsvector类型本身并不执行任何词正规化这一点很重要，它假定给它的词已经被恰当地为应用正规化过。例如，</p>
<div class="highlight"><pre><span></span><code>select &#39;The Fat Rats&#39;::tsvector;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &#39;Fat&#39; &#39;Rats&#39; &#39;The&#39;
</code></pre></div>
<p>对于大部分英语文本搜索应用，上面的词将会被认为是非正规化的，但是tsvector并不在乎这一点。原始文档文本通常应该经过to_tsvector以恰当地为搜索正规化其中的词：</p>
<div class="highlight"><pre><span></span><code>select to_tsvector(&#39;english&#39;, &#39;The Fat Rats&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &#39;fat&#39;:2 &#39;rat&#39;:3
</code></pre></div>
<h5 id="tsquery"><strong>tsquery</strong></h5>
<p>一个tsquery值存储要用于搜索的词位，并且使用布尔操作符&amp;（AND）、|（OR）和!（NOT）来组合它们，还有短语搜索操作符&lt;-&gt;（FOLLOWED BY）。也有一种 FOLLOWED BY 操作符的变体<N>，其中N是一个整数常量，它指定要搜索的两个词位之间的距离。&lt;-&gt;等效于&lt;1&gt;。</p>
<p>圆括号可以被用来强制对操作符分组。如果没有圆括号，!（NOT）的优先级最高，其次是&lt;-&gt;（FOLLOWED BY），然后是&amp;（AND），最后是|（OR）。</p>
<p>这里有一些示例：</p>
<div class="highlight"><pre><span></span><code>select &#39;fat &amp; rat&#39;::tsquery;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &#39;fat&#39; &amp; &#39;rat&#39;
</code></pre></div>
<div class="highlight"><pre><span></span><code>select &#39;fat &amp; (rat | cat)&#39;::tsquery;
</code></pre></div>
<div class="highlight"><pre><span></span><code>返回信息如下：
</code></pre></div>
<div class="highlight"><pre><span></span><code> &#39;fat&#39; &amp; ( &#39;rat&#39; | &#39;cat&#39; )
</code></pre></div>
<div class="highlight"><pre><span></span><code>select &#39;fat &amp; rat &amp; ! cat&#39;::tsquery;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &#39;fat&#39; &amp; &#39;rat&#39; &amp; !&#39;cat&#39;
</code></pre></div>
<p>可选地，一个tsquery中的词位可以被标注一个或多个权重字母，这将限制它们只能和具有那些权重之一的tsvector词位相匹配：</p>
<div class="highlight"><pre><span></span><code>select &#39;fat:ab &amp; cat&#39;::tsquery;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &#39;fat&#39;:AB &amp; &#39;cat&#39;
</code></pre></div>
<p>此外，一个tsquery中的词位可以被标注为*来指定前缀匹配：</p>
<div class="highlight"><pre><span></span><code>select &#39;super:*&#39;::tsquery;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &#39;super&#39;:*
</code></pre></div>
<p>这个查询将匹配一个tsvector中以“super”开头的任意词。</p>
<p>词位的引号规则和之前描述的tsvector中的词位相同；并且，正如tsvector，任何请求的词正规化必须在转换到tsquery类型之前完成。to_tsquery函数可以方便地执行这种正规化：</p>
<div class="highlight"><pre><span></span><code>select to_tsquery(&#39;Fat:ab &amp; Cats&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &#39;fat&#39;:AB &amp; &#39;cat&#39;
</code></pre></div>
<p>注意to_tsquery将会以和其他词同样的方式处理前缀，这也意味着下面的比较会返回真：</p>
<div class="highlight"><pre><span></span><code>select to_tsvector( &#39;postgraduate&#39; ) @@ to_tsquery( &#39;postgres:*&#39; );
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> t
</code></pre></div>
<p>因为postgres会被处理成postgr：</p>
<div class="highlight"><pre><span></span><code>select to_tsvector( &#39;postgraduate&#39; ), to_tsquery( &#39;postgres:*&#39; );
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &#39;postgradu&#39;:1 | &#39;postgr&#39;:*
</code></pre></div>
<p>这会匹配postgraduate被处理后的形式。</p>
<h5 id="_179"><strong>函数和操作符</strong></h5>
<h6 id="_180"><strong>操作符</strong></h6>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_@@_1">@@</a></td>
<td>tsvector是否匹配tsquery</td>
</tr>
<tr>
<td><a href="#_@@@">@@@</a></td>
<td>这是@@已弃用的同义词。</td>
</tr>
<tr>
<td>[</td>
<td></td>
</tr>
<tr>
<td><a href="#_&amp;&amp;_2">&amp;&amp;</a></td>
<td>AND两个tsquery一起。</td>
</tr>
<tr>
<td>[</td>
<td></td>
</tr>
<tr>
<td><a href="#_!!">!!</a></td>
<td>否定tsquery</td>
</tr>
<tr>
<td><a href="#_&lt;-&gt;_1">&lt;-&gt;</a></td>
<td>构造一个短语查询，如果两个输入查询在连续的词素上匹配，该查询将进行匹配。</td>
</tr>
<tr>
<td><a href="#_@&gt;_1">@&gt;</a></td>
<td>第一个tsquery是否包含了第二个</td>
</tr>
<tr>
<td><a href="#_&lt;@_1">&lt;@</a></td>
<td>第一个tsquery是否包含在第二个中</td>
</tr>
</tbody>
</table>
<h6 id="_181"># @@</h6>
<p>目的：tsvector是否匹配tsquery</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select to_tsvector(&#39;fat cats ate rats&#39;) @@ to_tsquery(&#39;cat &amp; rat&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_182"># @@@</h6>
<p>目的：这是@@已弃用的同义词。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select to_tsvector(&#39;fat cats ate rats&#39;) @@@ to_tsquery(&#39;cat &amp; rat&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_183"># ||</h6>
<p>目的：连接两个tsvector。如果两个输入都包含词素位置，则相应地调整第二个输入的位置。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;a:1 b:2&#39;::tsvector || &#39;c:1 d:2 b:3&#39;::tsvector;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> &#39;a&#39;:1 &#39;b&#39;:2,5 &#39;c&#39;:3 &#39;d&#39;:4
</code></pre></div>
<h6 id="_184"># &amp;&amp;</h6>
<p>目的：AND 两个tsquery一起，生成一个匹配两个输入查询的匹配文档的查询。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;fat | rat&#39;::tsquery &amp;&amp; &#39;cat&#39;::tsquery;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>( &#39;fat&#39; | &#39;rat&#39; ) &amp; &#39;cat&#39;
</code></pre></div>
<h6 id="_185"># ||</h6>
<p>目的：OR 两个tsquery一起，生成一个匹配两个输入查询的匹配文档的查询。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;fat | rat&#39;::tsquery || &#39;cat&#39;::tsquery;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;fat&#39; | &#39;rat&#39; | &#39;cat&#39;
</code></pre></div>
<h6 id="_186"># !!</h6>
<p>目的：否定tsquery，生成一个与输入查询不匹配的匹配文档的查询。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select !! &#39;cat&#39;::tsquery;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>!&#39;cat&#39;
</code></pre></div>
<h6 id="-_15"># &lt;-&gt;</h6>
<p>目的：构造一个短语查询，如果两个输入查询在连续的词素上匹配，该查询将进行匹配。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select to_tsquery(&#39;fat&#39;) &lt;-&gt; to_tsquery(&#39;rat&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;fat&#39; &lt;-&gt; &#39;rat&#39;
</code></pre></div>
<h6 id="_187"># @&gt;</h6>
<p>目的：第一个tsquery是否包含了第二个</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;cat&#39;::tsquery @&gt; &#39;cat &amp; rat&#39;::tsquery;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>f
</code></pre></div>
<h6 id="_188"># &lt;@</h6>
<p>目的：第一个tsquery是否包含在第二个中</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;cat&#39;::tsquery &lt;@ &#39;cat &amp; rat&#39;::tsquery;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_189"><strong>函数</strong></h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_array_to_tsvector()">array_to_tsvector()</a></td>
<td>将词素数组转换为tsvector。</td>
</tr>
<tr>
<td><a href="#_get_current_ts_config ()">get_current_ts_config ()</a></td>
<td>返回当前默认文本搜索配置</td>
</tr>
<tr>
<td><a href="#_length ()_1">length()</a></td>
<td>返回tsvector中的词位数。</td>
</tr>
<tr>
<td><a href="#_numnode ()">numnode()</a></td>
<td>返回tsquery中词位和操作符的数目。</td>
</tr>
<tr>
<td><a href="#_plainto_tsquery ()">plainto_tsquery()</a></td>
<td>将文本转换为tsquery，根据指定的或默认配置对单词进行标准化。</td>
</tr>
<tr>
<td><a href="#_phraseto_tsquery()">phraseto_tsquery()</a></td>
<td>将文本转换为tsquery，根据指定的或默认配置对单词进行标准化。</td>
</tr>
<tr>
<td><a href="#_websearch_to_tsquery()">websearch_to_tsquery()</a></td>
<td>将文本转换为tsquery，根据指定的或默认配置对单词进行标准化。</td>
</tr>
<tr>
<td><a href="#_querytree()">querytree()</a></td>
<td>生成tsquery的可转位部分的表示。</td>
</tr>
<tr>
<td><a href="#_setweight()">setweight()</a></td>
<td>将指定的weight赋给vector的每个元素。</td>
</tr>
<tr>
<td><a href="#_setweight()_1">setweight()</a></td>
<td>将指定的weight赋给列在lexemes中的vector元素。</td>
</tr>
<tr>
<td><a href="#_strip()">strip()</a></td>
<td>从tsvector中移除位置和权重。</td>
</tr>
<tr>
<td><a href="#_to_tsquery()">to_tsquery()</a></td>
<td>将文本转换为tsquery，根据指定的或默认配置对单词进行标准化</td>
</tr>
<tr>
<td><a href="#_to_tsvector()">to_tsvector()</a></td>
<td>将文本转换为tsvector，根据指定的或默认配置对单词进行标准化。结果中包含位置信息。</td>
</tr>
<tr>
<td><a href="#_to_tsvector()_1">to_tsvector()</a></td>
<td>将JSON文档中的每个字符串值转换为tsvector，根据指定的或默认配置对单词进行标准化。</td>
</tr>
<tr>
<td><a href="#_json_to_tsvector()">json_to_tsvector()</a></td>
<td>选择filter请求的JSON文档中的每个项，并将每个项转换为tsvector，根据指定的或默认配置对单词进行标准化。</td>
</tr>
<tr>
<td><a href="#_ts_delete()">ts_delete()</a></td>
<td>从vector中删除任何出现的给定lexeme。</td>
</tr>
<tr>
<td><a href="#_ts_delete()_1">ts_delete()</a></td>
<td>从vector中删除lexemes中出现的任何词位。</td>
</tr>
<tr>
<td><a href="#_ts_filter()">ts_filter()</a></td>
<td>只从vector中选择具有给定weights的元素。</td>
</tr>
<tr>
<td><a href="#_ts_headline()">ts_headline()</a></td>
<td>以缩写形式显示document中query的匹配项，该匹配项必须是原始文本，而不是tsvector</td>
</tr>
<tr>
<td><a href="#_ts_headline()_1">ts_headline()</a></td>
<td>以缩写形式显示匹配JSONdocument中字符串值中的query。</td>
</tr>
<tr>
<td><a href="#_ts_rank()">ts_rank()</a></td>
<td>计算一个分数，显示vector与query的匹配程度。</td>
</tr>
<tr>
<td><a href="#_ts_rank_cd()">ts_rank_cd()</a></td>
<td>使用覆盖密度算法计算一个分数，显示vector与query的匹配程度。</td>
</tr>
<tr>
<td><a href="#_ts_rewrite()">ts_rewrite()</a></td>
<td>在query中使用 substitute替换出现的target。</td>
</tr>
<tr>
<td><a href="#_tsquery_phrase()">tsquery_phrase()</a></td>
<td>构造一个短语查询，在连续的词位上搜索query1和query2的匹配项(与&lt;-&gt;操作符相同)。</td>
</tr>
<tr>
<td><a href="#_tsquery_phrase()_1">tsquery_phrase()</a></td>
<td>构造一个短语查询，用于搜索query1和query2的匹配项，这些匹配项恰好出现在distance词位之间。</td>
</tr>
<tr>
<td><a href="#_tsvector_to_array()">tsvector_to_array()</a></td>
<td>将tsvector转换为词位的数组。</td>
</tr>
<tr>
<td><a href="#_unnest()_1">unnest()</a></td>
<td>将tsvector展开为一组行，每个行对应一个词位。</td>
</tr>
<tr>
<td><a href="#_ts_debug()">ts_debug()</a></td>
<td>根据指定的或默认的文本搜索配置从document中提取和标准化标记，并返回关于每个标记是如何处理的信息。</td>
</tr>
<tr>
<td><a href="#_ts_lexize()">ts_lexize()</a></td>
<td>如果字典知道输入标记，则返回替换词位数组;如果字典知道标记，但它是停止词，则返回空数组;如果它不是已知词，则返回NULL。</td>
</tr>
<tr>
<td><a href="#_ts_parse()">ts_parse()</a></td>
<td>使用命名的解析器从document中提取标记。</td>
</tr>
<tr>
<td><a href="#_ts_parse()_1">ts_parse()</a></td>
<td>使用OID指定的解析器从document中提取标记。</td>
</tr>
<tr>
<td><a href="#_ts_token_type()">ts_token_type()</a></td>
<td>返回一个表，该表描述命名解析器可以识别的每种类型的标记。</td>
</tr>
<tr>
<td><a href="#_ts_token_type()_1">ts_token_type()</a></td>
<td>返回一个表，该表描述OID指定的解析器可以识别的每种标记类型。</td>
</tr>
<tr>
<td><a href="#_ts_stat()">ts_stat()</a></td>
<td>执行sqlquery，该查询必须返回单个tsvector列，并返回关于数据中包含的每个不同词位的统计信息。</td>
</tr>
</tbody>
</table>
<h6 id="array_to_tsvector"># array_to_tsvector()</h6>
<p>目的：将词素数组转换为tsvector。给定的字符串按原样使用，不做进一步处理。</p>
<p>语法：</p>
<p>输入值:   text[]
返回值:   tsvector</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select array_to_tsvector(&#39;{fat,cat,rat}&#39;::text[]);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;cat&#39; &#39;fat&#39; &#39;rat&#39;
</code></pre></div>
<h6 id="get_current_ts_config"># get_current_ts_config ()</h6>
<p>目的：返回当前默认文本搜索配置</p>
<p>语法：</p>
<p>返回值:  regconfig</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select get_current_ts_config();
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>english
</code></pre></div>
<h6 id="length_4"># length ()</h6>
<p>目的：返回tsvector中的词位数。</p>
<p>语法：</p>
<p>输入值:   tsvector
返回值:   integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select length(&#39;fat:2,4 cat:3 rat:5A&#39;::tsvector);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>3
</code></pre></div>
<h6 id="numnode"># numnode ()</h6>
<p>目的：返回tsquery中词位和操作符的数目。</p>
<p>语法：</p>
<p>输入值:   tsquery
返回值:   integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select numnode(&#39;(fat &amp; rat) | cat&#39;::tsquery);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>5
</code></pre></div>
<h6 id="plainto_tsquery"># plainto_tsquery ()</h6>
<p>目的：将文本转换为tsquery，根据指定的或默认配置对单词进行标准化。</p>
<p>语法：</p>
<p>输入值:   [regconfig,] text
返回值:   tsquery</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select plainto_tsquery(&#39;english&#39;, &#39;The Fat Rats&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;fat&#39; &amp; &#39;rat&#39;
</code></pre></div>
<h6 id="phraseto_tsquery"># phraseto_tsquery()</h6>
<p>目的：</p>
<p>语法：</p>
<p>输入值:   [regconfig,] text
返回值:   tsquery</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select phraseto_tsquery(&#39;english&#39;, &#39;The Fat Rats&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;fat&#39; &lt;-&gt; &#39;rat&#39;
</code></pre></div>
<h6 id="websearch_to_tsquery"># websearch_to_tsquery()</h6>
<p>目的：将文本转换为tsquery，根据指定的或默认配置对单词进行标准化。</p>
<p>语法：</p>
<p>输入值:   [regconfig,] text
返回值:   tsquery</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select websearch_to_tsquery(&#39;english&#39;, &#39;&quot;fat rat&quot; or cat dog&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;fat&#39; &lt;-&gt; &#39;rat&#39; | &#39;cat&#39; &amp; &#39;dog&#39;
</code></pre></div>
<h6 id="querytree"># querytree()</h6>
<p>目的：生成tsquery的可转位部分的表示。</p>
<p>语法：</p>
<p>输入值:   tsquery
返回值:   text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select querytree(&#39;foo &amp; ! bar&#39;::tsquery);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;foo&#39;
</code></pre></div>
<h6 id="setweight"># setweight()</h6>
<p>目的：将指定的weight赋给vector的每个元素。</p>
<p>语法：</p>
<p>输入值:   tsvector, "char"
返回值:   tsvector</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select setweight(&#39;fat:2,4 cat:3 rat:5B&#39;::tsvector, &#39;A&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;cat&#39;:3A &#39;fat&#39;:2A,4A &#39;rat&#39;:5A
</code></pre></div>
<h6 id="setweight_1"># setweight()</h6>
<p>目的：将指定的weight赋给列在lexemes中的vector元素。</p>
<p>语法：</p>
<p>输入值:   tsvector, "char", text[]
返回值:   tsvector</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select setweight(&#39;fat:2,4 cat:3 rat:5,6B&#39;::tsvector, &#39;A&#39;, &#39;{cat,rat}&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;cat&#39;:3A &#39;fat&#39;:2,4 &#39;rat&#39;:5A,6A
</code></pre></div>
<h6 id="strip"># strip()</h6>
<p>目的：从tsvector中移除位置和权重。</p>
<p>语法：</p>
<p>输入值:   tsvector
返回值:   tsvector</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select strip(&#39;fat:2,4 cat:3 rat:5A&#39;::tsvector);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;cat&#39; &#39;fat&#39; &#39;rat&#39;
</code></pre></div>
<h6 id="to_tsquery"># to_tsquery()</h6>
<p>目的：将文本转换为tsquery，根据指定的或默认配置对单词进行标准化。单词必须由有效的tsquery操作符组合。</p>
<p>语法：</p>
<p>输入值:   [regconfig,] text
返回值:   tsquery</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select to_tsquery(&#39;english&#39;, &#39;The &amp; Fat &amp; Rats&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;fat&#39; &amp; &#39;rat&#39;
</code></pre></div>
<h6 id="to_tsvector"># to_tsvector()</h6>
<p>目的：将文本转换为tsvector，根据指定的或默认配置对单词进行标准化。结果中包含位置信息。</p>
<p>语法：</p>
<p>输入值:   [regconfig,] text 
返回值:   tsvector</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select to_tsvector(&#39;english&#39;, &#39;The Fat Rats&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;fat&#39;:2 &#39;rat&#39;:3
</code></pre></div>
<h6 id="to_tsvector_1"># to_tsvector()</h6>
<p>目的：将JSON文档中的每个字符串值转换为tsvector，根据指定的或默认配置对单词进行标准化。 然后将结果按文档顺序连接起来以产生输出。位置信息就像在每对字符串值之间存在一个停止词一样生成。</p>
<p>语法：</p>
<p>输入值:  [regconfig,] json<br />
返回值:  tsvector </p>
<p>或者</p>
<p>输入值:  [regconfig,] jsonb
返回值:  tsvector </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select to_tsvector(&#39;english&#39;, &#39;{&quot;aa&quot;: &quot;The Fat Rats&quot;, &quot;b&quot;: &quot;dog&quot;}&#39;::json);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;dog&#39;:5 &#39;fat&#39;:2 &#39;rat&#39;:3
</code></pre></div>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select to_tsvector(&#39;english&#39;, &#39;{&quot;aa&quot;: &quot;The Fat Rats&quot;, &quot;b&quot;: &quot;dog&quot;}&#39;::jsonb);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;dog&#39;:1 &#39;fat&#39;:4 &#39;rat&#39;:5
</code></pre></div>
<h6 id="json_to_tsvector"># json_to_tsvector()</h6>
<p>目的：选择filter请求的JSON文档中的每个项，并将每个项转换为tsvector，根据指定的或默认配置对单词进行标准化。 然后将结果按文档顺序连接起来以产生输出。位置信息就像在每对选定的项目之间存在一个停止词一样生成。 (注意，当输入为jsonb时，JSON对象字段的“document order”取决于实现。) filter必须是一个jsonb数组，其中包含0个或多个关键字: "string"(包括所有字符串值)， "numeric"(包括所有数值)， "boolean"(包括所有布尔值)， "key"(包括所有键)，或 "all"(包括以上所有关键字)。 作为一种特殊情况，该filter也可以是这些关键字之一的简单JSON值。</p>
<p>语法：</p>
<p>输入值:   [regconfig,] json, jsonb<br />
返回值:   tsvector</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select json_to_tsvector(&#39;english&#39;, &#39;{&quot;a&quot;: &quot;The Fat Rats&quot;, &quot;b&quot;: 123}&#39;::json, &#39;[&quot;string&quot;, &quot;numeric&quot;]&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;123&#39;:5 &#39;fat&#39;:2 &#39;rat&#39;:3
</code></pre></div>
<h6 id="ts_delete"># ts_delete()</h6>
<p>目的：从vector中删除任何出现的给定lexeme。</p>
<p>语法：</p>
<p>输入值:   tsvector, text
返回值:   tsvector</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ts_delete(&#39;fat:2,4 cat:3 rat:5A&#39;::tsvector, &#39;fat&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;cat&#39;:3 &#39;rat&#39;:5A
</code></pre></div>
<h6 id="ts_delete_1"># ts_delete()</h6>
<p>目的：从vector中删除lexemes中出现的任何词位。</p>
<p>语法：</p>
<p>输入值:   tsvector, text[]
返回值:   tsvector</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ts_delete(&#39;fat:2,4 cat:3 rat:5A&#39;::tsvector, ARRAY[&#39;fat&#39;,&#39;rat&#39;]);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;cat&#39;:3
</code></pre></div>
<h6 id="ts_filter"># ts_filter()</h6>
<p>目的：只从vector中选择具有给定weights的元素。</p>
<p>语法：</p>
<p>输入值:   tsvector, "char"[] 
返回值:   tsvector</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ts_filter(&#39;fat:2,4 cat:3b,7c rat:5A&#39;::tsvector, &#39;{a,b}&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;cat&#39;:3B &#39;rat&#39;:5A
</code></pre></div>
<h6 id="ts_headline"># ts_headline()</h6>
<p>目的：以缩写形式显示document中query的匹配项，该匹配项必须是原始文本，而不是tsvector。 在匹配查询之前，文档中的单词将根据指定的或默认的配置进行规范化。</p>
<p>语法：</p>
<p>输入值:   [regconfig,] text, tsquery[, text]
返回值:   text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ts_headline(&#39;The fat cat ate the rat.&#39;, &#39;cat&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>The fat &lt;b&gt;cat&lt;/b&gt; ate the rat.
</code></pre></div>
<h6 id="ts_headline_1"># ts_headline()</h6>
<p>目的：以缩写形式显示匹配JSONdocument中字符串值中的query。</p>
<p>语法：</p>
<p>输入值:   [regconfig,] json, tsquery[, text]
返回值:   json</p>
<p>或者：</p>
<p>输入值:   [regconfig,] jsonb, tsquery[, text]
返回值:   jsonb</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ts_headline(&#39;{&quot;cat&quot;:&quot;raining cats and dogs&quot;}&#39;::jsonb, &#39;cat&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>{&quot;cat&quot;: &quot;raining &lt;b&gt;cats&lt;/b&gt; and dogs&quot;}
</code></pre></div>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ts_headline(&#39;{&quot;a&quot;:&quot;x y z&quot;}&#39;::json, &#39;z&#39;::tsquery);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>{&quot;a&quot;:&quot;x y &lt;b&gt;z&lt;/b&gt;&quot;}
</code></pre></div>
<h6 id="ts_rank"># ts_rank()</h6>
<p>目的：计算一个分数，显示vector与query的匹配程度。</p>
<p>语法：</p>
<p>输入值:  [ real[], ] tsvector, tsquery [ , integer ]
返回值:  real </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ts_rank(to_tsvector(&#39;raining cats and dogs&#39;), &#39;cat&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>0.0607927
</code></pre></div>
<h6 id="ts_rank_cd"># ts_rank_cd()</h6>
<p>目的：使用覆盖密度算法计算一个分数，显示vector与query的匹配程度。</p>
<p>语法：</p>
<p>输入值:   [ real[], ] tsvector, tsquery [, integer]
返回值:   real</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ts_rank_cd(to_tsvector(&#39;raining cats and dogs&#39;), &#39;cat&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>0.1
</code></pre></div>
<h6 id="ts_rewrite"># ts_rewrite()</h6>
<p>目的：在query中使用 substitute替换出现的target。</p>
<p>语法：</p>
<p>输入值:   tsquery, tsquery, tsquery
返回值:   tsquery</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ts_rewrite(&#39;a &amp; b&#39;::tsquery, &#39;a&#39;::tsquery, &#39;foo|bar&#39;::tsquery);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;b&#39; &amp; ( &#39;foo&#39; | &#39;bar&#39; )
</code></pre></div>
<h6 id="ts_rewrite_1"># ts_rewrite()</h6>
<p>目的：根据目标替换部分query，并替换通过执行SELECT命令获得的查询。</p>
<p>语法：</p>
<p>输入值:   tsquery, text
返回值:   tsquery</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ts_rewrite(&#39;a &amp; b&#39;::tsquery, &#39;select t,s FROM aliases&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;b&#39; &amp; ( &#39;foo&#39; | &#39;bar&#39; )
</code></pre></div>
<h6 id="tsquery_phrase"># tsquery_phrase()</h6>
<p>目的：构造一个短语查询，在连续的词位上搜索query1和query2的匹配项(与&lt;-&gt;操作符相同)。</p>
<p>语法：</p>
<p>输入值:   tsquery, tsquery
返回值:   tsquery</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select tsquery_phrase(to_tsquery(&#39;fat&#39;), to_tsquery(&#39;cat&#39;));
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;fat&#39; &lt;-&gt; &#39;cat&#39;
</code></pre></div>
<h6 id="tsquery_phrase_1"># tsquery_phrase()</h6>
<p>目的：构造一个短语查询，用于搜索query1和query2的匹配项，这些匹配项恰好出现在distance词位之间。</p>
<p>语法：</p>
<p>输入值:   tsquery, tsquery, integer
返回值:   tsquery</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select tsquery_phrase(to_tsquery(&#39;fat&#39;), to_tsquery(&#39;cat&#39;), 10);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>&#39;fat&#39; &lt;10&gt; &#39;cat&#39;
</code></pre></div>
<h6 id="tsvector_to_array"># tsvector_to_array()</h6>
<p>目的：将tsvector转换为词位的数组。</p>
<p>语法：</p>
<p>输入值:   tsvector
返回值:   text[]</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select tsvector_to_array(&#39;fat:2,4 cat:3 rat:5A&#39;::tsvector);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>{cat,fat,rat}
</code></pre></div>
<h6 id="unnest_4"># unnest()</h6>
<p>目的：将tsvector展开为一组行，每个行对应一个词位。</p>
<p>语法：</p>
<p>输入值:   tsvector tsvector, OUT lexeme text, OUT positions smallint[], OUT weights text[] | func
返回值:   SETOF record</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select * from unnest(&#39;cat:3 fat:2,4 rat:5A&#39;::tsvector);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> lexeme | positions | weights 
----------+------------+---------
 cat    | {3}      | {D}
 fat    | {2,4}     | {D,D}
 rat    | {5}       | {A}
</code></pre></div>
<h6 id="ts_debug"># ts_debug()</h6>
<p>目的：根据指定的或默认的文本搜索配置从document中提取和标准化标记，并返回关于每个标记是如何处理的信息。
文本搜索调试函数，通常不被用于日常的文本搜索操作，主要有助于开发和调试新的文本搜索配置。</p>
<p>语法：</p>
<p>输入值:   config regconfig, document text, OUT alias text, OUT description text, OUT token text, OUT dictionaries regdictionary[], OUT dictionary regdictionary, OUT lexemes text[] 
返回值:   SETOF record </p>
<p>或者：</p>
<p>输入值:   document text, OUT alias text, OUT description text, OUT token text, OUT dictionaries regdictionary[], OUT dictionary regdictionary, OUT lexemes text[] <br />
返回值:   SETOF record </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ts_debug(&#39;english&#39;, &#39;The Brightest supernovaes&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (asciiword,&quot;Word, all ASCII&quot;,The,{english_stem},english_stem,{})
 (blank,&quot;Space symbols&quot;,&quot; &quot;,{},,)
 (asciiword,&quot;Word, all ASCII&quot;,Brightest,{english_stem},english_stem,{brightest})
 (blank,&quot;Space symbols&quot;,&quot; &quot;,{},,)
 (asciiword,&quot;Word, all ASCII&quot;,supernovaes,{english_stem},english_stem,{supernova})
</code></pre></div>
<h6 id="ts_lexize"># ts_lexize()</h6>
<p>目的：如果字典知道输入标记，则返回替换词位数组;如果字典知道标记，但它是停止词，则返回空数组;如果它不是已知词，则返回NULL。
文本搜索调试函数，通常不被用于日常的文本搜索操作，主要有助于开发和调试新的文本搜索配置。</p>
<p>语法：</p>
<p>输入值:   regdictionary, text
返回值:   text[] </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ts_lexize(&#39;english_stem&#39;, &#39;stars&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>{star}
</code></pre></div>
<h6 id="ts_parse"># ts_parse()</h6>
<p>目的：使用命名的解析器从document中提取标记。
文本搜索调试函数，通常不被用于日常的文本搜索操作，主要有助于开发和调试新的文本搜索配置。</p>
<p>语法：</p>
<p>输入值:  parser_name text, txt text, OUT tokid integer, OUT token text<br />
返回值:  SETOF record    </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ts_parse(&#39;default&#39;, &#39;foo - bar&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (1,foo)
 (12,&quot; &quot;)
 (12,&quot;- &quot;)
 (1,bar)
</code></pre></div>
<h6 id="ts_parse_1"># ts_parse()</h6>
<p>目的：使用OID指定的解析器从document中提取标记。
文本搜索调试函数，通常不被用于日常的文本搜索操作，主要有助于开发和调试新的文本搜索配置。</p>
<p>语法：</p>
<p>输入值:  parser_oid oid, txt text, OUT tokid integer, OUT token text
返回值:  SETOF record </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ts_parse(3722, &#39;foo - bar&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (1,foo)
 (12,&quot; &quot;)
 (12,&quot;- &quot;)
 (1,bar)
</code></pre></div>
<h6 id="ts_token_type"># ts_token_type()</h6>
<p>目的：返回一个表，该表描述命名解析器可以识别的每种类型的标记。
文本搜索调试函数，通常不被用于日常的文本搜索操作，主要有助于开发和调试新的文本搜索配置。</p>
<p>语法：</p>
<p>输入值:   parser_name text, OUT tokid integer, OUT alias text, OUT description text | func 
返回值:   SETOF record  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ts_token_type(&#39;default&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (1,asciiword,&quot;Word, all ASCII&quot;)
 (2,word,&quot;Word, all letters&quot;)
 (3,numword,&quot;Word, letters and digits&quot;)
 (4,email,&quot;Email address&quot;)
 (5,url,URL)
 (6,host,Host)
 (7,sfloat,&quot;Scientific notation&quot;)
 (8,version,&quot;Version number&quot;)
 (9,hword_numpart,&quot;Hyphenated word part, letters and digits&quot;)
 (10,hword_part,&quot;Hyphenated word part, all letters&quot;)
 (11,hword_asciipart,&quot;Hyphenated word part, all ASCII&quot;)
 (12,blank,&quot;Space symbols&quot;)
 (13,tag,&quot;XML tag&quot;)
 (14,protocol,&quot;Protocol head&quot;)
 (15,numhword,&quot;Hyphenated word, letters and digits&quot;)
 (16,asciihword,&quot;Hyphenated word, all ASCII&quot;)
 (17,hword,&quot;Hyphenated word, all letters&quot;)
 (18,url_path,&quot;URL path&quot;)
 (19,file,&quot;File or path name&quot;)
 (20,float,&quot;Decimal notation&quot;)
 (21,int,&quot;Signed integer&quot;)
 (22,uint,&quot;Unsigned integer&quot;)
 (23,entity,&quot;XML entity&quot;)
</code></pre></div>
<h6 id="ts_token_type_1"># ts_token_type()</h6>
<p>目的：返回一个表，该表描述OID指定的解析器可以识别的每种标记类型。
文本搜索调试函数，通常不被用于日常的文本搜索操作，主要有助于开发和调试新的文本搜索配置。</p>
<p>语法：</p>
<p>输入值:    parser_oid oid, OUT tokid integer, OUT alias text, OUT description text   | func
返回值:    SETOF record</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ts_token_type(3722);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (1,asciiword,&quot;Word, all ASCII&quot;)
 (2,word,&quot;Word, all letters&quot;)
 (3,numword,&quot;Word, letters and digits&quot;)
 (4,email,&quot;Email address&quot;)
 (5,url,URL)
 (6,host,Host)
 (7,sfloat,&quot;Scientific notation&quot;)
 (8,version,&quot;Version number&quot;)
 (9,hword_numpart,&quot;Hyphenated word part, letters and digits&quot;)
 (10,hword_part,&quot;Hyphenated word part, all letters&quot;)
 (11,hword_asciipart,&quot;Hyphenated word part, all ASCII&quot;)
 (12,blank,&quot;Space symbols&quot;)
 (13,tag,&quot;XML tag&quot;)
 (14,protocol,&quot;Protocol head&quot;)
 (15,numhword,&quot;Hyphenated word, letters and digits&quot;)
 (16,asciihword,&quot;Hyphenated word, all ASCII&quot;)
 (17,hword,&quot;Hyphenated word, all letters&quot;)
 (18,url_path,&quot;URL path&quot;)
 (19,file,&quot;File or path name&quot;)
 (20,float,&quot;Decimal notation&quot;)
 (21,int,&quot;Signed integer&quot;)
 (22,uint,&quot;Unsigned integer&quot;)
 (23,entity,&quot;XML entity&quot;)
</code></pre></div>
<h6 id="ts_stat"># ts_stat()</h6>
<p>目的：执行sqlquery，该查询必须返回单个tsvector列，并返回关于数据中包含的每个不同词位的统计信息。被用于检查你的配置以及寻找候选的停用词。
文本搜索调试函数，通常不被用于日常的文本搜索操作，主要有助于开发和调试新的文本搜索配置。</p>
<p>语法：</p>
<p>输入值:   query text, OUT word text, OUT ndoc integer, OUT nentry integer | func
返回值:   SETOF record</p>
<p>或者：
输入值:   query text, weights text, OUT word text, OUT ndoc integer, OUT nentry integer | func
返回值:   SETOF record</p>
<p>query是一个文本值，它包含一个必须返回单一tsvector列的 SQL 查询。ts_stat执行该查询并返回有关包含在该tsvector数据中的每一个可区分词位（词）的统计数据。返回的列是：</p>
<p>word text — 一个词位的值
ndoc integer — 词出现过的文档（tsvector）的数量
nentry integer — 词出现的总次数</p>
<p>如果提供了权重，只有具有其中之一权重的出现才被计算在内。</p>
<p>例如，要在一个文档集合中查找十个最频繁的词：</p>
<div class="highlight"><pre><span></span><code>select * FROM ts_stat(&#39;select &#39;&#39;cat and dog&#39;&#39;::tsvector as info union select &#39;&#39;cat and rat&#39;&#39;::tsvector&#39;)  
 ORDER BY nentry DESC, ndoc DESC, word  
 LIMIT 10; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> word | ndoc | nentry 
--------+-------+----------
 and  |    2 |     2
 cat   |    2 |     2
 dog  |    1 |     1
 rat   |    1 |     1
</code></pre></div>
<h4 id="_190"><strong>域类型</strong></h4>
<p>域是一种用户定义的数据类型，它基于另一种底层类型。根据需要，它可以有约束来限制其有效值为底层类型所允许值的一个子集。如果没有约束，它的行为就和底层类型一样 — 例如，任何适用于底层类型的操作符或函数都对该域类型有效。底层类型可以是任何内建或者用户定义的基础类型、枚举类型、数组类型、组合类型、范围类型或者另一个域。</p>
<p>例如，我们可以在整数之上创建一个域，它只接受正整数：</p>
<div class="highlight"><pre><span></span><code>CREATE DOMAIN posint AS integer CHECK (VALUE &gt; 0);
CREATE TABLE mytable (id posint);
INSERT INTO mytable VALUES(1);   
INSERT INTO mytable VALUES(-1);  
</code></pre></div>
<p>返回错误信息如下：</p>
<div class="highlight"><pre><span></span><code>value for domain posint violates check constraint &quot;posint_check&quot;
</code></pre></div>
<p>当底层类型的一个操作符或函数适用于一个域值时，域会被自动向下造型为底层类型。因此，mytable.id - 1的结果会被认为是类型integer而不是posint。我们可以写成(mytable.id - 1)::posint来把结果转换回posint，这会导致域的约束被重新检查。在这种情况下，如果该表达式被应用于一个值为1的id就会错误。把底层类型的值赋给域类型的一个字段或者变量不需要写显式的造型，但是域的约束将会被检查。</p>
<h4 id="_191"><strong>伪类型</strong></h4>
<p>类型系统包含了一些特殊目的的项，它们被统称为伪类型。一个伪类型不能被用作一个列的数据类型，但是它可以被用来定义一个函数的参数或者结果类型。每一种可用的伪类型都有其可以发挥作用的情况，这些情况的特点是一个函数的行为并不能符合于简单使用，或者返回一种特定SQL数据类型的值。
小表列出了现有的伪类型：</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>any</td>
<td>表示一个函数可以接受任意输入数据类型。</td>
</tr>
<tr>
<td>anyelement</td>
<td>表示一个函数可以接受任意数据类型。</td>
</tr>
<tr>
<td>anyarray</td>
<td>表示一个函数可以接受任意数组数据类型</td>
</tr>
<tr>
<td>anynonarray</td>
<td>表示一个函数可以接受任意非数组数据类型。</td>
</tr>
<tr>
<td>anyenum</td>
<td>表示一个函数可以接受任意枚举数据类型。</td>
</tr>
<tr>
<td>anyrange</td>
<td>表示一个函数可以接受任意范围数据类型。</td>
</tr>
<tr>
<td>anycompatible</td>
<td>指示函数接受任何数据类型，并自动将多个参数提升为通用数据类型</td>
</tr>
<tr>
<td>anycompatiblearray</td>
<td>指示函数接受任何数组数据类型，并自动将多个参数提升为通用数据类型</td>
</tr>
<tr>
<td>anycompatiblenonarray</td>
<td>指示函数接受任何非数组数据类型，并将多个参数自动提升为通用数据类型</td>
</tr>
<tr>
<td>anycompatiblerange</td>
<td>指示函数接受任何范围数据类型，并将多个参数自动提升为通用数据类型</td>
</tr>
<tr>
<td>cstring</td>
<td>表示一个函数接受或者返回一个非空结尾的C字符串。</td>
</tr>
<tr>
<td>internal</td>
<td>表示一个函数接受或返回一个服务器内部数据类型。</td>
</tr>
<tr>
<td>language_handler</td>
<td>一个被声明为返回language_handler的过程语言调用处理器。</td>
</tr>
<tr>
<td>fdw_handler</td>
<td>一个被声明为返回fdw_handler的外部数据包装器处理器。</td>
</tr>
<tr>
<td>table_am_handler</td>
<td>一种表访问方法处理程序，声明要返回 table_am_handler.</td>
</tr>
<tr>
<td>index_am_handler</td>
<td>一个被声明为返回index_am_handler索引访问方法处理器。</td>
</tr>
<tr>
<td>tsm_handler</td>
<td>一个被声明为返回tsm_handler的表采样方法处理器。</td>
</tr>
<tr>
<td>record</td>
<td>标识一个接收或者返回一个未指定的行类型的函数。</td>
</tr>
<tr>
<td>trigger</td>
<td>一个被声明为返回trigger的触发器函数。</td>
</tr>
<tr>
<td>event_trigger</td>
<td>一个被声明为返回event_trigger的事件触发器函数。</td>
</tr>
<tr>
<td>pg_ddl_command</td>
<td>标识一种对事件触发器可用的 DDL 命令的表达。</td>
</tr>
<tr>
<td>void</td>
<td>表示一个函数不返回值。</td>
</tr>
<tr>
<td>unknown</td>
<td>标识一种还未被解析的类型，例如一个未修饰的字符文本。</td>
</tr>
</tbody>
</table>
<h3 id="bsql_2"><strong>BSQL</strong> <strong>语言</strong></h3>
<p>SQL语言部分描述了所有AiSQL SQL语句。</p>
<h4 id="abort"><strong>ABORT</strong></h4>
<p>中止当前事务
语法：abort ::= ABORT [ TRANSACTION | WORK ]
描述：ABORT回滚当前事务并且导致由该事务所作的所有更新被丢弃。这个命令的行为与标准SQL命令ROLLBACK的行为一样。
参数：
WORK
TRANSACTION
可选关键词，它们没有效果。</p>
<h4 id="alter-database"><strong>ALTER DATABASE</strong></h4>
<p>更改一个数据库
语法：alter_database ::= ALTER DATABASE name 
                   [ [ WITH ] alter_database_option [ ... ]
                     | RENAME TO name
                     | OWNER TO { new_owner
                                  | CURRENT_USER
                                  | SESSION_USER }
                     | SET run_time_parameter { TO | = } 
                       { value | DEFAULT }
                     | SET run_time_parameter FROM CURRENT
                     | RESET run_time_parameter
                     | RESET ALL ]</p>
<p>alter_database_option ::= ALLOW_CONNECTIONS allowconn
                          | CONNECTION LIMIT connlimit
                          | IS_TEMPLATE istemplate
描述：ALTER DATABASE 更改一个数据库。
参数：
name：指定要更改的数据库的名称
ALLOW_CONNECTIONS：指定false以禁止连接到此数据库。默认值为true，允许任何具有CREATEDB权限的用户克隆此数据库。
CONNECTION_LIMIT：指定可以与此数据库建立的并发连接数。默认值-1，允许无限制的并发连接。
IS_TEMPLATE：如果为true，则任何具有CREATEDB特权的用户都可以从这个数据库进行克隆。如果为false，则只有超级用户或者这个数据库的拥有者可以克隆它。</p>
<h4 id="alter-default-privileges"><strong>ALTER DEFAULT PRIVILEGES</strong></h4>
<p>定义默认访问特权
语法：
alter_default_priv ::= ALTER DEFAULT PRIVILEGES 
                       [ FOR { ROLE | USER } role_name [ , ... ] ]<br />
                       [ IN SCHEMA schema_name [ , ... ] ] 
                       abbr_grant_or_revoke</p>
<p>abbr_grant_or_revoke ::= a_grant_table
                         | a_grant_seq
                         | a_grant_func
                         | a_grant_type
                         | a_grant_schema
                         | a_revoke_table
                         | a_revoke_seq
                         | a_revoke_func
                         | a_revoke_type
                         | a_revoke_schema</p>
<p>a_grant_table ::= GRANT { grant_table_priv [ , ... ]
                          | ALL [ PRIVILEGES ] } ON TABLES TO 
                  grantee_role [ , ... ]  [ WITH GRANT OPTION ]</p>
<p>a_grant_seq ::= GRANT { grant_seq_priv [ , ... ]
                        | ALL [ PRIVILEGES ] } ON SEQUENCES TO 
                grantee_role [ , ... ]  [ WITH GRANT OPTION ]</p>
<p>a_grant_func ::= GRANT { EXECUTE | ALL [ PRIVILEGES ] } ON 
                 { FUNCTIONS | ROUTINES } TO grantee_role [ , ... ]<br />
                 [ WITH GRANT OPTION ]</p>
<p>a_grant_type ::= GRANT { USAGE | ALL [ PRIVILEGES ] } ON TYPES TO 
                 grantee_role [ , ... ]  [ WITH GRANT OPTION ]</p>
<p>a_grant_schema ::= GRANT { USAGE | CREATE | ALL [ PRIVILEGES ] } ON 
                   SCHEMAS TO grantee_role [ , ... ]<br />
                   [ WITH GRANT OPTION ]</p>
<p>a_revoke_table ::= REVOKE [ GRANT OPTION FOR ] 
                   { grant_table_priv [ , ... ] | ALL [ PRIVILEGES ] } 
                   ON TABLES  FROM grantee_role [ , ... ] 
                   [ CASCADE | RESTRICT ]</p>
<p>a_revoke_seq ::= REVOKE [ GRANT OPTION FOR ] 
                 { grant_seq_priv [ , ... ] | ALL [ PRIVILEGES ] } ON 
                 SEQUENCES  FROM grantee_role [ , ... ] 
                 [ CASCADE | RESTRICT ]</p>
<p>a_revoke_func ::= REVOKE [ GRANT OPTION FOR ] 
                  { EXECUTE | ALL [ PRIVILEGES ] } ON 
                  { FUNCTIONS | ROUTINES }  FROM grantee_role 
                  [ , ... ] [ CASCADE | RESTRICT ]</p>
<p>a_revoke_type ::= REVOKE [ GRANT OPTION FOR ] 
                  { USAGE | ALL [ PRIVILEGES ] } ON TYPES  FROM 
                  grantee_role [ , ... ] [ CASCADE | RESTRICT ]</p>
<p>a_revoke_schema ::= REVOKE [ GRANT OPTION FOR ] 
                    { USAGE | CREATE | ALL [ PRIVILEGES ] } ON SCHEMAS 
                     FROM grantee_role [ , ... ] 
                    [ CASCADE | RESTRICT ]</p>
<p>grant_table_priv ::= SELECT
                     | INSERT
                     | UPDATE
                     | DELETE
                     | TRUNCATE
                     | REFERENCES
                     | TRIGGER</p>
<p>grant_seq_priv ::= USAGE | SELECT | UPDATE</p>
<p>grantee_role ::= [ GROUP ] role_name
                 | PUBLIC
                 | CURRENT_USER
                 | SESSION_USER</p>
<p>描述：ALTER DEFAULT PRIVILEGES允许你设置将被应用于未来要创建的对象的特权，它不会影响分配给已经存在的对象的特权。用户只能更改由自己或其成员角色创建的对象的默认权限。
示例：
示例1：向所有用户授予在架构营销中创建的所有表的SELECT权限。 </p>
<div class="highlight"><pre><span></span><code>ALTER DEFAULT PRIVILEGES IN SCHEMA marketing GRANT SELECT ON TABLES TO PUBLIC;
</code></pre></div>
<p>示例2：撤消用户john对所有表的INSERT权限。</p>
<div class="highlight"><pre><span></span><code>ALTER DEFAULT PRIVILEGES REVOKE INSERT ON TABLES FROM john;
</code></pre></div>
<h4 id="alter-domain"><strong>ALTER DOMAIN</strong></h4>
<p>更改一个域的定义
语法：
alter_domain_default ::= ALTER DOMAIN name 
                         { SET DEFAULT expression | DROP DEFAULT }</p>
<p>alter_domain_rename ::= ALTER DOMAIN name RENAME TO name
描述：ALTER DOMAIN更改一个现有域的定义。</p>
<p>参数：
SET DEFAULT/DROP DEFAULT:这些形式设置或者移除一个域的默认值。注意默认值只会应用到后续的 INSERT命令，它们不影响使用该域的已经存在于表中的行。
RENAME：重命名domain的名。
name：指定域的名称。如果域名称不存在，或域new_name已存在，则会引发错误。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE DOMAIN idx as int DEFAULT 5 CHECK (VALUE &gt; 0);

ALTER DOMAIN idx DROP DEFAULT;

ALTER DOMAIN idx RENAME TO idx_new;

DROP DOMAIN idx_new;
</code></pre></div>
<h4 id="alter-foreign-data-wrapper"><strong>ALTER FOREIGN DATA WRAPPER</strong></h4>
<p>更改一个外部数据包装器的定义
语法：
alter_foreign_data_wrapper ::= ALTER FOREIGN DATA WRAPPER fdw_name<br />
                               [ HANDLER handler_name | NO HANDLER ]<br />
                               [ VALIDATOR validator_name
                                 | NO VALIDATOR ]<br />
                               [ OPTIONS ( alter_fdw_options ) ]<br />
                               [ OWNER TO new_owner ]<br />
                               [ RENAME TO new_name ]
描述：ALTER FOREIGN DATA WRAPPER更改一个外部数据包装器的定义。
HANDLER：将调用handler_function来检索外部表的执行函数。这些功能是规划者和执行者所必需的。处理程序函数不接受任何参数，其返回类型应为fdw_handler。如果没有提供处理程序函数，则只能声明（而不能访问）使用包装器的外部表。
VALIDATOR：validator_function用于验证提供给外部数据包装器的选项，以及使用外部数据包装的外部服务器、用户映射和外部表。验证器函数有两个参数：一个文本数组（类型为text[]），其中包含要验证的选项，另一个是类型 oid，它将是包含该选项的系统目录的 OID，与选项关联的对象存储在该OID中。如果没有提供验证器函数（或未指定validator），则在创建时不会检查选项。
OPTIONS：这个子句为新的外部数据包装器指定选项。允许的选项名称和值与每一个外部数据包装器有关，并且它们会被该外部数据包装器的验证器函数验证。 选项名称必须唯一。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>ALTER FOREIGN DATA WRAPPER file NO HANDLER ;
ALTER FOREIGN DATA WRAPPER file HANDLER file_fdw_handler;
ALTER FOREIGN DATA WRAPPER file NO VALIDATOR;
ALTER FOREIGN DATA WRAPPER file OPTIONS(ADD new &#39;1&#39;);
</code></pre></div>
<h4 id="alter-foreign-table"><strong>ALTER FOREIGN TABLE</strong></h4>
<p>更改一个外部表的定义
语法：
alter_foreign_table ::= ALTER FOREIGN TABLE [ IF EXISTS ] table_name 
                        alter_foreign_table_action [ , ... ]</p>
<p>描述：
ALTER FOREIGN TABLE更改一个现有外部表的定义。
参数：
ADD COLUMN：可用于将新列添加到外部表中，对底层存储没有影响，ADD COLUMN操作只是指示可以通过外部表访问新添加的列。
DROP COLUMN：这种形式从一个外部表删掉一列。DROP COLUMN子句可用于从外部表中删除列。可以指定CASCADE或RESTRICT。如果在该表外部有任何东西依赖于该列，你将需要写上CASCADE，典型的示例就是视图。
Change owner：这种形式把该外部表的拥有者改成指定的用户。
Options：OPTIONS子句可用于指定外部表的新选项。ADD、SET和DROP指定要执行的操作。如果没有明确指定操作，则假定ADD。
Rename：RENAME TO子句可用于将外部表重命名为table_name。
示例：
示例1：增加一个新列：</p>
<div class="highlight"><pre><span></span><code>ALTER FOREIGN TABLE my_table ADD COLUMN new_col int;
</code></pre></div>
<p>示例2：更改options：</p>
<div class="highlight"><pre><span></span><code>ALTER FOREIGN TABLE my_table OPTIONS (ADD newopt1 &#39;value1&#39;, DROP oldopt1 &#39;value2&#39;, SET oldopt2 &#39;value3&#39;);
</code></pre></div>
<h4 id="alter-function"><strong>ALTER FUNCTION</strong></h4>
<p>更改一个函数的定义
语法：
alter_function ::= ALTER FUNCTION subprogram_name ( 
                   [ subprogram_signature ] )<br />
                   { special_fn_and_proc_attribute
                     | { alterable_fn_and_proc_attribute
                         | alterable_fn_only_attribute } [ ... ] 
                       [ RESTRICT ] }</p>
<p>subprogram_signature ::= arg_decl [ , ... ]</p>
<p>arg_decl ::= [ formal_arg ] [ arg_mode ] arg_type</p>
<p>special_fn_and_proc_attribute ::= RENAME TO subprogram_name
                                  | OWNER TO 
                                    { role_name
                                      | CURRENT_ROLE
                                      | CURRENT_USER
                                      | SESSION_USER }
                                  | SET SCHEMA schema_name
                                  | [ NO ] DEPENDS ON EXTENSION 
                                    extension_name</p>
<p>alterable_fn_and_proc_attribute ::= SET run_time_parameter 
                                    { TO value
                                      | = value
                                      | FROM CURRENT }
                                    | RESET run_time_parameter
                                    | RESET ALL
                                    | [ EXTERNAL ] SECURITY 
                                      { INVOKER | DEFINER }</p>
<p>alterable_fn_only_attribute ::= volatility
                                | on_null_input
                                | PARALLEL parallel_mode
                                | [ NOT ] LEAKPROOF
                                | COST int_literal
                                | ROWS int_literal</p>
<p>volatility ::= IMMUTABLE | STABLE | VOLATILE</p>
<p>on_null_input ::= CALLED ON NULL INPUT
                  | RETURNS NULL ON NULL INPUT
                  | STRICT</p>
<p>parallel_mode ::= UNSAFE | RESTRICTED | SAFE</p>
<p>描述：ALTER FUNCTION更改一个函数的定义。</p>
<p>参数：
subprogram_name：一个现有函数的名称（可以被模式限定）。如果没有指定参数列表， 则该名称必须在它的模式中唯一。
argmode：一个参数的模式：IN、OUT、 INOUT或者VARIADIC。如果被忽略，默认为 IN。注意ALTER FUNCTION 并不真正关心OUT参数，因为在决定函数的身份时只需要输入参数。因此列出IN、INOUT以及 VARIADIC参数即可。
formal_arg：一个参数的名称。注意ALTER FUNCTION 并不真正参数名称，因为在确定函数的身份时只需要参数的数据类型即可。
argtype：该函数的参数（如果有）的数据类型（可以被模式限定）。</p>
<p>role_name：该函数的新拥有者。
schema_name：该函数的新模式。
extension_name：该函数所依赖的扩展名。
on_null_input：CALLED ON NULL INPUT将该函数改为在某些 或者全部参数为空值时可以被调用。 RETURNS NULL ON NULL INPUT或者 STRICT将该函数改为只要任一参数为空值就不被调用而 是自动假定一个空值结果。
volatility：把该函数的稳定性更改为指定的设置。详见 CREATE FUNCTION。
[ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER：更改该函数是否为一个安全性定义者。关键词EXTERNAL 是为了符合 SQL，它会被忽略。
PARALLEL：决定该函数对于并行是否安全。
LEAKPROOF：更改该函数是否被认为是防泄漏的。
COST int_literal：更改该函数的估计执行代价。
ROWS int_literal：更改一个集合返回函数的估计行数。
run_time_parameter：
value
当该函数被调用时，要对一个配置参数做出增加或者更改的赋值。如果 value是DEFAULT 或者使用等价的RESET，该函数本地的设置将会被移除，这样该函数会使用其环境中存在的值执行。使用RESET ALL可以清除所有函数本地的设置。 SET FROM CURRENT把ALTER FUNCTION 执行时该参数的当前值保存为进入该函数时要应用的值。
RESTRICT：为了符合 SQL 标准存在，被忽略。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>drop schema if exists s3 cascade;
drop schema if exists s4 cascade;
create schema s3;

create function s3.f(i in int)
  returns text
  security definer
  volatile
  language plpgsql
as $body$
begin
  return &#39;Result: &#39;||(i*2)::text;
end;
$body$;

select s3.f(17) as &quot;s3.f(17)&quot;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>  s3.f(17)
------------
 Result: 34
</code></pre></div>
<p>现在假设您意识到security definer是错误的选择，您想将其标记为不可变的，并且您想设置statement_timeout属性。同样假设：您想调用函数g()，而不是f()；并且您希望它在模式s4中，而不是在模式s3中。因此，必须使用三个ALTER语句才能执行此操作，如下所示：</p>
<div class="highlight"><pre><span></span><code>alter function s3.f(int)
  security invoker
  immutable
  set statement_timeout = 1;
</code></pre></div>
<p>执行完成之后，可以通过检查函数的元数据来检查是否成功，可以执行如下脚本来进行相关检查：</p>
<div class="highlight"><pre><span></span><code>select
  proname::text                                as name,
  pronamespace::regnamespace::text             as schema,
  case
    when prosecdef then &#39;definer&#39;
    else &#39;invoker&#39;
  end                                          as security,
  case
    when provolatile = &#39;v&#39; then &#39;volatile&#39;
    when provolatile = &#39;s&#39; then &#39;stable&#39;
    when provolatile = &#39;i&#39; then &#39;immutable&#39;
  end                                          as volatility,
  proconfig                                    as settings
from pg_proc
where
  proname::text in (&#39;f&#39;, &#39;g&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> name | schema | security | volatility |       settings
------+--------+----------+------------+-----------------------
 f    | s3     | invoker  | immutable  | {statement_timeout=1}
</code></pre></div>
<p>接下来，重命名此函数：</p>
<div class="highlight"><pre><span></span><code>alter function s3.f(int) rename to g;
</code></pre></div>
<p>再次执行上述检查脚本，进行检查，返回信息如下：</p>
<div class="highlight"><pre><span></span><code> name | schema | security | volatility |       settings        
------+--------+----------+------------+-----------------------
 g    | s3     | invoker  | immutable  | {statement_timeout=1}
</code></pre></div>
<p>最后，修改模式：</p>
<div class="highlight"><pre><span></span><code>create schema s4;
alter function s3.g(int) set schema s4;
</code></pre></div>
<p>继续执行上述检查脚本，进行检查，返回信息如下：</p>
<div class="highlight"><pre><span></span><code> name | schema | security | volatility |       settings        
------+--------+----------+------------+-----------------------
 g    | s4     | invoker  | immutable  | {statement_timeout=1}
</code></pre></div>
<h4 id="alter-group"><strong>ALTER GROUP</strong></h4>
<p>更改角色名称或者成员关系
语法：
alter_group ::= ALTER GROUP role_specification { ADD | DROP } USER 
                role_name [ , ... ]</p>
<p>role_specification ::= role_name | CURRENT_USER | SESSION_USER</p>
<p>alter_group_rename ::= ALTER GROUP role_name RENAME TO new_role_name</p>
<p>描述：使用ALTER GROUP语句可以更改组（角色）的属性。添加此项是为了与Postgres兼容。不鼓励使用它。ALTER ROLE是更改角色属性的首选方式。有关更多详细信息，请参阅<a href="#_ALTER ROLE">ALTER ROLE</a>
ALTER GROUP可用于在组中添加或删除角色，请改用GRANT或REVOKE，它还可以用于重命名角色。</p>
<h4 id="alter-policy"><strong>ALTER POLICY</strong></h4>
<p>更改一条行级安全性策略的定义
语法：
alter_policy ::= ALTER POLICY name ON table_name 
                 [ TO { role_name
                        | PUBLIC
                        | CURRENT_USER
                        | SESSION_USER } [ , ... ] ]<br />
                 [ USING ( using_expression ) ] 
                 [ WITH CHECK ( check_expression ) ]</p>
<p>alter_policy_rename ::= ALTER POLICY name ON table_name RENAME TO 
                        new_name</p>
<p>描述：ALTER POLICY更改一条现有行级安全性策略的定义。
参数：
name：要更改的现有策略的名称。
table_name：该策略所在的表的名称（可以被模式限定）。
new_name：该策略的新名称。
role_name：该策略适用的角色。可以一次指定多个角色。要把该策略应用于所有角色，可使用PUBLIC。
using_expression：该策略的USING表达式。
check_expression：该策略的WITH CHECK表达式。</p>
<h4 id="alter-procedure"><strong>ALTER PROCEDURE</strong></h4>
<p>更改过程的定义
语法：
alter_procedure ::= ALTER PROCEDURE subprogram_name ( 
                    [ subprogram_signature ] )<br />
                    { special_fn_and_proc_attribute
                      | alterable_fn_and_proc_attribute [ ... ] 
                        [ RESTRICT ] }</p>
<p>subprogram_signature ::= arg_decl [ , ... ]</p>
<p>arg_decl ::= [ formal_arg ] [ arg_mode ] arg_type</p>
<p>special_fn_and_proc_attribute ::= RENAME TO subprogram_name
                                  | OWNER TO 
                                    { role_name
                                      | CURRENT_ROLE
                                      | CURRENT_USER
                                      | SESSION_USER }
                                  | SET SCHEMA schema_name
                                  | [ NO ] DEPENDS ON EXTENSION 
                                    extension_name</p>
<p>alterable_fn_and_proc_attribute ::= SET run_time_parameter 
                                    { TO value
                                      | = value
                                      | FROM CURRENT }
                                    | RESET run_time_parameter
                                    | RESET ALL
                                    | [ EXTERNAL ] SECURITY 
                                      { INVOKER | DEFINER }</p>
<p>描述：ALTER PROCEDURE更改一个过程的定义。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>ALTER PROCEDURE insert_data(integer, integer) OWNER TO joe;
</code></pre></div>
<h4 id="alter-role"><strong>ALTER ROLE</strong></h4>
<p>更改一个数据库角色
语法：
alter_role ::= ALTER ROLE role_specification 
               [ [ WITH ] alter_role_option [ , ... ] ]</p>
<p>alter_role_option ::= SUPERUSER
                      | NOSUPERUSER
                      | CREATEDB
                      | NOCREATEDB
                      | CREATEROLE
                      | NOCREATEROLE
                      | INHERIT
                      | NOINHERIT
                      | LOGIN
                      | NOLOGIN
                      | CONNECTION LIMIT connlimit
                      | [ ENCRYPTED ] PASSWORD  ' password ' 
                      | PASSWORD NULL
                      | VALID UNTIL  ' timestamp ' </p>
<p>role_specification ::= role_name | CURRENT_USER | SESSION_USER</p>
<p>alter_role_rename ::= ALTER ROLE role_name RENAME TO new_role_name</p>
<p>alter_role_config ::= ALTER ROLE { role_specification | ALL } 
                      [ IN DATABASE database_name ] config_setting</p>
<p>config_setting ::= SET config_param { TO | = } 
                   { config_value | DEFAULT }
                   | SET config_param FROM CURRENT
                   | RESET config_param
                   | RESET ALL</p>
<p>描述：使用ALTER ROLE语句可以更改角色（用户或组）的属性。
超级用户可以更改任何角色的属性。具有CREATE ROLE权限的角色可以更改任何非超级用户角色的属性。其他角色只能更改自己的密码。</p>
<p>参数：
role_specification：指定要更改其属性的角色、当前用户或当前会话用户的名称。
SUPERUSER，NOSUPERUSER：确定新角色是否为“超级用户”。超级用户可以覆盖所有访问限制，应谨慎使用。只有具有SUPERUSER权限的角色才能创建其他SUPERUSER角色。如果未指定，则默认为NOSUPERUSER。
CREATEDB，NOCREATEDB：确定新角色是否可以创建数据库。默认为NOCREATEDB。
CREATEROLE，NOCREATEROLE：确定新角色是否可以创建其他角色。默认值为NOCREATEROLE。 
INHERIT，NOINHERIT：确定新角色是否继承其所属角色的特权。如果没有INHERIT，另一个角色的成员资格只能授予该角色设置角色的能力。其他角色的权限只有在完成后才可用。如果未指定，则默认为INHERIT。
LOGIN，NOLOGIN：确定是否允许新角色登录。只有具有登录权限的角色才能在客户端连接期间使用。具有LOGIN的角色可以被视为用户。如果未指定，则默认为NOLOGIN。请注意，如果使用CREATE USER语句而不是CREATE ROLE，则默认值为LOGIN。
CONNECTION LIMIT：指定角色可以进行的并发连接数。默认值为-1，表示不受限制。这仅适用于可以登录的角色。
[ENCRYPTED] PASSWORD：设置新角色的密码。这只适用于可以登录的角色。如果未指定密码，则密码将设置为null，并且该用户的密码身份验证将始终失败。请注意，密码始终加密存储在系统目录中，可选关键字encrypted仅用于与PostgreSQL兼容。 
VALID UNTIL：设置角色密码不再有效的日期和时间。如果省略此子句，密码将始终有效。 
config_param和config_value：是正在设置的配置参数的名称和值。 
ALTER ROLE ROLE_name RENAME TO：可用于更改角色的名称。请注意，当前会话角色无法重命名。如果密码是MD5加密的，则重命名角色会清除其密码。 
ALTER ROLE SET | RESET config_param：用于更改配置变量的角色会话默认值，可以用于所有数据库，也可以在指定IN DATABASE子句时仅用于命名数据库中的会话。如果指定了ALL而不是角色名称，则会更改所有角色的设置。
示例：</p>
<p>示例1：更改角色的密码。</p>
<div class="highlight"><pre><span></span><code>ALTER ROLE John WITH PASSWORD &#39;new_password&#39;;
</code></pre></div>
<p>示例2：重命名一个角色。</p>
<div class="highlight"><pre><span></span><code>ALTER ROLE John RENAME TO Jane;
</code></pre></div>
<p>示例3：更改角色的default_transaction_isolation会话参数。 </p>
<div class="highlight"><pre><span></span><code>ALTER ROLE Jane SET default_transaction_isolation=&#39;serializable&#39;;
</code></pre></div>
<h4 id="alter-schema"><strong>ALTER SCHEMA</strong></h4>
<p>更改一个模式的定义
语法：
alter_schema ::= ALTER SCHEMA schema_name 
                 { RENAME TO new_name
                   | OWNER TO { new_owner
                                | CURRENT_USER
                                | SESSION_USER } }</p>
<p>描述：ALTER SCHEMA更改一个模式的定义。
注意以下几点：
为了可以使用ALTER SCHEMA，您需要是模式的所有者。
重命名模式需要具有数据库的CREATE权限。
如果要更改所有者，您还必须是新所有者角色的直接或间接成员，并且您需要拥有数据库的CREATE权限。
参数：
schema_name：指定模式的名称（schema_name）。如果当前数据库中不存在具有该名称的模式，则会引发错误。
RENAME TO new_name：重命名模式名称。模式名称不得以pg_开头。尝试使用这样的名称创建模式，或将现有模式重命名为具有这样的名称，会导致错误。
OWNER TO (new_owner | CURRENT_USER | SESSION_USER)：更改模式的所有者。
new_owner：模式的新的所有者。
CURRENT_USER：当前执行上下文的用户名。
SESSION_USER：当前会话的用户名。</p>
<p>示例：
创建一个新的模式：</p>
<div class="highlight"><pre><span></span><code>CREATE SCHEMA schema22;
</code></pre></div>
<p>示例1：重命名此模式的名称：</p>
<div class="highlight"><pre><span></span><code>ALTER SCHEMA schema22 RENAME TO schema25;
</code></pre></div>
<p>示例2：更改模式的所有者：</p>
<div class="highlight"><pre><span></span><code>ALTER SCHEMA schema25 OWNER TO postgres;
</code></pre></div>
<h4 id="alter-sequence"><strong>ALTER SEQUENCE</strong></h4>
<p>更改一个序列发生器的定义
语法：
alter_sequence ::= ALTER SEQUENCE [ IF EXISTS ] sequence_name 
                   alter_sequence_options</p>
<p>alter_sequence_options ::= [ AS seq_data_type ]<br />
                           [ INCREMENT [ BY ] int_literal ]<br />
                           [ MINVALUE int_literal | NO MINVALUE ]<br />
                           [ MAXVALUE int_literal | NO MAXVALUE ]<br />
                           [ START [ WITH ] int_literal ]<br />
                           [ RESTART [ [ WITH ] int_literal ] ]<br />
                           [ CACHE int_literal ]  [ [ NO ] CYCLE ]<br />
                           [ OWNED BY table_name . column_name
                             | NONE ]</p>
<p>描述：ALTER SEQUENCE更改一个现有序列发生器的参数。</p>
<p>参数：
sequence_name [ IF EXISTS ]：指定序列的名称（sequence_name）。如果当前模式中不存在具有该名称的序列，并且未指定if exists，则会引发错误。
AS seq_data_type：改变序列的数据类型。如果以前的值超出了新类型允许的范围，这将自动更改序列的最小值和最大值，有效类型是smallint、integer 和bigint。
INCREMENT BY int_literal：指定序列中连续值之间的差值。默认值为1 
MINVALUE int_literal | NO MINVALUE：指定序列中允许的最小值。如果达到这个值（在负增量的序列中），nextval()将返回一个错误。如果未指定MINVALUE，则将使用默认值。默认值为1。
MAXVALUE int_literal | NO MAXVALUE：指定序列中允许的最大值。如果达到该值，nextval()将返回一个错误。如果未指定MAXVALUE，则将使用默认值。默认值为  2⁶³-1。
START WITH int_literal：指定序列中的第一个值。start不能小于minvalue。默认值为1。
RESTART [ [ WITH ] int_literal ] ]：更改序列的当前值。如果未指定值，则当前值将设置为创建或更改序列时使用START[with]指定的最后一个值。 
CACHE int_literal：指定要在客户端中缓存序列中的数字。默认值为1。
当TServer bsql_sequence_cache_minval配置标志未显式关闭（设置为0）时，将使用该标志和缓存子句的最大值。
[ NO ] CYCLE：如果指定了CYCLE，则一旦达到minvalue或maxvalue，序列就会回卷。如果达到了maxvalue，则minvalue将是序列中的下一个数字。如果达到minvalue（对于递减序列），maxvalue将是序列中的下一个数字。“无循环”是默认设置。
OWNED BY table_name.table_column | NONE：它将序列的所有权赋予指定的列（如果有的话）。这意味着，如果删除列（或其所属的表），则序列将自动删除。如果指定了NONE，则将删除以前的所有权。
示例：</p>
<p>创建一个序列。 </p>
<div class="highlight"><pre><span></span><code>CREATE SEQUENCE s;
</code></pre></div>
<p>示例1：修改增量值。 </p>
<div class="highlight"><pre><span></span><code>ALTER SEQUENCE s INCREMENT BY 5;
</code></pre></div>
<p>示例2：修改起始值。</p>
<div class="highlight"><pre><span></span><code>ALTER SEQUENCE s RESTART WITH 2;
</code></pre></div>
<h4 id="alter-server"><strong>ALTER SERVER</strong></h4>
<p>更改一个外部服务器的定义
语法：
alter_server ::= ALTER SERVER server_name [ VERSION server_version ]<br />
                 [ OPTIONS ( alter_fdw_options ) ] 
                 [ OWNER TO new_owner ]</p>
<p>描述：ALTER SERVER更改一个外部服务器的定义。</p>
<p>参数：
server_version：新的服务器版本。
OPTIONS ( alter_fdw_options )：更改该服务器的选项。ADD、SET和 DROP指定要执行的动作。如果没有显式地指定操作， 将会假定为ADD。选项名称必须唯一，名称和值也会 使用该服务器的外部数据包装器库进行验证。
new_owner：该外部服务器的新拥有者的用户名。</p>
<p>示例：
改变server的版本为2.0，设置opt1 为true，删除opt2：</p>
<div class="highlight"><pre><span></span><code>ALTER SERVER my_server SERVER VERSION &#39;2.0&#39; OPTIONS (SET opt1 &#39;true&#39;, DROP opt2);
</code></pre></div>
<h4 id="alter-table"><strong>ALTER TABLE</strong></h4>
<p>更改一个表的定义
语法：alter_table ::= ALTER TABLE table_expr alter_table_action [ , ... ]</p>
<p>alter_table_action ::= ADD [ COLUMN ] column_name data_type 
                       [ alter_column_constraint [ ... ] ]
                       | RENAME TO table_name
                       | DROP [ COLUMN ] column_name 
                         [ RESTRICT | CASCADE ]
                       | ADD alter_table_constraint
                       | DROP CONSTRAINT constraint_name 
                         [ RESTRICT | CASCADE ]
                       | RENAME [ COLUMN ] column_name TO column_name
                       | RENAME CONSTRAINT constraint_name TO 
                         constraint_name
                       | DISABLE ROW LEVEL SECURITY
                       | ENABLE ROW LEVEL SECURITY
                       | FORCE ROW LEVEL SECURITY
                       | NO FORCE ROW LEVEL SECURITY</p>
<p>alter_table_constraint ::= [ CONSTRAINT constraint_name ]<br />
                           { CHECK ( expression )
                             | UNIQUE ( column_names ) 
                               index_parameters
                             | FOREIGN KEY ( column_names ) 
                               references_clause }<br />
                           [ DEFERRABLE | NOT DEFERRABLE ] 
                           [ INITIALLY DEFERRED
                             | INITIALLY IMMEDIATE ]</p>
<p>alter_column_constraint ::= [ CONSTRAINT constraint_name ]<br />
                            { NOT NULL
                              | NULL
                              | CHECK ( expression )
                              | DEFAULT expression
                              | UNIQUE index_parameters
                              | references_clause } 
                            [ DEFERRABLE | NOT DEFERRABLE ] 
                            [ INITIALLY DEFERRED
                              | INITIALLY IMMEDIATE ]</p>
<p>table_expr ::= [ ONLY ] table_name [ * ]
描述：ALTER TABLE更改一个现有表的定义。
参数：
alter_table_action：
指定以下操作的一种。 
ADD [ COLUMN ] column_name data_type constraint：向该表增加一个新列，使用与 CREATE TABLE相同的语法。
RENAME TO table_name：重命名指定的表。
DROP [COLUMN] COLUMN_name [RESTRICT|CASCADE]：从表中删除列。
RESTRICT--仅删除指定的列。
CASCADE—删除指定的列和任何依赖对象。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>drop table if exists children cascade;
drop table if exists parents  cascade;

-- The column &quot;b&quot; models a (natural) business unique key.
create table parents(
  k int primary key,
  b int not null,
  v text not null,
  constraint parents_b_unq unique(b));

create table children(
  parents_b  int  not null,
  k          int  not null,
  v          text not null,

  constraint children_pk primary key(parents_b, k),

  constraint children_fk foreign key(parents_b)
    references parents(b)
    match full
    on delete cascade
    on update restrict);

insert into parents(k, b, v) values (1, 10, &#39;dog&#39;), (2, 20, &#39;cat&#39;), (3, 30, &#39;frog&#39;);

insert into children(parents_b, k, v) values
  (10, 1, &#39;dog-child-a&#39;),
  (10, 2, &#39;dog-child-b&#39;),
  (10, 3, &#39;dog-child-c&#39;),
  (20, 1, &#39;cat-child-a&#39;),
  (20, 2, &#39;cat-child-b&#39;),
  (20, 3, &#39;cat-child-c&#39;),
  (30, 1, &#39;frog-child-a&#39;),
  (30, 2, &#39;frog-child-b&#39;),
  (30, 3, &#39;frog-child-c&#39;);

select p.v as &quot;p.v&quot;, c.v as &quot;c.v&quot;
from parents p inner join children c on c.parents_b = p.b
order by p.b, c.k;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> p.v  |     c.v
------+--------------
 dog  | dog-child-a
 dog  | dog-child-b
 dog  | dog-child-c
 cat  | cat-child-a
 cat  | cat-child-b
 cat  | cat-child-c
 frog | frog-child-a
 frog | frog-child-b
 frog | frog-child-c
</code></pre></div>
<p>\d children 元命令显示它有一个外键，该外键是parents表中列b上的依赖对象：
返回信息如下：</p>
<div class="highlight"><pre><span></span><code>Indexes:
    &quot;children_pk&quot; PRIMARY KEY, lsm (parents_b HASH, k ASC)
Foreign-key constraints:
    &quot;children_fk&quot; FOREIGN KEY (parents_b) REFERENCES parents(b) MATCH FULL ON UPDATE RESTRICT ON DELETE CASCADE
</code></pre></div>
<p>这是一个人为的示例。除了定义父表主键约束的列之外，将外键约束作为任何对象都是不常见的做法（通常也是不好的做法）。但这样做有时是有正当理由的。
现在尝试删除列parents.b:</p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  message  text not null := &#39;&#39;;
  detail   text not null := &#39;&#39;;
begin
  -- Causes error &#39;cos &quot;cascade&quot; is required.
  alter table parents drop column b;
  assert false, &#39;Should not get here&#39;;
exception
  -- Error 2BP01
  when dependent_objects_still_exist then
    get stacked diagnostics
      message  = message_text,
      detail   = pg_exception_detail;
    assert message = &#39;cannot drop column b of table parents because other objects depend on it&#39;,      &#39;Bad message&#39;;
    assert detail  = &#39;constraint children_fk on table children depends on column b of table parents&#39;, &#39;Bad detail&#39;;
end;
$body$;
</code></pre></div>
<p>它完成时没有出现错误，表明空的alter table parents drop column b（没有cascade）失败，并导致代码显示的消息和提示。现在用cascade重复该尝试，并观察结果： </p>
<div class="highlight"><pre><span></span><code>alter table parents drop column b cascade;
</code></pre></div>
<p>执行成功，现在\d children显示外键约束children _fk已被传递性删除。
ADD alter_table_constraint：将指定的约束添加到表中。
DROP CONSTRAINT constraint_name [ RESTRICT | CASCADE ]:从表中删除约束。
RESTRICT—仅删除指定的约束。
CASCADE—删除指定的约束和任何依赖对象。 
RENAME [ COLUMN ] column_name TO column_name：将列重命名为指定的名称。</p>
<p>RENAME CONSTRAINT constraint_name TO constraint_name：将约束重命名为指定的名称。
例如：
创建带有约束的表并重命名约束：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test(id BIGSERIAL PRIMARY KEY, a TEXT);
ALTER TABLE test ADD constraint vague_name unique (a);
ALTER TABLE test RENAME CONSTRAINT vague_name TO unique_a_constraint;
</code></pre></div>
<p>ENABLE / DISABLE ROW LEVEL SECURITY：这将启用或禁用表的行级安全性。如果启用了该表并且不存在任何策略，则应用默认的拒绝策略。如果禁用，则不会应用该表的现有策略，并将被忽略。有关如何创建行级安全策略的详细信息，请参阅<a href="#_CREATE POLICY">CREATE POLICY</a> 
FORCE / NO FORCE ROW LEVEL SECURITY：当用户是表的所有者时，这将控制表的行安全策略的应用。如果启用，则当用户是表所有者时，将应用行级安全策略。如果禁用（默认设置），则当用户是表所有者时，不会应用行级安全性。有关如何创建行级安全策略的详细信息，请参阅<a href="#_CREATE POLICY">CREATE POLICY</a>
Constraints：指定表或列的约束。
CONSTRAINT constraint_name：指定约束的名称。 
Foreign key：FOREIGN KEY和REFERENCES指定列集只能包含引用表的引用列中存在的值。它用于强制数据的引用完整性。
Unique：这强制要求UNIQUE约束中指定的列集在表中是唯一的，也就是说，对于UNIQUE限制中指定的一组列，没有两行可以具有相同的值。
Check：这用于强制指定表中的数据满足CHECK子句中指定的要求。
Default：这用于指定列的默认值。如果INSERT语句没有为列指定值，则使用默认值。如果没有为列指定默认值，则默认值为NULL
Deferrable constraints：可以使用DEFERRABLE子句延迟约束。目前，AiSQL中只能延迟外键约束。语句中的每一行之后都会检查一个不可延迟的约束。在可延迟约束的情况下，约束的检查可以推迟到事务结束。
标记为INITIALLY IMMEDIATE的约束将在语句中的每一行之后进行检查。
标记为INITIALLY DEFERRED的约束将在事务结束时进行检查。 </p>
<h4 id="alter-user"><strong>ALTER USER</strong></h4>
<p>更改一个数据库角色
语法：
alter_user ::= ALTER USER role_specification 
               [ [ WITH ] alter_role_option [ , ... ] ]</p>
<p>alter_role_option ::= SUPERUSER
                      | NOSUPERUSER
                      | CREATEDB
                      | NOCREATEDB
                      | CREATEROLE
                      | NOCREATEROLE
                      | INHERIT
                      | NOINHERIT
                      | LOGIN
                      | NOLOGIN
                      | CONNECTION LIMIT connlimit
                      | [ ENCRYPTED ] PASSWORD  ' password ' 
                      | PASSWORD NULL
                      | VALID UNTIL  ' timestamp ' </p>
<p>role_specification ::= role_name | CURRENT_USER | SESSION_USER</p>
<p>alter_user_rename ::= ALTER USER role_name RENAME TO new_role_name</p>
<p>alter_user_config ::= ALTER USER { role_specification | ALL } 
                      [ IN DATABASE database_name ] config_setting</p>
<p>config_setting ::= SET config_param { TO | = } 
                   { config_value | DEFAULT }
                   | SET config_param FROM CURRENT
                   | RESET config_param
                   | RESET ALL</p>
<p>描述：使用ALTER USER语句可以更改角色。ALTER USER是ALTER ROLE的别名，用于更改角色。
有关更多详细信息，请参阅<a href="#_ALTER ROLE">ALTER ROLE</a></p>
<h4 id="analyze"><strong>ANALYZE</strong></h4>
<p>收集有关一个数据库的统计信息
语法：
analyze ::= ANALYZE [ VERBOSE ] [ table_and_columns [ , ... ] ]
table_and_columns ::= table_name [ ( column_name [ , ... ] ) ]
描述：ANALYZE收集一个数据库中的表的内容的统计信息。
参数：
VERBOSE：允许显示进度消息。
table_name：要分析的一个指定表的名称（可以是模式限定的），默认分析当前数据库中的所有常规表。
column_name：要分析的一个指定列的名称。默认是所有列。
示例：
示例1：分析一个表</p>
<div class="highlight"><pre><span></span><code>ANALYZE some_table;
</code></pre></div>
<p>示例2：分析指定的列</p>
<div class="highlight"><pre><span></span><code>ANALYZE some_table(col1, col3);
</code></pre></div>
<p>示例3：分析多个表</p>
<div class="highlight"><pre><span></span><code>ANALYZE VERBOSE some_table, other_table;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>INFO:  analyzing &quot;public.some_table&quot;
INFO:  &quot;some_table&quot;: scanned, 3 rows in sample, 3 estimated total rows
INFO:  analyzing &quot;public.other_table&quot;
INFO:  &quot;other_table&quot;: scanned, 3 rows in sample, 3 estimated total rows
</code></pre></div>
<p>ANALYZE
示例4：分析查询计划，此示例演示统计信息如何影响优化器。 
创建表，并插入一些数据</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE test(a int primary key, b int);
INSERT INTO test VALUES (1, 1), (2, 2), (3, 3);
</code></pre></div>
<p>在没有统计信息的情况下，优化器使用硬编码的默认值，例如表中的行数为1000。</p>
<div class="highlight"><pre><span></span><code>EXPLAIN select * from test where b = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>                       QUERY PLAN
---------------------------------------------------------
 Seq Scan on test  (cost=0.00..102.50 rows=1000 width=8)
   Filter: (b = 1)
</code></pre></div>
<p>现在运行ANALYZE命令来收集统计信息。 </p>
<div class="highlight"><pre><span></span><code>ANALYZE test;
EXPLAIN select * from test where b = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>                     QUERY PLAN
----------------------------------------------------
 Seq Scan on test  (cost=0.00..0.31 rows=3 width=8)
   Filter: (b = 1)
</code></pre></div>
<p>一旦优化器对表中的数据有了更好的了解，它就能够创建性能更好的查询计划。 </p>
<h4 id="begin"><strong>BEGIN</strong></h4>
<p>开始一个事务块
语法：
begin ::= BEGIN [ TRANSACTION | WORK ] [ transaction_mode [ ... ] ]</p>
<p>描述：BEGIN开始一个事务块，也就是说所有 BEGIN命令之后的所有语句将被在一个事务中执行，直到给出一个显式的COMMIT或者ROLLBACK。
参数：
WORK | TRANSACTION：可选的关键词。它们没有效果。
transaction_mode：支持Serializable、Snapshot和Read Committed Isolation，分别使用Serializable、REPEATABLE Read和Read Committed的PostgreSQL隔离级别语法。PostgreSQL的READ UNCOMITTED也映射到READ Committed Isolation。 
只有当TServer标志bm_enable_read_committed_isolation设置为true时，才支持读取提交隔离。默认情况下，此标志为false，在这种情况下，AiSQL事务层的Read Committed隔离级别会回落到更严格的快照隔离（在这种情况中，BSQL的Read Committed和Read UNCOMITTED也依次使用快照隔离）。
示例：
创建表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sample(k1 int, k2 int, v1 int, v2 text, PRIMARY KEY (k1, k2));
</code></pre></div>
<p>开启一个事务，并插入一些数据：</p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
INSERT INTO sample(k1, k2, v1, v2) VALUES (1, 2.0, 3, &#39;a&#39;), (1, 3.0, 4, &#39;b&#39;);
</code></pre></div>
<p>使用bsqlsh启动一个新的shell，然后开始另一个事务来插入更多的行。</p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
INSERT INTO sample(k1, k2, v1, v2) VALUES (2, 2.0, 3, &#39;a&#39;), (2, 3.0, 4, &#39;b&#39;);
</code></pre></div>
<p>在每个shell中，检查是否只有当前事务中的行可见。
在第一个shell中，执行：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2 
----+----+----+----
  1 |  2 |  3 | a
  1 |  3 |  4 | b
</code></pre></div>
<p>在第二个shell中，执行：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2 
----+----+----+----
  2 |  2 |  3 | a
  2 |  3 |  4 | b
</code></pre></div>
<p>提交第一个事务并中止第二个事务。
在第一个shell中，执行：</p>
<div class="highlight"><pre><span></span><code>COMMIT TRANSACTION; 
</code></pre></div>
<p>中止当前事务（从第二个shell）。</p>
<div class="highlight"><pre><span></span><code>ABORT TRANSACTION;
</code></pre></div>
<p>在每个shell中，检查是否只有来自提交事务的行可见。 </p>
<p>在第一个shell中，执行：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2 
----+----+----+----
  1 |  2 |  3 | a
  1 |  3 |  4 | b
</code></pre></div>
<p>在第二个shell中，执行：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2 
----+----+----+----
  1 |  2 |  3 | a
  1 |  3 |  4 | b
</code></pre></div>
<h4 id="call"><strong>CALL</strong></h4>
<p>调用一个过程
语法：
call_procedure ::= CALL subprogram_name ( [ actual_arg [ , ... ] ] )
actual_arg ::= [ formal_arg =&gt; ] expression
formal_arg ::= name</p>
<p>描述：CALL执行一个存储过程。如果过程有任何输出参数，那么将返回一个结果行，其中包含这些参数的值。调用方必须同时具有要调用过程所在架构的使用权限和执行权限。如果调用方缺乏所需的使用权限，则会导致以下错误： </p>
<p>42501: permission denied for schema %"
如果调用方具有所需的使用权限，但缺少所需的执行权限，则会导致以下错误： 
42501: permission denied for procedure %</p>
<p>注意：
如果CALL在事务块中执行，则它无法执行事务控制语句。该尝试导致此运行时错误：2D000: invalid transaction termination
当调用CALL时将autocommit设置为on时，允许使用事务控制语句——在这种情况下，过程在自己的事务中执行。 
示例：
创建一个简单的存储过程：</p>
<div class="highlight"><pre><span></span><code>set client_min_messages = warning;
drop procedure if exists p(text, int) cascade;
create procedure p(
  caption in text default &#39;Caption&#39;,
  int_val in int default 17)
  language plpgsql
as $body$
begin
  raise info &#39;Result: %: %&#39;, caption, int_val::text;
end;
$body$;
</code></pre></div>
<p>执行此存储过程：</p>
<div class="highlight"><pre><span></span><code>call p(&#39;Forty-two&#39;, 42);
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>INFO:  Result: Forty-two: 42
</code></pre></div>
<p>省略第二个默认参数： </p>
<div class="highlight"><pre><span></span><code>call p(&#39;&quot;int_val&quot; default is&#39;);
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>INFO:  Result: &quot;int_val&quot; default is: 17
</code></pre></div>
<p>省略两个默认参数： </p>
<div class="highlight"><pre><span></span><code>call p();
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>INFO:  Result: Caption: 17
</code></pre></div>
<p>通过使用形式参数的名称来调用它。 </p>
<div class="highlight"><pre><span></span><code>call p(caption =&gt; &#39;Forty-two&#39;, int_val=&gt;42);
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>INFO:  Result: Forty-two: 42
</code></pre></div>
<p>仅通过命名的第二个参数调用它。 </p>
<div class="highlight"><pre><span></span><code>call p(int_val=&gt;99);
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>INFO:  Result: Caption: 99
</code></pre></div>
<p>只使用第二个未命名的参数可引发错误。</p>
<div class="highlight"><pre><span></span><code>call p(99);
</code></pre></div>
<p>引发如下错误：</p>
<div class="highlight"><pre><span></span><code>ERROR:  procedure p(integer) does not exist
</code></pre></div>
<h4 id="close"><strong>CLOSE</strong></h4>
<p>关闭一个游标
语法：
close ::= CLOSE { name | ALL }</p>
<p>描述：CLOSE释放与一个已打开游标相关的资源。</p>
<p>参数
name：要关闭的已打开游标的名称。游标仅由非限定名称标识，并且仅在声明它的会话中可见。这决定了其名称的唯一性范围。（在这方面，游标的名称与准备好的语句的名称类似。）</p>
<p>使用关键字ALL代替现存游标的名称会关闭所有现存游标。</p>
<p>示例 ：</p>
<div class="highlight"><pre><span></span><code>close all;

start transaction;
  declare &quot;Cur-One&quot; no scroll cursor without hold for
  select 17 as v;

  declare &quot;Cur-Two&quot; no scroll cursor with hold for
  select 42 as v;

  select name, is_holdable::text, is_scrollable::text
  from pg_cursors
  order by name;

  close &quot;Cur-One&quot;;
commit;

select name, is_holdable::text, is_scrollable::text
from pg_cursors
order by name;

fetch all from &quot;Cur-Two&quot;;
</code></pre></div>
<p>第一个pg_cursors查询返回信息如下： </p>
<div class="highlight"><pre><span></span><code>  name   | is_holdable | is_scrollable 
---------+-------------+---------------
 Cur-One | false       | false
 Cur-Two | true        | false
</code></pre></div>
<p>第二个pg_cursors查询返回信息如下：</p>
<div class="highlight"><pre><span></span><code>  name   | is_holdable | is_scrollable 
---------+-------------+---------------
 Cur-Two | true        | false
</code></pre></div>
<p>从“Cur Two”中获取全部的结果返回信息如下： </p>
<div class="highlight"><pre><span></span><code> v  
----
 42
</code></pre></div>
<h4 id="comment"><strong>COMMENT</strong></h4>
<p>定义或者更改一个对象的注释
语法：
comment_on ::= COMMENT ON 
               { ACCESS METHOD access_method_name
                 | AGGREGATE aggregate_name ( aggregate_signature )
                 | CAST ( source_type AS target_type )
                 | COLLATION object_name
                 | COLUMN relation_name . column_name
                 | CONSTRAINT constraint_name ON table_name
                 | CONSTRAINT constraint_name ON DOMAIN domain_name
                 | CONVERSION object_name
                 | DATABASE object_name
                 | DOMAIN object_name
                 | EXTENSION object_name
                 | EVENT TRIGGER object_name
                 | FOREIGN DATA WRAPPER object_name
                 | FOREIGN TABLE object_name
                 | FUNCTION subprogram_name ( [ subprogram_signature ] 
                   ) | INDEX object_name
                 | LARGE OBJECT large_object_oid
                 | MATERIALIZED VIEW object_name
                 | OPERATOR operator_name ( operator_signature )
                 | OPERATOR CLASS object_name USING index_method
                 | OPERATOR FAMILY object_name USING index_method
                 | POLICY policy_name ON table_name
                 | [ PROCEDURAL ] LANGUAGE object_name
                 | PROCEDURE subprogram_name ( 
                   [ subprogram_signature ] )
                 | PUBLICATION object_name
                 | ROLE object_name
                 | ROUTINE subprogram_name ( [ subprogram_signature ] 
                   ) | RULE rule_name ON table_name
                 | SCHEMA object_name
                 | SEQUENCE object_name
                 | SERVER object_name
                 | STATISTICS object_name
                 | SUBSCRIPTION object_name
                 | TABLE object_name
                 | TABLESPACE object_name
                 | TEXT SEARCH CONFIGURATION object_name
                 | TEXT SEARCH DICTIONARY object_name
                 | TEXT SEARCH PARSER object_name
                 | TEXT SEARCH TEMPLATE object_name
                 | TRIGGER trigger_name ON table_name
                 | TYPE object_name
                 | VIEW object_name } IS { text_literal | NULL }</p>
<p>描述：COMMENT存储关于一个数据库对象的注释。若要删除注释，请将值设置为NULL。
示例：
示例1：增加注释：</p>
<div class="highlight"><pre><span></span><code>COMMENT ON DATABASE postgres IS &#39;Default database&#39;;
COMMENT ON INDEX index_name IS &#39;Special index&#39;;
</code></pre></div>
<p>示例2：删除注释：</p>
<div class="highlight"><pre><span></span><code>COMMENT ON TABLE some_table IS NULL;
</code></pre></div>
<h4 id="commit"><strong>COMMIT</strong></h4>
<p>提交当前事务
语法：
commit ::= COMMIT [ TRANSACTION | WORK ]</p>
<p>描述：使用COMMIT语句提交当前事务。事务所做的所有更改对其他人都是可见的，并保证在发生崩溃时是持久的。</p>
<p>参数：
WORK | TRANSACTION：可选的关键词。它们没有效果。
示例：
创建表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sample(k1 int, k2 int, v1 int, v2 text, PRIMARY KEY (k1, k2));
</code></pre></div>
<p>开启一个事务，并插入一些数据：</p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
INSERT INTO sample(k1, k2, v1, v2) VALUES (1, 2.0, 3, &#39;a&#39;), (1, 3.0, 4, &#39;b&#39;);
</code></pre></div>
<p>用bsqlsh启动一个新的shell，然后开始另一个事务来插入更多的行。</p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
INSERT INTO sample(k1, k2, v1, v2) VALUES (2, 2.0, 3, &#39;a&#39;), (2, 3.0, 4, &#39;b&#39;);
</code></pre></div>
<p>在每个shell中，检查是否只有当前事务中的行可见。
在第一个shell中：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2
----+----+----+----
  1 |  2 |  3 | a
  1 |  3 |  4 | b
</code></pre></div>
<p>在第二个shell中：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2
----+----+----+----
  2 |  2 |  3 | a
  2 |  3 |  4 | b
</code></pre></div>
<p>提交第一个事务并中止第二个事务。 
在第一个shell中：</p>
<div class="highlight"><pre><span></span><code>COMMIT TRANSACTION; 
</code></pre></div>
<p>在第二个shell中：</p>
<div class="highlight"><pre><span></span><code>ABORT TRANSACTION; 
</code></pre></div>
<p>在每个shell中，检查是否只有来自提交事务的行可见。 </p>
<p>在第一个shell中，执行：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2 
----+----+----+----
  1 |  2 |  3 | a
  1 |  3 |  4 | b
</code></pre></div>
<p>在第二个shell中，执行：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2 
----+----+----+----
  1 |  2 |  3 | a
  1 |  3 |  4 | b
</code></pre></div>
<h4 id="copy"><strong>COPY</strong></h4>
<p>在一个文件和一个表之间复制数据
语法：
copy_from ::= COPY table_name [ ( column_name [ , ... ] ) ]  FROM 
              { 'filename' | PROGRAM 'command' | STDIN }<br />
              [ [ WITH ] ( copy_option [ , ... ] ) ]</p>
<p>copy_to ::= COPY { table_name [ ( column_names ) ] | subquery }  TO 
            { 'filename' | PROGRAM 'command' | STDOUT }<br />
            [ [ WITH ] ( copy_option [ , ... ] ) ]</p>
<p>copy_option ::= FORMAT format_name
                | OIDS [ boolean ]
                | FREEZE [ boolean ]
                | DELIMITER 'delimiter_character'
                | NULL 'null_string'
                | HEADER [ boolean ]
                | QUOTE 'quote_character'
                | ESCAPE 'escape_character'
                | FORCE_QUOTE { ( column_names ) | * }
                | FORCE_NOT_NULL ( column_names )
                | FORCE_NULL ( column_names )
                | ENCODING 'encoding_name'
                | ROWS_PER_TRANSACTION int_literal
                | DISABLE_FK_CHECK
                | REPLACE
                | SKIP int_literal</p>
<p>参数：
table_name：一个现有表的名称（可以是模式限定的）。
column_name：可选的要被复制的列列表。如果没有指定列列表，则该表的所有列都会被复制。
query：指定要复制其结果的SELECT、VALUES、INSERT、UPDATE或DELETE语句。对于INSERT、UPDATE和DELETE语句，必须提供RETURNING子句。
filename：指定要复制的文件的路径。输入文件名可以是绝对路径或相对路径，但输出文件名必须是绝对路径。至关重要的是，该文件必须位于您所连接的TServer的本地文件系统的服务器端。
要使用驻留在客户端上的文件，请指定stdin作为FROM的参数，或指定stdout作为To的参数。
或者，您可以在bsqlsh中使用\copy meta命令。
STDIN 与 STDOUT：指定输入或输出来自客户端应用。
如果从用Python等语言编写的客户端程序中执行COPY TO或COPY FROM语句，则无法使用bsqlsh功能。相反，您必须依靠所选语言的功能将stdin和stdout连接到指定的文件。
但是，如果使用bsqlsh执行COPY FROM，则可以进一步选择在以.sql脚本启动的文件的开头包含COPY调用。如下进行一个测试：</p>
<div class="highlight"><pre><span></span><code>drop table if exists t cascade;
create table t(c1 text primary key, c2 text, c3 text);
</code></pre></div>
<p>并准备t.sql，脚本内容如下：</p>
<div class="highlight"><pre><span></span><code>copy t(c1, c2, c3) from stdin with (format &#39;csv&#39;, header true);
c1,c2,c3
dog,cat,frog
\.
</code></pre></div>
<p>请注意 . 终止符。您只需在bsqlsh提示符下执行\i t.sql即可复制数据。 </p>
<p>ROWS_PER_TRANSACTION：ROWS_PER_TRANSACTION选项定义了COPY命令要使用的事务大小。
默认值：20000。
例如，如果要复制的元组总数为5000，并且ROWS_PER_TRANSACTION设置为1000，则数据库将创建5个事务，每个事务将插入1000行。如果在执行复制命令的过程中出现错误，则可以基于已完成的事务持久化一些元组。这意味着，如果在插入第3500行之后发生错误，那么前3000行将被保留在数据库中。
1 to 1000 → Transaction_1
1001 to 2000 → Transaction_2
2001 to 3000 → Transaction_3
3001 to 3500 → Error
前3000行将持久化到表中，tuples_processed将显示3000行。
REPLACE：如果新行的主键/唯一键与现有行的主键冲突，REPLACE选项将替换表中的现有行。
请注意，REPLACE不适用于具有1个以上唯一约束的表。
默认：默认情况下报告冲突错误。
DISABLE_FK_CHECK：将新行复制到表时，DISABLE_FK_CHECK选项将跳过外键检查。
默认值：默认情况下，当未提供DISABLE_FK_check选项时，始终执行外键检查。
SKIP n：SKIP n选项跳过文件的前n行。n必须是非负整数。
默认值：0，不跳过任何行。</p>
<p>示例：
假设有如下表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE users(id BIGSERIAL PRIMARY KEY, name TEXT);
INSERT INTO users(name) VALUES (&#39;John Doe&#39;), (&#39;Jane Doe&#39;), (&#39;Dorian Gray&#39;);
</code></pre></div>
<p>示例1：导出整个表
使用绝对路径将整个表复制到CSV文件中，标题中包含列名。 </p>
<div class="highlight"><pre><span></span><code>COPY users TO &#39;/home/bigmath/users.txt.sql&#39; DELIMITER &#39;,&#39; CSV HEADER;
</code></pre></div>
<p>示例2：使用带列选择的WHERE子句导出分部表
在以下示例中，WHERE子句用于筛选行，而仅用于筛选名称列。 
COPY (SELECT name FROM users where name='Dorian Gray') TO '/home/bigmath/users.txt.sql' DELIMITER ',' CSV HEADER;</p>
<p>示例3：从CSV文件导入</p>
<p>在下面的示例中，在前面的示例中导出的数据将导入到users表中 </p>
<div class="highlight"><pre><span></span><code>COPY users FROM &#39;/home/bigmath/users.txt.sql&#39; DELIMITER &#39;,&#39; CSV HEADER;
</code></pre></div>
<p>示例4：使用跳过行导入
假设我们运行了一次命令，但它在中间失败了，就好像服务器崩溃了一样。由于我们使用ROWS_PER_TRANSACTION=5000，我们可以以5000的倍数恢复导入： </p>
<div class="highlight"><pre><span></span><code>COPY users FROM &#39;/home/bigmath/users.txt.sql&#39; WITH (FORMAT CSV,HEADER, DELIMITER &#39;,&#39;, ROWS_PER_TRANSACTION 5000, SKIP 50000);
</code></pre></div>
<p>示例5：导入并替换行
如果数据库中存在重复的行，我们可以使用REPLACE来追加新行： </p>
<div class="highlight"><pre><span></span><code>COPY users FROM &#39;/home/bigmath/users.txt.sql&#39; WITH (FORMAT CSV,HEADER, DELIMITER &#39;,&#39;, REPLACE);
</code></pre></div>
<p>示例6：导入时禁用外键检查
如果我们确定外键引用的行已经存在，我们可以禁用对它们的检查，以加快导入速度：</p>
<div class="highlight"><pre><span></span><code>COPY users FROM &#39;/home/bigmath/users.txt.sql&#39; WITH (FORMAT CSV,HEADER, DELIMITER &#39;,&#39;, DISABLE_FK_CHECK);
</code></pre></div>
<p>示例7：使用多个参数</p>
<div class="highlight"><pre><span></span><code>COPY users FROM &#39;/home/bigmath/users.txt.sql&#39; WITH (FORMAT CSV,HEADER, DELIMITER &#39;,&#39;, ROWS_PER_TRANSACTION 5000, DISABLE_FK_CHECK, REPLACE, SKIP 50);
</code></pre></div>
<h4 id="create-aggregate"><strong>CREATE AGGREGATE</strong></h4>
<p>定义一个新的聚集函数
语法：
create_aggregate ::= create_aggregate_normal
                     | create_aggregate_order_by
                     | create_aggregate_old</p>
<p>create_aggregate_normal ::= CREATE AGGREGATE aggregate_name ( 
                            { aggregate_arg [ , ... ] | * } )  ( SFUNC 
                            = sfunc , STYPE = state_data_type 
                            [ , aggregate_normal_option [ ... ] ] )</p>
<p>create_aggregate_order_by ::= CREATE AGGREGATE aggregate_name ( 
                              [ aggregate_arg [ , ... ] ] ORDER BY 
                              aggregate_arg [ , ... ] )  ( SFUNC = 
                              sfunc , STYPE = state_data_type 
                              [ , aggregate_order_by_option [ ... ] ] 
                              )</p>
<p>create_aggregate_old ::= CREATE AGGREGATE aggregate_name ( BASETYPE = 
                         base_type ,  SFUNC = sfunc , STYPE = 
                         state_data_type 
                         [ , aggregate_old_option [ ... ] ] )</p>
<p>aggregate_arg ::= [ aggregate_arg_mode ] [ formal_arg ] arg_type</p>
<p>aggregate_normal_option ::= SSPACE = state_data_size
                            | FINALFUNC = ffunc
                            | FINALFUNC_EXTRA
                            | FINALFUNC_MODIFY = 
                              { READ_ONLY | SHAREABLE | READ_WRITE }
                            | COMBINEFUNC = combinefunc
                            | SERIALFUNC = serialfunc
                            | DESERIALFUNC = deserialfunc
                            | INITCOND = initial_condition
                            | MSFUNC = msfunc
                            | MINVFUNC = minvfunc
                            | MSTYPE = mstate_data_type
                            | MSSPACE = mstate_data_size
                            | MFINALFUNC = mffunc
                            | MFINALFUNC_EXTRA
                            | MFINALFUNC_MODIFY = 
                              { READ_ONLY | SHAREABLE | READ_WRITE }
                            | MINITCOND = minitial_condition
                            | SORTOP = sort_operator
                            | PARALLEL = 
                              { SAFE | RESTRICTED | UNSAFE }</p>
<p>aggregate_order_by_option ::= SSPACE = state_data_size
                              | FINALFUNC = ffunc
                              | FINALFUNC_EXTRA
                              | FINALFUNC_MODIFY = 
                                { READ_ONLY | SHAREABLE | READ_WRITE }
                              | INITCOND = initial_condition
                              | PARALLEL = 
                                { SAFE | RESTRICTED | UNSAFE }
                              | HYPOTHETICAL</p>
<p>aggregate_old_option ::= SSPACE = state_data_size
                         | FINALFUNC = ffunc
                         | FINALFUNC_EXTRA
                         | FINALFUNC_MODIFY = 
                           { READ_ONLY | SHAREABLE | READ_WRITE }
                         | COMBINEFUNC = combinefunc
                         | SERIALFUNC = serialfunc
                         | DESERIALFUNC = deserialfunc
                         | INITCOND = initial_condition
                         | MSFUNC = msfunc
                         | MINVFUNC = minvfunc
                         | MSTYPE = mstate_data_type
                         | MSSPACE = mstate_data_size
                         | MFINALFUNC = mffunc
                         | MFINALFUNC_EXTRA
                         | MFINALFUNC_MODIFY = 
                           { READ_ONLY | SHAREABLE | READ_WRITE }
                         | MINITCOND = minitial_condition
                         | SORTOP = sort_operator</p>
<p>描述：CREATE AGGREGATE定义一个新的聚集函数。选项的顺序无关紧要，即使是强制性选项BASETYPE、SFUNC和STYPE，也可能以任何顺序出现。
示例：
示例1：正常语法示例</p>
<div class="highlight"><pre><span></span><code>CREATE AGGREGATE sumdouble (float8) (
              STYPE = float8,
              SFUNC = float8pl,
              MSTYPE = float8,
              MSFUNC = float8pl,
              MINVFUNC = float8mi
           );
CREATE TABLE normal_table(
             f float8,
             i int
           );
INSERT INTO normal_table(f, i) VALUES
             (0.1, 9),
             (0.9, 1);
SELECT sumdouble(f), sumdouble(i) FROM normal_table;
</code></pre></div>
<p>示例2：</p>
<div class="highlight"><pre><span></span><code>CREATE AGGREGATE oldcnt(
             SFUNC = int8inc,
             BASETYPE = &#39;ANY&#39;,
             STYPE = int8,
             INITCOND = &#39;0&#39;
           );
SELECT oldcnt(*) FROM pg_aggregate;
</code></pre></div>
<p>示例3：零参数聚合示例</p>
<div class="highlight"><pre><span></span><code>CREATE AGGREGATE newcnt(*) (
             SFUNC = int8inc,
             STYPE = int8,
             INITCOND = &#39;0&#39;,
             PARALLEL = SAFE
           );
SELECT newcnt(*) FROM pg_aggregate;
</code></pre></div>
<h4 id="create-cast"><strong>CREATE CAST</strong></h4>
<p>定义一种新的造型
语法：
create_cast ::= create_cast_with_function
                | create_cast_without_function
                | create_cast_with_inout</p>
<p>create_cast_with_function ::= CREATE CAST ( cast_signature ) WITH 
                              FUNCTION  subprogram_name 
                              [ ( subprogram_signature ) ] 
                              [ AS ASSIGNMENT | AS IMPLICIT ]</p>
<p>create_cast_without_function ::= CREATE CAST ( cast_signature ) 
                                 WITHOUT FUNCTION 
                                 [ AS ASSIGNMENT | AS IMPLICIT ]</p>
<p>create_cast_with_inout ::= CREATE CAST ( cast_signature ) WITH INOUT 
                           [ AS ASSIGNMENT | AS IMPLICIT ]</p>
<p>cast_signature ::= source_type AS target_type</p>
<p>描述：CREATE CAST定义一种新的造型。 一种造型指定如何在两种数据类型之间执行转换。例如，SELECT CAST(42 AS float8);
通过调用一个之前指定的函数（这种情况中是 float8(int4)）把整型常量 42 转换成类型 float8（如果没有定义合适的造型， 该转换会失败）。
默认情况下，只有一次显式造型请求才会调用造型， 形式是CAST(x AS typename) or x::typename。
如果造型被标记为AS ASSIGNMENT，那么在为一个目标数据 类型的列赋值时会隐式地调用它。例如，假设foo.f1是 一个类型text的列，那么如果从类型integer 到类型text的造型被标记为AS ASSIGNMENT， 则：</p>
<p>INSERT INTO foo (f1) VALUES (42);
将被允许，否则不会允许（我们通常使用赋值造型 来描述此类造型）。</p>
<p>如果造型被标记为AS IMPLICIT，那么可以在任何上下文 中隐式地调用它，无论是赋值还是在一个表达式内部（我们通常用术语 隐式造型来描述这类造型）。例如，考虑这个 查询：</p>
<div class="highlight"><pre><span></span><code>SELECT 2 + 4.0;
</code></pre></div>
<p>解析器初始会把常量分别标记为类型integer和 numeric。在系统目录中没有integer + numeric操作符，但是有一个 numeric + numeric操作符。 因此，如果有一种可用的从integer到 numeric的造型且被标记为AS IMPLICIT — 实际上确实有 — 该查询将会成功。解析器将应用该隐式造型 并且解决该查询，就好像它被写成：</p>
<div class="highlight"><pre><span></span><code>SELECT CAST ( 2 AS numeric ) + 4.0;
</code></pre></div>
<p>参数：
source_type：该造型的源数据类型的名称。
target_type：该造型的目标数据类型的名称。
create_cast_with_function:被用于执行该造型的函数。函数名称可以用模式限定。如果没有被限定，将在模式搜索路径中查找该函数。函数的结果数据类型必须是该造型的 目标数据类型。它的参数讨论如下。如果没有指定参数列表，则该函数名称在其模式中必须是唯一的。
create_cast_without_function:指示源类型可以二进制强制到目标类型，因此执行该造型不需要函数。
create_cast_with_inout:指示该造型是一种 I/O 转换造型，执行需要调用源数据类型的输出函数，并且把结果字符串传递给目标数据类型的输入函数。</p>
<p>AS ASSIGNMENT:指示该造型可以在赋值的情况下被隐式调用。
AS IMPLICIT:指示该造型可以在任何上下文中被隐式调用。
示例：
示例1：WITH FUNCTION</p>
<div class="highlight"><pre><span></span><code>CREATE FUNCTION sql_to_date(integer) RETURNS date AS $$
             SELECT $1::text::date
             $$ LANGUAGE SQL IMMUTABLE STRICT;
CREATE CAST (integer AS date) WITH FUNCTION sql_to_date(integer) AS ASSIGNMENT;
SELECT CAST (20200603 AS date);
</code></pre></div>
<p>示例2：WITHOUT FUNCTION</p>
<div class="highlight"><pre><span></span><code>CREATE TYPE myfloat4;
CREATE FUNCTION myfloat4_in(cstring) RETURNS myfloat4
             LANGUAGE internal IMMUTABLE STRICT PARALLEL SAFE AS &#39;float4in&#39;;
CREATE FUNCTION myfloat4_out(myfloat4) RETURNS cstring
             LANGUAGE internal IMMUTABLE STRICT PARALLEL SAFE AS &#39;float4out&#39;;
CREATE TYPE myfloat4 (
             INPUT = myfloat4_in,
             OUTPUT = myfloat4_out,
             LIKE = float4
           );
SELECT CAST(&#39;3.14&#39;::myfloat4 AS float4);
CREATE CAST (myfloat4 AS float4) WITHOUT FUNCTION;
SELECT CAST(&#39;3.14&#39;::myfloat4 AS float4);
</code></pre></div>
<p>示例3：WITH INOUT</p>
<div class="highlight"><pre><span></span><code>CREATE TYPE myint4;
CREATE FUNCTION myint4_in(cstring) RETURNS myint4
             LANGUAGE internal IMMUTABLE STRICT PARALLEL SAFE AS &#39;int4in&#39;;
CREATE FUNCTION myint4_out(myint4) RETURNS cstring
             LANGUAGE internal IMMUTABLE STRICT PARALLEL SAFE AS &#39;int4out&#39;;
CREATE TYPE myint4 (
             INPUT = myint4_in,
             OUTPUT = myint4_out,
             LIKE = int4
           );
SELECT CAST(&#39;2&#39;::myint4 AS int4);
CREATE CAST (myint4 AS int4) WITH INOUT;
SELECT CAST(&#39;2&#39;::myint4 AS int4);
</code></pre></div>
<h4 id="create-database"><strong>CREATE DATABASE</strong></h4>
<p>创建一个新数据库
语法：
create_database ::= CREATE DATABASE name [ create_database_options ]</p>
<p>create_database_options ::= [ WITH ] [ OWNER [ = ] user_name ]<br />
                            [ TEMPLATE [ = ] template_name ]<br />
                            [ ENCODING [ = ] encoding ]<br />
                            [ LC_COLLATE [ = ] lc_collate ]<br />
                            [ LC_CTYPE [ = ] lc_ctype ]<br />
                            [ ALLOW_CONNECTIONS [ = ] allowconn ]<br />
                            [ CONNECTION LIMIT [ = ] connlimit ]<br />
                            [ IS_TEMPLATE [ = ] istemplate ]<br />
                            [ COLOCATION [ = ] { 'true' | 'false' } ]
描述：CREATE DATABASE创建一个新的AiSQL数据库。
参数：
name：要创建的数据库名。
[ WITH ] OWNER user_name：指定将拥有新数据库的用户的角色名称。如果未指定，则数据库创建者为所有者。
TEMPLATE template：指定用于创建新数据库的模板的名称。
ENCODING encoding：指定要在新数据库中使用的字符集编码。
LC_COLLATE lc_collate：要在新数据库中使用的排序规则顺序。
LC_CTYPE lc_ctype：要在新数据库中使用的字符分类。
ALLOW_CONNECTIONS allowconn：指定false以禁止连接到数据库。默认值为true，允许连接到数据库。
CONNECTION_LIMIT connlimit：指定可以与此数据库建立的并发连接数。-1 （默认值）表示没有限制。
IS_TEMPLATE istemplate：如果为真（true），则任何具有CREATEDB权限的用户都可以克隆此数据库；如果为假（false），默认，则指定为仅超级用户或数据库所有者可以克隆它。
COLOCATION：指定为true，则此数据库的表应在单一分片中共址。具体细节，请参阅<a href="#_共址表（colocated table）">共址表</a>，了解共址表的详细信息。
默认值为false，数据库中的每个表都有自己的分片集。
示例：
创建一个共址数据库</p>
<div class="highlight"><pre><span></span><code>CREATE DATABASE company WITH COLOCATION = true;
</code></pre></div>
<p>此例中，数据库company的表将在单一分片中共址。</p>
<h4 id="create-domain"><strong>CREATE DOMAIN</strong></h4>
<p>定义一个新的域
语法：
create_domain ::= CREATE DOMAIN name [ AS ] data_type 
                  [ DEFAULT expression ] 
                  [ [ domain_constraint [ ... ] ] ]</p>
<p>domain_constraint ::= [ CONSTRAINT constraint_name ] 
                      { NOT NULL | NULL | CHECK ( expression ) }</p>
<p>描述：CREATE DOMAIN创建一个新的域。
参数：
name：要被创建的域的名称（可以被模式限定）。
data_type：域的底层数据类型。可以包括数组指示符。
DEFAULT expression：DEFAULT子句为该域数据类型的列指定一个默认值。 该值是任何没有变量的表达式（但不允许子查询）。默认值表达式的数据类型必须匹配域的数据类型。如果没有指定默认值，那么默认值就是空值。
CONSTRAINT constraint_name：一个约束的名称（可选）。如果没有指定，系统会生成一个名称。</p>
<p>NOT NULL：这个域的值通常不能为空值。
NULL：这个域的值允许为空值。这是默认值。
CHECK (expression)：CHECK子句指定该域的值必须满足的完整性约束，每一个约束必须是一个产生布尔结果的表达式。它应该使用关键词VALUE来引用要被测试的值。计算为 TRUE 或者 UNKNOWN 的表达式成功。如果该表达式产生一个 FALSE 结果，会报告一个错误并且该值不允许被转换成该域类型。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE DOMAIN phone_number AS TEXT CHECK(VALUE ~ &#39;^\d{3}-\d{3}-\d{4}$&#39;);
CREATE TABLE person(first_name TEXT, last_name TEXT, phone_number phone_number);
</code></pre></div>
<h4 id="create-extension"><strong>CREATE EXTENSION</strong></h4>
<p>安装一个扩展
语法：
create_extension ::= CREATE EXTENSION [ IF NOT EXISTS ] extension_name 
                      [ WITH ] [ SCHEMA schema_name ] 
                     [ VERSION version ] [ CASCADE ]</p>
<p>描述： CREATE EXTENSION把一个新的扩展载入到当前数据库中。不能有同名扩展已经被载入。
参数：
IF NOT EXISTS：已有同名扩展存在时不要抛出错误。这种情况下会发出一个提示。 注意，不保证现有的扩展与将要从当前可用的脚本文件创建的脚本有任何相似。
extension_name：要安装的扩展的名称。
schema_name：假定该扩展允许其内容被重定位，这是要在其中安装该扩展的对象的 模式名称。被提到的模式必须已经存在。
version：要安装的扩展的版本。这可以写成一个标识符或者一个字符串。 默认版本在该扩展的控制文件中指定。
CASCADE：自动安装这个扩展所依赖的任何还未安装的扩展。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE SCHEMA myschema;
CREATE EXTENSION pgcrypto WITH SCHEMA myschema VERSION &#39;1.3&#39;;

CREATE EXTENSION IF NOT EXISTS earthdistance CASCADE;
</code></pre></div>
<h4 id="create-foreign-data-wrapper"><strong>CREATE FOREIGN DATA WRAPPER</strong></h4>
<p>定义一个新的外部数据包装器
语法：
create_foreign_data_wrapper ::= CREATE FOREIGN DATA WRAPPER fdw_name<br />
                                [ HANDLER handler_name | NO HANDLER ] 
                                [ VALIDATOR validator_name
                                  | NO VALIDATOR ] 
                                [ OPTIONS ( fdw_options ) ]
描述：CREATE FOREIGN DATA WRAPPER创建一个新的外部数据包装器。定义外部数据包装器的用户将成为它的拥有者。
参数：
HANDLER：将调用handler_function来检索外部表的执行函数。这些功能是规划者和执行者所必需的。处理程序函数不接受任何参数，其返回类型应为fdw_handler。如果没有提供处理程序函数，则只能声明（而不能访问）使用包装器的外部表。
VALIDATOR：validator_function用于验证提供给外部数据包装器的选项，以及使用外部数据包装的外部服务器、用户映射和外部表。验证器函数有两个参数：一个文本数组（类型为text[]），其中包含要验证的选项，另一个是类型 oid，它将是包含该选项的系统目录的 OID，与选项关联的对象存储在该OID中。如果没有提供验证器函数（或未指定validator），则在创建时不会检查选项。
OPTIONS：这个子句为新的外部数据包装器指定选项。允许的选项名称和值与每一个外部数据包装器有关，并且它们会被该外部数据包装器的验证器函数验证。 选项名称必须唯一。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE FOREIGN DATA WRAPPER file HANDLER file_fdw_handler;
</code></pre></div>
<h4 id="create-foreign-table"><strong>CREATE FOREIGN TABLE</strong></h4>
<p>定义一个新的外部表
语法：
create_foreign_table ::= CREATE FOREIGN TABLE [ IF NOT EXISTS ] 
                         table_name ( [ foreign_table_elem [ , ... ] ] 
                         )  SERVER server_name 
                         [ OPTIONS ( fdw_options ) ]</p>
<p>描述：CREATE FOREIGN TABLE在当前数据库中创建一个新的外部表。该表将由发出这个命令的用户所拥有。如果指定的数据库中已存在table_name，则除非使用If NOT exists子句，否则将引发错误。</p>
<p>参数：
COLLATE：COLLATE子句为该列（必须是一个可排序的数据类型）赋予一个排序规则。如果没有指定，则会使用该列的数据类型的默认排序规则。
server_name：要用于该外部表的一个现有外部服务器的名称。有关定义一个服务器 的细节可以参考<a href="#_CREATE SERVER">CREATE SERVER</a>。
OPTIONS ：要与新外部表或者它的一个列相关联的选项。被允许的选项名称和值是与每一个外部数据包装器相关的，并且它们会被该外部数据包装器的验证器函数验证。不允许重复的选项名称（不过一个表选项和一个列选项重名是可以的）。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code> CREATE FOREIGN TABLE mytable (col1 int, col2 int) SERVER my_server OPTIONS (schema &#39;external_schema&#39;, table &#39;external_table&#39;);
</code></pre></div>
<h4 id="create-function"><strong>CREATE FUNCTION</strong></h4>
<p>定义一个新函数 
语法：
create_function ::= CREATE [ OR REPLACE ] FUNCTION subprogram_name ( 
                    [ arg_decl_with_dflt [ , ... ] ] )<br />
                    { RETURNS data_type
                      | RETURNS TABLE ( { column_name data_type } 
                        [ , ... ] ) }<br />
                    { unalterable_fn_attribute
                      | alterable_fn_only_attribute
                      | alterable_fn_and_proc_attribute } [ ... ]</p>
<p>arg_decl_with_dflt ::= arg_decl [ { DEFAULT | = } expression ]</p>
<p>arg_decl ::= [ formal_arg ] [ arg_mode ] arg_type</p>
<p>subprogram_signature ::= arg_decl [ , ... ]</p>
<p>unalterable_fn_attribute ::= WINDOW
                             | LANGUAGE lang_name
                             | AS subprogram_implementation</p>
<p>lang_name ::= SQL | PLPGSQL | C</p>
<p>subprogram_implementation ::= ' sql_stmt_list '
                              | ' plpgsql_block_stmt '
                              | ' obj_file ' [ , ' link_symbol ' ]</p>
<p>sql_stmt_list ::= sql_stmt ; [ sql_stmt ... ]</p>
<p>alterable_fn_and_proc_attribute ::= SET run_time_parameter 
                                    { TO value
                                      | = value
                                      | FROM CURRENT }
                                    | RESET run_time_parameter
                                    | RESET ALL
                                    | [ EXTERNAL ] SECURITY 
                                      { INVOKER | DEFINER }</p>
<p>alterable_fn_only_attribute ::= volatility
                                | on_null_input
                                | PARALLEL parallel_mode
                                | [ NOT ] LEAKPROOF
                                | COST int_literal
                                | ROWS int_literal</p>
<p>volatility ::= IMMUTABLE | STABLE | VOLATILE</p>
<p>on_null_input ::= CALLED ON NULL INPUT
                  | RETURNS NULL ON NULL INPUT
                  | STRICT</p>
<p>parallel_mode ::= UNSAFE | RESTRICTED | SAFE</p>
<p>描述：与表等其他模式对象一样，函数不可避免地具有所有者。创建函数时，不能显式指定所有者。相反，它被隐式定义为内置的current_user函数在创建该函数的会话中被调用时返回的内容。此用户必须对函数的模式、参数数据类型和返回数据类型具有使用权限。
CREATE OR REPLACE FUNCTION不会更改已授予现有函数的权限。若要使用此语句，当前用户必须拥有该函数，或者是拥有该函数的角色的成员。
相反，如果您删除并重新创建一个函数，则新函数与旧函数不是同一个实体。因此，您将不得不删除依赖于旧函数的现有对象。（删除函数CASCADE可以实现这一点。）或者，ALTER FUNCTION可以用于更改现有函数的大部分属性。</p>
<p>参数：
subprogram_name：要创建的函数的名称（可以被模式限定）。
arg_mode：一个参数的模式：IN、OUT、INOUT或者VARIADIC。如果省略，默认为IN。
formal_arg：一个参数的名称。
arg_type：该函数参数（如果有）的数据类型（可以是模式限定的）。参数类型可以是基本类型、组合类型或者域类型，或者可以引用一个表列的类型。
{ DEFAULT | = } expression：如果参数没有被指定值时要用作默认值的表达式。
LANGUAGE：默认支持的语言有SQL、PLPGSQL和C。
WINDOW：WINDOW表示该函数是一个窗口函数而不是一个普通函数。当前只用于用 C 编写的函数。在替换一个现有函数定义时，不能更改WINDOW属性。</p>
<p>IMMUTABLE | STABLE | VOLATILE
这些属性告知查询优化器该函数的行为。最多只能指定其中一个。如果这些都不出现，则会默认为VOLATILE。
IMMUTABLE表示该函数不能修改数据库并且对于给定的参数值总是会返回相同的值。也就是说，它不会做数据库查找或者使用没有在其参数列表中直接出现的信息。如果给定合格选项，任何用全常量参数对该函数的额调用可以立刻用该函数值替换。
STABLE表示该函数不能修改数据库，并且对于相同的参数值，它在一次表扫描中将返回相同的结果。但是这种结果在不同的 SQL 语句执行期间可能会变化。对于那些结果依赖于数据库查找、参数变量（例如当前时区）等的函数来说，这是合适的（对希望查询被当前命令修改的行的AFTER触发器不适合）。还要注意current_timestamp函数族适合被标记为稳定，因为它们的值在一个事务内不会改变。
VOLATILE表示该函数的值在一次表扫描中都有可能改变，因此不能做优化。在这种意义上，相对较少的数据库函数是不稳定的，一些示例是random()、currval()、timeofday()。但是注意任何有副作用的函数都必须被分类为不稳定的，即便其结果是可以预测的，这是为了调用被优化掉。一个示例是setval()。
CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
CALLED ON NULL INPUT（默认）表示在某些参数为空值时应正常调用该函数。如果有必要，函数的作者应该负责检查空值并且做出适当的相应。
RETURNS NULL ON NULL INPUT或STRICT表示只要其任意参数为空值，该函数就会返回空值。如果指定了这个参数，当有空值参数时该函数不会被执行，而是自动返回一个空值结果。
[EXTERNAL] SECURITY INVOKER | [EXTERNAL] SECURITY DEFINER
SECURITY INVOKER表示要用调用该函数的用户的特权来执行它。这是默认值。SECURITY DEFINER指定要用拥有该函数的用户的特权来执行该函数。
为了符合 SQL，允许使用关键词EXTERNAL。但是它是可选的，因为与 SQL 中不同，这个特性适用于所有函数而不仅是那些外部函数。
PARALLEL：PARALLEL UNSAFE表示该函数不能在并行模式中运行并且 SQL 语句中存在一个这样的函数会强制使用顺序执行计划。这是默认选项。PARALLEL RESTRICTED表示该函数能在并行模式中运行，但是其执行被限制在并行组的领导者中。PARALLEL SAFE表示该函数对于在并行模式中运行是安全的并且不受限制。
COST int_literal：一个给出该函数的估计执行代价的正数。
ROWS int_literal：一个正数，它给出规划器期望该函数返回的行数估计。只有当该函数被声明为返回一个集合时才允许这个参数。
标量函数和表函数：使用RETURN子句的适当变体创建标量函数或表函数。请注意，标量不仅可以表示int、numeric、text等数据类型（以及基于这些数据类型的域）的原子值；它还可以表示单个复合值，类似于用户定义的类型。 
标量函数示例：</p>
<div class="highlight"><pre><span></span><code>create schema s;

create type s.x as (i int, t text);

create function s.f(i in int, t in text)
  returns s.x
  security invoker
  set search_path = pg_catalog, pg_temp
  language plpgsql
as $body$
begin
  return (i*2, t||t)::s.x;
end;
$body$;

WITH c as (select s.f(42, &#39;dog&#39;) as v)
select
  (v).i, (v).t
FROM c;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> i  |   t    
----+--------
 84 | dogdog
</code></pre></div>
<p>表函数示例：</p>
<div class="highlight"><pre><span></span><code>create table s.t(k serial primary key, v text);
insert into s.t(v) values (&#39;dog&#39;), (&#39;cat&#39;), (&#39;frog&#39;);

create function s.f()
  returns table(z text)
  security definer
  set search_path = pg_catalog, pg_temp
  language plpgsql
as $body$
begin
  z := &#39;Starting content of t &#39;; return next;
  z := &#39;----------------------&#39;; return next;
  for z in (select v from s.t order by k) loop
    return next;
  end loop;

  begin
    insert into s.t(v) values (&#39;mouse&#39;);
  exception
    when string_data_right_truncation then
      z := &#39;&#39;; return next;
      z := &#39;string_data_right_truncation caught&#39;; return next;
  end;

  insert into s.t(v) values (&#39;bird&#39;);

  z := &#39;&#39;; return next;
  z := &#39;Finishing content of t&#39;; return next;
  z := &#39;----------------------&#39;; return next;
  for z in (select v from s.t order by k) loop
    return next;
  end loop;
end;
$body$;

\t on
select z from s.f();
\t off
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> Starting content of t 
 ----------------------
 dog
 cat
 frog

 Finishing content of t
 ----------------------
 dog
 cat
 frog
 mouse
 bird
</code></pre></div>
<h4 id="create-group"><strong>CREATE GROUP</strong></h4>
<p>定义一个新的数据库组角色
语法：
create_group ::= CREATE GROUP role_name 
                 [ [ WITH ] role_option [ , ... ] ]</p>
<p>role_option ::= SUPERUSER
                | NOSUPERUSER
                | CREATEDB
                | NOCREATEDB
                | CREATEROLE
                | NOCREATEROLE
                | INHERIT
                | NOINHERIT
                | LOGIN
                | NOLOGIN
                | CONNECTION LIMIT connlimit
                | [ ENCRYPTED ] PASSWORD  ' password ' 
                | PASSWORD NULL
                | VALID UNTIL  ' timestamp ' 
                | IN ROLE role_name [ , ... ]
                | IN GROUP role_name [ , ... ]
                | ROLE role_name [ , ... ]
                | ADMIN role_name [ , ... ]
                | USER role_name [ , ... ]
                | SYSID uid</p>
<p>有关更多详细信息，请参阅<a href="#_CREATE ROLE">CREATE ROLE</a>。 </p>
<p>示例：
创建一个可以管理数据库和角色的组。</p>
<div class="highlight"><pre><span></span><code>CREATE GROUP SysAdmin WITH CREATEDB CREATEROLE;
</code></pre></div>
<h4 id="create-index"><strong>CREATE INDEX</strong></h4>
<p>定义一个新索引
语法：
create_index ::= CREATE [ UNIQUE ] INDEX 
                 [ CONCURRENTLY | NONCONCURRENTLY ]<br />
                 [ [ IF NOT EXISTS ] name ] ON [ ONLY ] table_name<br />
                 [ USING access_method_name ] ( index_elem [ , ... ] ) 
                  [ INCLUDE ( column_name [ , ... ] ) ]<br />
                 [ TABLESPACE tablespace_name ]<br />
                 [ SPLIT { INTO int_literal TABLETS
                           | AT VALUES ( split_row [ , ... ] ) } ] 
                 [ WHERE boolean_expression ]</p>
<p>index_elem ::= { column_name | ( expression ) } 
               [ operator_class_name ] [ HASH | ASC | DESC ] 
               [ NULLS { FIRST | LAST } ]</p>
<p>描述：定义一个新索引。
当在填充的表上创建索引时，AiSQL会自动将现有数据填充到索引中。在大多数情况下，这使用在线模式迁移。下表解释了联机创建索引和未联机创建索引之间的一些区别。</p>
<table>
<thead>
<tr>
<th>条件</th>
<th>在线</th>
<th>未联机</th>
</tr>
</thead>
<tbody>
<tr>
<td>在CREATE INDEX期间执行其他DML是否安全？</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>在CREATE INDEX期间保持其他事务活动？</td>
<td>通常</td>
<td>否</td>
</tr>
<tr>
<td>是否并行索引加载？</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>虽然默认情况下启用了联机索引回填，但支持CREATE INDEX CONCURRENTLY。一些限制适用（请参阅并发）。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>如果要禁用CREATE INDEX的联机架构迁移，请在所有节点的Master和 TServer上设置标志bsql_disable_index_backfill=true。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>若要禁用一个CREATE INDEX的联机架构迁移，请使用CREATE INDEX NONCURRENTLY。</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>关于共址，索引如下表所示。如果表是共址的，那么它的索引也是共址的；如果表未共址，则其索引也未共址。</p>
<p><strong>分区索引</strong>
在分区表上创建索引会自动为默认表空间中的每个分区创建相应的索引。也可以在每个分区上单独创建索引，在以下情况下应该这样做：</p>
<ul>
<li>创建索引时，期望并行写入，因为在分区表上的并发创建索引还不支持，在这种情况下，最好针对每一个分区单独并发创建索引。 </li>
<li>对应正在使用的行级地理分区，在这种情况下，在每个分区上分别创建索引，以及自定义创建每个索引的表空间。</li>
<li>分区表不支持CREATE INDEX CONCURRENTLY。
  <strong>参数：</strong>
  UNIQUE：强制表中不允许有重复的值。
  CONCURRENTLY：启用联机架构迁移，但有一些限制：</li>
<li>在临时表上创建索引时，将禁用联机架构迁移。</li>
<li>分区表不支持CREATE INDEX CONCURRENTLY。</li>
<li>事务块内不支持CREATE INDEX CONCURRENTLY。</li>
</ul>
<p>NONCONCURRENTLY：禁用联机架构迁移。
ONLY：如果该表是分区表，指示不要在分区上递归创建索引。默认会递归创建索引。
access_method_name：索引访问方法的名称。默认情况下，lsm用于AiSQL表，btree用于其他表（例如，临时表）。可以使用bmgin访问方法在AiSQL中创建GIN索引。 
INCLUDE clause：可选的INCLUDE子句指定一个列的列表，其中的列将被包括在索引中作为非键列。
TABLESPACE clause：指定描述此索引的放置配置的表空间的名称。默认情况下，索引被放置在pg_default表空间中，该表空间将索引的片剂均匀地分布在集群中。
WHERE clause：部分索引是建立在表的子集上的索引，只包括满足WHERE子句中指定条件的行。它可以用于从索引中排除NULL或公共值，或者只包括感兴趣的行。这加快了对表的任何写入，因为包含公共列值的行不需要索引。它还减少了索引的大小，从而提高了使用索引的读取查询的速度。
Name：要创建的索引名称。
table_name：要被索引的表的名称。
index_elem：
column_name：指定表的列名。
Expression：一个基于一个或者更多个表列的表达式，用括号括起来。 </p>
<ul>
<li>HASH-使用列的哈希。这是第一列的默认选项，用于分割索引表。</li>
<li>ASC—按升序排序。这是索引的第二列和后续列的默认选项。</li>
<li>DESC—按降序排序。</li>
<li>NULLS FIRST-指定null在非null之前排序。当指定DESC时，这是默认值。</li>
<li>NULLS LAST-指定null在非null之后排序。这是未指定DESC时的默认值。</li>
</ul>
<p>SPLIT INTO：对于哈希分片索引，可以使用SPLIT INTO子句指定要为索引创建的分片的数量，然后将hash 范围均匀地分布在这些分片上。
使用SPLIT INTO预拆分索引可在生产集群上分配索引工作负载。例如，如果您有3台服务器，将索引拆分为30分片，可以在索引上提供更高的写入吞吐量。
注意：
默认情况下，AiSQL将索引预拆分为bsql_num_shards_per_tserver*num_of_tserver个分片。而SPLIT INTO子句可用于在每个索引的基础上重写该设置。
SPLIT AT VALUES：对于范围分片索引，可以使用SPLIT AT VALUES子句设置拆分点以预拆分范围分片的索引。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE tbl(
  a INT,
  b INT,
  PRIMARY KEY(a ASC, b DESC);
);

CREATE INDEX idx1 ON tbl(b ASC, a DESC) SPLIT AT VALUES((100), (200), (200, 5));
</code></pre></div>
<p>在上面的示例中，有三个分割点，因此将为索引创建四个分片： 
    分片1: b=<lowest>, a=<lowest> to b=100, a=<lowest>
    分片2: b=100, a=<lowest> to b=200, a=<lowest>
    分片3: b=200, a=<lowest> to b=200, a=5
    分片4: b=200, a=5 to b=<highest>, a=<highest></p>
<p>注意： 
默认情况下，AiSQL将创建一个范围分片索引作为单个分片。SPLIT AT子句可用于在每个索引的基础上重写该设置。 </p>
<p><strong>示例：</strong></p>
<p>示例1：具有HASH列排序的唯一索引 
使用哈希排序列创建唯一索引。 </p>
<div class="highlight"><pre><span></span><code>CREATE TABLE products(id int PRIMARY KEY,
                                 name text,
                                 code text);
CREATE UNIQUE INDEX ON products(code);
\d products
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>              Table &quot;public.products&quot;
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 id     | integer |           | not null |
 name   | text    |           |          |
 code   | text    |           |          |
Indexes:
    &quot;products_pkey&quot; PRIMARY KEY, lsm (id HASH)
    &quot;products_code_idx&quot; UNIQUE, lsm (code HASH)
</code></pre></div>
<p>示例2：ASC有序索引
使用升序键创建索引。 </p>
<div class="highlight"><pre><span></span><code>CREATE INDEX products_name ON products(name ASC);
\d products_name
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>   Index &quot;public.products_name&quot;
 Column | Type | Key? | Definition
--------+------+------+------------
 name   | text | yes  | name
lsm, for table &quot;public.products
</code></pre></div>
<p>示例3：INCLUDE 列
使用升序键创建索引，并将其他列包括为非键列。</p>
<div class="highlight"><pre><span></span><code>CREATE INDEX products_name_code ON products(name) INCLUDE (code);
\d products_name_code;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> Index &quot;public.products_name_code&quot;
 Column | Type | Key? | Definition
--------+------+------+------------
 name   | text | yes  | name
 code   | text | no   | code
lsm, for table &quot;public.products&quot;
</code></pre></div>
<p>示例4：创建一个指定分片数量的索引
要指定索引的分片数量，可以将CREATE index语句与SPLIT INTO子句一起使用。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE employees (id int PRIMARY KEY, first_name TEXT, last_name TEXT) SPLIT INTO 10 TABLETS;
CREATE INDEX ON employees(first_name, last_name) SPLIT INTO 10 TABLETS;
</code></pre></div>
<p>示例5：部分索引 
考虑一个维护装运信息的应用程序。它有一个带有delivery_status列的shipments表。如果应用程序需要频繁访问飞行中的装运，则可以使用部分索引来排除装运状态delivered的行。 </p>
<div class="highlight"><pre><span></span><code>create table shipments(id int, delivery_status text, address text, delivery_date date);
create index shipment_delivery on shipments(delivery_status, address, delivery_date) where delivery_status != &#39;delivered&#39;;
</code></pre></div>
<p><strong>故障排除：</strong>
<strong>1.无效索引</strong>
如果联机CREATE INDEX失败，则可能会留下无效索引。这些索引在查询中不可用，并且会导致内部操作，因此应该删除它们。</p>
<p>例如，以下命令可能会创建无效索引：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE uniqueerror (i int);
INSERT INTO uniqueerror VALUES (1), (1);
CREATE UNIQUE INDEX ON uniqueerror (i);
</code></pre></div>
<p>此时报告如下错误信息：</p>
<div class="highlight"><pre><span></span><code>ERROR:  ERROR:  duplicate key value violates unique constraint &quot;uniqueerror_i_idx&quot;
\d uniqueerror
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>            Table &quot;public.uniqueerror&quot;
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 i      | integer |           |          |
Indexes:
    &quot;uniqueerror_i_idx&quot; UNIQUE, lsm (i HASH) INVALID
</code></pre></div>
<p>删除无效索引，如下所示： </p>
<div class="highlight"><pre><span></span><code>DROP INDEX uniqueerror_i_idx;
</code></pre></div>
<p><strong>2.常见错误及解决方案</strong>
错误1. ERROR: duplicate key value violates unique constraint "uniqueerror_i_idx"
原因：创建唯一索引时，发现违反了唯一约束。
修复：解决发生冲突的行。 </p>
<p>错误2. ERROR: Backfilling indexes { timeoutmaster_i_idx } for tablet 42e3857759f54733a47e3bb817636f60 from key '' in state kFailed
原因：服务器端回填超时，重复命中。
修复：执行以下任何一项或全部操作： 
增加BM-Master 标志bsql_index_backfill_rpc_timeout_ms，从60000（1分钟）到300000 （5分钟）。
增加BM-TServer 标志backfill_index_timeout_grace_margin_ms，从-1（1秒）到60000 （1分钟）。
减少BM-TServer 标志backfill_index_write_batch_size ，从128 到 32。</p>
<p>错误3. ERROR: BackfillIndex RPC (request call id 123) to 127.0.0.1:9100 timed out after 86400.000s
原因：客户端回填超时。
修复：在回填过程中，master  leader可能发生了变化。目前不支持此操作。请重试创建索引，并密切关注master  leader。</p>
<p>尝试增加并行性。索引回填在表的每个分片上并行进行。RF-3设置中的一个一分片表不会利用这种并行性。对于范围分区表和共址表，一分片表是默认的。另一方面，无论有多大的并行性，一分片索引都会成为索引回填写入的瓶颈。拆分分片则可以改善分区。
如果回填确实需要更多时间，请将TServer标志backfill_index_client_rpc_timeout_ms增加到回填所需的时间（例如，一周）。 
要在索引回填期间优先考虑保持其他事务的有效性，请将以下各项设置为大于预期的最长事务： 
    BM-Master 标志index_backfill_wait_for_old_txns_ms
    BSQL参数bsql_bm_index_state_flags_update_delay</p>
<p>当您知道不会有联机写入时，要将索引创建速度加快几秒钟，请将BSQL参数bsql_bm_index_state_flags_update_delay设置为零。 </p>
<h4 id="create-materialized-view"><strong>CREATE MATERIALIZED VIEW</strong></h4>
<p>定义一个新的物化视图
语法：
create_matview ::= CREATE MATERIALIZED VIEW [ IF NOT EXISTS ]<br />
                   matview_name [ ( column_name [ , ... ] ) ]<br />
                   [ WITH ( storage_parameters ) ]<br />
                   [ TABLESPACE tablespace_name ]  AS subquery 
                   [ WITH [ NO ] DATA ]</p>
<p>描述：创建一个名为matview_name的物化视图。如果指定的数据库中已存在matview_name，则除非使用If NOT exists子句，否则将引发错误。
参数：
Tablespace：用于指定物化视图的表空间。
storage_parameters：</p>
<p>COLOCATION：为要共址的物化视图指定COLOCATION=true。此选项的默认值为false。 </p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE t1(a int4, b int4);
INSERT INTO t1 VALUES (2, 4), (3, 4);
CREATE MATERIALIZED VIEW m1 AS SELECT * FROM t1 WHERE a = 3;
SELECT * FROM t1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> a | b
---+---
 3 | 4
 2 | 4
</code></pre></div>
<h4 id="create-operator"><strong>CREATE OPERATOR</strong></h4>
<p>定义一个新的操作符
语法：
create_operator ::= CREATE OPERATOR operator_name  ( 
                    { FUNCTION = subprogram_name
                      | PROCEDURE = subprogram_name } 
                    [ , operator_option [ ... ] ] )</p>
<p>operator_option ::= LEFTARG = left_type
                    | RIGHTARG = right_type
                    | COMMUTATOR = com_op
                    | NEGATOR = neg_op
                    | RESTRICT = res_proc
                    | JOIN = join_proc
                    | HASHES
                    | MERGES
描述：CREATE OPERATOR定义一个新的操作符 name。定义操作符的用户会成为该操作符的拥有者。如果给出一个模式名，该操作符将被创建在指定的模式中。否则它会被创建在当前模式中。
操作符名称是最多NAMEDATALEN-1（默认为 63） 个字符的序列，这些字符可以是：+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?</p>
<p>参数：
operator_name：要定义的操作符的名称。允许使用的字符请见上文。名称可以被模式限定，例如CREATE OPERATOR myschema.+ (...)。如果没有被模式限定，该操作符将被创建在当前模式中。如果两个同一模式中的操作符在不同的数据类型上操作，它们可以具有相同的名称。这被称为重载。
subprogram_name：用来实现这个操作符的函数。
left_type：这个操作符的左操作数（如果有）的数据类型。忽略这个选项可以表示一个左一元操作符。
right_type：这个操作符的右操作数（如果有）的数据类型。忽略这个选项可以表示一个右一元操作符。
com_op：这个操作符的交换子。
neg_op：这个操作符的求反器。
res_proc：用于这个操作符的限制选择度估计函数。
join_proc：用于这个操作符的连接选择度估算函数。
HASHES：表示这个操作符可以支持哈希连接。
MERGES：表示这个操作符可以支持归并连接。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE OPERATOR @#@ (
             rightarg = int8,
             procedure = numeric_fac
           );
SELECT @#@ 5;
</code></pre></div>
<h4 id="create-operator-class"><strong>CREATE OPERATOR CLASS</strong></h4>
<p>定义一个新的操作符类
语法：
create_operator_class ::= CREATE OPERATOR CLASS operator_class_name 
                          [ DEFAULT ] FOR TYPE data_type  USING 
                          index_method AS operator_class_as [ , ... ]</p>
<p>operator_class_as ::= OPERATOR strategy_number operator_name 
                      [ ( operator_signature ) ] [ FOR SEARCH ]
                      | FUNCTION support_number 
                        [ ( op_type [ , ... ] ) ] subprogram_name ( 
                        subprogram_signature )
                      | STORAGE storage_type</p>
<p>描述：定义一个新的操作符类
参数：
operator_class_name：要创建的操作符类的名称。该名称可以被模式限定。
DEFAULT：如果存在，该操作符类将成为其数据类型的默认操作符类。对一种特定的数据类型和索引方法至多有一个默认操作符类。
data_type：这个操作符类所用于的列数据类型。
index_method：这个操作符类所用于的索引方法的名称。
strategy_number：用于一个与该操作符类相关联的操作符的索引方法策略号。
operator_name：一个与该操作符类相关联的操作符的名称（可以被模式限定）。
op_type：在一个OPERATOR子句中，这表示该操作符的操作数数据类型，或者用NONE来表示一个左一元或者右一元操作符。在操作数数据类型与该操作符的数据类型相同的一般情况下，操作数的数据类型可以被省略。
在一个FUNCTION子句中，这表示该函数要支持的操作数数据类型，如果它与该函数的输入数据类型（对于 B-树比较函数和哈希函数）或者操作符类的数据类型（对于 B-树排序支持函数和所有GiST、 SP-GiST、GIN 和 BRIN 操作符类中的函数）不同。这些默认值是正确的，并且op_type因此不必在FUNCTION子句中被指定，对于B-树排序支持函数的情况来说，这表示跨数据类型比较。
support_number：用于一个与该操作符类相关联的函数的索引方法支持函数编号。
subprogram_name：一个用于该操作符类的索引方法支持函数的函数名称（可以是模式限定的）。
storage_type：实际存储在索引中的数据类型。通常这和列数据类型相同，但是有些 索引方法（当前有 GiST、GIN 和 BRIN）允许它们不同。除非索引方法允许使用不同的类型，STORAGE子句必须被省略。 如果data_type列被指定为anyarray，那么storage_type可以被声明为anyelement以指示索引条目是属于为每个特定索引创建的实际数组类型的元素类型的成员。
OPERATOR、FUNCTION和STORAGE 子句可以以任何顺序出现。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE OPERATOR CLASS my_op_class
           FOR TYPE int4
           USING btree AS
           OPERATOR 1 &lt;,
           OPERATOR 2 &lt;=;
</code></pre></div>
<h4 id="create-policy"><strong>CREATE POLICY</strong></h4>
<p>为一个表定义一条新的行级安全性策略</p>
<p>语法：
create_policy ::= CREATE POLICY name ON table_name 
                  [ AS { PERMISSIVE | RESTRICTIVE } ]<br />
                  [ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ] 
                  [ TO { role_name
                         | PUBLIC
                         | CURRENT_USER
                         | SESSION_USER } [ , ... ] ]<br />
                  [ USING ( using_expression ) ] 
                  [ WITH CHECK ( check_expression ) ]</p>
<p>描述：CREATE POLICY为一个表定义一条行级安全性策略。注意为了应用已被创建的策略，在表上必须启用行级安全性（使用ALTER TABLE ... ENABLE ROW LEVEL SECURITY）。
参数：
name：要创建的策略的名称。
table_name：该策略适用的表的名称（可以被模式限定）。
PERMISSIVE | RESTRICTIVE：指定策略是宽容性的还是限制性的。在将策略应用于表时，宽容性的策略使用逻辑OR运算符组合在一起，而限制策略使用逻辑AND运算符组合。限制性策略用于减少可访问的记录数量。默认为宽容性的。 
role_name：该策略适用的角色。默认是PUBLIC，它将把策略应用到所有的角色。
using_expression：任意的SQL条件表达式（返回 boolean）。该条件表达式不能包含任何聚集或者窗口函数。如果行级安全性被启用，这个表达式将被增加到引用该表的查询。让这个表达式返回真的行将可见。让这个表达式返回假或者空的任何行将对用户不可见（在SELECT中）并且将对修改不可用（ 在UPDATE或DELETE中）。这类行 会被悄悄地禁止而不会报告错误。只有条件返回true的行才会在SELECT中可见，并可在UPDATE或DELETE中进行修改。 
check_expression：任意的SQL条件表达式（返回 boolean），仅用于INSERT和UPDATE查询。该条件表达式不能包含任何聚集或者窗口 函数。如果行级安全性被启用，这个表达式将被用在该表上的 INSERT以及 UPDATE查询中。INSERT或UPDATE中只允许表达式计算结果为true的行。如果任何被插入的记录或者跟新后的记录导致该表达式计算为假或者空，则会抛出一个错误。请注意，与using_expression不同，check_expression 是根据行中建议的新内容而不是原始内容进行评估的。</p>
<p>示例：
示例1：创建一个宽容性策略。 </p>
<div class="highlight"><pre><span></span><code>CREATE POLICY p1 ON document
  USING (dlevel &lt;= (SELECT level FROM user_account WHERE user = current_user));
</code></pre></div>
<p>示例2：创建一个限制性策略。</p>
<div class="highlight"><pre><span></span><code>CREATE POLICY p_restrictive ON document AS RESTRICTIVE TO user_bob
    USING (cid &lt;&gt; 44);
</code></pre></div>
<p>示例3：为插入创建具有CHECK条件的策略。</p>
<div class="highlight"><pre><span></span><code>CREATE POLICY p2 ON document FOR INSERT WITH CHECK (dauthor = current_user);
</code></pre></div>
<h4 id="create-procedure"><strong>CREATE PROCEDURE</strong></h4>
<p>定义一个新的存储过程</p>
<p>语法：
create_procedure ::= CREATE [ OR REPLACE ] PROCEDURE subprogram_name ( 
                     [ arg_decl_with_dflt [ , ... ] ] )<br />
                     { unalterable_proc_attribute
                       | alterable_fn_and_proc_attribute } [ ... ]</p>
<p>arg_decl_with_dflt ::= arg_decl [ { DEFAULT | = } expression ]</p>
<p>arg_decl ::= [ formal_arg ] [ arg_mode ] arg_type</p>
<p>subprogram_signature ::= arg_decl [ , ... ]</p>
<p>unalterable_proc_attribute ::= LANGUAGE lang_name
                               | AS subprogram_implementation</p>
<p>lang_name ::= SQL | PLPGSQL | C</p>
<p>subprogram_implementation ::= ' sql_stmt_list '
                              | ' plpgsql_block_stmt '
                              | ' obj_file ' [ , ' link_symbol ' ]</p>
<p>sql_stmt_list ::= sql_stmt ; [ sql_stmt ... ]</p>
<p>alterable_fn_and_proc_attribute ::= SET run_time_parameter 
                                    { TO value
                                      | = value
                                      | FROM CURRENT }
                                    | RESET run_time_parameter
                                    | RESET ALL
                                    | [ EXTERNAL ] SECURITY 
                                      { INVOKER | DEFINER }</p>
<p>描述：定义一个新的存储过程，存储过程和表等其他模式对象一样，不可避免地有一个所有者。创建存储过程时，不能显式指定所有者。相反，它被隐式定义为current_user内置函数在创建过程的会话中被调用时返回的内容。此用户必须对存储过程的架构及其参数数据类型具有使用权限。具有不同参数类型的过程可以共享同一个名称（这被称为重载）。
要替换一个已有存储过程的当前定义，请使用CREATE OR REPLACE PROCEDURE。不能用这种方式更改存储过程的名称或者参数类型（如果尝试这样做，实际上会创建一个新的、不同的存储过程）。
当CREATE OR REPLACE PROCEDURE被用来替换一个现有的存储过程时，该存储过程的拥有关系和权限保持不变。所有其他的存储过程属性会被赋予这个命令中指定的或者暗示的值。必须拥有（包括成为拥有角色的成员）该存储过程才能替换它。
创建存储过程的用户将成为该存储过程的拥有者。
为了能够创建一个存储过程，用户必须具有参数类型上的USAGE特权。</p>
<p>示例：</p>
<p>创建accounts表，及插入一些数据。</p>
<div class="highlight"><pre><span></span><code>create schema s;

create table s.accounts (
  id integer primary key,
  name text not null,
  balance decimal(15,2) not null);

insert into s.accounts values (1, &#39;Jane&#39;, 100.00);
insert into s.accounts values (2, &#39;John&#39;, 50.00);

select * from s.accounts order by 1;
</code></pre></div>
<p>定义将资金从一个帐户转移到另一个帐户的存储过程。</p>
<div class="highlight"><pre><span></span><code>create or replace procedure s.transfer(from_id in int, to_id in int, amnt in decimal)
  security definer
  set search_path = pg_catalog, pg_temp
  language plpgsql
as $body$
begin
  if amnt &lt;= 0.00 then
    raise exception &#39;The transfer amount must be positive&#39;;
  end if;
  if from_id = to_id then
    raise exception &#39;Sender and receiver cannot be the same&#39;;
  end if;
  update s.accounts set balance = balance - amnt where id = from_id;
  update s.accounts set balance = balance + amnt where id = to_id;
end;
$body$;

Jane转账$20.00给John：
call s.transfer(1, 2, 20.00);
select * from s.accounts order by 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> id | name | balance
----+------+---------
  1 | Jane |   80.00
  2 | John |   70.00
(2 rows)
</code></pre></div>
<p>不受支持的参数值将会引发错误：</p>
<div class="highlight"><pre><span></span><code>CALL s.transfer(2, 2, 20.00);
</code></pre></div>
<p>错误信息如下：</p>
<div class="highlight"><pre><span></span><code>ERROR:  Sender and receiver cannot be the same
</code></pre></div>
<div class="highlight"><pre><span></span><code>call s.transfer(1, 2, -20.00);
</code></pre></div>
<p>错误信息如下：</p>
<div class="highlight"><pre><span></span><code>ERROR:  The transfer amount must be positive
</code></pre></div>
<h4 id="create-role"><strong>CREATE ROLE</strong></h4>
<p>定义一个新的数据库角色</p>
<p>语法：
create_role ::= CREATE ROLE role_name 
                [ [ WITH ] role_option [ , ... ] ]</p>
<p>role_option ::= SUPERUSER
                | NOSUPERUSER
                | CREATEDB
                | NOCREATEDB
                | CREATEROLE
                | NOCREATEROLE
                | INHERIT
                | NOINHERIT
                | LOGIN
                | NOLOGIN
                | CONNECTION LIMIT connlimit
                | [ ENCRYPTED ] PASSWORD  ' password ' 
                | PASSWORD NULL
                | VALID UNTIL  ' timestamp ' 
                | IN ROLE role_name [ , ... ]
                | IN GROUP role_name [ , ... ]
                | ROLE role_name [ , ... ]
                | ADMIN role_name [ , ... ]
                | USER role_name [ , ... ]
                | SYSID uid</p>
<p>描述：定义一个新的数据库角色
使用CREATE ROLE语句将角色添加到AiSQL数据库集群中。角色是一个可以拥有数据库对象并具有数据库权限的实体。角色可以是用户或组，具体取决于其使用方式。具有LOGIN的角色可以被视为“用户”。您必须具有CREATE ROLE权限或是数据库超级用户才能使用此命令。
请注意，角色是在BSQL集群级别定义的，因此在集群中的所有数据库中都是有效的。
可以使用GRANT/REVOKE命令设置/删除角色的权限。</p>
<p>参数：
role_name：新角色的名称。
SUPERUSER，NOSUPERUSER：确定新角色是否为“超级用户”。超级用户可以覆盖所有访问限制，应谨慎使用。只有具有SUPERUSER权限的角色才能创建其他SUPERUSER角色。如果未指定，则默认为NOSUPERUSER。
CREATEDB，NOCREATEDB：确定新角色是否可以创建数据库。默认为NOCREATEDB。
CREATEROLE，NOCREATEROLE：确定新角色是否可以创建其他角色。默认值为NOCREATEROLE。 
INHERIT，NOINHERIT：确定新角色是否继承其所属角色的特权。如果没有INHERIT，另一个角色的成员资格只能授予该角色设置角色的能力。其他角色的权限只有在完成后才可用。如果未指定，则默认为INHERIT。
LOGIN，NOLOGIN：确定是否允许新角色登录。只有具有登录权限的角色才能在客户端连接期间使用。具有LOGIN的角色可以被视为用户。如果未指定，则默认为NOLOGIN。请注意，如果使用CREATE USER语句而不是CREATE ROLE，则默认值为LOGIN。
CONNECTION LIMIT：指定角色可以进行的并发连接数。默认值为-1，表示不受限制。这仅适用于可以登录的角色。
[ENCRYPTED] PASSWORD：设置新角色的密码。这只适用于可以登录的角色。如果未指定密码，则密码将设置为null，并且该用户的密码身份验证将始终失败。请注意，密码始终加密存储在系统目录中，可选关键字encrypted仅用于与PostgreSQL兼容。 
VALID UNTIL：设置角色密码不再有效的日期和时间。如果省略此子句，密码将始终有效。 
IN ROLE ROLE_name，IN GROUP ROLE_name：列出一个或多个现有角色，新角色将作为新成员立即添加到这些角色中。（请注意，没有以管理员身份添加新角色的选项；请使用单独的GRANT命令来执行此操作。） 
ROLE role_name, USER role_name：列出一个或多个自动添加为新角色成员的现有角色。 
ADMIN role_name：与role role_name类似，但已命名的角色将添加到新角色WITH ADMIN OPTION中，使他们有权将此角色的成员资格授予其他人。
SYSID uid：仅为了与Postgres兼容，SYSID uid被忽略。 
示例：
示例1：创建一个可以登录的角色。</p>
<div class="highlight"><pre><span></span><code>CREATE ROLE John LOGIN; 
</code></pre></div>
<p>示例2：创建一个可以登录并具有密码的角色。 </p>
<div class="highlight"><pre><span></span><code>CREATE ROLE Jane LOGIN PASSWORD &#39;password&#39;;
</code></pre></div>
<p>示例3：创建一个可以管理数据库和角色的角色。</p>
<div class="highlight"><pre><span></span><code>CREATE ROLE SysAdmin CREATEDB CREATEROLE;
</code></pre></div>
<h4 id="create-rule"><strong>CREATE RULE</strong></h4>
<p>定义一条新的重写规则</p>
<p>语法：
create_rule ::= CREATE [ OR REPLACE ] RULE rule_name AS ON rule_event 
                TO table_name  [ WHERE boolean_expression ] DO 
                [ ALSO | INSTEAD ] { NOTHING
                                     | command
                                     | ( command [ ; ... ] ) }</p>
<p>rule_event ::= SELECT | INSERT | UPDATE | DELETE</p>
<p>command ::= SELECT | INSERT | UPDATE | DELETE | NOTIFY</p>
<p>描述：CREATE RULE定义一条应用于指定表或视图的新规则。
参数：
rule_name：要创建的规则的名称。它必须与同一个表上任何其他规则的名称相区分。 同一个表上同一种事件类型的多条规则会按照其名称的字符顺序被应用。
rule_event：是SELECT、 INSERT、UPDATE或者 DELETE之一。 注意包含ON CONFLICT子句的INSERT 不能被用在具有INSERT或者 UPDATE规则的表上。那种情况下请考虑使用可更新的视图。
table_name：规则适用的表或者视图的名称（可以是模式限定的）。
boolean_expression：任意的SQL条件表达式（返回 boolean）。该条件表达式不能引用除NEW以及 OLD之外的任何表，并且不能包含聚集函数。
INSTEAD：INSTEAD指示该命令应该取代原始命令被执行。
ALSO：ALSO指示应该在原始命令 之外执行这些命令。
如果ALSO和INSTEAD都没有被指定， 默认是ALSO。
command：组成规则动作的命令。可用的命令有SELECT、 INSERT、UPDATE、 DELETE或者NOTIFY。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE t1(a int4, b int4);
CREATE TABLE t2(a int4, b int4);
CREATE RULE t1_to_t2 AS ON INSERT TO t1 DO INSTEAD
             INSERT INTO t2 VALUES (new.a, new.b);
INSERT INTO t1 VALUES (3, 4);
SELECT * FROM t1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> a | b
---+---
(0 rows)
SELECT * FROM t2;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> a | b 
---+---
 3 | 4
(1 rows)
</code></pre></div>
<h4 id="create-schema"><strong>CREATE SCHEMA</strong></h4>
<p>定义一个新模式</p>
<p>语法：
create_schema_name ::= CREATE SCHEMA [ IF NOT EXISTS ] schema_name 
                       [ AUTHORIZATION role_specification ]</p>
<p>create_schema_role ::= CREATE SCHEMA [ IF NOT EXISTS ] AUTHORIZATION 
                       role_specification</p>
<p>role_specification ::= role_name | CURRENT_USER | SESSION_USER</p>
<p>描述：定义一个新模式
使用CREATE SCHEMA语句在当前数据库中创建模式。模式本质上是一个命名空间：它包含命名对象（表、数据类型、函数和运算符），这些对象的名称可以与其他模式中的对象的名称重复。可以使用模式名称作为前缀或在搜索路径中设置模式名称来访问模式中的命名对象。
参数：
schema_name：创建的架构的名称。如果未指定schema_name，则使用角色名称。架构名称不得以pg_开头。尝试使用这样的名称创建模式，或将现有模式重命名为具有这样的名称，都会导致错误。
role_name：是将拥有新模式的角色。如果省略，则默认为执行命令的用户。若要创建另一个角色拥有的架构，您必须是该角色的直接或间接成员，或者是超级用户。</p>
<p>示例：
示例1：创建一个模式 </p>
<div class="highlight"><pre><span></span><code>CREATE SCHEMA IF NOT EXISTS branch;
</code></pre></div>
<p>示例2：为用户创建模式 </p>
<div class="highlight"><pre><span></span><code>CREATE ROLE John;
CREATE SCHEMA AUTHORIZATION john;
</code></pre></div>
<p>示例3：创建一个将由另一个角色拥有的模式</p>
<div class="highlight"><pre><span></span><code>CREATE SCHEMA branch AUTHORIZATION john;
</code></pre></div>
<h4 id="create-sequence"><strong>CREATE SEQUENCE</strong></h4>
<p>定义一个新的序列发生器
语法：
create_sequence ::= CREATE [ TEMPORARY | TEMP ] SEQUENCE 
                    [ IF NOT EXISTS ] sequence_name sequence_options</p>
<p>sequence_name ::= qualified_name</p>
<p>sequence_options ::= [ INCREMENT [ BY ] int_literal ]<br />
                     [ MINVALUE int_literal | NO MINVALUE ] 
                     [ MAXVALUE int_literal | NO MAXVALUE ] 
                     [ START [ WITH ] int_literal ]<br />
                     [ CACHE positive_int_literal ] [ [ NO ] CYCLE ]</p>
<p>描述：定义一个新的序列发生器。指定序列的名称（sequence_name）。如果当前模式中已存在具有该名称的序列，并且未指定if NOT exists，则会引发错误。</p>
<p>参数：
TEMPORARY | TEMP：使用此限定符将创建一个临时序列。临时序列仅在创建它们的当前客户端会话中可见，并在会话结束时自动删除。
INCREMENT BY int_literal：指定要添加到当前序列值以创建新值的增量值。默认值为1。
MINVALUE int_literal | NO MINVALUE：指定序列中允许的最小值。如果达到这个值（在负增量的序列中），nextval（）将返回一个错误。如果未指定MINVALUE，则将使用默认值。默认值为1。
MAXVALUE int_literal | NO MAXVALUE：指定序列中允许的最大值。如果达到该值，nextval（）将返回一个错误。如果未指定MAXVALUE，则将使用默认值。默认值为2⁶³-1。
START WITH int_literal：指定序列中的第一个值。start不能小于minvalue。默认值为1。
CACHE int_literal：指定要在客户端中缓存序列中的数字数量。默认值为100。
当TServer bsql_sequence_cache_minval配置标志未显式关闭（设置为0）时，将使用该标志和缓存子句的最大值。
[ NO ] CYCLE：如果指定了CYCLE，则一旦达到minvalue或maxvalue，序列就会回卷。如果达到了maxvalue，则minvalue将是序列中的下一个数字。如果达到minvalue（对于递减序列），maxvalue将是序列中的下一个数字。NO CYCLE（无循环）是默认值。
Cache：
在BSQL中，就像在PostgreSQL中一样，序列的数据存储在一个持久系统表中。在BSQL中，该表每个序列有一行，并以两个值存储序列数据：
last_val：存储上次使用的值或下一个要使用的值 
is_called：存储是否已使用的last_val。如果为false，last_val是序列中的下一个值。否则，last_val+INCREMENT为下一个值。
默认情况下（当INCREMENT为1时），每次调用nextval()都会更新该序列的last_val。在BSQL中，保存序列数据的表被复制，而不是在本地文件系统中。对该表的每次更新都需要两个RPC（将来将优化为一个RPC）。在任何情况下，在BSQL中调用nextval()所经历的延迟都将显著高于Postgres中的相同操作。为了避免这种性能下降，AiSQL建议使用一个足够大的缓存值。缓存的值存储在本地节点的内存中，检索这些值可以避免任何RPC，因此一个缓存分配的延迟可以分摊到为缓存分配的所有数字上。
SERIAL类型创建一个具有默认值为1的缓存的序列。因此，应该避免使用SERIAL类型，并且应该使用它们的等效语句。不要像这样创建SERIAL类型的表： </p>
<div class="highlight"><pre><span></span><code>CREATE TABLE t(k SERIAL)
</code></pre></div>
<p>您应该首先创建一个具有足够大缓存的序列，然后将要具有串行类型的列设置为DEFAULT，以设置序列的nextval()。</p>
<div class="highlight"><pre><span></span><code>CREATE SEQUENCE t_k_seq CACHE 10000;
CREATE TABLE t(k integer NOT NULL DEFAULT nextval(&#39;t_k_seq&#39;));
</code></pre></div>
<p>示例：</p>
<p>示例1：创建一个简单序列，每次调用nextval()时递增1。</p>
<div class="highlight"><pre><span></span><code>CREATE SEQUENCE s;
</code></pre></div>
<p>示例2：创建一个具有10000个值的缓存的序列。 </p>
<div class="highlight"><pre><span></span><code>CREATE SEQUENCE s2 CACHE 10000;
</code></pre></div>
<p>在同一个会话中，执行</p>
<div class="highlight"><pre><span></span><code>SELECT nextval(&#39;s2&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> nextval
---------
       1
</code></pre></div>
<p>在不同的会话中，执行</p>
<div class="highlight"><pre><span></span><code>SELECT nextval(&#39;s2&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> nextval
---------
   10001
</code></pre></div>
<p>示例3：创建一个从0开始的序列。MINVALUE从默认值1更改为小于或等于0。 </p>
<div class="highlight"><pre><span></span><code>CREATE SEQUENCE s3 START 0 MINVALUE 0;
</code></pre></div>
<h4 id="create-server"><strong>CREATE SERVER</strong></h4>
<p>定义一个新的外部服务器
语法：
create_server ::= CREATE SERVER [ IF NOT EXISTS ] server_name<br />
                  [ TYPE server_type ] [ VERSION server_version ]<br />
                  FOREIGN DATA WRAPPER fdw_name 
                  [ OPTIONS ( fdw_options ) ]</p>
<p>描述：CREATE SERVER定义一个新的外部服务器。 定义该服务器的用户会成为拥有者。外部服务器通常包装了外部数据包装器用来访问一个外部数据源所需的连接信息。额外的用户相关的连接信息可以通过用户映射的方式来指定。
服务器名称在数据库中必须唯一。
创建服务器要求所使用的外部数据包装器上的USAGE特权。
如果指定的数据库中已存在server_name，则除非使用If NOT exists子句，否则将引发错误。</p>
<p>参数：
Type：可选的服务器类型。
Server Version：可选的服务器版本。
FDW name：FOREIGN DATA WRAPPER子句可用于指定外部数据包装的名称。
Options：OPTIONS子句指定外部服务器的选项。它们通常定义服务器的连接详细信息，但实际允许的选项名称和值特定于服务器的外部数据包装器。 
示例：</p>
<div class="highlight"><pre><span></span><code>CREATE SERVER my_server FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host &#39;187.51.62.1&#39;);
</code></pre></div>
<h4 id="create-table"><strong>CREATE TABLE</strong></h4>
<p>定义一个新表。</p>
<p>语法：
create_table ::= CREATE [ TEMPORARY | TEMP ] TABLE [ IF NOT EXISTS ] 
                 table_name ( [ table_elem [ , ... ] ] )<br />
                 [ WITH ( { COLOCATION = { 'true' | 'false' }
                            | storage_parameters } )
                   | WITHOUT OIDS ]  [ TABLESPACE tablespace_name ] 
                 [ SPLIT { INTO positive_int_literal TABLETS
                           | AT VALUES ( split_row [ , ... ] ) } ]</p>
<p>table_elem ::= column_name data_type [ column_constraint [ ... ] ]
               | table_constraint</p>
<p>column_constraint ::= [ CONSTRAINT constraint_name ] 
                      { NOT NULL
                        | NULL
                        | CHECK ( expression )
                        | DEFAULT expression
                        | UNIQUE index_parameters
                        | PRIMARY KEY
                        | references_clause }<br />
                      [ DEFERRABLE | NOT DEFERRABLE ] 
                      [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]</p>
<p>table_constraint ::= [ CONSTRAINT constraint_name ] 
                     { CHECK ( expression )
                       | UNIQUE ( column_names ) index_parameters
                       | PRIMARY KEY ( key_columns )
                       | FOREIGN KEY ( column_names ) 
                         references_clause }<br />
                     [ DEFERRABLE | NOT DEFERRABLE ] 
                     [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]</p>
<p>key_columns ::= hash_columns [ , range_columns ] | range_columns</p>
<p>hash_columns ::= column_name [ HASH ] | ( column_name [ , ... ] ) HASH</p>
<p>range_columns ::= { column_name { ASC | DESC } } [ , ... ]</p>
<p>storage_parameters ::= storage_parameter [ , ... ]</p>
<p>storage_parameter ::= param_name [ = param_value ]</p>
<p>index_parameters ::= [ INCLUDE ( column_names ) ] 
                     [ WITH ( storage_parameters ) ]<br />
                     [ USING INDEX TABLESPACE tablespace_name ]</p>
<p>references_clause ::= REFERENCES table_name [ column_name [ , ... ] ] 
                      [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]<br />
                      [ ON DELETE key_action ] 
                      [ ON UPDATE key_action ]</p>
<p>split_row ::= ( column_value [ , ... ] )
描述：CREATE TABLE将在当前数据库中创建一个新的、初始为空的表。
<strong>参数：</strong>
TEMPORARY 或TEMP：如果指定，该表被创建为一个临时表。临时表会被在会话结束时自动被删除，或者也可以选择在当前事务结束时删除。当临时表存在时，已有的同名持久表将对于当前会话不可见，不过可以使用模式限定的名称进行引用。在一个临时表上创建的任何索引也自动地变为临时的。
IF NOT EXISTS：如果一个同名表已经存在，不要抛出一个错误。在这种情况下会发出一个提示。注意这不保证现有的关系是和将要被创建的表相似的东西。
table_name：要被创建的表名（可以选择用模式限定）。
column_name：列的名称。
data_type：列的数据类型。
CONSTRAINT constraint_name：一个列约束或表约束的可选名称。如果该约束被违背，约束名将会出现在错误消息中。如果没有指定约束名，系统将生成一个。
NOT NULL：该列不允许包含空值。
NULL：该列允许包含空值。这是默认情况。
CHECK ( expression )：CHECK指定一个产生布尔结果的表达式，一个插入或更新操作要想成功，其中新的或被更新的行必须满足该表达式。计算出 TRUE 或 UNKNOWN 的表达式就会成功。只要任何一个插入或更新操作的行产生了 FALSE 结果，将报告一个错误异常并且插入或更新不会修改数据库。一个被作为列约束指定的检查约束只应该引用该列的值，而一个出现在表约束中的表达式可以引用多列。</p>
<p>DEFAULT expression：DEFAULT子句为出现在其定义中的列赋予一个默认数据。该值是可以使用变量的表达式（特别是，不允许用对其他列的交叉引用）。子查询也是不允许的。 默认值表达式的数据类型必须匹配列的数据类型。
默认值表达式将被用在任何没有为该列指定值的插入操作中。如果一列没有默认值，那么默认值为空值。
UNIQUE （列约束） |  UNIQUE ( column_names ) index_parameters (表约束)：UNIQUE约束指定一个表中的一列或多列组成的组包含唯一的值。唯一表约束的行为与列约束的行为相同，只是表约束能够跨越多列。
对于一个唯一约束的目的来说，空值不被认为是相等的。
每一个唯一表约束必须命名一个列的集合，并且它与该表上任何其他唯一或主键约束所命名的列集合都不相同。
PRIMARY KEY （列约束） |  PRIMARY KEY ( key_columns ) (表约束)：PRIMARY KEY约束指定表的一个或者多个列只能包含唯一（不重复）、非空的值。一个表上只能指定一个主键，可以作为列约束或表约束。
references_clause （列约束） |  FOREIGN KEY ( column_names ) references_clause(表约束)：这些子句指定一个外键约束，它要求新表的一列或一个列的组必须只包含能匹配被引用表的某个行在被引用列上的值。 如果refcolumn列表被忽略，将使用reftable的主键。 被引用列必须是被引用表中一个非可延迟唯一约束或主键约束的列。 用户必须在被引用的表（或整个表,或特定的引用列）上拥有REFERENCES权限。 增加的外键约束需要SHARE ROW EXCLUSIVE 锁定引用的表。 注意外键约束不能在临时表和永久表之间定义。 此外请注意，虽然可以在分区表上定义外键，但不能够声明引用分区表的外键。
被插入到引用列的一个值会使用给定的匹配类型与被引用表的值进行匹配。 有三种匹配类型：MATCH FULL、MATCH PARTIAL以及MATCH SIMPLE（这是默认值）。 MATCH FULL将不允许一个多列外键中的一列为空，除非所有外键列都是空；如果它们都是空，则不要求该行在被引用表中有一个匹配。 MATCH SIMPLE允许任意外键列为空，如果任一为空，则不要求该行在被引用表中有一个匹配。 MATCH PARTIAL现在还没有被实现。
另外，当被引用列中的数据被改变时，在这个表的列中的数据上可以执行特定的动作。ON DELETE指定当被引用表中一个被引用行被删除时要执行的动作。同样，ON UPDATE指定当被引用表中一个被引用列被更新为新值时要执行的动作。如果该行被更新，但是被引用列并没有被实际改变，不会做任何动作。除了NO ACTION检查之外的引用动作不能被延迟，即便该约束被声明为可延迟的。对每一个子句可能有以下动作：
NO ACTION：产生一个错误指示删除或更新将会导致一个外键约束违背。如果该约束被延迟，并且仍存在引用行，这个错误将在约束检查时被产生。这是默认动作。
RESTRICT：产生一个错误指示删除或更新将会导致一个外键约束违背。这个动作与NO ACTION形同，不过该检查不是可延迟的。
CASCADE：删除任何引用被删除行的行，或者把引用列的值更新为被引用列的新值。
SET NULL：将引用列设置为空。
SET DEFAULT：设置引用列为它们的默认值（如果该默认值非空，在被引用表中必须有一行匹配该默认值，否则该操作将会失败）。</p>
<p>DEFERRABLE  |  NOT DEFERRABLE：这个子句控制该约束是否能被延迟。一个不可延迟的约束将在每一次命令后立刻被检查。可延迟约束的检查将被推迟到事务结束时进行（使用SET CONSTRAINTS命令）。NOT DEFERRABLE是默认值。当前，只有UNIQUE、PRIMARY KEY、EXCLUDE以及REFERENCES（外键）约束接受这个子句。NOT NULL以及CHECK约束是不可延迟的。注意在包括ON CONFLICT DO UPDATE子句的INSERT语句中，可延迟约束不能被用作冲突裁判者。
INITIALLY IMMEDIATE  |  INITIALLY DEFERRED：如果一个约束是可延迟的，这个子句指定检查该约束的默认时间。如果该约束是INITIALLY IMMEDIATE，它会在每一个语句之后被检查。这是默认值。如果该约束是INITIALLY DEFERRED，它只会在事务结束时被检查。约束检查时间可以用SET CONSTRAINTS命令修改。</p>
<p>WITH ( { COLOCATION = { 'true' | 'false' }：指定为true，则此表应在单一分片中共址。具体细节，请参阅<a href="#_共址表（colocated table）">共址表</a>，了解共址表的详细信息。
要创建共址表，请使用以下命令： 
CREATE TABLE <name> (columns) WITH (COLOCATION = true);
在共址数据库中，默认情况下，所有表都是共址的。如果需要创建非共址的表，请使用以下命令：
CREATE TABLE <name> (columns) WITH (COLOCATION = false);
这样可以确保该表不会与该数据库的其他表存储在同一个分片上，而是有自己的一组分片。
如果表所属的数据库是非共址的，则设置COLOCATION=true无效，因为当前仅在数据库级别支持共址。有关详细信息，请参阅<a href="#_共址表（colocated table）">共址表</a>。 
WITHOUT OIDS：与WITH (OIDS=FALSE)等效，新表不会存储 OID 并且对插入其中的一个新行不会分配 OID。
TABLESPACE tablespace_name：指定描述此表的放置配置的表空间的名称。默认情况下，表被放置在pg_default表空间中，该表空间将表的tablet均匀地分布在集群中。
SPLIT INTO：对于哈希分片表，可以使用SPLIT INTO子句指定要为该表创建的分片的数量。然后将散列范围均匀地分布在这些分片上。<br />
使用SPLIT INTO的预拆分分片，在生产集群上分发读写工作负载。例如，如果您有3台服务器，那么将表拆分为30个分片，可以提供表上的写入吞吐量。
注意：
默认情况下，AiSQL预拆分一个表为bsql_num_shards_per_tserver*num_of_tserver个分片。SPLIT INTO子句可用于在每个表的基础上重写该设置。
SPLIT AT VALUES：对于范围分片表，可以使用SPLIT AT VALUES子句设置拆分点，来预拆分范围分片的表。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE tbl(
  a int,
  b int,
  primary key(a asc, b desc)
) SPLIT AT VALUES((100), (200), (200, 5));
</code></pre></div>
<p>在上面的示例中，存在3个分片点，因此，表被拆分为如下4个分片：
    tablet 1: a=<lowest>, b=<lowest> to a=100, b=<lowest>
    tablet 2: a=100, b=<lowest> to a=200, b=<lowest>
    tablet 3: a=200, b=<lowest> to a=200, b=5
    tablet 4: a=200, b=5 to a=<highest>, b=<highest>
Storage parameters：PostgreSQL定义的存储参数将被忽略，并且仅用于与PostgreSQL兼容。</p>
<p>以下是一些示例：
创建带有主键的表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sample(k1 int, 
k2 int, 
v1 int, 
v2 text, 
PRIMARY KEY (k1, k2) );
</code></pre></div>
<p>在该示例中，第一列k1将是HASH，而第二列k2将是ASC。</p>
<div class="highlight"><pre><span></span><code>bigmath=# \d sample
               Table &quot;public.sample&quot;
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 k1     | integer |           | not null |
 k2     | integer |          | not null |
 v1     | integer |          |          |
 v2     | text    |          |          |
Indexes:
    &quot;sample_pkey&quot; PRIMARY KEY, lsm (k1 HASH, k2)
</code></pre></div>
<p>创建带范围主键的表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE range(k1 int,
 k2 int, 
v1 int, 
v2 text, 
PRIMARY KEY (k1 ASC, k2 DESC));
</code></pre></div>
<p>创建带有检查约束的表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE student_grade(student_id int, 
class_id int, 
term_id int, 
grade int CHECK (grade &gt;= 0 AND grade &lt;= 10),
PRIMARY KEY (student_id, class_id, term_id));
</code></pre></div>
<p>创建具有默认值的表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE cars(id int PRIMARY KEY, 
brand text CHECK (brand in (&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;)), 
model text NOT NULL, 
color text NOT NULL DEFAULT &#39;WHITE&#39; CHECK (color in (&#39;RED&#39;, &#39;WHITE&#39;, &#39;BLUE&#39;)));
</code></pre></div>
<p>创建具有外键约束的表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE products(id int PRIMARY KEY,
descr text);
CREATE TABLE orders(id int PRIMARY KEY,
 pid int REFERENCES products(id) ON DELETE CASCADE,
                     amount int);
</code></pre></div>
<p>创建具有唯一约束的表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE translations(message_id int UNIQUE,
message_txt text);
</code></pre></div>
<p>创建一个指定分片数量的表：
要指定表的分片数量，可以将CREATE TABLE 语句与SPLIT INTO子句一起使用。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE tracking (id int PRIMARY KEY) SPLIT INTO 10 TABLETS;
</code></pre></div>
<p>创建一个共址表：</p>
<div class="highlight"><pre><span></span><code>CREATE DATABASE company WITH COLOCATION = true;
</code></pre></div>
<div class="highlight"><pre><span></span><code>CREATE TABLE employee(id INT PRIMARY KEY, 
name TEXT) WITH (COLOCATION = false);
</code></pre></div>
<p>在本例中，数据库company是共址的，意味着，employee表以外的所有表都存储在一个分片上。</p>
<h4 id="create-table-as"><strong>CREATE TABLE AS</strong></h4>
<p>从一个查询的结果创建一个新表。
语法：
create_table_as ::= CREATE [ TEMPORARY | TEMP ] TABLE 
                    [ IF NOT EXISTS ]  table_name 
                    [ ( column_name [ , ... ] ) ]  AS subquery 
                    [ WITH [ NO ] DATA ]</p>
<p>描述：从一个查询的结果创建一个新表。</p>
<p>参数：
table_name：指定表名。
( column_name [ , ... ] )：指定新表中列的名称。如果未指定，则列名取自查询的输出列名。
WITH [ NO ] DATA：这个子句指定查询产生的数据是否应该被复制到新表中。如果不是，则只有表结构会被复制。默认是复制数据。
TEMPORARY | TEMP：使用此限定符将创建一个临时表。临时表仅在创建它们的当前客户端会话中可见，并在会话结束时自动删除。在临时表上创建的任何索引也是临时的。 
示例：
创建一个表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sample(k1 int, k2 int, v1 int, v2 text, PRIMARY KEY (k1, k2));
</code></pre></div>
<p>插入一些数据行：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO sample VALUES (1, 2.0, 3, &#39;a&#39;), (2, 3.0, 4, &#39;b&#39;), (3, 4.0, 5, &#39;c&#39;);
</code></pre></div>
<p>创建一个示例表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE selective_sample AS SELECT * FROM sample WHERE k1 &gt; 1;
</code></pre></div>
<p>从上面创建的示例表中查询数据：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM selective_sample ORDER BY k1;
</code></pre></div>
<h4 id="create-trigger"><strong>CREATE TRIGGER</strong></h4>
<p>定义一个新触发器</p>
<p>语法：
create_trigger ::= CREATE TRIGGER name { BEFORE | AFTER | INSTEAD OF } 
                   { event [ OR ... ] } ON table_name 
                   [ FROM table_name ]  [ NOT DEFERRABLE ] 
                   [ FOR [ EACH ] { ROW | STATEMENT } ] 
                   [ WHEN ( boolean_expression ) ]  EXECUTE 
                   { FUNCTION | PROCEDURE } subprogram_name ( 
                   [ subprogram_signature ] )</p>
<p>event ::= INSERT
          | UPDATE [ OF column_name [ , ... ] ]
          | DELETE
          | TRUNCATE</p>
<p>描述：CREATE TRIGGER创建一个新触发器。该触发器将被关联到指定的表、视图或者外部表并且在表上发生特定操作时将执行指定的函数function_name。
WHEN条件可用于指定是否应触发触发器。对于低级触发器，它可以引用行的列的旧值和/或新值。可以为同一事件定义多个触发器，在这种情况下，它们将按照名称的字母表顺序被触发。
示例：
设置一个带有触发器的表，用于跟踪修改时间和用户(角色）。使用预先安装的扩展插件insert_username和moddatetime。</p>
<div class="highlight"><pre><span></span><code>CREATE EXTENSION insert_username;
CREATE EXTENSION moddatetime;

CREATE TABLE posts (
  id int primary key,
  content text,
  username text not null,
  moddate timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TRIGGER insert_usernames
   BEFORE INSERT OR UPDATE ON posts
   FOR EACH ROW
   EXECUTE PROCEDURE insert_username (username);

CREATE TRIGGER update_moddatetime
   BEFORE UPDATE ON posts
   FOR EACH ROW
   EXECUTE PROCEDURE moddatetime (moddate);
</code></pre></div>
<p>插入一些行。对于每个插入，触发器应该将当前角色设置为username，将当前时间戳设置为moddate。 </p>
<div class="highlight"><pre><span></span><code>SET ROLE bigmath;
INSERT INTO posts VALUES(1, &#39;desc1&#39;);

SET ROLE postgres;
INSERT INTO posts VALUES(2, &#39;desc2&#39;);
INSERT INTO posts VALUES(3, &#39;desc3&#39;);

SET ROLE bigmath;
INSERT INTO posts VALUES(4, &#39;desc4&#39;);

SELECT * FROM posts ORDER BY id;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> id | content | username |          moddate           
----+---------+----------+----------------------------
  1 | desc1   | bigmath  | 2023-11-06 15:27:21.623908
  2 | desc2   | postgres | 2023-11-06 15:27:21.671353
  3 | desc3   | postgres | 2023-11-06 15:27:21.687268
  4 | desc4   | bigmath  | 2023-11-06 15:27:21.735876
</code></pre></div>
<p>更新一些行。对于每次更新，触发器都应该相应地设置username和moddate。 </p>
<div class="highlight"><pre><span></span><code>UPDATE posts SET content = &#39;desc1_updated&#39; WHERE id = 1;
UPDATE posts SET content = &#39;desc3_updated&#39; WHERE id = 3;

SELECT * FROM posts ORDER BY id;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> id |    content    | username |          moddate           
----+---------------+----------+----------------------------
  1 | desc1_updated | bigmath  | 2023-11-06 15:51:41.388021
  2 | desc2         | postgres | 2023-11-06 15:27:21.671353
  3 | desc3_updated | bigmath  | 2023-11-06 15:51:41.446264
  4 | desc4         | bigmath  | 2023-11-06 15:27:21.735876
</code></pre></div>
<h4 id="create-type"><strong>CREATE TYPE</strong></h4>
<p>定义一种新的数据类型
语法：
create_type ::= create_composite_type
                | create_enum_type
                | create_range_type
                | create_shell_type
                | create_base_type</p>
<p>create_composite_type ::= CREATE TYPE type_name AS ( 
                          [ composite_type_elem [ , ... ] ] )</p>
<p>create_enum_type ::= CREATE TYPE type_name AS ENUM ( 
                     [ name [ , ... ] ] )</p>
<p>create_range_type ::= CREATE TYPE type_name AS RANGE  ( SUBTYPE = 
                      subtype [ , range_type_option [ ... ] ] )</p>
<p>create_shell_type ::= CREATE TYPE type_name</p>
<p>create_base_type ::= CREATE TYPE type_name (  INPUT = input_function , 
                      OUTPUT = output_function 
                     [ , base_type_option [ ... ] ]  )</p>
<p>composite_type_elem ::= attribute_name data_type [ COLLATE collation ]</p>
<p>range_type_option ::= SUBTYPE_OPCLASS = subtype_operator_class
                      | COLLATION = collation
                      | CANONICAL = canonical_function
                      | SUBTYPE_DIFF = subtype_diff_function</p>
<p>base_type_option ::= RECEIVE = receive_function
                     | SEND = send_function
                     | TYPMOD_IN = type_modifier_input_function
                     | TYPMOD_OUT = type_modifier_output_function
                     | INTERNALLENGTH = { internallength | VARIABLE }
                     | PASSEDBYVALUE
                     | ALIGNMENT = alignment
                     | STORAGE = storage
                     | LIKE = like_type
                     | CATEGORY = category
                     | PREFERRED = { TRUE | FALSE }
                     | DEFAULT = default_type_value
                     | ELEMENT = element
                     | DELIMITER = delimiter
                     | COLLATABLE = { TRUE | FALSE }</p>
<p>描述：使用CREATE TYPE语句在数据库中创建用户定义的类型。有五种类型：composite、enumerated、range、base和shell。每个都有自己的CREATE TYPE语法。
示例：
示例1：composite </p>
<div class="highlight"><pre><span></span><code>CREATE TYPE feature_struct AS (id INTEGER, name TEXT);
CREATE TABLE feature_tab_struct (feature_col feature_struct);
</code></pre></div>
<p>示例2：Enumerated</p>
<div class="highlight"><pre><span></span><code>CREATE TYPE feature_enum AS ENUM (&#39;one&#39;, &#39;two&#39;, &#39;three&#39;);
CREATE TABLE feature_tab_enum (feature_col feature_enum);
</code></pre></div>
<p>示例3：Range </p>
<div class="highlight"><pre><span></span><code>CREATE TYPE feature_range AS RANGE (subtype=INTEGER);
CREATE TABLE feature_tab_range (feature_col feature_range);
</code></pre></div>
<p>示例4：</p>
<div class="highlight"><pre><span></span><code>CREATE TYPE int4_type;
CREATE FUNCTION int4_type_in(cstring) RETURNS int4_type
               LANGUAGE internal IMMUTABLE STRICT PARALLEL SAFE AS &#39;int4in&#39;;
CREATE FUNCTION int4_type_out(int4_type) RETURNS cstring
               LANGUAGE internal IMMUTABLE STRICT PARALLEL SAFE AS &#39;int4out&#39;;
CREATE TYPE int4_type (
               INPUT = int4_type_in,
               OUTPUT = int4_type_out,
               LIKE = int4
           );
CREATE TABLE int4_table (t int4_type);
</code></pre></div>
<p>示例5：Shell</p>
<div class="highlight"><pre><span></span><code>CREATE TYPE shell_type;
</code></pre></div>
<h4 id="create-user"><strong>CREATE USER</strong></h4>
<p>定义一个新的数据库角色
语法：
create_user ::= CREATE USER role_name 
                [ [ WITH ] role_option [ , ... ] ]</p>
<p>role_option ::= SUPERUSER
                | NOSUPERUSER
                | CREATEDB
                | NOCREATEDB
                | CREATEROLE
                | NOCREATEROLE
                | INHERIT
                | NOINHERIT
                | LOGIN
                | NOLOGIN
                | CONNECTION LIMIT connlimit
                | [ ENCRYPTED ] PASSWORD  ' password ' 
                | PASSWORD NULL
                | VALID UNTIL  ' timestamp ' 
                | IN ROLE role_name [ , ... ]
                | IN GROUP role_name [ , ... ]
                | ROLE role_name [ , ... ]
                | ADMIN role_name [ , ... ]
                | USER role_name [ , ... ]
                | SYSID uid</p>
<p>描述：定义一个新的数据库角色。CREATE USER是 CREATE ROLE的一个别名，详细信息请参考<a href="#_CREATE ROLE">CREATE ROLE</a>。
示例：
示例1：创建一个带有密码的新用户</p>
<div class="highlight"><pre><span></span><code>CREATE USER John WITH PASSWORD &#39;password&#39;;
</code></pre></div>
<p>示例2：授予John对bigmath数据库的所有权限。 </p>
<div class="highlight"><pre><span></span><code>GRANT ALL ON DATABASE bigmath TO John;
</code></pre></div>
<p>示例3：从bigmath数据库中删除John的权限。</p>
<div class="highlight"><pre><span></span><code>REVOKE ALL ON DATABASE bigmath FROM John;
</code></pre></div>
<h4 id="create-user-mapping"><strong>CREATE USER MAPPING</strong></h4>
<p>定义一个用户到一个外部服务器的新映射
语法：
create_user_mapping ::= CREATE USER MAPPING [ IF NOT EXISTS ]  FOR 
                        user SERVER server_name<br />
                        [ OPTIONS ( fdw_options ) ]</p>
<p>描述：CREATE USER MAPPING定义一个用户到一个外部服务器的新映射。
如果用户和外部服务器之间的映射已经存在，则除非使用IF NOT EXISTS 子句，否则将引发错误。
参数：
Options：OPTIONS子句指定外部数据服务器的选项。它们通常定义要在外部数据源上使用的映射用户名和密码，但实际允许的选项名称和值特定于服务器的外部数据包装器。 
示例：</p>
<div class="highlight"><pre><span></span><code>CREATE USER MAPPING FOR myuser SERVER my_server OPTIONS (user &#39;john&#39;, password &#39;password&#39;);
</code></pre></div>
<h4 id="create-view"><strong>CREATE VIEW</strong></h4>
<p>定义一个新视图
语法：
create_view ::= CREATE [ OR REPLACE ] [ TEMPORARY | TEMP ] VIEW 
                qualified_name  [ ( column_name [ , ... ] ) ] AS 
                select</p>
<p>描述：使用CREATE VIEW语句在数据库中创建视图。它定义了视图名称和定义它的（select）语句。
参数：
qualified_name：指定视图的名称。如果指定的数据库中已存在具有该名称的视图，则会引发错误（除非使用了OR REPLACE选项）。
column_list：指定以逗号分隔的列的列表。如果未指定，则从查询中推断列名。
select：指定SELECT或VALUES语句，该语句将提供视图的列和行。
TEMPORARY | TEMP：使用此限定符将创建一个临时视图。临时视图仅在创建它们的当前客户端会话中可见，并在会话结束时自动删除。
示例：
创建一个示例表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sample(k1 int, k2 int, v1 int, v2 text, PRIMARY KEY (k1, k2));
</code></pre></div>
<p>插入一些数据行：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO sample(k1, k2, v1, v2) VALUES (1, 2.0, 3, &#39;a&#39;), (2, 3.0, 4, &#39;b&#39;), (3, 4.0, 5, &#39;c&#39;);
Create a view on the sample table.
</code></pre></div>
<p>基于sample表，创建一个视图。</p>
<div class="highlight"><pre><span></span><code>CREATE VIEW sample_view AS SELECT * FROM sample WHERE v2 != &#39;b&#39; ORDER BY k1 DESC;
</code></pre></div>
<p>从上面创建的视图中查询数据：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample_view;
</code></pre></div>
<h4 id="deallocate"><strong>DEALLOCATE</strong></h4>
<p>释放一个预备语句
语法：
deallocate ::= DEALLOCATE [ PREPARE ] { name | ALL }
描述：DEALLOCATE被用来释放一个之前准备好的 SQL 语句</p>
<p>参数：
PREPARE：这个关键词会被忽略。
name ：要释放的预备语句的名称。</p>
<p>ALL：释放所有预备语句。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sample(k1 int, k2 int, v1 int, v2 text, PRIMARY KEY (k1, k2));
PREPARE ins (bigint, double precision, int, text) AS
               INSERT INTO sample(k1, k2, v1, v2) VALUES ($1, $2, $3, $4);
DEALLOCATE PREPARE  ins;
</code></pre></div>
<h4 id="declare"><strong>DECLARE</strong></h4>
<p>定义一个游标
语法：
declare ::= DECLARE cursor_name [ BINARY ] [ INSENSITIVE ] 
            [ [ NO ] SCROLL ]  CURSOR [ { WITH | WITHOUT } HOLD ] FOR 
            subquery</p>
<p>描述：DECLARE允许用户创建游标，游标可以被用来在大型查询暂停时检索少量的行。游标被创建后，可以用FETCH从中取得行。
DECLARE创建一个游标。游标的持续时间限制为声明它的会话的持续时间。请注意可保持游标和不可保持游标之间的最大生存时间差异。CLOSE语句会删除一个游标，这样您就可以缩短它的生存期（通常是为了节省资源）。
pg_cursors目录视图列出当前会话中所有当前存在的游标。
参数：</p>
<p>cursor_name：要创建的游标的名称。游标仅由非限定名称标识，并且仅在声明它的会话中可见。这决定了其名称的唯一性范围。（在这方面，游标的名称与准备好的语句的名称类似。） 
BINARY：让游标返回二进制数据而不是返回文本格式数据。
通常，游标被指定为以文本格式返回数据，这与SELECT语句产生的数据相同。这种二进制格式减少了服务器和客户端的转换工作量，但代价是程序员在处理依赖于平台的二进制数据格式时付出更多。例如，如果查询从整数列返回一个值，那么您将使用默认选项获得字符串值1。但是使用二进制游标，您会得到一个4字节的字段，其中包含值的内部表示形式。
小心使用二进制游标。包括bsqlsh在内的许多应用程序都不准备处理二进制游标，并期望数据以文本格式返回。 
INSENSITIVE：指示从游标中检索数据的过程不受游标创建之后在其底层表上发生的更新的影响。因此在BSQL中，这是唯一的行为。因此，此关键字没有任何作用，仅为与SQL标准兼容而被接受。
SCROLL | NO SCROLL:SCROLL指定游标可以用非顺序（例如，反向）的方式从中检索行。根据查询的执行计划的复杂度，指定 SCROLL可能导致查询执行时间上的性能损失。 NO SCROLL指定游标不能以非顺序的方式从中检索行。默认是允许在某些情况下滚动，但这和指定 SCROLL不完全相同。
SCROLL指定您可以使用FETCH和MOVE的风格来访问当前行以及游标结果集中位于当前行之前的行（即，包括FETCH RELATIVE 0访问的行及其之前）。在简单的情况下，执行计划本质上是可逆的：它允许向后获取，就像允许向前获取一样容易。但并非所有的执行计划都是可逆的；当计划不可逆时，指定SCROLL意味着创建游标的子查询在执行第一个MOVE或FETCH语句时定义的行的缓存（或在访问新行时按需创建）。这意味着性能成本和资源消耗成本。
NO SCROLL指定游标不能用于检索当前行或位于其前面的行。</p>
<p>如果既不指定SCROLL也不指定NO SCROLL，则只在某些情况下允许滚动，这与显式指定SCROLL不同。 
WITH HOLD | WITHOUT HOLD：WITH HOLD指定该游标在创建它的事务提交之后还能被继续使用。WITHOUT HOLD指定该游标不能在创建它的事务之外使用。如果两者都没有指定，则默认为 WITHOUT HOLD。
WITHOUT HOLD指定在创建游标的事务结束后（即使以成功提交结束）不能使用游标。
WITH HOLD指定在创建游标的事务成功提交后，游标可以继续使用。（当然，如果创建它的事务回滚，它就会消失。）
示例：</p>
<div class="highlight"><pre><span></span><code>drop table if exists t cascade;
create table t(k, v) as
select g.val, g.val*100
from generate_series(1, 22) as g(val);

start transaction;
  declare cur scroll cursor without hold for
  select k, v
  from t
  where (k &lt;&gt; all (array[1, 3, 5, 7, 11, 13, 17, 19]))
  order by k;

  select
    statement,
    is_holdable::text,
    is_scrollable::text
  from pg_cursors where name = &#39;cur&#39;
  and not is_binary;

  fetch all from cur;

  close cur;
rollback;
</code></pre></div>
<p>上述脚本中，执行select... from pg_cursors; 
返回类似如下信息：</p>
<div class="highlight"><pre><span></span><code>                       statement                        | is_holdable | is_scrollable 
--------------------------------------------------------+-------------+---------------
 declare cur scroll cursor without hold for            +| false       | true
   select k, v                                         +|             | 
   from t                                              +|             | 
   where (k &lt;&gt; all (array[1, 3, 5, 7, 11, 13, 17, 19]))+|             | 
   order by k;           
</code></pre></div>
<p>执行FETCH ALL：
返回如下信息：</p>
<div class="highlight"><pre><span></span><code> k  |  v   
----+------
  2 |  200
  4 |  400
  6 |  600
  8 |  800
  9 |  900
 10 | 1000
 12 | 1200
 14 | 1400
 15 | 1500
 16 | 1600
 18 | 1800
 20 | 2000
 21 | 2100
 22 | 2200
</code></pre></div>
<h4 id="delete"><strong>DELETE</strong></h4>
<p>删除一个表的行
语法：
delete ::= [ with_clause ]  DELETE FROM table_expr [ [ AS ] alias ]<br />
           [ WHERE boolean_expression | WHERE CURRENT OF cursor_name ] 
            [ returning_clause ]</p>
<p>returning_clause ::= RETURNING { * | { output_expression 
                                     [ [ AS ] output_name ] } 
                                     [ , ... ] }</p>
<p>描述：使用DELETE语句可以删除满足某些条件的行，如果WHERE子句中没有提供条件，则会删除所有行。DELETE输出要删除的行数 。
注意：表继承不被支持。
参数：
with_query：指定DELETE语句中按名称引用的子查询。 
table_name：要从其中删除行的表名（可以是模式限定的）。
alias：目标表的一个别名。在DELETE语句中指定目标表的标识符。当指定了别名时，必须使用它来代替语句中的实际表。
RETURNING：指定要返回的值。output_expression引用列时，将使用该列的现有值（已删除的值）进行返回。
示例：
创建一个示例表，插入几行，然后删除其中一行 </p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sample(k1 int, k2 int, v1 int, v2 text, PRIMARY KEY (k1, k2));
INSERT INTO sample VALUES (1, 2.0, 3, &#39;a&#39;), (2, 3.0, 4, &#39;b&#39;), (3, 4.0, 5, &#39;c&#39;);
SELECT * FROM sample ORDER BY k1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2 
----+----+----+----
  1 |  2 |  3 | a
  2 |  3 |  4 | b
  3 |  4 |  5 | c
</code></pre></div>
<div class="highlight"><pre><span></span><code>DELETE FROM sample WHERE k1 = 2 AND k2 = 3;
SELECT * FROM sample ORDER BY k1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2
----+----+----+----
  1 |  2 |  3 | a
  3 |  4 |  5 | c
</code></pre></div>
<h4 id="do"><strong>DO</strong></h4>
<p>执行一个匿名代码块
语法：
do ::= DO ' plpgsql_block_stmt '
描述：使用DO语句执行一个匿名PL/pgSQL块语句——换句话说，一个暂时的匿名PL/pgSQL过程。plpgsql_block_stmt被视为一个没有参数的过程的主体： 
块语句遇到的任何SQL语句都将以与在语言plpgsql子程序中遇到的SQL语句相同的方式进行处理，因此，如果在同一会话中使用文本相同的块语句重复执行DO语句，然后，所包含SQL语句的第二次和后续执行将受益于第一次遇到它时所做的语法和语义分析。
语法允许一个可选的LANGUAGE子句，该子句可以在代码块之前或之后编写。但是，唯一支持的选择是语言plpgsql。例如，尝试执行指定语言sql的DO语句会导致0A000运行时错误：
language "sql" does not support inline code execution</p>
<p>参数：
plpgsql_block_stmt：要执行的过程语言代码plpgsql_block_stmt。必须将其指定为字符串文字，就像在CREATE FUNCTION 和CREATE PROCEDURE中一样。AiSQL建议您使用美元符号来标准化，例如：$body。
lang_name：指定用以编写代码的过程语言的名称。默认值为plpgsql。请参阅提示避免在上面的“DO”语句中使用可选的“LANGUAGE”子句。此代码是合法的。它运行时没有错误，并具有预期效果。</p>
<div class="highlight"><pre><span></span><code>do
  language plpgsql
$body$
begin
  raise info &#39;Block statement started at %&#39;,
    to_char((statement_timestamp() at time zone &#39;UTC&#39;), &#39;hh24:mi:ss Dy&#39;);
end;
$body$;

示例：
do $body$
begin
  drop schema if exists s cascade;
  create schema s;

  create table s.masters(
    mk serial primary key,
    mv text not null unique);

  create table s.details(
    dk serial primary key,
    mk int not null references s.masters(mk),
    dv text not null);
end;
$body$;
</code></pre></div>
<p>假设在执行DO语句的那一刻，模式s已经存在，但由用户所有，而不是current_role内置函数返回的用户（并且这个当前角色不是超级用户）。同样，假设当前没有正在进行的事务，因此块语句是在单语句自动事务模式下执行的。
删除架构（如果存在）的级联尝试将导致42501错误：</p>
<div class="highlight"><pre><span></span><code>must be owner of schema s
</code></pre></div>
<p>然后，该块将立即退出，并出现未处理的异常，运行时系统将自动发出一个隐藏的提交——在这里，这将具有与回滚相同的效果。将此行为与在显式start transaction; ... commit; 封装相同语句的行为进行比较： </p>
<div class="highlight"><pre><span></span><code>start transaction;
  drop schema if exists s cascade;
  create schema s;

  create table s.masters(
    mk serial primary key,
    mv text not null unique);

  create table s.details(
    dk serial primary key,
    mk int not null references s.masters(mk),
    dv text not null);
commit;
</code></pre></div>
<h4 id="drop-aggregate"><strong>DROP AGGREGATE</strong></h4>
<p>删除一个聚集函数
语法：
drop_aggregate ::= DROP AGGREGATE [ IF EXISTS ] 
                   { aggregate_name ( aggregate_signature ) } 
                   [ , ... ] [ CASCADE | RESTRICT ]</p>
<p>aggregate_signature ::= * | aggregate_arg [ , ... ]
                        | [ aggregate_arg [ , ... ] ] ORDER BY 
                          aggregate_arg [ , ... ]</p>
<p>示例：
示例1：</p>
<div class="highlight"><pre><span></span><code>CREATE AGGREGATE newcnt(*) (
             sfunc = int8inc,
             stype = int8,
             initcond = &#39;0&#39;,
             parallel = safe
           );
DROP AGGREGATE newcnt(*);
</code></pre></div>
<p>示例2：CASCADE 与RESTRICT </p>
<div class="highlight"><pre><span></span><code>CREATE AGGREGATE newcnt(*) (
             sfunc = int8inc,
             stype = int8,
             initcond = &#39;0&#39;,
             parallel = safe
           );
CREATE VIEW cascade_view AS
             SELECT newcnt(*) FROM pg_aggregate;
</code></pre></div>
<p>-- 如下将显示错误:</p>
<div class="highlight"><pre><span></span><code>DROP AGGREGATE newcnt(*) RESTRICT;
</code></pre></div>
<p>-- 如下将显示错误:</p>
<div class="highlight"><pre><span></span><code>DROP AGGREGATE newcnt(*);
DROP AGGREGATE newcnt(*) CASCADE;
</code></pre></div>
<h4 id="drop-cast"><strong>DROP CAST</strong></h4>
<p>删除一个造型
语法：
drop_cast ::= DROP CAST [ IF EXISTS ] ( cast_signature ) 
              [ CASCADE | RESTRICT ]</p>
<p>描述：DROP CAST删除一个之前定义好的造型。
示例：</p>
<div class="highlight"><pre><span></span><code>CREATE FUNCTION sql_to_date(integer) RETURNS date AS $$
             SELECT $1::text::date
             $$ LANGUAGE SQL IMMUTABLE STRICT;
CREATE CAST (integer AS date) WITH FUNCTION sql_to_date(integer) AS ASSIGNMENT;
DROP CAST (integer AS date);
</code></pre></div>
<h4 id="drop-database"><strong>DROP DATABASE</strong></h4>
<p>删除一个数据库
语法：
drop_database ::= DROP DATABASE [ IF EXISTS ] database_name</p>
<p>描述：
删除数据库和所有关联的对象。drop语句完成后，所有与database_name关联的对象（如表）都将无效。所有到丢弃数据库的连接都将失效，并最终断开连接。
参数：
database_name：指定数据的名称。
示例：</p>
<div class="highlight"><pre><span></span><code>drop database IF EXISTS test;
</code></pre></div>
<h4 id="drop-domain"><strong>DROP DOMAIN</strong></h4>
<p>删除一个域
语法：
drop_domain ::= DROP DOMAIN [ IF EXISTS ] name [ , ... ] 
                [ CASCADE | RESTRICT ]
描述：DROP DOMAIN删除一个域。
参数：
IF EXISTS：如果该域不存在则不要抛出一个错误，而是发出一个提示。
name：一个现有域的名称（可以是模式限定的）。
CASCADE：自动删除依赖于该域的对象（例如表列），然后删除所有依赖于那些对象的对象。
RESTRICT：如果有任何对象依赖于该域，则拒绝删除它。这是默认值。</p>
<p>示例：</p>
<p>示例1：</p>
<div class="highlight"><pre><span></span><code>CREATE DOMAIN idx int DEFAULT 5 CHECK (VALUE &gt; 0);
DROP DOMAIN idx;
</code></pre></div>
<p>示例2：</p>
<div class="highlight"><pre><span></span><code>CREATE DOMAIN idx int DEFAULT 5 CHECK (VALUE &gt; 0);
CREATE TABLE t (k idx primary key);
DROP DOMAIN idx CASCADE;
</code></pre></div>
<h4 id="drop-extension"><strong>DROP EXTENSION</strong></h4>
<p>删除一个扩展
语法：
drop_extension ::= DROP EXTENSION [ IF EXISTS ] extension_name 
                   [ , ... ] [ CASCADE | RESTRICT ]</p>
<p>描述：DROP EXTENSION从数据库删除扩展。
参数：
IF EXISTS：如果该扩展不存在则不要抛出一个错误，而是发出一个提示。
name：一个已安装扩展的名称。
CASCADE：自动删除依赖于该扩展的对象，然后删除所有依赖于那些对象的对象。
RESTRICT：如果有任何对象依赖于该扩展（而不是它自己拥有的成员对象和其他被列在同一个DROP命令中的扩展），则拒绝删除它。这是默认值。</p>
<p>示例
示例1：</p>
<div class="highlight"><pre><span></span><code>DROP EXTENSION IF EXISTS cube;
</code></pre></div>
<p>示例2：</p>
<div class="highlight"><pre><span></span><code>CREATE EXTENSION cube;
CREATE EXTENSION earthdistance;
DROP EXTENSION IF EXISTS cube RESTRICT; 
</code></pre></div>
<p>返回错误信息如下：</p>
<div class="highlight"><pre><span></span><code>ERROR:  cannot drop extension cube because other objects depend on it
DETAIL:  extension earthdistance depends on type cube
HINT:  Use DROP ... CASCADE to drop the dependent objects too.

DROP EXTENSION IF EXISTS cube CASCADE;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>NOTICE:  drop cascades to extension earthdistance
DROP EXTENSION
</code></pre></div>
<h4 id="drop-foreign-data-wrapper"><strong>DROP FOREIGN DATA WRAPPER</strong></h4>
<p>删除一个外部数据包装器
语法：
drop_foreign_data_wrapper ::= DROP FOREIGN DATA WRAPPER [ IF EXISTS ] 
                              fdw_name [ CASCADE | RESTRICT ]</p>
<p>描述：DROP FOREIGN DATA WRAPPER 移除一个已有的外部数据包装器。
参数：
IF EXISTS：如果该外部数据包装器不存在则不要抛出一个错误，而是发出一个提示。
fdw_name：一个现有外部数据包装器的名称。</p>
<p>CASCADE：自动删除依赖于该外部数据包装器的对象（例如服务器），然后删除所有依赖于那些对象的对象。
RESTRICT：如果有任何对象依赖于该外部数据包装器，则拒绝删除它。这是默认值。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>DROP FOREIGN DATA WRAPPER my_wrapper CASCADE;
</code></pre></div>
<h4 id="drop-foreign-table"><strong>DROP FOREIGN TABLE</strong></h4>
<p>删除一个外部表
语法：
drop_foreign_table ::= DROP FOREIGN TABLE [ IF EXISTS ] table_name 
                       [ CASCADE | RESTRICT ]</p>
<p>描述：DROP FOREIGN TABLE删除一个外部表。</p>
<p>参数：
IF EXISTS：如果该外部表不存在则不要抛出一个错误，而是发出一个提示。
table_name：要删除的外部表的名称（可以是模式限定的）。
CASCADE：自动删除依赖于该外部表的对象（例如视图），然后删除所有依赖于那些对象的对象。
RESTRICT：如果有任何对象依赖于该外部表，则拒绝删除它。这是默认值。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>DROP FOREIGN TABLE mytable CASCADE;
</code></pre></div>
<h4 id="drop-function"><strong>DROP FUNCTION</strong></h4>
<p>删除一个函数
语法：
drop_function ::= DROP FUNCTION [ IF EXISTS ]<br />
                  { subprogram_name ( [ subprogram_signature ] ) } 
                  [ , ... ] [ CASCADE | RESTRICT ]</p>
<p>subprogram_signature ::= arg_decl [ , ... ]</p>
<p>arg_decl ::= [ formal_arg ] [ arg_mode ] arg_type</p>
<p>描述：DROP FUNCTION移除一个已有函数的定义。要执行这个命令用户必须是该函数的拥有者。该函数的参数类型必须被指定，因为多个不同的函数可能会具有相同的函数名和不同的参数列表。</p>
<p>参数：
IF EXISTS：如果该函数不存在则不要抛出一个错误，而是发出一个提示。
Name：一个现有函数的名称（可以是模式限定的）。 如果未指定参数列表，则该名称在其模式中必须是唯一的。
argmode：一个参数的模式：IN、OUT、 INOUT或者VARIADIC。如果被忽略， 则默认为IN。注意 DROP FUNCTION并不真正关心OUT参数，因为决定函数的身份时只需要输入参数。
argname：一个参数的名称。注意 DROP FUNCTION并不真正关心 参数名称，因为决定函数的身份时只需要参数的数据类型。
argtype：如果函数有参数，这是函数参数的数据类型（可以是模式限定的）。
CASCADE：自动删除依赖于该函数的对象（例如操作符和触发器），然后删除所有 依赖于那些对象的对象。
RESTRICT：如果有任何对象依赖于该函数，则拒绝删除它。这是默认值。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>DROP FUNCTION IF EXISTS inc(i integer), mul(integer, integer) CASCADE;
</code></pre></div>
<h4 id="drop-group"><strong>DROP GROUP</strong></h4>
<p>删除一个数据库角色
语法：
drop_group ::= DROP GROUP [ IF EXISTS ] role_name [ , ... ]</p>
<p>描述：DROP GROUP是 DROP ROLE的一个别名。
有关更多详细信息，请参阅<a href="#_DROP ROLE">DROP ROLE</a>。 </p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>DROP GROUP SysAdmin;
</code></pre></div>
<h4 id="drop-index"><strong>DROP INDEX</strong></h4>
<p>删除一个索引
语法：
drop_index ::= DROP INDEX [ IF EXISTS ] index_name 
               [ CASCADE | RESTRICT ]
描述：DROP INDEX从数据库系统中删除一个已有的索引。
参数：
IF EXISTS：如果该索引不存在则不要抛出一个错误，而是发出一个提示。
index_name：要删除的索引的名称（可以是模式限定的）。
CASCADE：自动删除依赖于该索引的对象，然后删除所有依赖于那些对象的对象。
RESTRICT：如果有任何对象依赖于该索引，则拒绝删除它。这是默认值。</p>
<h4 id="drop-materialized-view"><strong>DROP MATERIALIZED VIEW</strong></h4>
<p>删除一个物化视图
语法：
drop_matview ::= DROP MATERIALIZED VIEW [ IF EXISTS ] matview_name<br />
                 [ CASCADE | RESTRICT ]</p>
<p>描述：DROP MATERIALIZED VIEW删除一个现有的物化视图。要执行这个命令你必须是该物化视图的拥有者。</p>
<p>参数：
IF EXISTS：如果该物化视图不存在则不要抛出一个错误，而是发出一个提示。
matview_name：要移除的物化视图的名称（可以是模式限定的）。
CASCADE：自动删除依赖于该物化视图的对象（例如其他物化视图或常规视图），然后删除所有依赖于那些对象的对象。
RESTRICT：如果有任何对象依赖于该物化视图，则拒绝删除它。这是默认值。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE t1(a int4);
CREATE MATERIALIZED VIEW m1 AS SELECT * FROM t1;
CREATE MATERIALIZED VIEW m2 AS SELECT * FROM m1;
DROP MATERIALIZED VIEW m1; --失败，因为m2 依赖m1

DROP MATERIALIZED VIEW m1 CASCADE; --成功
</code></pre></div>
<h4 id="drop-operator"><strong>DROP OPERATOR</strong></h4>
<p>删除一个操作符
语法：
drop_operator ::= DROP OPERATOR [ IF EXISTS ] 
                  { operator_name ( operator_signature ) } [ , ... ] 
                  [ CASCADE | RESTRICT ]</p>
<p>operator_signature ::= { left_type | NONE } , { right_type | NONE }</p>
<p>参数：
IF EXISTS：如果该操作符不存在则不要抛出一个错误，而是发出一个提示。
operator_name：一个现有的操作符的名称（可以是模式限定的）。
left_type：该操作符左操作数的数据类型，如果没有左操作数就写 NONE。
right_type：该操作符右操作数的数据类型，如果没有右操作数就写 NONE。
CASCADE：自动删除依赖于该操作符的对象（例如使用它的视图），然后删除所有 依赖于那些对象的对象。
RESTRICT：如果有任何对象依赖于该操作符，则拒绝删除它。这是默认值。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE OPERATOR @#@ (
             rightarg = int8,
             procedure = numeric_fac
           );
DROP OPERATOR @#@ (NONE, int8);
</code></pre></div>
<h4 id="drop-operator-class"><strong>DROP OPERATOR CLASS</strong></h4>
<p>删除一个操作符类
语法：
drop_operator_class ::= DROP OPERATOR CLASS [ IF EXISTS ] 
                        operator_class_name USING index_method 
                        [ CASCADE | RESTRICT ]
描述：DROP OPERATOR CLASS删除一个现有的操作符类。</p>
<p>参数：
IF EXISTS：如果该操作符类不存在则不要抛出一个错误，而是发出一个提示。
operator_class_name：一个现有的操作符类的名称（可以是模式限定的）。
index_method：该操作符类适用的索引访问方法的名称。
CASCADE：自动删除依赖于该操作符类的对象（例如索引），然后删除所有依赖于那些对象的对象。
RESTRICT：如果有任何对象依赖于该操作符类，则拒绝删除它。这是默认值。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE OPERATOR CLASS my_op_class
           FOR TYPE int4
           USING btree AS
           OPERATOR 1 &lt;,
           OPERATOR 2 &lt;=;
DROP OPERATOR CLASS my_op_class USING btree;
</code></pre></div>
<h4 id="drop-owned"><strong>DROP OWNED</strong></h4>
<p>删除一个数据库角色拥有的数据库对象
语法：
drop_owned ::= DROP OWNED BY role_specification [ , ... ] 
               [ CASCADE | RESTRICT ]</p>
<p>role_specification ::= role_name | CURRENT_USER | SESSION_USER
描述：DROP OWNED删除当前数据库中被指定角色之一拥有的所有对象，授予给定角色对当前数据库中对象或共享对象的任何权限也将被撤销。
参数：
CASCADE：自动删除依赖于受影响对象的对象，然后删除所有依赖于那些对象的对象。
RESTRICT：如果有任何其他数据库对象依赖于一个受影响的对象， 则拒绝删除一个角色所拥有的对象。这是默认值。</p>
<p>示例：删除john拥有的所有对象</p>
<div class="highlight"><pre><span></span><code>drop owned by john;
</code></pre></div>
<h4 id="drop-policy"><strong>DROP POLICY</strong></h4>
<p>从一个表删除一条行级安全性策略
语法：
drop_policy ::= DROP POLICY [ IF EXISTS ] name ON table_name 
                [ CASCADE | RESTRICT ]</p>
<p>描述：DROP POLICY从该表删除指定的策略。</p>
<p>参数：
IF EXISTS：如果该策略不存在也不抛出一个错误。这种情况下会发出一个提示。
name：要删除的策略的名称。
table_name：该策略所在的表的名称（可以被模式限定）。
CASCADE | RESTRICT：这些关键词不会产生效果，因为它们不依赖于策略。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>DROP POLICY p1 ON table_foo;
</code></pre></div>
<h4 id="drop-procedure"><strong>DROP PROCEDURE</strong></h4>
<p>删除一个过程
语法：
drop_procedure ::= DROP PROCEDURE [ IF EXISTS ]<br />
                   { subprogram_name ( [ subprogram_signature ] ) } 
                   [ , ... ] [ CASCADE | RESTRICT ]</p>
<p>subprogram_signature ::= arg_decl [ , ... ]</p>
<p>arg_decl ::= [ formal_arg ] [ arg_mode ] arg_type</p>
<p>描述：DROP PROCEDURE删除一个现有过程的定义。为了执行这个命令，用户必须是该过程的拥有者。该过程的参数类型必须指定，因为可能存在多个不同的过程具有相同名称和不同参数列表。</p>
<p>参数：
IF EXISTS：如果该过程不存在也不抛出一个错误。这种情况下会发出一个提示。
subprogram_name：现有过程的名称（可以是被方案限定的）。如果没有指定参数列表，则该名称在其所属的方案中必须是唯一的。
argmode：参数的模式：IN或者VARIADIC。如果省略，默认为IN。
formal_arg：参数的名称。注意，其实DROP PROCEDURE并不在意参数名称，因为只需要参数的数据类型来确定过程的身份。
argtype：该过程如果有参数，参数的数据类型（可以是被方案限定的）。
CASCADE：自动删除依赖于该过程的对象，然后接着删除依赖于那些对象的对象。
RESTRICT：如果有任何对象依赖于该过程，则拒绝删除它。这是默认选项。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>DROP PROCEDURE IF EXISTS transfer(integer, integer, dec) CASCADE;
</code></pre></div>
<h4 id="drop-role"><strong>DROP ROLE</strong></h4>
<p>删除一个数据库角色
语法：
drop_role ::= DROP ROLE [ IF EXISTS ] role_name [ , ... ]</p>
<p>描述：DROP ROLE删除指定的角色。要删除一个超级用户角色，你必须自己就是一个超级用户。要删除一个非超级用户角色，你必须具有CREATEROLE特权。
在删除角色之前，必须删除它所拥有的所有对象（或重新分配其所有权），并撤消授予该角色对其他对象的任何权限。REASSIGN OWNED和DROP OWNED命令可用于此目的。
但是，没有必要删除涉及该角色的角色成员身份。DROP ROLE会自动撤销目标角色在其他角色中的任何成员身份，以及目标角色中其他角色的任何成员资格。其他角色不会被删除或影响。
参数：
IF EXISTS：如果该角色不存在则不要抛出一个错误，而是发出一个提示。
role_name：要删除的角色的名称。
示例：</p>
<div class="highlight"><pre><span></span><code>DROP ROLE John;
</code></pre></div>
<h4 id="drop-rule"><strong>DROP RULE</strong></h4>
<p>删除一个重写规则
语法：
drop_rule ::= DROP RULE [ IF EXISTS ] rule_name ON table_name 
              [ CASCADE | RESTRICT ]</p>
<p>描述：DROP RULE删除一个重写规则。</p>
<p>参数：
IF EXISTS：如果该规则不存在则不要抛出一个错误，而是发出一个提示。
rule_name：要删除的规则的名称。
table_name：该规则适用的表或视图的名称（可以是模式限定的）。
CASCADE：自动删除依赖于该规则的对象，然后删除所有依赖于那些对象的对象。
RESTRICT：如果有任何对象依赖于该规则，则拒绝删除它。这是默认值。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE t1(a int4, b int4);
CREATE TABLE t2(a int4, b int4);
CREATE RULE t1_to_t2 AS ON INSERT TO t1 DO INSTEAD
             INSERT INTO t2 VALUES (new.a, new.b);
DROP RULE t1_to_t2 ON t1;
</code></pre></div>
<h4 id="drop-schema"><strong>DROP SCHEMA</strong></h4>
<p>删除一个模式</p>
<p>语法：
drop_schema ::= DROP SCHEMA [ IF EXISTS ] schema_name [ , ... ] 
                [ CASCADE | RESTRICT ]</p>
<p>描述：DROP SCHEMA从数据库中移除模式。
参数
IF EXISTS：如果该模式不存在则不要抛出一个错误，而是发出一个提示。
schema_name：一个模式的名称。
CASCADE：自动删除包含在该模式中的对象（表、函数等），然后删除所有依赖于那些对象的对象。
RESTRICT：如果该模式含有任何对象，则拒绝删除它。这是默认值。
示例：
创建模式，并创建模式下表。</p>
<div class="highlight"><pre><span></span><code>CREATE SCHEMA sch1;
CREATE TABLE sch1.t1(id BIGSERIAL PRIMARY KEY);
</code></pre></div>
<p>删除模式：</p>
<div class="highlight"><pre><span></span><code>DROP SCHEMA sch1;
</code></pre></div>
<p>返回如下错误信息：</p>
<div class="highlight"><pre><span></span><code>ERROR:  cannot drop schema sch1 because other objects depend on it
DETAIL:  table sch1.t1 depends on schema sch1
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
</code></pre></div>
<p>带有CASCADE参数删除模式：</p>
<div class="highlight"><pre><span></span><code>DROP SCHEMA sch1 CASCADE;
</code></pre></div>
<h4 id="drop-sequence"><strong>DROP SEQUENCE</strong></h4>
<p>删除一个序列
语法：
drop_sequence ::= DROP SEQUENCE [ IF EXISTS ] sequence_name 
                  [ CASCADE | RESTRICT ]
描述：DROP SEQUENCE删除序数生成器。 
参数：
IF EXISTS：如果该序列不存在则不要抛出一个错误，而是发出一个提示。</p>
<p>sequence_name：一个序列的名称（可以是模式限定的）。
CASCADE：自动删除依赖于该序列的对象，然后删除所有依赖于那些对象的对象。
RESTRICT：如果有任何对象依赖于该序列，则拒绝删除它。这是默认值。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE t(k SERIAL, v INT);
</code></pre></div>
<p>\d t
返回信息如下：</p>
<div class="highlight"><pre><span></span><code>                            Table &quot;public.t&quot;
 Column |  Type   | Collation | Nullable |           Default            
--------+---------+-----------+----------+------------------------------
 k      | integer |           | not null | nextval(&#39;t_k_seq&#39;::regclass)
 v      | integer |           |          | 
</code></pre></div>
<div class="highlight"><pre><span></span><code>DROP SEQUENCE t_k_seq;
</code></pre></div>
<p>返回错误信息如下：</p>
<div class="highlight"><pre><span></span><code>ERROR:  cannot drop sequence t_k_seq because other objects depend on it
DETAIL:  default value for column k of table t depends on sequence t_k_seq
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
</code></pre></div>
<p>使用CASCADE选项删除序列可以解决问题，还可以删除表t中的默认值。</p>
<div class="highlight"><pre><span></span><code>DROP SEQUENCE t_k_seq CASCADE;
</code></pre></div>
<h4 id="drop-server"><strong>DROP SERVER</strong></h4>
<p>删除一个外部服务器描述符
语法：
drop_server ::= DROP SERVER [ IF EXISTS ] server_name 
                [ CASCADE | RESTRICT ]</p>
<p>描述：DROP SERVER删除一个现有的外部服务器描述符。</p>
<p>参数：
IF EXISTS：如果该服务器不存在则不要抛出一个错误，而是发出一个提示。
server_name：一个现有服务器的名称。
CASCADE：自动删除依赖于该服务器的对象（例如用户映射），然后删除所有依赖于那些对象的对象。
RESTRICT：如果有任何对象依赖于该服务器，则拒绝删除它。这是默认值。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>DROP SERVER my_server CASCADE;
</code></pre></div>
<h4 id="drop-table"><strong>DROP TABLE</strong></h4>
<p>删除一个表
语法：
drop_table ::= DROP TABLE [ IF EXISTS ] table_name [ , ... ] 
               [ CASCADE | RESTRICT ]</p>
<p>描述：使用DROP TABLE语句从数据库中删除一个或多个表（及其所有数据）。
参数：
IF EXISTS：如果该表不存在则不要抛出一个错误，而是发出一个提示。
table_name：要删除的表的名称（可以是模式限定的）。
CASCADE：自动删除依赖于该表的对象（例如视图），然后删除所有依赖于那些对象的对象。
RESTRICT：如果有任何对象依赖于该表，则拒绝删除它。这是默认值。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>set client_min_messages = warning;
drop table if exists children, parents cascade;

create table parents(k int primary key, v text);

create table children(
  k int, parents_k int, v text,
  constraint children_pk primary key(k, parents_k),
  constraint children_fk foreign key(parents_k) references parents(k));

\d children
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>Foreign-key constraints:
    &quot;children_fk&quot; FOREIGN KEY (parents_k) REFERENCES parents(k)
</code></pre></div>
<p>执行如下操作：</p>
<div class="highlight"><pre><span></span><code>\set VERBOSITY verbose
drop table parents restrict;
</code></pre></div>
<p>返回如下错误信息：</p>
<div class="highlight"><pre><span></span><code>ERROR:  2BP01: cannot drop table parents because other objects depend on it
</code></pre></div>
<p>并返回如下详细信息：</p>
<div class="highlight"><pre><span></span><code>DETAIL:  constraint children_fk on table children depends on index parents_pkey
</code></pre></div>
<p>继续执行如下操作：</p>
<div class="highlight"><pre><span></span><code>drop table parents cascade;
\d children
</code></pre></div>
<p>“DROP”执行成功，\d元命令显示表“children”仍然存在，但它现在对现在删除的“parents”表没有外键约束。</p>
<h4 id="drop-trigger"><strong>DROP TRIGGER</strong></h4>
<p>删除一个触发器
语法：
drop_trigger ::= DROP TRIGGER [ IF EXISTS ] name ON table_name 
                 [ CASCADE | RESTRICT ]</p>
<p>描述：DROP TRIGGER删除一个现有的触发器定义。 
参数：
IF EXISTS：如果该触发器不存在则不要抛出一个错误，而是发出一个提示。
name：要删除的触发器的名称。
table_name：定义了该触发器的表的名称（可以是模式限定的）。
CASCADE：自动删除依赖于该触发器的对象，然后删除所有依赖于那些对象的对象。
RESTRICT：如果有任何对象依赖于该触发器，则拒绝删除它。这是默认值。</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>DROP TRIGGER update_moddatetime ON posts;
</code></pre></div>
<h4 id="drop-type"><strong>DROP TYPE</strong></h4>
<p>删除一个数据类型
语法：
drop_type ::= DROP TYPE [ IF EXISTS ] type_name [ , ... ] 
              [ CASCADE | RESTRICT ]</p>
<p>描述：DROP TYPE删除一种用户定义的数据类型。
参数
IF EXISTS：如果该类型不存在则不要抛出一个错误，而是发出一个提示。
type_name：要删除的数据类型的名称（可以是模式限定的）。
CASCADE：自动删除依赖于该类型的对象（例如表列、函数、操作符），然后删除所有依赖于那些对象的对象。
RESTRICT：如果有任何对象依赖于该类型，则拒绝删除它。这是默认值。</p>
<p>示例：
示例1：</p>
<div class="highlight"><pre><span></span><code>CREATE TYPE feature_struct AS (id INTEGER, name TEXT);
DROP TYPE feature_struct;
</code></pre></div>
<p>示例2：</p>
<div class="highlight"><pre><span></span><code>DROP TYPE IF EXISTS feature_shell;
</code></pre></div>
<p>示例3：</p>
<div class="highlight"><pre><span></span><code>CREATE TYPE feature_enum AS ENUM (&#39;one&#39;, &#39;two&#39;, &#39;three&#39;);
CREATE TABLE feature_tab_enum (feature_col feature_enum);
DROP TYPE feature_tab_enum CASCADE;
</code></pre></div>
<p>示例4：</p>
<div class="highlight"><pre><span></span><code>CREATE TYPE feature_range AS RANGE (subtype=INTEGER);
CREATE TABLE feature_tab_range (feature_col feature_range);
</code></pre></div>
<p>-- 接下来执行的这个语句会报告错误</p>
<div class="highlight"><pre><span></span><code>DROP TYPE feature_range RESTRICT;
DROP TABLE feature_tab_range;
DROP TYPE feature_range RESTRICT;
</code></pre></div>
<h4 id="drop-user"><strong>DROP USER</strong></h4>
<p>删除一个数据库角色
语法：
drop_user ::= DROP USER [ IF EXISTS ] role_name [ , ... ]</p>
<p>描述：删除一个数据库角色。
有关更多详细信息，请参阅<a href="#_DROP ROLE">DROP ROLE</a>。 </p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>DROP USER John;
</code></pre></div>
<h4 id="end"><strong>END</strong></h4>
<p>提交当前事务
语法：
end ::= END [ TRANSACTION | WORK ]</p>
<p>描述：使用END语句提交当前事务。事务所做的所有更改对其他人都是可见的，并保证在发生崩溃时是持久的。
参数：
WORK | TRANSACTION：可选关键词，它们没有效果。
示例：要提交当前事务并且让所有更改持久化：</p>
<div class="highlight"><pre><span></span><code>END;
</code></pre></div>
<h4 id="execute"><strong>EXECUTE</strong></h4>
<p>执行一个预备语句
语法：
execute_statement ::= EXECUTE name [ ( expression [ , ... ] ) ]</p>
<p>描述：EXECUTE被用来执行一个之前准备好的语句，这是一种性能优化，因为在PREPARE处理过程中，准备好的语句将使用不同的值执行多次，而语法和语义分析以及重写只执行一次。
参数：
name：要执行的预备语句的名称。
expression：给预备语句的参数的实际值。这必须是一个能得到与该参数数据类型（ 在预备语句创建时决定）兼容的值的表达式。</p>
<p>示例：
创建一个表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sample(k1 int, k2 int, v1 int, v2 text, PRIMARY KEY (k1, k2));
</code></pre></div>
<p>准备一个简单的Insert：</p>
<div class="highlight"><pre><span></span><code>PREPARE ins (bigint, double precision, int, text) AS
               INSERT INTO sample(k1, k2, v1, v2) VALUES ($1, $2, $3, $4);
</code></pre></div>
<p>使用不同的参数执行两次：</p>
<div class="highlight"><pre><span></span><code>EXECUTE ins(1, 2.0, 3, &#39;a&#39;);
EXECUTE ins(2, 3.0, 4, &#39;b&#39;);
</code></pre></div>
<p>查询并检查结果：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample ORDER BY k1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2 
----+----+----+----
  1 |  2 |  3 | a
  2 |  3 |  4 | b
</code></pre></div>
<h4 id="explain"><strong>EXPLAIN</strong></h4>
<p>显示一个语句的执行计划
语法：
explain ::= EXPLAIN [ [ ANALYZE ] [ VERBOSE ] | ( option [ , ... ] ) ] 
            sql_stmt</p>
<p>option ::= ANALYZE [ boolean ]
           | VERBOSE [ boolean ]
           | COSTS [ boolean ]
           | BUFFERS [ boolean ]
           | TIMING [ boolean ]
           | SUMMARY [ boolean ]
           | FORMAT { TEXT | XML | JSON | YAML }</p>
<p>描述：使用EXPLAIN语句可以显示语句的执行计划。如果使用ANALYZE选项，则语句将被执行，而不仅仅是计划执行。在这种情况下，执行信息（而不仅仅是计划的预估）被添加到EXPLAIN结果中。 
参数：
ANALYZE：执行命令并且显示实际的运行时间和其他统计信息。这个参数默认被设置为FALSE。
示例：
创建表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sample(k1 int, k2 int, v1 int, v2 text, PRIMARY KEY (k1, k2));
</code></pre></div>
<p>插入一些数据：</p>
<div class="highlight"><pre><span></span><code>INSERT INTO sample(k1, k2, v1, v2) VALUES (1, 2.0, 3, &#39;a&#39;), (2, 3.0, 4, &#39;b&#39;), (3, 4.0, 5, &#39;c&#39;);
</code></pre></div>
<p>检查执行计划中的简单选择（条件被下推）。 </p>
<div class="highlight"><pre><span></span><code>EXPLAIN SELECT * FROM sample WHERE k1 = 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>                                  QUERY PLAN
------------------------------------------------------------------------------
 Index Scan using sample_pkey on sample  (cost=0.00..15.25 rows=100 width=44)
   Index Cond: (k1 = 1)
(2 rows)
</code></pre></div>
<p>检查执行计划中是否有复杂条件的选择（第二个条件需要筛选）。 </p>
<div class="highlight"><pre><span></span><code>EXPLAIN SELECT * FROM sample WHERE k1 = 2 and floor(k2 + 1.5) = v1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Index Scan using sample_pkey on sample  (cost=0.00..17.75 rows=100 width=44)
   Index Cond: (k1 = 2)
   Remote Filter: (floor(((k2)::numeric + 1.5)) = (v1)::numeric)
(3 rows)
</code></pre></div>
<p>使用ANALYZE选项检查执行情况。 </p>
<div class="highlight"><pre><span></span><code>EXPLAIN ANALYZE SELECT * FROM sample WHERE k1 = 2 and floor(k2 + 1.5) = v1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>                                                       QUERY PLAN                            
---------------------------------------------------------------------------------------------------
 Index Scan using sample_pkey on sample  (cost=0.00..17.75 rows=100 width=44) (actual time=2.521..2.525 rows=1 loops=1)
   Index Cond: (k1 = 2)
   Remote Filter: (floor(((k2)::numeric + 1.5)) = (v1)::numeric)
 Planning Time: 0.113 ms
 Execution Time: 2.572 ms
 Peak Memory Usage: 14 kB
</code></pre></div>
<h4 id="fetch"><strong>FETCH</strong></h4>
<p>使用游标从查询中检索行
语法：
fetch ::= FETCH [ fetch_one_row | fetch_many_rows ] [ FROM | IN ] name</p>
<p>fetch_one_row ::= FIRST
                  | LAST
                  | ABSOLUTE int_literal
                  | NEXT
                  | FORWARD
                  | PRIOR
                  | BACKWARD
                  | RELATIVE int_literal</p>
<p>fetch_many_rows ::= ALL | FORWARD ALL
                    | FORWARD int_literal
                    | int_literal
                    | BACKWARD ALL
                    | BACKWARD int_literal</p>
<p>描述：FETCH从之前创建的一个游标中检索行。<br />
参数：
NEXT：取出下一行，是默认值。
PRIOR：取出当前位置之前的一行。
FIRST：取出该查询的第一行。
LAST：取出该查询的最后一行。
ABSOLUTE int_literal：取出该查询的第int_literal个行。
RELATIVE int_literal：取出第int_literal个后继行。
int_literal：取出接下来的int_literal行。
ALL：取出所有剩余的行。
FORWARD：取出下一行。
FORWARD int_literal：取出接下来的int_literal行。
FORWARD ALL：取出所有剩下的行。
BACKWARD：取出当前行前面的一行。
BACKWARD int_literal：取出前面的int_literal行（反向扫描）。
BACKWARD ALL：取出所有当前位置之前的行（反向扫描）。
name:一个已打开游标的名称。</p>
<p>游标表示其结果集中的当前位置，在声明游标之后，但在第一次FETCH或MOVE执行之前，当前位置就在第一行之前。</p>
<ul>
<li>FETCH FORWARD 0在当前位置获取行，并保持当前位置不变。 </li>
<li>FETCH NEXT、FETCH、FETCH FORWARD和FETCH FORWARD 1都在当前位置之后立即获取行，并将当前位置更新为刚刚获取的行。然而，如果在执行这些FETCH之一之前，当前位置是结果集中的最后一行，则FETCH从可用行的末尾运行，返回空结果，并且游标位置留在最后一行之后。这是一个唯一定义的状态，因此在这种状态下调用任何数量的FETCH NEXT之后，FETCH PRIOR将获取结果集中的最后一行，并将当前位置更新为最后一行。</li>
<li>FETCH PRIOR、FETCH BACKWARD和FETCH BACKWARD 1都在当前位置之前立即获取行，并将当前位置更新为刚刚获取的行。然而，如果在执行这些FETCH变体之一之前，当前位置是结果集中的第一行，则FETCH从可用行的开始处运行，返回空结果，并且游标位置留在第一行之前。这是一个唯一定义的状态，因此在该状态下调用任意数量的FETCH PRIOR后，FETCH NEXT将获取结果集中的第一行，并将当前位置更新为第一行。 </li>
<li>FETCH ALL和FETCH FORWARD ALL从当前位置之后的行中提取所有行，直到最后一行，游标位置在最后一行之后。当然，如果调用FETCH ALL（或FETCH FORWARD ALL）时，当前位置是最后一行，或者在最后一行之后，则返回空结果，并且当前位置留在最后一行后面。 </li>
<li>FETCH BACKWARD ALL从当前位置之前的行中通过第一行获取所有行，游标位置位于第一行之前。当然，如果调用FETCH BACKWARD ALL时，当前位置是第一行，或者在第一行之前，则返回一个空结果，并且当前位置留在第一行之前。
  当有这么多行可用时，FETCH :n和FETCH FORWARD :n从当前位置后的行向前精确地获取 :n 行，并包括该行，否则，与FETCH FORFORWARD ALL的行为类似，获取的行数也一样多。
  当有这么多行可用时，FETCH BACKWARD :n变量从当前位置之前的行向后精确地获取 :n 行，并包括该行，否则，与FETCH BACKWARD ALL 的行为类似，将获取尽可能多的行。</li>
<li>FETCH ABSOLUTE :n在指定的绝对位置获取单行。FETCH RELATIVE :n在与当前行精确指示的相对位置（:n可以为负）获取单行。对于FETCH ABSOLUTE :n和FETCH RELATIVE :n，请求的行可能位于第一行之前或最后一行之后。这里的结果与执行其他FETCH导致当前位置位于游标结果集中从第一行到最后一行的范围之外时的结果相同。注意：对于ABSOLUTE 和RELATIVE ，n都可以是负数。</li>
<li>FETCH FIRST和FETCH LAST中的每一个分别获取第一行或最后一行。因此，这些含义对当前游标位置不敏感，并且每个含义都可以一次又一次地重复，并且总是会产生相同的结果。</li>
</ul>
<p>请注意，FETCH FORWARD 0、FETCH BACKWARD 0和FETCH RELATIVE 0这三个的含义都相同。</p>
<p>注意：BSQL目前只支持在向前的方向上连续地从游标中提取行。</p>
<p>对于SQL语句获取和移动，以及它们的PL/pgSQL对应项尚未完全起作用的问题，这反映在以下情况下出现的错误中：
每种移动方式都会导致0A000错误，并显示诸如“move尚未支持”之类的消息。
许多fetch风格使用诸如“fetch FIRST尚未支持”、“fetch LAST尚未支持”和“fetch BACKWARD尚未支持”等消息来绘制0A000错误。
以下是唯一不会导致错误的提取方式：
fetch next
fetch
fetch :N
fetch forward
fetch forward :N
fetch all
fetch forward all</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>drop table if exists t cascade;
create table t(k, v) as
select g.val, g.val*100
from generate_series(1, 22) as g(val);

start transaction;
  declare cur scroll cursor without hold for
  select k, v
  from t
  where (k &lt;&gt; all (array[1, 3, 5, 7, 11, 13, 17, 19]))
  order by k;

  fetch forward     from cur;
  fetch forward     from cur;
  fetch forward     from cur;
  fetch forward   0 from cur;
  fetch forward   0 from cur;
  fetch forward all from cur;
rollback;
</code></pre></div>
<p>返回信息如下（空白行是手动添加的，以提高可读性）：</p>
<div class="highlight"><pre><span></span><code>  k |  v  
----+------
  2 |  200
  4 |  400
  6 |  600

  6 |  600
  6 |  600

  8 |  800
  9 |  900
 10 | 1000
 12 | 1200
 14 | 1400
 15 | 1500
 16 | 1600
 18 | 1800
 20 | 2000
 21 | 2100
 22 | 2200
</code></pre></div>
<h4 id="grant"><strong>GRANT</strong></h4>
<p>定义访问特权
语法：
grant ::= grant_table
          | grant_table_col
          | grant_seq
          | grant_db
          | grant_domain
          | grant_schema
          | grant_type
          | grant_role</p>
<p>grant_table ::= GRANT 
                { { SELECT
                    | INSERT
                    | UPDATE
                    | DELETE
                    | TRUNCATE
                    | REFERENCES
                    | TRIGGER } [ , ... ]
                  | ALL [ PRIVILEGES ] }  ON 
                { [ TABLE ] table_name [ , ... ]
                  | ALL TABLES IN SCHEMA schema_name [ , ... ] }  TO 
                grantee_role [ , ... ] [ WITH GRANT OPTION ]</p>
<p>grant_table_col ::= GRANT 
                    { { SELECT | INSERT | UPDATE | REFERENCES } ( 
                      column_names )
                      | ALL [ PRIVILEGES ] ( column_names ) }  ON 
                    { [ TABLE ] table_name [ , ... ] }  TO 
                    grantee_role [ , ... ]  [ WITH GRANT OPTION ]</p>
<p>grant_seq ::= GRANT { { USAGE | SELECT | UPDATE } [ , ... ]
                      | ALL [ PRIVILEGES ] }  ON 
              { SEQUENCE sequence_name [ , ... ]
                | ALL SEQUENCES IN SCHEMA schema_name [ , ... ] }  TO 
              grantee_role [ , ... ]  [ WITH GRANT OPTION ]</p>
<p>grant_db ::= GRANT { { CREATE | CONNECT | TEMPORARY | TEMP } [ , ... ]
                     | ALL [ PRIVILEGES ] }  ON DATABASE database_name 
             [ , ... ]  TO grantee_role [ , ... ] 
             [ WITH GRANT OPTION ]</p>
<p>grant_domain ::= GRANT { USAGE | ALL [ PRIVILEGES ] }  ON DOMAIN 
                 domain_name [ , ... ]  TO grantee_role [ , ... ]<br />
                 [ WITH GRANT OPTION ]</p>
<p>grant_schema ::= GRANT { { CREATE | USAGE } [ , ... ]
                         | ALL [ PRIVILEGES ] }  ON SCHEMA schema_name 
                 [ , ... ]  TO grantee_role [ , ... ]<br />
                 [ WITH GRANT OPTION ]</p>
<p>grant_type ::= GRANT { USAGE | ALL [ PRIVILEGES ] }  ON TYPE type_name 
               [ , ... ]  TO grantee_role [ , ... ]<br />
               [ WITH GRANT OPTION ]</p>
<p>grant_role ::= GRANT role_name [ , ... ] TO role_name 
               [ , grantee_role [ ... ] ]  [ WITH ADMIN OPTION ]</p>
<p>grantee_role ::= [ GROUP ] role_name
                 | PUBLIC
                 | CURRENT_USER
                 | SESSION_USER</p>
<p>描述：GRANT可以用于分配数据库对象的权限以及角色中的成员身份。
数据库对象上的GRANT
GRANT命令的此变体用于将数据库对象的权限分配给一个或多个角色。如果使用关键字PUBLIC而不是role_name，则意味着将权限授予所有角色，包括以后可能创建的角色。
如果指定了WITH GRANT OPTION，则特权的接收者可以将其授予其他人；否则，接受者就无法做到这一点。无法将授予选项授予PUBLIC。
不需要将权限授予对象的所有者（通常是创建对象的用户），因为默认情况下，所有者拥有所有权限。
可能的特权是：
SELECT：允许从指定表、视图或序列的任何列或者列出的特定列进行SELECT。还允许使用COPY TO。在UPDATE或DELETE中引用已有列值时也需要这个特权。
INSERT：允许INSERT一个新行到指定表中。如果列出了特定的列，只有这些列能在INSERT命令中被赋值（其他列将因此收到默认值）。还允许COPY FROM。
UPDATE：这允许对指定表的任何列或列出的特定列进行UPDATE。 
DELETE：这允许从指定的表中删除一行。 </p>
<p>TRUNCATE：允许在指定的表上TRUNCATE。
REFERENCES：这允许创建引用指定表或表的指定列的外键约束。 
TRIGGER：允许在指定的表上创建触发器。
CREATE：对于数据库，这允许在数据库中创建模式。
对于模式，这允许在模式中创建对象。若要重命名对象，您必须拥有该对象并对包含的架构具有此权限。
CONNECT：这允许用户连接到指定的数据库。此权限在连接启动时检查。 
TEMPORARY | TEMP：这允许在使用指定数据库时创建临时表。
EXECUTE：允许使用指定的函数或过程，以及使用在函数顶部实现的任何运算符。 
USAGE：对于模式，这允许访问指定模式中包含的对象（假设对象自身的权限要求也得到满足）。本质上，这允许被授予者在模式中“查找”对象。
对于序列，这种特权允许使用currval和nextval函数。
对于类型和域，此特权允许在创建表、函数和其他模式对象时使用类型或域。
ALL PRIVILEGES：同时授予所有特权。 </p>
<p>角色GRANT：
GRANT的此变体用于将角色中的成员资格授予一个或多个其他角色。如果指定了WITH ADMIN OPTION，则成员可以将该角色的成员资格授予其他人，也可以撤销该角色的会员资格。
示例：
示例1：向表'stores'上的所有用户授予SELECT权限 </p>
<div class="highlight"><pre><span></span><code>GRANT SELECT ON stores TO PUBLIC;
</code></pre></div>
<p>示例2：将用户John添加到SysAdmins组。</p>
<div class="highlight"><pre><span></span><code>GRANT SysAdmins TO John;
</code></pre></div>
<h4 id="import-foreign-schema"><strong>IMPORT FOREIGN SCHEMA</strong></h4>
<p>从一个外部服务器导入表定义
语法：
import_foreign_schema ::= IMPORT FOREIGN SCHEMA remote_schema<br />
                          [ { LIMIT TO | EXCEPT } ( table_name [ ... ] 
                            ) ]  FROM SERVER server_name INTO 
                          local_schema  [ OPTIONS ( fdw_options ) ]</p>
<p>描述：使用IMPORT FOREIGN SCHEMA命令可以创建表示外部服务器上的外部架构中的表的外部表。新创建的外部表由发出命令的用户所有。默认情况下，将导入外部架构中的所有表。但是，用户可以使用LIMIT TO 和EXCEPT 子句指定要导入的表。要使用此命令，用户必须在外部服务器上具有USAGE权限，在目标架构上具有CREATE权限。</p>
<p>参数：
LIMIT TO：LIMIT TO子句可以选择性地用于指定要导入的表，所有其他表都将被忽略。
EXCEPT ：EXCEPT子句可以选择性地用于指定不导入哪些表，将忽略所有其他表。</p>
<h4 id="insert"><strong>INSERT</strong></h4>
<p>在一个表中创建新行
语法：
insert ::= [ with_clause ]  INSERT INTO table_name [ AS alias ] 
           [ ( column_names ) ]  { DEFAULT VALUES
                                   | VALUES ( column_values ) 
                                     [ ,(column_values ... ]
                                   | subquery }<br />
           [ ON CONFLICT [ conflict_target ] conflict_action ]<br />
           [ returning_clause ]</p>
<p>returning_clause ::= RETURNING { * | { output_expression 
                                     [ [ AS ] output_name ] } 
                                     [ , ... ] }</p>
<p>column_values ::= { expression | DEFAULT } [ , ... ]</p>
<p>conflict_target ::= ( { column_name | expression } [ , ... ] ) 
                    [ WHERE boolean_expression ]
                    | ON CONSTRAINT constraint_name</p>
<p>conflict_action ::= DO NOTHING
                    | DO UPDATE SET update_item [ , ... ] 
                      [ WHERE boolean_expression ]</p>
<p>描述：INSERT将新行插入到一个表中。
参数：
table_name：一个已有表的名称（可以被模式限定）。
column_names：指定以逗号分隔的列名列表。如果指定的列不存在，则会引发错误。每个主键列都必须具有非null值。
VALUES子句：
每个值列表的长度必须与列列表的长度相同。
每个值都必须可转换为相应的（按位置）列类型。
每个值都可以是一个表达式。
ON CONFLICT子句：
目标表必须至少有一个具有唯一索引或唯一约束的列（列表）。VALUES的参数必须至少包含一个目标表的唯一键。此唯一键的某些值可能是新的，而其他值可能已存在于目标表中。
INSERT ON CONFLICT的基本目的只是插入具有唯一键的新值的行，并使用唯一键的现有值更新行，以将其余指定列的值设置为values关系中的值。通过这种方式，要么是插入，要么是更新；因此，INSERT ON CONFLICT通常被通俗地称为“upsert”。 
示例：
创建表，并插入一些数据行：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sample(
  id int  CONSTRAINT sample_id_pk PRIMARY KEY,
  c1 text CONSTRAINT sample_c1_NN NOT NULL,
  c2 text CONSTRAINT sample_c2_NN NOT NULL);
INSERT INTO sample(id, c1, c2)
  VALUES (1, &#39;cat&#39;    , &#39;sparrow&#39;),
         (2, &#39;dog&#39;    , &#39;blackbird&#39;),
         (3, &#39;monkey&#39; , &#39;thrush&#39;);
</code></pre></div>
<p>示例1：on conflict do nothing。在这种情况下，您不需要指定冲突目标。 </p>
<div class="highlight"><pre><span></span><code>INSERT INTO sample(id, c1, c2)
  VALUES (3, &#39;horse&#39; , &#39;pigeon&#39;),
         (4, &#39;cow&#39;   , &#39;robin&#39;)
  ON CONFLICT
  DO NOTHING;
</code></pre></div>
<p>检查结果。已插入id为4的非冲突行，但id为3的冲突行未更新。</p>
<div class="highlight"><pre><span></span><code>SELECT id, c1, c2 FROM sample ORDER BY id;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> id |   c1   |    c2     
----+--------+-----------
  1 | cat    | sparrow
  2 | dog    | blackbird
  3 | monkey | thrush
  4 | cow    | robin
</code></pre></div>
<p>示例2：upsert，在这种情况下，您需要指定冲突目标。请注意，EXCLUDED 关键字用于指定冲突行。</p>
<div class="highlight"><pre><span></span><code>INSERT INTO sample(id, c1, c2)
  VALUES (3, &#39;horse&#39; , &#39;pigeon&#39;),
         (5, &#39;tiger&#39; , &#39;starling&#39;)
  ON CONFLICT (id)
  DO UPDATE SET (c1, c2) = (EXCLUDED.c1, EXCLUDED.c2);
</code></pre></div>
<p>检查结果。插入id为5的非冲突行，并更新id为3的冲突行。</p>
<div class="highlight"><pre><span></span><code>SELECT id, c1, c2 FROM sample ORDER BY id;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> id |  c1   |    c2     
----+-------+-----------
  1 | cat   | sparrow
  2 | dog   | blackbird
  3 | horse | pigeon
  4 | cow   | robin
  5 | tiger | starling
</code></pre></div>
<p>示例3：
我们可以只对排除的行的指定子集进行“更新”。我们通过尝试插入两个冲突的行（id＝4和id＝5）和一个不冲突的行（id＝6），来说明这一点。并且不应使用“WHERE sample.c1&lt;&gt;'tiger'”指定c1=“tiger”的现有行进行更新。</p>
<div class="highlight"><pre><span></span><code>INSERT INTO sample(id, c1, c2)
  VALUES (4, &#39;deer&#39;   , &#39;vulture&#39;),
         (5, &#39;lion&#39;   , &#39;hawk&#39;),
         (6, &#39;cheeta&#39; , &#39;chaffinch&#39;)
  ON CONFLICT (id)
  DO UPDATE SET (c1, c2) = (EXCLUDED.c1, EXCLUDED.c2)
  WHERE sample.c1 &lt;&gt; &#39;tiger&#39;;
</code></pre></div>
<p>检查结果。插入id为6的非冲突行；更新id＝4的冲突行；但是id＝5（c1＝'tiger'）的冲突行没有被更新； </p>
<div class="highlight"><pre><span></span><code>SELECT id, c1, c2 FROM sample ORDER BY id;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> id |   c1   |    c2     
----+--------+-----------
  1 | cat    | sparrow
  2 | dog    | blackbird
  3 | horse  | pigeon
  4 | deer   | vulture
  5 | tiger  | starling
  6 | cheeta | chaffinch
</code></pre></div>
<p>请注意，此限制也是合法的：
WHERE EXCLUDED.c1 &lt;&gt; 'lion'</p>
<p>示例4：复杂的“upsert”示例
重建表，并插入一些数据行：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sample(
  id INTEGER GENERATED ALWAYS AS IDENTITY CONSTRAINT sample_id_pk PRIMARY KEY,
  c1 TEXT CONSTRAINT sample_c1_NN NOT NULL CONSTRAINT sample_c1_unq unique,
  c2 TEXT CONSTRAINT sample_c2_NN NOT NULL);

INSERT INTO sample(c1, c2)
  VALUES (&#39;cat&#39;   , &#39;sparrow&#39;),
         (&#39;deer&#39;  , &#39;thrush&#39;),
         (&#39;dog&#39;   , &#39;blackbird&#39;),
         (&#39;horse&#39; , &#39;vulture&#39;);

WITH to_be_upserted AS (
  SELECT c1, c2 FROM (VALUES
    (&#39;cat&#39;   , &#39;chaffinch&#39;),
    (&#39;deer&#39;  , &#39;robin&#39;),
    (&#39;lion&#39;  , &#39;duck&#39;),
    (&#39;tiger&#39; , &#39;pigeon&#39;)
   )
  AS t(c1, c2)
  )
  INSERT INTO sample(c1, c2) SELECT c1, c2 FROM to_be_upserted
  ON CONFLICT ON CONSTRAINT sample_c1_unq
  DO UPDATE SET c2 = EXCLUDED.c2;
</code></pre></div>
<p>检查结果：</p>
<div class="highlight"><pre><span></span><code>SELECT id, c1, c2 FROM sample ORDER BY c1;

 id |  c1   |    c2     
----+-------+-----------
  1 | cat   | chaffinch
  2 | deer  | robin
  3 | dog   | blackbird
  4 | horse | vulture
  7 | lion  | duck
  8 | tiger | pigeon
</code></pre></div>
<h4 id="lock"><strong>LOCK</strong></h4>
<p>锁定一个表
语法：
lock_table ::= LOCK [ TABLE ] { table_expr [ , ... ] } 
               [ IN lockmode MODE ] [ NOWAIT ]</p>
<p>lockmode ::= ACCESS SHARE
             | ROW SHARE
             | ROW EXCLUSIVE
             | SHARE UPDATE EXCLUSIVE
             | SHARE
             | SHARE ROW EXCLUSIVE
             | EXCLUSIVE
             | ACCESS EXCLUSIVE</p>
<p>描述：LOCK TABLE获得一个表级锁，必要时会等待任何冲突锁被释放。
注意：暂不支持表继承。</p>
<p>参数：
name：锁定的表名
lockmode：锁模式指定这个锁和哪些锁冲突，目前仅仅支持ACCESS SHARE。</p>
<h4 id="move"><strong>MOVE</strong></h4>
<p>定位一个游标
语法：
move ::= MOVE [ move_to_one_row | move_over_many_rows ] [ FROM | IN ] 
         name</p>
<p>move_to_one_row ::= FIRST
                    | LAST
                    | ABSOLUTE int_literal
                    | NEXT
                    | FORWARD
                    | PRIOR
                    | BACKWARD
                    | RELATIVE int_literal</p>
<p>move_over_many_rows ::= ALL | FORWARD ALL
                        | FORWARD int_literal
                        | int_literal
                        | BACKWARD ALL
                        | BACKWARD int_literal</p>
<p>描述：MOVE重新定位一个游标而不检索任何数据，MOVE更改游标中当前行的位置。</p>
<p>游标表示其结果集中的当前位置。在声明游标之后，但在第一次FETCH或MOVE执行之前，当前位置就在第一行之前。</p>
<ul>
<li>MOVE 0和MOVE FORWARD 0变量保持当前位置不变。因此，它们没有实际价值。</li>
<li>MOVE、MOVE NEXT、MOVE FORWARD和MOVE FORFORWARD 1都会在调用语句之前将当前位置更新到所在位置之后的一行。如果在执行其中一个MOVE之前，当前位置是结果集中的最后一行，则当前位置设置在最后一行之后。这是一个唯一定义的状态，因此在这种状态下调用任意数量的MOVE NEXT后，MOVE PRIOR将获取结果集中的最后一行，并将当前位置更新为最后一行。</li>
<li>MOVE PRIOR、MOVE BACKWARD和MOVE BACKWARD 1都会在调用语句之前将当前位置更新到所在位置之前的一行。如果在执行这些MOVE之一之前，当前位置是结果集中的第一行，则当前位置设置为第一行之前。这是一个唯一定义的状态，因此在该状态下调用任意数量的MOVE PRIOR后，MOVE NEXT将更新当前位置到第一行。 </li>
<li>MOVE ALL（和MOVE FORWARD ALL）从当前位置之后的行到最后一行移动所有行，游标位置在最后一行之后。当然，如果调用MOVE ALL（或MOVE FORWARD ALL）时，当前位置已经在最后一行之后，则当前位置留在最后一行后面。</li>
<li>MOVE BACKWARD ALL在所有行上从当前位置之前的行移动到第一行，游标位置在第一行之前。当然，如果调用MOVE BACKWARD ALL时，当前位置已经在第一行之前，那么当前位置留在第一行之前。
  当有这么足够多的行可用时，MOVE :n (和MOVE FORWARD :n) 从当前位置后的行向前精确移动 :n 行并包括该行；否则，移动尽可能多的行，类似于MOVE FORWARD ALL的行为。 
  当有这么多行可用时，MOVE BACKWARD :n变量会从当前位置之前的行向后移动：n行，并包括该行，否则会尽可能多地移动，类似于MOVE BACKWARD ALL的行为。</li>
<li>MOVE ABSOLUTE :n移动到指定绝对位置的单行。MOVE RELATIVE :n移动到与当前行精确指示的相对位置（ :n可以为负）的单行。对于MOVE ABSOLUTE :n和MOVE RELATIVE :n，请求的行可能位于第一行之前或最后一行之后。这里的结果与执行其他MOVE变体时的结果相同，这些变体导致当前位置位于游标结果集中从第一行到最后一行的范围之外。注意：对于ABSOLUTE和RELATIVE，n都可以是负数。</li>
<li>MOVE FIRST和MOVE LAST分别移动到第一行或最后一行。因此，这些含义对当前游标位置不敏感，并且每个含义都可以一次又一次地重复，并且始终具有相同的效果。 </li>
</ul>
<p>请注意，MOVE FORWARD 0、MOVE BACKWARD 0和MOVE RELATIVE 0这三个含义都相同。</p>
<h4 id="prepare"><strong>PREPARE</strong></h4>
<p>为执行准备一个语句
语法：
prepare_statement ::= PREPARE name [ ( data_type [ , ... ] ) ] AS 
                      subquery</p>
<p>描述：使用PREPARE语句通过解析、分析和重写（但不执行）目标语句来创建准备好的语句的句柄。
PREPARE中的语句可以（应该）包含EXECUTE中的表达式列表将提供的参数（例如$1）。 
PREPARE中的数据类型列表，表示语句中使用的参数的类型。</p>
<p>示例：
创建表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sample(k1 int, k2 int, v1 int, v2 text, PRIMARY KEY (k1, k2));
</code></pre></div>
<p>准备一个简单的Insert：</p>
<div class="highlight"><pre><span></span><code>PREPARE ins (bigint, double precision, int, text) AS
               INSERT INTO sample(k1, k2, v1, v2) VALUES ($1, $2, $3, $4);
</code></pre></div>
<p>执行插入两次（使用不同的参数）。</p>
<div class="highlight"><pre><span></span><code>EXECUTE ins(1, 2.0, 3, &#39;a&#39;);
EXECUTE ins(2, 3.0, 4, &#39;b&#39;);
</code></pre></div>
<p>检查数据：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample ORDER BY k1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2 
----+----+----+----
  1 |  2 |  3 | a
  2 |  3 |  4 | b
</code></pre></div>
<h4 id="reassign-owned"><strong>REASSIGN OWNED</strong></h4>
<p>更改一个数据库角色拥有的数据库对象的拥有关系
语法：
reassign_owned ::= REASSIGN OWNED BY role_specification [ , ... ] TO 
                   role_specification</p>
<p>role_specification ::= role_name | CURRENT_USER | SESSION_USER
描述：REASSIGN OWNED通常用于为删除角色做准备。它需要源角色和目标角色的成员身份。 
示例：将john拥有的所有对象重新分配给bigmath。 </p>
<div class="highlight"><pre><span></span><code>reassign owned by john to bigmath;
</code></pre></div>
<h4 id="refresh-materialized-view"><strong>REFRESH MATERIALIZED VIEW</strong></h4>
<p>替换一个物化视图的内容
语法：
refresh_matview ::= REFRESH MATERIALIZED VIEW [ CONCURRENTLY ]<br />
                    matview_name [ WITH [ NO ] DATA ]</p>
<p>描述：REFRESH MATERIALIZED VIEW完全替换一个物化视图的内容。</p>
<p>参数：
WITH DATA：如果指定了WITH DATA（默认值），则执行视图的查询以获取新数据，并更新物化视图的内容。
WITH NO DATA：如果指定WITH NO DATA，则物化视图的旧内容将被丢弃，物化视图将处于不可编辑状态。
CONCURRENTLY：在少数行需要更新的情况下，此选项可能会更快。如果没有此选项，更新大量行的刷新将使用更少的资源并更快地完成。只有当物化视图上至少有一个UNIQUE索引，并且填充了物化视图时，才允许使用此选项。CONCURRENTLY 和WITH NO DATA不能一起使用。此外，当存在所有列都为null的行时，也不能使用CONCURRENTLY选项。在这两种情况下，刷新物化视图都会引发错误。
示例：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE t1(a int4);
CREATE MATERIALIZED VIEW m1 AS SELECT * FROM t1;
INSERT INTO t1 VALUES (1);
SELECT * FROM m1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> a
---
(0 rows)
</code></pre></div>
<div class="highlight"><pre><span></span><code>REFRESH MATERIALIZED VIEW m1;
SELECT * FROM m1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> a
---
 1
(1 row)
</code></pre></div>
<h4 id="release-savepoint"><strong>RELEASE SAVEPOINT</strong></h4>
<p>销毁一个之前定义的保存点
语法：
savepoint_release ::= RELEASE [ SAVEPOINT ] name
参数
name：要销毁的保存点的名称。</p>
<p>示例：
开始一个事务并创建一个保存点。 </p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION;
SAVEPOINT test;
</code></pre></div>
<p>释放保存点： </p>
<div class="highlight"><pre><span></span><code>RELEASE test;
</code></pre></div>
<p>如果此时您尝试回滚到test，则会出现错误：</p>
<div class="highlight"><pre><span></span><code>ROLLBACK TO test;
</code></pre></div>
<p>返回错误信息如下：</p>
<div class="highlight"><pre><span></span><code>ERROR:  savepoint &quot;test&quot; does not exist
</code></pre></div>
<h4 id="reset"><strong>RESET</strong></h4>
<p>把一个运行时参数的值恢复到默认值
语法：
reset_stmt ::= RESET { run_time_parameter | ALL }
描述：RESET把运行时参数恢复到它们的默认值。RESET是SET run_time_parameter TO DEFAULT的另一种拼写。</p>
<p>参数：
run_time_parameter：一个可设置的运行时参数名称。</p>
<h4 id="revoke"><strong>REVOKE</strong></h4>
<p>移除访问特权
语法：
revoke_table ::= REVOKE [ GRANT OPTION FOR ] 
                 { { SELECT
                     | INSERT
                     | UPDATE
                     | DELETE
                     | TRUNCATE
                     | REFERENCES
                     | TRIGGER } [ , ... ]
                   | ALL [ PRIVILEGES ] }  ON 
                 { [ TABLE ] table_name [ , ... ]
                   | ALL TABLES IN SCHEMA schema_name [ , ... ] }<br />
                 FROM { [ GROUP ] role_name | PUBLIC } [ , ... ] 
                 [ CASCADE | RESTRICT ]</p>
<p>revoke_table_col ::= REVOKE [ GRANT OPTION FOR ]<br />
                     { { SELECT | INSERT | UPDATE | REFERENCES } ( 
                       column_names ) [ ,(column_names ... ]
                       | ALL [ PRIVILEGES ] ( column_names ) }  ON 
                     [ TABLE ] table_name [ , ... ] FROM 
                     { [ GROUP ] role_name | PUBLIC } [ , ... ] 
                     [ CASCADE | RESTRICT ]</p>
<p>revoke_seq ::= REVOKE [ GRANT OPTION FOR ] 
               { { USAGE | SELECT | UPDATE } [ , ... ]
                 | ALL [ PRIVILEGES ] }  ON 
               { SEQUENCE sequence_name [ , ... ]
                 | ALL SEQUENCES IN SCHEMA schema_name [ , ... ] }<br />
               FROM { [ GROUP ] role_name | PUBLIC } [ , ... ] 
               [ CASCADE | RESTRICT ]</p>
<p>revoke_db ::= REVOKE [ GRANT OPTION FOR ] 
              { { CREATE | CONNECT | TEMPORARY | TEMP } [ , ... ]
                | ALL [ PRIVILEGES ] } ON DATABASE database_name 
              [ , ... ]  FROM { [ GROUP ] role_name | PUBLIC } 
              [ , ... ] [ CASCADE | RESTRICT ]</p>
<p>revoke_domain ::= REVOKE [ GRANT OPTION FOR ] 
                  { USAGE | ALL [ PRIVILEGES ] } ON DOMAIN domain_name 
                  [ , ... ]  FROM { [ GROUP ] role_name | PUBLIC } 
                  [ , ... ] [ CASCADE | RESTRICT ]</p>
<p>revoke_schema ::= REVOKE [ GRANT OPTION FOR ] 
                  { { CREATE | USAGE } [ , ... ]
                    | ALL [ PRIVILEGES ] } ON SCHEMA schema_name 
                  [ , ... ]  FROM { [ GROUP ] role_name | PUBLIC } 
                  [ , ... ] [ CASCADE | RESTRICT ]</p>
<p>revoke_type ::= REVOKE [ GRANT OPTION FOR ] 
                { USAGE | ALL [ PRIVILEGES ] } ON TYPE type_name 
                [ , ... ]  FROM { [ GROUP ] role_name | PUBLIC } 
                [ , ... ] [ CASCADE | RESTRICT ]</p>
<p>revoke_role ::= REVOKE [ ADMIN OPTION FOR ] role_name [ , ... ] FROM 
                role_name [ , ... ] [ CASCADE | RESTRICT ]
描述：REVOKE命令收回之前从一个或者更多角色授予的特权。
任何角色都有分配给它的所有权限的总和。因此，如果REVOKE用于从PUBLIC中收回SELECT，那么并不意味着所有角色都失去了SELECT权限。如果一个角色被直接授予SELECT，或者通过组继承了它，那么它可以继续拥有SELECT权限。 
如果指定了GRANT OPTION FOR，则只收回特权的授予选项，而不收回特权本身。否则，特权和授予选项都将被撤销。 
类似地，在撤销角色时，如果指定了ADMIN OPTION FOR，则仅撤销该权限的ADMIN选项。 
如果一个用户拥有带有grant选项的特权，并已将其授予其他用户，则如果指定了CASCADE，则从第一个用户撤销特权也将从从属用户撤销特权。否则，REVOKE将失败。 
在撤销表上的权限时，也会自动撤销表中每列的相应列权限（如果有的话）。另一方面，如果一个角色被授予了对表的权限，那么从各个列中撤销相同的权限将没有任何效果。</p>
<p>示例：
示例1：撤销PUBLIC对表“stores”的SELECT权限 </p>
<div class="highlight"><pre><span></span><code>REVOKE SELECT ON stores FROM PUBLIC;
</code></pre></div>
<p>示例2：从SysAdmins组中删除用户John。</p>
<div class="highlight"><pre><span></span><code>REVOKE SysAdmins FROM John;
</code></pre></div>
<h4 id="rollback"><strong>ROLLBACK</strong></h4>
<p>中止当前事务
语法：
rollback ::= ROLLBACK [ TRANSACTION | WORK ]
描述：ROLLBACK回滚当前事务并且导致该事务所作的所有更新都被抛弃。</p>
<p>参数：
WORK | TRANSACTION：可选关键词，没有效果。
示例：</p>
<div class="highlight"><pre><span></span><code>ROLLBACK ;
</code></pre></div>
<h4 id="rollback-to-savepoint"><strong>ROLLBACK TO SAVEPOINT</strong></h4>
<p>回滚到一个保存点
语法：
savepoint_rollback ::= ROLLBACK [ WORK | TRANSACTION ] TO 
                       [ SAVEPOINT ] name
描述：使用ROLLBACK TO SAVEPOINT语句将事务的状态恢复到以前建立的保存点。这对于处理和展开键/索引约束冲突等错误特别有用。
参数：
name：要回滚到的保存点。</p>
<p>示例：
创建表，并插入一些数据：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sample(k int PRIMARY KEY, v int);
INSERT INTO sample(k, v) VALUES (1, 2);
</code></pre></div>
<p>开启一个新的事务，并插入一些数据：</p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION;
INSERT INTO sample(k, v) VALUES (3, 4);
</code></pre></div>
<p>现在，在插入k=1的重复行之前创建一个保存点： </p>
<div class="highlight"><pre><span></span><code>SAVEPOINT test;
INSERT INTO sample(k, v) VALUES (1, 3);
</code></pre></div>
<p>得到如下错误信息：</p>
<div class="highlight"><pre><span></span><code>duplicate key value violates unique constraint &quot;sample_pkey&quot;
</code></pre></div>
<p>任何其他操作都应该出错，因为事务现在处于错误状态：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample;
</code></pre></div>
<p>得到如下错误信息：</p>
<div class="highlight"><pre><span></span><code>current transaction is aborted, commands ignored until end of transaction block
</code></pre></div>
<p>但是，您可以回滚到我们以前的保存点并继续处理事务，而不会丢失我们以前的插入。</p>
<div class="highlight"><pre><span></span><code>ROLLBACK TO test;
INSERT INTO sample(k, v) VALUES (5, 6);
COMMIT;
</code></pre></div>
<p>如果检查表中的行，您将看到在主键冲突之前插入的行，以及在回滚之后插入的行：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code> k  | v
----+----
  1 |  2
  3 |  4
  5 |  6
</code></pre></div>
<h4 id="savepoint"><strong>SAVEPOINT</strong></h4>
<p>在当前事务中定义一个新的保存点
语法：
savepoint_create ::= SAVEPOINT name
描述：SAVEPOINT在当前事务中建立一个新保存点。
参数
name：给新保存点的名字。</p>
<p>示例：
创建一个表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sample(k int PRIMARY KEY, v int);
</code></pre></div>
<p>开启一个事务，并插入一些数据：</p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION;
INSERT INTO sample(k, v) VALUES (1, 2);
SAVEPOINT test;
INSERT INTO sample(k, v) VALUES (3, 4);
</code></pre></div>
<p>现在，先检查一下数据：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k | v 
---+---
 1 | 2
 3 | 4
</code></pre></div>
<p>然后，回滚到保存点测试并再次检查行。请注意，第二行不会出现： </p>
<div class="highlight"><pre><span></span><code>ROLLBACK TO test;
SELECT * FROM sample;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k  | v
----+----
  1 |  2
</code></pre></div>
<p>我们甚至可以在这一点上添加新行。如果我们随后提交事务，则只有插入的第一行和第三行将保持： </p>
<div class="highlight"><pre><span></span><code>INSERT INTO sample(k, v) VALUES (5, 6);
COMMIT;
SELECT * FROM SAMPLE;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k  | v
----+----
  1 |  2
  5 |  6
</code></pre></div>
<h4 id="select"><strong>SELECT</strong></h4>
<p>从一个表或视图检索行
语法：
select ::= [ with_clause ] SELECT select_list 
           [ trailing_select_clauses ]</p>
<p>with_clause ::= WITH [ RECURSIVE ] 
                { common_table_expression [ , ... ] }</p>
<p>select_list ::= [ ALL | DISTINCT [ ON { ( expression [ , ... ] ) } ] ] 
                 [ * | { { expression
                           | fn_over_window
                           | ordinary_aggregate_fn_invocation
                           | within_group_aggregate_fn_invocation } 
                       [ [ AS ] name ] } [ , ... ] ]</p>
<p>trailing_select_clauses ::= [ FROM { from_item [ , ... ] } ]<br />
                            [ WHERE boolean_expression ]<br />
                            [ GROUP BY { grouping_element [ , ... ] } ] 
                             [ HAVING boolean_expression ]<br />
                            [ WINDOW 
                              { { name AS window_definition } 
                              [ , ... ] } ]<br />
                            [ { UNION | INTERSECT | EXCEPT } 
                              [ ALL | DISTINCT ] select ]<br />
                            [ ORDER BY { order_expr [ , ... ] } ]<br />
                            [ LIMIT { int_expression | ALL } ]<br />
                            [ OFFSET int_expression [ ROW | ROWS ] ]<br />
                            [ FETCH { FIRST | NEXT } int_expression 
                              { ROW | ROWS } ONLY ]<br />
                            [ FOR { UPDATE
                                    | NO KEY UPDATE
                                    | SHARE
                                    | KEY SHARE } 
                              [ OF table_name [ , ... ] ] 
                              [ NOWAIT | SKIP LOCKED ] [ ... ] ]</p>
<p>common_table_expression ::= cte_name [ ( column_name [ , ... ] ) ] AS 
                            ( { select
                                | values
                                | insert
                                | update
                                | delete } )</p>
<p>fn_over_window ::= name  ( [ expression [ , ... ] | * ]<br />
                   [ FILTER ( WHERE boolean_expression ) ] OVER 
                   { window_definition | name }</p>
<p>ordinary_aggregate_fn_invocation ::= name  ( 
                                     { [ ALL | DISTINCT ] expression 
                                       [ , ... ]
                                       | * } 
                                     [ ORDER BY order_expr [ , ... ] ] 
                                     )  [ FILTER ( WHERE 
                                          boolean_expression ) ]</p>
<p>within_group_aggregate_fn_invocation ::= name  ( 
                                         { expression [ , ... ] } )<br />
                                         WITHIN GROUP ( ORDER BY 
                                         order_expr [ , ... ] )<br />
                                         [ FILTER ( WHERE 
                                           boolean_expression ) ]</p>
<p>grouping_element ::= ( ) | ( expression [ , ... ] )
                     | ROLLUP ( expression [ , ... ] )
                     | CUBE ( expression [ , ... ] )
                     | GROUPING SETS ( grouping_element [ , ... ] )</p>
<p>order_expr ::= expression [ ASC | DESC | USING operator_name ] 
               [ NULLS { FIRST | LAST } ]</p>
<p>描述：使用SELECT语句从表中检索符合给定条件的指定列的行。它指定要检索的列、表的名称以及每个选定行必须满足的条件。
相同的语法规则管理子查询，无论您在哪里使用子查询——例如，在INSERT语句中。某些语法点，例如WHERE子句谓词或sqrt（）等函数的实际参数，只允许标量子查询。
参数：
with_clause：WITH子句允许你指定一个或者多个在主查询中可以 其名称引用的子查询。在主查询期间子查询实际扮演了临时表或者视图的角色。每一个子查询都可以是一个SELECT、 TABLE、VALUES、 INSERT、 UPDATE或者 DELETE语句。在WITH中使用一个数据修改语句（INSERT、 UPDATE或者 DELETE）时，通常要包括一个RETURNING子句。
from_item：FROM子句为SELECT 指定一个或者更多源表。如果指定了多个源表，结果将是所有源表的笛卡尔积（交叉连接）。但是通常会增加限定条件（通过 WHERE）来把返回的行限制为该笛卡尔积的一个小子集。
FROM子句可以包含下列元素：
table_name：一个现有表或视图的名称（可以是模式限定的）。
alias：一个包含别名的FROM项的替代名称。
select：一个子SELECT可以出现在FROM子句中。
with_query_name：可以通过写一个WITH查询的名称来引用它，就好像该查询的名称是一个表名。
function_name：函数调用可以出现在FROM子句中，这就好像把该函数的输出创建为一个存在于该SELECT命令期间的临时表。当为该函数调用增加可选的 WITH ORDINALITY子句时，会在该函数的输出列之后追加一个新的列来为每一行编号。
可以用和表一样的方式提供一个别名。如果写了一个别名，还可以写一个列别名列表来为该函数的组合返回类型的一个或者多个属性提供替代名称，包括由ORDINALITY（如果有）增加的新列。
通过把多个函数调用包围在ROWS FROM( ... )中可以把它们整合在单个FROM-子句项中。这样一个项的输出是把每一个函数的第一行串接起来，然后是每个函数的第二行，以此类推。如果有些函数产生的行比其他函数少，则在缺失数据的地方放上空值，这样被返回的总行数总是和产生最多行的函数一样。
如果函数被定义为返回record数据类型，那么必须出现一个别名或者关键词AS，后面跟上形为 ( column_name data_type [, ... ])的列定义列表。列定义列表必须匹配该函数返回的列的实际数量和类型。
在使用ROWS FROM( ... )语法时，如果函数之一要求一个列定义列表，最好把该列定义列表放在ROWS FROM( ... )中该函数的调用之后。当且仅当正好只有一个函数并且没有 WITH ORDINALITY子句时，才能把列定义列表放在 ROWS FROM( ... )结构后面。
要把ORDINALITY和列定义列表一起使用，你必须使用 ROWS FROM( ... )语法，并且把列定义列表放在 ROWS FROM( ... )里面。
join_type：以下中的一个：
[ INNER ] JOIN
LEFT [ OUTER ] JOIN
RIGHT [ OUTER ] JOIN
FULL [ OUTER ] JOIN
CROSS JOIN
fn_over_window：fn_over_window规则表示必须用于调用窗口函数，并且可以用于调用聚合函数的特殊类型的SELECT列表项。在一些SQL数据库系统的术语中，窗口函数被称为分析函数。select规则显示了FILTER和OVER关键字 ，您可以看到，如果不指定OVER子句，就无法以这种方式调用函数，而且OVER子句需要指定为该调用样式命名的所谓窗口。FILTER子句是可选的，只有在以这种方式调用聚合函数时才能使用。
ordinary_aggregate_fn_invocation规则和within_group_aggregate_fn_invocation规则表示用于调用聚合函数（当它不是作为窗口函数调用时）的特殊类型的SELECT列表项。当聚合函数以这两种方式之一调用时，通常与GROUP BY和HAVING子句一起调用。
当您了解了从Window函数部分和Aggregate函数部分的帐户调用这两种函数后，您可以使用bsqlsh中的\df meta命令来发现特定函数的状态，例如： </p>
<div class="highlight"><pre><span></span><code>\df row_number
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>   Schema   |    Name    | Result data type | Argument data types |  Type  
------------+------------+------------------+---------------------+--------
 pg_catalog | row_number | bigint           |                     | window
\df rank
</code></pre></div>
<p>返回信息如下：             </p>
<div class="highlight"><pre><span></span><code>   Schema   | Name | Result data type |          Argument data types           |  Type  
------------+------+------------------+----------------------------------------+--------
 pg_catalog | rank | bigint           |                                        | window
 pg_catalog | rank | bigint           | VARIADIC &quot;any&quot; ORDER BY VARIADIC &quot;any&quot; | agg
</code></pre></div>
<p>函数的类型被标识为“window”，只能作为窗口函数调用。
函数的类型被同时标识为“window”和agg的函数： </p>
<ul>
<li>使用fn_over_window语法作为窗口函数 </li>
<li>使用within_group_aggregate_fn_invocation语法作为所谓的组内假设集聚合函数。 </li>
</ul>
<p>事实上，类型仅为“agg”的函数可以使用ordinary_aggregate_fn_invocation语法作为聚合函数调用，也可以使用fn_over_window syntax语法作为窗口函数调用。avg()函数在<a href="#_avg() , count(), max(), min(), sum()">avg() , count(), max(), min(), sum()</a> 小节中进行了描述。
请注意，mode()、percentile_disc()和percentile_cont()这三个函数是例外，也是唯一的例外。这些函数被称为组内有序集合聚合函数。\df仅将这些函数的类型列为“agg”，但这些不能作为窗口函数调用。尝试会导致此错误： </p>
<div class="highlight"><pre><span></span><code>WITHIN GROUP is required for ordered-set aggregate mode
</code></pre></div>
<p>实例：
创建表，并插入一些数据：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sample1(k1 bigint, k2 float, v text, PRIMARY KEY (k1, k2));
CREATE TABLE sample2(k1 bigint, k2 float, v text, PRIMARY KEY (k1, k2));
INSERT INTO sample1(k1, k2, v) VALUES (1, 2.5, &#39;abc&#39;), (1, 3.5, &#39;def&#39;), (1, 4.5, &#39;xyz&#39;);
INSERT INTO sample2(k1, k2, v) VALUES (1, 2.5, &#39;foo&#39;), (1, 4.5, &#39;bar&#39;);
</code></pre></div>
<p>使用联接从两个表中进行选择。 </p>
<div class="highlight"><pre><span></span><code>SELECT a.k1, a.k2, a.v as av, b.v as bv FROM sample1 a LEFT JOIN sample2 b ON (a.k1 = b.k1 and a.k2 = b.k2) WHERE a.k1 = 1 AND a.k2 IN (2.5, 3.5) ORDER BY a.k2 DESC;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2  | av  | bv  
----+-----+-----+-----
  1 | 3.5 | def | 
  1 | 2.5 | abc | foo
</code></pre></div>
<h4 id="set"><strong>SET</strong></h4>
<p>更改一个运行时参数
语法：
set ::= SET [ SESSION | LOCAL ] { run_time_parameter { TO | = } 
                                  { value | DEFAULT }
                                  | TIME ZONE 
                                    { timezone | LOCAL | DEFAULT } }</p>
<p>描述：SET命令更改运行时配置参数。使用此语句设置的参数值仅适用于单个会话的范围，并且不超过会话的持续时间。还可以在整个集群级别或特定数据库级别设置此类参数的默认值。例如：
alter database demo set timezone = 'America/Los_Angeles';</p>
<p>参数：
SESSION：指定该命令对当前会话有效（这是默认值）。
LOCAL：指定该命令只对当前事务有效。在COMMIT或者 ROLLBACK之后，会话级别的设置会再次生效。在事务块外部发出这个参数会发出一个警告并且不会有效果。
run_time_parameter：一个可设置运行时参数的名称。您可以使用current_setting()内置函数检查运行时参数的当前值，例如：
select current_setting('search_path');
许多运行时参数都是系统定义的。系统定义的运行时参数仅使用拉丁字母和下划线拼写。而且，在任何特定的PostgreSQL版本中，系统定义的运行时参数列表都是固定的。
show ... SQL语句是select current_setting()的简写，例如： 
show search_path;
show语句有一个特殊的变量show all，当使用select current_setting(...)无效时，它列出了每个系统定义的运行时参数的当前值。查看此列表的另一种方法是查询pg_settings目录视图，其中包含每个设置的一些有用的附带信息。
value：参数的值。</p>
<p>示例：
示例1：用户定义的运行时参数 
您还可以通过适当拼写来动态创建用户定义的运行时参数。用户定义的运行时参数的持续时间永远不会超过会话的持续时间。拼写必须包含句点，而且，只要在set语句中使用双引号，它就可以包含任意字符的任意组合。如下：</p>
<div class="highlight"><pre><span></span><code>set min.værelse17 = &#39;stue&#39;;
set &quot;MIN.VÆRELSE17@&quot; = &#39;kjøkken&#39;;
set &quot;^我的.爱好&quot; = &#39;跳舞&#39;;
select
  current_setting(&#39;min.værelse17&#39;)  as s1,
  current_setting(&#39;MIN.VÆRELSE17@&#39;) as s2,
  current_setting(&#39;^我的.爱好&#39;)      as s3;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>  s1  |   s2    |  s3  
------+---------+------
 stue | kjøkken | 跳舞
</code></pre></div>
<p>请注意：show all和查询pg_settings，从不列出用户定义的运行时参数。 </p>
<p>示例2：运行时参数涉及事务</p>
<div class="highlight"><pre><span></span><code>set search_path = pg_catalog, pg_temp;
start transaction;
set search_path = some_schema, pg_catalog, pg_temp;
set my.value = &#39;something&#39;;
select current_setting(&#39;search_path&#39;);
select current_setting(&#39;my.value&#39;);
rollback;
select current_setting(&#39;search_path&#39;);
select &#39;&gt;&#39;||current_setting(&#39;my.value&#39;)||&#39;&lt;&#39;;
</code></pre></div>
<h4 id="set-constraints"><strong>SET CONSTRAINTS</strong></h4>
<p>为当前事务设置约束检查时机
语法：
set_constraints ::= SET CONSTRAINTS { ALL | name [ , ... ] } 
                    { DEFERRED | IMMEDIATE }</p>
<p>描述：SET CONSTRAINTS设置当前事务内约束检查的行为，但不适用于not NULL和CHECK约束。
参数：
ALL：更改所有可延迟约束的模式。
name：指定一个或一个约束名称列表。
DEFERRED：将约束设置为在事务提交之前不进行检查，除非标记为DEFERRABLE，否则会立即检查唯一性和排除约束。
IMMEDIATE：设置约束立即生效。</p>
<h4 id="set-role"><strong>SET ROLE</strong></h4>
<p>设置当前会话的当前用户标识符
语法：
set_role ::= SET [ SESSION | LOCAL ] ROLE { role_name | NONE }
reset_role ::= RESET ROLE</p>
<p>描述：指定的角色名称必须是当前会话用户所属的角色。超级用户可以设置为任何角色。一旦将角色设置为role_name，任何其他SQL命令都将使用该角色可用的权限。
要将角色重置回当前用户，可以使用reset role或SET role NONE </p>
<p>示例：
示例1：更改到用户John：</p>
<div class="highlight"><pre><span></span><code>select session_user, current_user;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> session_user | current_user 
--------------+--------------
 bigmath      | bigmath

set role john;
</code></pre></div>
<div class="highlight"><pre><span></span><code>select session_user, current_user;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> session_user | current_user 
--------------+--------------
 bigmath      | john
</code></pre></div>
<p>示例2：
更改为新角色将获得该角色可用的权限。</p>
<div class="highlight"><pre><span></span><code>select session_user, current_user;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> session_user | current_user 
--------------+--------------
 bigmath      | bigmath

create database db1;
set role john;

select session_user, current_user;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> session_user | current_user 
--------------+--------------
 bigmath      | john
</code></pre></div>
<div class="highlight"><pre><span></span><code>create database db2;
</code></pre></div>
<p>返回错误信息如下：</p>
<div class="highlight"><pre><span></span><code>ERROR:  permission denied to create database
</code></pre></div>
<h4 id="set-session-authorization"><strong>SET SESSION AUTHORIZATION</strong></h4>
<p>设置当前会话的会话用户标识符和当前用户标识符
语法：
set_session_authorization ::= SET [ SESSION | LOCAL ] SESSION 
                              AUTHORIZATION { role_name | DEFAULT }</p>
<p>reset_session_authorization ::= RESET SESSION AUTHORIZATION</p>
<p>描述：使用SET SESSION AUTHORIZATION语句将当前用户和当前会话的会话用户设置为指定的用户。
会话用户只能由超级用户更改。一旦会话用户设置为role_name，任何其他SQL命令都将使用该角色可用的权限。
要将会话用户重置回当前已验证的用户，可以使用reset session AUTHORIZATION或SET session AUTHORIZATION DEFAULT</p>
<p>示例：</p>
<div class="highlight"><pre><span></span><code>select session_user, current_user;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> session_user | current_user
--------------+--------------
 bigmath| bigmath

set session authorization john;

select session_user, current_user;
 session_user | current_user
--------------+--------------
 john     | john
</code></pre></div>
<h4 id="set-transaction"><strong>SET TRANSACTION</strong></h4>
<p>设置当前事务的特性
语法：
set_transaction ::= SET TRANSACTION transaction_mode [ ... ]</p>
<p>transaction_mode ::= isolation_level
                     | read_write_mode
                     | deferrable_mode</p>
<p>isolation_level ::= ISOLATION LEVEL { READ UNCOMMITTED
                                      | READ COMMITTED
                                      | REPEATABLE READ
                                      | SERIALIZABLE }</p>
<p>read_write_mode ::= READ ONLY | READ WRITE</p>
<p>deferrable_mode ::= [ NOT ] DEFERRABLE</p>
<p>描述：使用SET TRANSACTION语句可以设置当前事务隔离级别。</p>
<p>分别使用Serializable、REPEATABLE Read和Read Committed的PostgreSQL隔离级别语法，支持Serializable、Snapshot和Read Committed Isolation。PostgreSQL的READ UNCOMITTED也映射到READ Committed Isolation。 
只有当TServer标志bm_enable_read_committed_isolation设置为true时，才支持Read Committed隔离级别。默认情况下，此标志为false，在这种情况下，AiSQL事务层的Read Committed隔离级别会回落到更严格的Snapshot 隔离级别（在这种情况中，BSQL的Read Committed和Read UNCOMITTED也依次使用快照隔离）。</p>
<p>参数：
transaction_mode：将事务模式设置为以下之一：</p>
<ul>
<li>ISOLATION LEVEL子句</li>
<li>访问模式</li>
<li>DEFERABLE模式 
  ISOLATION LEVEL clause：
  SERIALIZABLE：ANSI SQL标准中的默认值
  REPEATABLE  READ：映射到AiSQL的快照隔离级别
  READ COMMITTED：如果bm_enable_read_committed_isolation=true，则read committed被映射到AiSQL的事务层的read committed（即，语句将在开始之前看到所有提交的行）。但是，默认情况下，bm_enable_read_committed_isolation=false，在这种情况下，AiSQL的事务层的read committed返回到更严格的快照隔离。
  从本质上讲，这可以归结为快照隔离是BSQL中的默认设置。
  READ UNCOMMITTED：READ UNCOMITTED映射到AiSQL的事务层的READ Committed（请注意，如果bm_enable_read_committed_isolation=false，则事务层中的READ Committed 可能反过来映射到Snapshot 隔离级别）。
  在PostgreSQL中，READ UNCOMITTED被映射到READ COMMITTED 。
  READ WRITE mode：默认值。
  READ ONLY mode：READ ONLY模式不会阻止所有对磁盘的写入。 
  当事务为READ ONLY时，以下SQL语句为： 
  1）如果要写入的表不是临时表，则不允许：
  INSERT
  UPDATE
  DELETE
  COPY FROM
  2）总是被禁止： 
  COMMENT
  GRANT
  REVOKE
  TRUNCATE
  3）当要执行的语句是上述语句之一时，不允许执行：
  EXECUTE
  EXPLAIN ANALYZE</li>
</ul>
<p>DEFERRABLE mode：仅当同时选择了SERIALIZABLE和READ ONLY模式时，用于推迟事务。如果使用，则事务可能会在第一次获取其快照时阻塞，之后它能够在没有SERIALIZABLE 事务的正常开销的情况下运行，并且没有任何导致串行化失败或被串行化失败取消的风险。</p>
<p>DEFERRABLE模式可能有助于长时间运行的报告或备份。</p>
<p>示例：
创建表：</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sample(k1 int, k2 int, v1 int, v2 text, PRIMARY KEY (k1, k2));
</code></pre></div>
<p>开启一个事务，并插入一些数据：</p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
INSERT INTO sample(k1, k2, v1, v2) VALUES (1, 2.0, 3, &#39;a&#39;), (1, 3.0, 4, &#39;b&#39;);
</code></pre></div>
<p>用bsqlsh启动一个新的shell，然后开始另一个事务来插入更多的行。 </p>
<div class="highlight"><pre><span></span><code>BEGIN TRANSACTION; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
INSERT INTO sample(k1, k2, v1, v2) VALUES (2, 2.0, 3, &#39;a&#39;), (2, 3.0, 4, &#39;b&#39;);
</code></pre></div>
<p>在每个shell中，检查是否只有当前事务中的行可见。 
在第一个shell中：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2 
----+----+----+----
  1 |  2 |  3 | a
  1 |  3 |  4 | b
</code></pre></div>
<p>在第二个shell中：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2 
----+----+----+----
  2 |  2 |  3 | a
  2 |  3 |  4 | b
</code></pre></div>
<p>提交第一个事务并中止第二个事务。 
在第一个shell中：</p>
<div class="highlight"><pre><span></span><code>COMMIT TRANSACTION; 
</code></pre></div>
<p>在第二个shell中：</p>
<div class="highlight"><pre><span></span><code>ABORT TRANSACTION;
</code></pre></div>
<p>在每个shell中，检查是否只有来自提交事务的行可见。 
在第一个shell中：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2 
----+----+----+----
  1 |  2 |  3 | a
  1 |  3 |  4 | b
</code></pre></div>
<p>在第二个shell中：</p>
<div class="highlight"><pre><span></span><code>SELECT * FROM sample;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2 
----+----+----+----
  1 |  2 |  3 | a
  1 |  3 |  4 | b
</code></pre></div>
<h4 id="show"><strong>SHOW</strong></h4>
<p>显示一个运行时参数的值
语法：
show_stmt ::= SHOW { run_time_parameter | ALL }</p>
<p>描述：SHOW将显示运行时参数的当前设置。
BSQL中的参数值可以设置，并且通常以与PostgreSQL中相同的方式生效。然而，由于AiSQL使用了不同的存储引擎（DocDB），许多与存储层相关的配置在AiSQL中不会像在PostgreSQL中那样产生效果。例如，与连接和身份验证、查询计划、错误报告和日志记录、运行时统计信息、客户端连接默认值等相关的配置应该与PostgreSQL中的配置一样工作。
但是，与预写日志、清空或复制相关的配置可能不适用于AiSQL。相反，可以使用tserver（或master）配置标志设置相关配置。
参数：
run_time_parameter：指定要显示的参数的名称。
ALL：显示所有配置参数的值以及说明。</p>
<h4 id="show-transaction"><strong>SHOW TRANSACTION</strong></h4>
<p>使用SHOW TRANSACTION ISOLATION LEVEL语句可以显示当前事务隔离级别。
语法：
show_transaction ::= SHOW TRANSACTION ISOLATION LEVEL</p>
<p>描述：支持Serializable、Snapshot和Read Committed Isolation，分别使用SERIALIZABLE、REPEATABLE READ和READ COMMITTED 的PostgreSQL隔离级别语法。PostgreSQL的READ UNCOMMITTED 也映射到Read Committed 隔离级别。 
只有当TServer标志bm_enable_read_committed_isolation设置为true时，才支持Read Committed隔离级别。默认情况下，此标志为false，在这种情况下，AiSQL事务层的Read Committed隔离级别会回落到更严格的Snapshot 隔离级别（在这种情况中，BSQL的Read Committed和Read UNCOMITTED也依次使用快照隔离）。 </p>
<h4 id="start-transaction"><strong>START TRANSACTION</strong></h4>
<p>开始一个事务块
语法：
start_transaction ::= START TRANSACTION [ transaction_mode [ ... ] ]
描述：START TRANSACTION语句只是BEGIN语句的另一种拼写。START TRANSACTION后面的语法与BEGIN[TRANACTION|WORK]后面的语法相同。这两种可供选择的拼写具有相同的语义</p>
<h4 id="truncate"><strong>TRUNCATE</strong></h4>
<p>清空一个表或者一组表
语法：
truncate ::= TRUNCATE [ TABLE ] { table_expr [ , ... ] } 
             [ CASCADE | RESTRICT ]</p>
<p>参数：
CASCADE：自动截断所有对任一所提及表有外键引用的表以及任何由于CASCADE被加入到组中的表。
RESTRICT：如果任一表上具有来自命令中没有列出的表的外键引用，则拒绝截断。这是默认值。
指定要截断的表的名称。</p>
<ul>
<li>TRUNCATE 获取要截断的表的ACCESS EXCLUSIVE 锁。ACCESS EXCLUSIVE锁定选项尚未完全受支持。</li>
<li>外部表不支持TRUNCATE。 </li>
<li>CASCADE和RESTRICT会影响TRUNCATE语句所针对的表具有依赖表时发生的情况。依赖表（以及它的依赖表）之所以具有这种状态，是因为它们对目标表具有直接或可传递的外键约束。CASCADE导致依赖表的闭包全部被截断。如果目标表有任何依赖表，RESTRICT会导致TRUNCATE尝试失败。即使所有表都为空，此错误结果也是相同的。如果既没有写CASCADE也没有写RESTRICT，那么效果就好像写了RESTRICT一样。 </li>
</ul>
<p>示例：
创建父子表对并插入一些数据：</p>
<div class="highlight"><pre><span></span><code>drop table if exists children cascade;
drop table if exists parents  cascade;

create table parents(k int primary key, v text not null);

create table children(
  parent_k  int  not null,
  k         int  not null,
  v         text not null,

  constraint children_pk primary key(parent_k, k),

  constraint children_fk foreign key(parent_k)
    references parents(k)
    match full
    on delete cascade
    on update restrict);

insert into parents(k, v) values (1, &#39;dog&#39;), (2, &#39;cat&#39;), (3, &#39;frog&#39;);

insert into children(parent_k, k, v) values
  (1, 1, &#39;dog-child-a&#39;),
  (1, 2, &#39;dog-child-b&#39;),
  (1, 3, &#39;dog-child-c&#39;),
  (2, 1, &#39;cat-child-a&#39;),
  (2, 2, &#39;cat-child-b&#39;),
  (2, 3, &#39;cat-child-c&#39;),
  (3, 1, &#39;frog-child-a&#39;),
  (3, 2, &#39;frog-child-b&#39;),
  (3, 3, &#39;frog-child-c&#39;);

select p.v as &quot;parents.v&quot;, c.v as &quot;children.v&quot;
from parents p inner join children c on c.parent_k = p.k
order by p.k, c.k;

返回信息如下：
 parents.v |  children.v
-----------+--------------
 dog       | dog-child-a
 dog       | dog-child-b
 dog       | dog-child-c
 cat       | cat-child-a
 cat       | cat-child-b
 cat       | cat-child-c
 frog      | frog-child-a
 frog      | frog-child-b
 frog      | frog-child-c
</code></pre></div>
<p>\d children元命令显示它对父表有一个外键约束。这使它成为该表的（传递性）依赖对象：
返回信息如下：</p>
<div class="highlight"><pre><span></span><code>Indexes:
    &quot;children_pk&quot; PRIMARY KEY, lsm (parent_k HASH, k ASC)
Foreign-key constraints:
    &quot;children_fk&quot; FOREIGN KEY (parent_k) REFERENCES parents(k) MATCH FULL ON UPDATE RESTRICT ON DELETE CASCADE
</code></pre></div>
<p>请注意，on delete cascade 子句的作用仅限于delete语句的作用，它对截断的行为没有影响。没有on truncate cascade 子句，请尝试delete from parents。执行成功，并从parents 表和children 表中删除了所有行。
对于上面插入的所有行，请尝试以下操作： </p>
<div class="highlight"><pre><span></span><code>do $body$
declare
  message  text not null := &#39;&#39;;
  detail   text not null := &#39;&#39;;
begin
  -- Causes error &#39;cos &quot;cascade&quot; is required.
  truncate table parents;
  assert false, &#39;Should not get here&#39;;
exception
  -- Error 0A000
  when feature_not_supported then
    get stacked diagnostics
      message  = message_text,
      detail   = pg_exception_detail;
    assert message = &#39;cannot truncate a table referenced in a foreign key constraint&#39;,  &#39;Bad message&#39;;
    assert detail  = &#39;Table &quot;children&quot; references &quot;parents&quot;.&#39;,                          &#39;Bad detail&#39;;
end;
$body$;
</code></pre></div>
<p>它完成时没有出现错误，表明没有cascade的truncate table parents失败，现在用cascade重复该尝试，并观察结果： </p>
<div class="highlight"><pre><span></span><code>truncate table parents cascade;

select
  (select count(*) from parents) as &quot;parents count&quot;,
  (select count(*) from children) as &quot;children count&quot;;
</code></pre></div>
<p>truncate语句现在无错误地完成。返回信息如下：</p>
<div class="highlight"><pre><span></span><code> parents count | children count
---------------+----------------
             0 |              0
</code></pre></div>
<p>最后，再次尝试truncate table parents。正如承诺的那样，即使传递依赖表children是空的，它仍然会以0A000错误失败。 </p>
<h4 id="update"><strong>UPDATE</strong></h4>
<p>更新一个表的行
语法：
update ::= [ with_clause ]  UPDATE table_expr [ [ AS ] alias ]  SET 
           update_item [ , ... ] [ WHERE boolean_expression
                                   | WHERE CURRENT OF cursor_name ]<br />
           [ returning_clause ]</p>
<p>returning_clause ::= RETURNING { * | { output_expression 
                                     [ [ AS ] output_name ] } 
                                     [ , ... ] }</p>
<p>update_item ::= column_name = column_value
                | ( column_names ) = [ ROW ] ( column_values )
                | ( column_names ) = subquery</p>
<p>column_values ::= { expression | DEFAULT } [ , ... ]</p>
<p>column_names ::= column_name [ , ... ]
描述：使用UPDATE语句可以修改所有符合特定条件的行中指定列的值，如果WHERE子句中没有提供条件，则会更新所有行。UPDATE输出更新的行数。</p>
<p>参数：
with_clause：WITH子句允许你指定一个或者更多个在 UPDATE中可用其名称引用的子查询。
table_expr：要更新的表的名称（可以是模式限定的）。
alias:在UPDATE语句中指定目标表的标识符。当指定了别名时，必须使用它来代替语句中的实际表。
column_name:更新表的列的名称。
expression：指定要分配给列的值，要被赋值给该列的一个表达式，该表达式可以使用该表中这一列或者其他列的旧值。
output_expression：在每一行被更新后，要被UPDATE命令计算并且返回的表达式。该表达式可以使用 table_name指定的表或者FROM列出的表中的任何列名。写* 可以返回所有列。
subquery：指定SELECT子查询语句。其选定的值将分配给指定的列。</p>
<p>示例：
新建表，并插入一些数据，然后，再进行更新这些数据。</p>
<div class="highlight"><pre><span></span><code>CREATE TABLE sample(k1 int, k2 int, v1 int, v2 text, PRIMARY KEY (k1, k2));
INSERT INTO sample VALUES (1, 2.0, 3, &#39;a&#39;), (2, 3.0, 4, &#39;b&#39;), (3, 4.0, 5, &#39;c&#39;);
SELECT * FROM sample ORDER BY k1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2 
----+----+----+----
  1 |  2 |  3 | a
  2 |  3 |  4 | b
  3 |  4 |  5 | c
</code></pre></div>
<div class="highlight"><pre><span></span><code>UPDATE sample SET v1 = v1 + 3, v2 = &#39;7&#39; WHERE k1 = 2 AND k2 = 3;
SELECT * FROM sample ORDER BY k1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k1 | k2 | v1 | v2 
----+----+----+----
  1 |  2 |  3 | a
  2 |  3 |  7 | 7
  3 |  4 |  5 | c
</code></pre></div>
<h4 id="values"><strong>VALUES</strong></h4>
<p>计算一个行集合
语法：
values ::= VALUES ( expression_list ) [ ,(expression_list ... ]<br />
           [ ORDER BY { order_expr [ , ... ] } ]<br />
           [ LIMIT { int_expression | ALL } ]<br />
           [ OFFSET int_expression [ ROW | ROWS ] ]<br />
           [ FETCH { FIRST | NEXT } int_expression { ROW | ROWS } ONLY ]</p>
<p>expression_list ::= expression [ , ... ]
描述：VALUES计算由值表达式指定的一个行值或者一组行值。</p>
<p>参数：
expression_list:要在结果表（行集合）中指定位置计算并且插入的一个常量或者表达式。 逗号分隔的带括号的表达式列表。 形如：</p>
<div class="highlight"><pre><span></span><code>values (&#39;dog&#39;::text);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> column1 
---------
 dog
</code></pre></div>
<p>结果具有与命名为“column1”、“column2”、…“columnN”的列一样多的列，因此： </p>
<div class="highlight"><pre><span></span><code>values
  (1::int, &#39;2019-06-25 12:05:30&#39;::timestamp, &#39;dog&#39;::text),
  (2::int, &#39;2020-07-30 13:10:45&#39;::timestamp, &#39;cat&#39;::text);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> column1 |       column2       | column3 
---------+---------------------+---------
       1 | 2019-06-25 12:05:30 | dog
       2 | 2020-07-30 13:10:45 | cat
</code></pre></div>
<p>如果一个表达式是在没有类型转换的情况下编写的，则会推断出它的数据类型。例如，“dog”被推断为具有数据类型text，4.2被推断为数据类型numeric。
每个连续的带括号的表达式列表必须指定相同数量的具有相同数据类型的表达式。试试这个示例：</p>
<div class="highlight"><pre><span></span><code>values
  (1::int, &#39;2019-06-25 12:05:30&#39;::timestamp, &#39;dog&#39;::text),
  (2::int, &#39;2020-07-30 13:10:45&#39;::timestamp, &#39;cat&#39;::text, 42::int);
</code></pre></div>
<p>返回错误信息如下：</p>
<div class="highlight"><pre><span></span><code> VALUES lists must all be the same length
</code></pre></div>
<p>而这个：values (1::int), ('x'::text);
返回错误信息如下：</p>
<div class="highlight"><pre><span></span><code>  VALUES types integer and text cannot be matched
</code></pre></div>
<p>ORDER BY, LIMIT, OFFSET, 与FETCH：当在VALUES语句中使用这些子句时，它们的语义与在SELECT语句中使用它们时的语义相同。</p>
<p>示例：
示例1：VALUES语句可以用作子查询，方法是用括号将其括起来，并给它一个别名，就像SELECT语句可以被如此引用使用一样。</p>
<div class="highlight"><pre><span></span><code>select chr(v) as c from (
  select * from generate_series(97, 101)
  ) as t(v);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> c 
---
 a
 b
 c
 d
 e
</code></pre></div>
<p>示例2：现在在括号中使用VALUES语句（第2行），而不是SELECT语句： </p>
<div class="highlight"><pre><span></span><code>select chr(v) as c from (
  values (100), (111), (103)
  ) as t(v);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> c
---
 d
 o
 g
</code></pre></div>
<h3 id="_192"><strong>内置函数和运算符</strong></h3>
<h4 id="_193"><strong>逻辑操作符</strong></h4>
<p>常用的逻辑操作符有：
AND 
OR
NOT 
SQL使用三值的逻辑系统，包括真、假和null，null表示“未知”。观察下面的真值表：</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>a AND b</th>
<th>a OR b</th>
</tr>
</thead>
<tbody>
<tr>
<td>TRUE</td>
<td>TRUE</td>
<td>TRUE</td>
<td>TRUE</td>
</tr>
<tr>
<td>TRUE</td>
<td>FALSE</td>
<td>FALSE</td>
<td>TRUE</td>
</tr>
<tr>
<td>TRUE</td>
<td>NULL</td>
<td>NULL</td>
<td>TRUE</td>
</tr>
<tr>
<td>FALSE</td>
<td>FALSE</td>
<td>FALSE</td>
<td>FALSE</td>
</tr>
<tr>
<td>FALSE</td>
<td>NULL</td>
<td>FALSE</td>
<td>NULL</td>
</tr>
<tr>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>a</th>
<th>NOT a</th>
</tr>
</thead>
<tbody>
<tr>
<td>TRUE</td>
<td>FALSE</td>
</tr>
<tr>
<td>FALSE</td>
<td>TRUE</td>
</tr>
<tr>
<td>NULL</td>
<td>NULL</td>
</tr>
</tbody>
</table>
<p>操作符AND和OR是可交换的，也就是说，你可以交换左右操作数而不影响结果。</p>
<h4 id="_194"><strong>比较函数和操作符</strong></h4>
<h5 id="_195"><strong>操作符</strong></h5>
<p>常见的比较操作符都可用，如下表所示：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
</tbody>
</table>
<p>这些比较操作符适用于所有具有自然排序的内置数据类型，包括数字、字符串、和日期/时间类型。 此外，如果它们的组件数据类型具有可比性，则可以比较阵列、复合类型和范围。</p>
<p>通常也可以比较相关数据类型的值；例如integer &gt; bigint 将起作用。 这种排序的某些情况直接由“cross-type” 比较操作符实现，但是，如果没有这种操作符，解析器将把不太通用的类型强制为更通用的类型，并应用后者的比较操作符。</p>
<p>如上所示，所有比较操作符都是二元操作符，返回boolean类型的值。 因此，类似1 &lt; 2 &lt; 3的表达式是无效的。因为没有&lt;操作符与 3 进行Boolean值比较）。 使用下面显示的BETWEEN谓词执行范围测试。</p>
<h5 id="_196"><strong>比较谓词</strong></h5>
<p>此外，也有一些比较谓词。它们的行为和操作符很像，但是具有 SQL 标准所要求的特殊语法。比较谓词如下表所示：</p>
<table>
<thead>
<tr>
<th>谓词</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>a BETWEEN x AND y</td>
<td>之间(包括范围端点)。</td>
<td>2 BETWEEN 1 AND 3 返回 t2 BETWEEN 3 AND 1 返回 f</td>
</tr>
<tr>
<td>a NOT BETWEEN x AND y</td>
<td>不在之间 (BETWEEN的否定)。</td>
<td>2 NOT BETWEEN 1 AND 3 返回 f</td>
</tr>
<tr>
<td>a BETWEEN SYMMETRIC x AND y</td>
<td>之间, 在对两个端点值排序之后。</td>
<td>2 BETWEEN SYMMETRIC 3 AND 1 返回 t</td>
</tr>
<tr>
<td>a NOT BETWEEN SYMMETRIC x AND y</td>
<td>不在之间, 在对两个端点值排序之后。</td>
<td>2 NOT BETWEEN SYMMETRIC 3 AND 1 返回 f</td>
</tr>
<tr>
<td>a IS DISTINCT FROM b</td>
<td>不相等, 将空(null)视为可比值。</td>
<td>1 IS DISTINCT FROM NULL 返回 t (而不是 NULL) NULL IS DISTINCT FROM NULL 返回 f (而不是 NULL)</td>
</tr>
<tr>
<td>a IS NOT DISTINCT FROM b</td>
<td>相等, 将空(null)视为可比值。</td>
<td>1 IS NOT DISTINCT FROM NULL 返回 f (而不是 NULL) NULL IS NOT DISTINCT FROM NULL 返回 t (而不是 NULL)</td>
</tr>
<tr>
<td>expression IS NULL</td>
<td>测试值是否为空。</td>
<td>1.5 IS NULL 返回 f</td>
</tr>
<tr>
<td>expression IS NOT NULL</td>
<td>测试值是否不为空。</td>
<td>'null' IS NOT NULL 返回 t</td>
</tr>
<tr>
<td>expression ISNULL</td>
<td>测试值是否为空（非标准语法）。</td>
<td></td>
</tr>
<tr>
<td>expression NOTNULL</td>
<td>测试值是否不为空（非标准语法）。</td>
<td></td>
</tr>
<tr>
<td>boolean_expression IS TRUE</td>
<td>测试布尔表达式是否为真。</td>
<td>true IS TRUE 返回 t NULL::boolean IS TRUE 返回 f (而不是 NULL)</td>
</tr>
<tr>
<td>boolean_expression IS NOT TRUE</td>
<td>测试布尔表达式是否为假或未知。</td>
<td>true IS NOT TRUE 返回 f NULL::boolean IS NOT TRUE 返回 t (而不是 NULL)</td>
</tr>
<tr>
<td>boolean_expression IS FALSE</td>
<td>测试布尔表达式是否为假。</td>
<td>true IS FALSE 返回 f NULL::boolean IS FALSE 返回 f (而不是 NULL)</td>
</tr>
<tr>
<td>boolean_expression IS NOT FALSE</td>
<td>测试布尔表达式是否为真或未知。</td>
<td>true IS NOT FALSE 返回 t NULL::boolean IS NOT FALSE 返回 t (而不是 NULL)</td>
</tr>
<tr>
<td>boolean_expression IS UNKNOWN</td>
<td>测试布尔表达式是否为未知。</td>
<td>true IS UNKNOWN 返回 f NULL::boolean IS UNKNOWN 返回 t (而不是 NULL)</td>
</tr>
<tr>
<td>boolean_expression IS NOT UNKNOWN</td>
<td>测试布尔表达式是否为真或假。</td>
<td>true IS NOT UNKNOWN 返回 t NULL::boolean IS NOT UNKNOWN 返回 f (而不是 NULL)</td>
</tr>
</tbody>
</table>
<p>BETWEEN谓词可以简化范围测试：</p>
<p>a BETWEEN x AND y
等效于</p>
<p>a &gt;= x AND a &lt;= y
注意BETWEEN认为终点值是包含在范围内的。 BETWEEN SYMMETRIC 就像BETWEEN，除了没有要求AND的左边的参数小于或等于右边的参数。 如果不是的话，这两个参数将自动交换，因此总是隐含一个非空范围。。</p>
<p>BETWEEN的各种变量都是以普通比较操作符的方式实现的，因此适用于任何可以比较的数据类型。</p>
<p>当有一个输入为空时，普通的比较操作符会得到空（表示“未知”），而不是真或假。例如，7 = NULL得到空，7 &lt;&gt; NULL也一样。如果这种行为不合适，可以使用IS [ NOT ] DISTINCT FROM谓词：</p>
<p>a IS DISTINCT FROM b
a IS NOT DISTINCT FROM b</p>
<p>对于非空输入，IS DISTINCT FROM和&lt;&gt;操作符一样。不过，如果两个输入都为空，它会返回假。而如果只有一个输入为空，它会返回真。类似地，IS NOT DISTINCT FROM对于非空输入的行为与=相同，但是当两个输入都为空时它返回真，并且当只有一个输入为空时返回假。因此，这些谓词实际上把空值当作一种普通数据值而不是“unknown”。</p>
<p>要检查一个值是否为空，使用下面的谓词：</p>
<p>expression IS NULL
expression IS NOT NULL</p>
<p>或者等效，但并不标准的谓词：</p>
<p>expression ISNULL
expression NOTNULL</p>
<p>不要写expression = NULL，因为NULL是不“等于”NULL的</p>
<p>如果expression是行值，那么当行表达式本身为非空值或者行的所有域为非空时IS NULL为真。由于这种行为，IS NULL和IS NOT NULL并不总是为行值表达式返回反转的结果，特别是，一个同时包含 NULL 和非空值的域将会对两种测试都返回假。在某些情况下，写成row IS DISTINCT FROM NULL或者row IS NOT DISTINCT FROM NULL会更好，它们只会检查整个行值是否为空而不需要在行的域上做额外的测试。</p>
<p>布尔值也可以使用下列谓词进行测试：</p>
<p>boolean_expression IS TRUE
boolean_expression IS NOT TRUE
boolean_expression IS FALSE
boolean_expression IS NOT FALSE
boolean_expression IS UNKNOWN
boolean_expression IS NOT UNKNOWN</p>
<p>这些谓词将总是返回真或假，从来不返回空值，即使操作数是空也如此。空值输入被当做逻辑值“未知”。 请注意实际上IS UNKNOWN和IS NOT UNKNOWN分别与IS NULL和IS NOT NULL相同， 只是输入表达式必须是布尔类型。</p>
<h5 id="_197"><strong>比较函数</strong></h5>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>num_nonnulls()</td>
<td>返回非空参数的数量。</td>
</tr>
<tr>
<td>num_nulls()</td>
<td>返回空参数的数量。</td>
</tr>
</tbody>
</table>
<h6 id="num_nonnulls"><strong>num_nonnulls()</strong></h6>
<p>目的：返回非空参数的数量。</p>
<p>语法：</p>
<p>输入值:      VARIADIC "any"
返回值:      integer </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select num_nonnulls(1, NULL, 2) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2
</code></pre></div>
<h6 id="num_nulls"><strong>num_nulls()</strong></h6>
<p>目的：返回空参数的数量。</p>
<p>语法：</p>
<p>输入值:    VARIADIC "any"
返回值:    integer  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select num_nulls(1, NULL, 2);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>1
</code></pre></div>
<h4 id="_198"><strong>数学函数和操作符</strong></h4>
<p>除非另有说明, 显示为可接受 numeric_type 的操作符对所有的 smallint、integer、bigint、numeric、real 和 double precision类型都可用。 显示为可接受 integral_type 的操作符对 smallint、integer 和 bigint类型是可用的。 除了特别说明之处，操作符的每种形式都返回与其参数相同的数据类型。 涉及多个参数数据类型的调用， 例如 integer + numeric，可通过使用这些列表中稍后出现的类型来解析。</p>
<h5 id="_199"><strong>数学操作符</strong></h5>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_+_4">+</a></td>
<td>加</td>
</tr>
<tr>
<td><a href="#_+_5">+</a></td>
<td>一元加(无操作)</td>
</tr>
<tr>
<td><a href="#_-_5">-</a></td>
<td>减</td>
</tr>
<tr>
<td><a href="#_-_6">-</a></td>
<td>否定</td>
</tr>
<tr>
<td><a href="#_*_2">*</a></td>
<td>乘</td>
</tr>
<tr>
<td><a href="#_/_1">/</a></td>
<td>除</td>
</tr>
<tr>
<td><a href="#_%">%</a></td>
<td>模（取余）</td>
</tr>
<tr>
<td><a href="#_^">^</a></td>
<td>指数</td>
</tr>
<tr>
<td>[</td>
<td>/](#_</td>
</tr>
<tr>
<td>[</td>
<td></td>
</tr>
<tr>
<td><a href="#_!">!</a></td>
<td>阶乘</td>
</tr>
<tr>
<td><a href="#_!!_1">!!</a></td>
<td>阶乘作为前缀操作符</td>
</tr>
<tr>
<td><a href="#_@">@</a></td>
<td>绝对值</td>
</tr>
<tr>
<td><a href="#_&amp;_2">&amp;</a></td>
<td>按位与(AND)</td>
</tr>
<tr>
<td>[</td>
<td>](#_</td>
</tr>
<tr>
<td><a href="#_#_3">#</a></td>
<td>按位异或</td>
</tr>
<tr>
<td><a href="#_~_2">~</a></td>
<td>按位求反(NOT)</td>
</tr>
<tr>
<td><a href="#_&lt;&lt;_4">&lt;&lt;</a></td>
<td>按位左移</td>
</tr>
<tr>
<td><a href="#_&gt;&gt;_4">&gt;&gt;</a></td>
<td>按位右移</td>
</tr>
</tbody>
</table>
<h6 id="_200"><strong>+</strong></h6>
<p>目的：相加。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select 2 + 3;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>5
</code></pre></div>
<h6 id="_201"><strong>+</strong></h6>
<p>目的：一元加(无操作)。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select + 3.5; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>3.5
</code></pre></div>
<h6 id="-_16"><strong>-</strong></h6>
<p>目的：减。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select 2 - 3; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>-1
</code></pre></div>
<h6 id="-_17"><strong>-</strong></h6>
<p>目的：否定。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select - (-4);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>4
</code></pre></div>
<h6 id="_202">*</h6>
<p>目的：乘。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select 2 * 3;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>6
</code></pre></div>
<h6 id="_203"><strong>/</strong></h6>
<p>目的：除(对于整型，除法将结果截断为零)。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select 5.0 / 2 ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2.5000000000000000
</code></pre></div>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select 5 / 2 ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2
</code></pre></div>
<h6 id="_204"><strong>%</strong></h6>
<p>目的：模（取余）; 适用于 smallint，integer，bigint 和 numeric。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select 5 % 4;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>1
</code></pre></div>
<h6 id="_205"><strong>^</strong></h6>
<p>目的：指数 (多次使用 ^ 将会从左到有关联) 。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select 2 ^ 3;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>8
</code></pre></div>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select 2 ^ 3 ^ 3;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>512
</code></pre></div>
<h6 id="_206"><strong>|/</strong></h6>
<p>目的：平方根。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select |/ 25.0 ; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>5
</code></pre></div>
<h6 id="_207"><strong>||/</strong></h6>
<p>目的：立方根。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ||/ 64.0;
</code></pre></div>
<p>返回信息如下： </p>
<div class="highlight"><pre><span></span><code>4
</code></pre></div>
<h6 id="_208"><strong>!</strong></h6>
<p>目的：阶乘(已弃用, 使用 factorial() 代替) 。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select 5 !;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>120
</code></pre></div>
<h6 id="_209"><strong>!!</strong></h6>
<p>目的：阶乘作为前缀操作符(已弃用, 使用 factorial() 代替)。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select !! 5; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>120
</code></pre></div>
<h6 id="_210"><strong>@</strong></h6>
<p>目的：绝对值。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select @ -5.0 ; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>5
</code></pre></div>
<h6 id="_211"><strong>&amp;</strong></h6>
<p>目的：按位与(AND)。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select 91 &amp; 15 ; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>11
</code></pre></div>
<h6 id="_212"><strong>|</strong></h6>
<p>目的：按位或(OR) 。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select 32 | 3;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>35
</code></pre></div>
<h6 id="_213"><strong>#</strong></h6>
<p>目的：按位异或。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select 17 # 5; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>20
</code></pre></div>
<h6 id="_214"><strong>~</strong></h6>
<p>目的：按位求反(NOT)。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ~1 ; 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>-2
</code></pre></div>
<h6 id="_215"><strong>&lt;&lt;</strong></h6>
<p>目的：按位左移。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select 1 &lt;&lt; 4;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>16
</code></pre></div>
<h6 id="_216"><strong>&gt;&gt;</strong></h6>
<p>目的：按位右移。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select 8 &gt;&gt; 2;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2
</code></pre></div>
<h5 id="_217"><strong>数学函数</strong></h5>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_abs()">abs()</a></td>
<td>绝对值</td>
</tr>
<tr>
<td><a href="#_cbrt()">cbrt()</a></td>
<td>立方根</td>
</tr>
<tr>
<td><a href="#_ceil()">ceil()</a></td>
<td>大于或等于参数的最接近的整数</td>
</tr>
<tr>
<td><a href="#_ceiling()">ceiling()</a></td>
<td>大于或等于参数的最接近的整数 (与 ceil 相同)</td>
</tr>
<tr>
<td><a href="#_degrees()">degrees()</a></td>
<td>将弧度转换为角度</td>
</tr>
<tr>
<td><a href="#_div()">div()</a></td>
<td>y/x 的整数商</td>
</tr>
<tr>
<td><a href="#_exp()">exp()</a></td>
<td>指数 (e 的给定次方)</td>
</tr>
<tr>
<td><a href="#_factorial()">factorial()</a></td>
<td>阶乘</td>
</tr>
<tr>
<td><a href="#_floor()">floor()</a></td>
<td>小于或等于参数的最接近整数</td>
</tr>
<tr>
<td><a href="#_ln()">ln()</a></td>
<td>自然对数</td>
</tr>
<tr>
<td><a href="#_log()">log()</a></td>
<td>以10为底的对数</td>
</tr>
<tr>
<td><a href="#_log()_1">log()</a></td>
<td>以指定值为底的对数</td>
</tr>
<tr>
<td><a href="#_mod()">mod()</a></td>
<td>余数</td>
</tr>
<tr>
<td><a href="#_pi()">pi()</a></td>
<td>π的近似值</td>
</tr>
<tr>
<td><a href="#_power()">power()</a></td>
<td>a的b次幂</td>
</tr>
<tr>
<td><a href="#_radians(dp)">radians()</a></td>
<td>将角度转换为弧度</td>
</tr>
<tr>
<td><a href="#_round()">round()</a></td>
<td>四舍五入到最近的整数</td>
</tr>
<tr>
<td><a href="#_round()_1">round()</a></td>
<td>四舍五入到指定的小数位</td>
</tr>
<tr>
<td><a href="#_scale(numeric)">scale()</a></td>
<td>小数点后的位数</td>
</tr>
<tr>
<td><a href="#_sign()">sign()</a></td>
<td>参数的符号</td>
</tr>
<tr>
<td><a href="#_sqrt()">sqrt()</a></td>
<td>平方根</td>
</tr>
<tr>
<td><a href="#_trunc()">trunc()</a></td>
<td>截断整数</td>
</tr>
<tr>
<td><a href="#_trunc(v numeric, s int)">trunc()</a></td>
<td>截断到指定小数位</td>
</tr>
<tr>
<td><a href="#_width_bucket(operand dp, b1 dp, b2 dp, count int)">width_bucket()</a></td>
<td>返回包含等宽柱的柱状图中，操作数所在的柱的编号，范围从低到高。</td>
</tr>
<tr>
<td><a href="#_width_bucket()_1">width_bucket()</a></td>
<td>返回一个柱号，这个柱是在给定数组中操作数将被分配的柱。</td>
</tr>
</tbody>
</table>
<h6 id="abs"><strong>abs()</strong></h6>
<p>目的：绝对值</p>
<p>语法：</p>
<p>输入值:    bigint 
返回值:    bigint</p>
<p>或者</p>
<p>输入值:    double precision 
返回值:    double precision</p>
<p>或者</p>
<p>输入值:    integer
返回值:    integer</p>
<p>或者</p>
<p>输入值:    numeric 
返回值:    numeric</p>
<p>或者</p>
<p>输入值:    real 
返回值:    real</p>
<p>或者</p>
<p>输入值:    smallint 
返回值:    smallint</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select abs(-17.4);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>17.4
</code></pre></div>
<h6 id="cbrt"><strong>cbrt()</strong></h6>
<p>目的：立方根</p>
<p>语法：</p>
<p>输入值:     double precision
返回值:     double precision  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select cbrt(64.0);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>4
</code></pre></div>
<h6 id="ceil"><strong>ceil()</strong></h6>
<p>目的：大于或等于参数的最接近的整数</p>
<p>语法：</p>
<p>输入值:     numeric
返回值:     numeric</p>
<p>或者</p>
<p>输入值:     double precision
返回值:     double precision  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ceil(-42.8);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>-42
</code></pre></div>
<h6 id="ceiling"><strong>ceiling()</strong></h6>
<p>目的：大于或等于参数的最接近的整数 (与 ceil 相同)</p>
<p>语法：</p>
<p>输入值:     numeric
返回值:     numeric</p>
<p>或者</p>
<p>输入值:     double precision
返回值:     double precision     </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ceiling(-42.8);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>-42
</code></pre></div>
<h6 id="degrees"><strong>degrees()</strong></h6>
<p>目的：将弧度转换为角度</p>
<p>语法：</p>
<p>输入值:    double precision 
返回值:    double precision   </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select degrees(0.5);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>28.6478897565412
</code></pre></div>
<h6 id="div"><strong>div()</strong></h6>
<p>目的：y/x 的整数商</p>
<p>语法：</p>
<p>输入值:     numeric, numeric
返回值:     numeric  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select div(9,4);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2
</code></pre></div>
<h6 id="exp"><strong>exp()</strong></h6>
<p>目的：指数 (e 的给定次方)</p>
<p>语法：</p>
<p>输入值:     numeric
返回值:     numeric</p>
<p>或者</p>
<p>输入值:     double precision
返回值:     double precision      </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select exp(1.0);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2.7182818284590452
</code></pre></div>
<h6 id="factorial"><strong>factorial()</strong></h6>
<p>目的：阶乘</p>
<p>语法：</p>
<p>输入值:     bigint
返回值:     numeric  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select factorial(5);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>120
</code></pre></div>
<h6 id="floor"><strong>floor()</strong></h6>
<p>目的：小于或等于参数的最接近整数</p>
<p>语法：</p>
<p>输入值:     numeric
返回值:     numeric</p>
<p>或者</p>
<p>输入值:     double precision
返回值:     double precision      </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select floor(42.8) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>42
</code></pre></div>
<h6 id="ln"><strong>ln()</strong></h6>
<p>目的：自然对数</p>
<p>语法：</p>
<p>输入值:     numeric
返回值:     numeric</p>
<p>或者</p>
<p>输入值:     double precision
返回值:     double precision       </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select ln(2.0);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>0.6931471805599453
</code></pre></div>
<h6 id="log"><strong>log()</strong></h6>
<p>目的：以10为底的对数</p>
<p>语法：</p>
<p>输入值:     numeric
返回值:     numeric</p>
<p>或者</p>
<p>输入值:     double precision
返回值:     double precision       </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select log(100);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2
</code></pre></div>
<h6 id="log_1"><strong>log()</strong></h6>
<p>目的：以指定值为底的对数</p>
<p>语法：</p>
<p>输入值:     numeric, numeric
返回值:     numeric  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select log(2.0, 64.0);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>6.0000000000000000
</code></pre></div>
<h6 id="mod"><strong>mod()</strong></h6>
<p>目的：余数； 适用于smallint、integer、bigint、和 numeric</p>
<p>语法：</p>
<p>输入值:     smallint, smallint
返回值:     smallint</p>
<p>或者</p>
<p>输入值:     bigint, bigint
返回值:     bigint</p>
<p>或者</p>
<p>输入值:     integer, integer
返回值:     integer</p>
<p>或者</p>
<p>输入值:     numeric, numeric
返回值:     numeric  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select mod(9,4) ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>1
</code></pre></div>
<h6 id="pi"><strong>pi()</strong></h6>
<p>目的：π的近似值</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pi();
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>3.14159265358979
</code></pre></div>
<h6 id="power"><strong>power()</strong></h6>
<p>目的：a的b次幂</p>
<p>语法：</p>
<p>输入值:     double precision, double precision
返回值:     double precision</p>
<p>或者</p>
<p>输入值:     numeric, numeric
返回值:     numeric      </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select power(9.0, 3.0);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>729.0000000000000000
</code></pre></div>
<h6 id="radians"><strong>radians()</strong></h6>
<p>目的：将角度转换为弧度</p>
<p>语法：</p>
<p>输入值:     double precision
返回值:     double precision  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select radians(45.0);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>0.785398163397448
</code></pre></div>
<h6 id="round"><strong>round()</strong></h6>
<p>目的：四舍五入到最近的整数</p>
<p>语法：</p>
<p>输入值:     double precision
返回值:     double precision</p>
<p>或者</p>
<p>输入值:     numeric
返回值:     numeric          </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select round(42.4);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>42
</code></pre></div>
<h6 id="round_1"><strong>round()</strong></h6>
<p>目的：四舍五入到指定的小数位</p>
<p>语法：</p>
<p>输入值:     numeric, integer
返回值:     numeric  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select round(42.4382, 2);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>42.44
</code></pre></div>
<h6 id="scale"><strong>scale()</strong></h6>
<p>目的：小数点后的位数</p>
<p>语法：</p>
<p>输入值:     numeric
返回值:     integer  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select scale(8.41);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2
</code></pre></div>
<h6 id="sign"><strong>sign()</strong></h6>
<p>目的：参数的符号 (-1, 0, 或 +1)</p>
<p>语法：</p>
<p>输入值:      double precision
返回值:      double precision </p>
<p>或者</p>
<p>输入值:      numeric
返回值:      numeric</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select sign(-8.4);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>-1
</code></pre></div>
<h6 id="sqrt"><strong>sqrt()</strong></h6>
<p>目的：平方根</p>
<p>语法：</p>
<p>输入值:      double precision
返回值:      double precision </p>
<p>或者</p>
<p>输入值:      numeric
返回值:      numeric</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select sqrt(2);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>1.4142135623731
</code></pre></div>
<h6 id="trunc"><strong>trunc()</strong></h6>
<p>目的：截断整数</p>
<p>语法：</p>
<p>输入值:      double precision
返回值:      double precision </p>
<p>或者</p>
<p>输入值:      numeric
返回值:      numeric</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select trunc(-42.8);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>-42
</code></pre></div>
<h6 id="trunc_1"><strong>trunc()</strong></h6>
<p>目的：截断到指定小数位</p>
<p>语法：</p>
<p>输入值:     numeric, integer
返回值:     numeric  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select trunc(42.4382, 2);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>42.43
</code></pre></div>
<h6 id="width_bucket"><strong>width_bucket()</strong></h6>
<p>目的：返回包含等宽柱的柱状图中，操作数所在的柱的编号，范围从低到高。 超出该范围的输入则返回0或计数+1。</p>
<p>语法：</p>
<p>输入值:     double precision, double precision, double precision, integer
返回值:     integer  </p>
<p>或者</p>
<p>输入值:     numeric, numeric, numeric, integer
返回值:     integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select width_bucket(5.35, 0.024, 10.06, 5);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>3
</code></pre></div>
<h6 id="width_bucket_1"><strong>width_bucket()</strong></h6>
<p>目的：返回一个柱号，这个柱是在给定数组中操作数将被分配的柱。 对于一个低于第一个下界的输入返回0。 操作数和数组元素可以是具有标准比较操作符的任何类型。 数组必须被排好序，最小的排在最前面，否则将会得到意想不到的结果。</p>
<p>语法：</p>
<p>输入值:     anyelement, anyarray
返回值:     integer  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select width_bucket(now(), array[&#39;yesterday&#39;, &#39;today&#39;, &#39;tomorrow&#39;]::timestamptz[]);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2
</code></pre></div>
<h5 id="_218"><strong>随机函数</strong></h5>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_random()">random()</a></td>
<td>返回一个范围 0.0 &lt;= x &lt; 1.0 中的随机值</td>
</tr>
<tr>
<td><a href="#_setseed()">setseed()</a></td>
<td>为后续的random()调用设置种子</td>
</tr>
</tbody>
</table>
<h6 id="random"><strong>random()</strong></h6>
<p>目的：返回一个范围 0.0 &lt;= x &lt; 1.0 中的随机值</p>
<p>语法：</p>
<p>返回值:     double precision</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select random();
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>0.326691458001733
</code></pre></div>
<h6 id="setseed"><strong>setseed()</strong></h6>
<p>目的：为后续的random()调用设置种子；参数必须在-1.0和1.0之间，包括边界值</p>
<p>语法：</p>
<p>输入值:     double precision
返回值:     void</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select setseed(0.12345);
</code></pre></div>
<h5 id="_219"><strong>三角函数</strong></h5>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_acos(x)">acos()</a></td>
<td>反余弦，结果为弧度</td>
</tr>
<tr>
<td><a href="#_acosd()">acosd()</a></td>
<td>反余弦，结果为度数</td>
</tr>
<tr>
<td><a href="#_asin(x)">asin()</a></td>
<td>反正弦，结果为弧度</td>
</tr>
<tr>
<td><a href="#_asind()">asind()</a></td>
<td>反正弦，结果为度数</td>
</tr>
<tr>
<td><a href="#_atan()">atan()</a></td>
<td>反正切，结果为弧度</td>
</tr>
<tr>
<td><a href="#_atand()">atand()</a></td>
<td>反正切，结果为度数</td>
</tr>
<tr>
<td><a href="#_atan2()">atan2()</a></td>
<td>y/x的反正切，结果为弧度</td>
</tr>
<tr>
<td><a href="#_atan2d()">atan2d()</a></td>
<td>y/x的反正切，结果为度数</td>
</tr>
<tr>
<td><a href="#_cos()">cos()</a></td>
<td>余弦，参数为弧度</td>
</tr>
<tr>
<td><a href="#_cosd()">cosd()</a></td>
<td>余弦，参数为度数</td>
</tr>
<tr>
<td><a href="#_cot()">cot()</a></td>
<td>余切，参数为弧度</td>
</tr>
<tr>
<td><a href="#_cotd()">cotd()</a></td>
<td>余切，参数为度数</td>
</tr>
<tr>
<td><a href="#_sin()">sin()</a></td>
<td>正弦，参数为弧度</td>
</tr>
<tr>
<td><a href="#_sind()">sind()</a></td>
<td>正弦，参数为度数</td>
</tr>
<tr>
<td><a href="#_tan()">tan()</a></td>
<td>正切，参数为弧度</td>
</tr>
<tr>
<td><a href="#_tand()">tand()</a></td>
<td>正切，参数为度数</td>
</tr>
</tbody>
</table>
<h6 id="acos"><strong>acos()</strong></h6>
<p>目的：反余弦，结果为弧度</p>
<p>语法：</p>
<p>输入值:      double precision
返回值:      double precision </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select acos(1);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>0
</code></pre></div>
<h6 id="acosd"><strong>acosd()</strong></h6>
<p>目的：反余弦，结果为度数</p>
<p>语法：</p>
<p>输入值:      double precision
返回值:      double precision </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select acosd(0.5);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>60
</code></pre></div>
<h6 id="asin"><strong>asin()</strong></h6>
<p>目的：反正弦，结果为弧度</p>
<p>语法：</p>
<p>输入值:      double precision
返回值:      double precision </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select asin(1);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>1.5707963267949
</code></pre></div>
<h6 id="asind"><strong>asind()</strong></h6>
<p>目的：反正弦，结果为度数</p>
<p>语法：</p>
<p>输入值:      double precision
返回值:      double precision </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select asind(0.5);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>30
</code></pre></div>
<h6 id="atan"><strong>atan()</strong></h6>
<p>目的：反正切，结果为弧度</p>
<p>语法：</p>
<p>输入值:      double precision
返回值:      double precision </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select atan(1);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>0.785398163397448
</code></pre></div>
<h6 id="atand"><strong>atand()</strong></h6>
<p>目的：反正切，结果为度数</p>
<p>语法：</p>
<p>输入值:      double precision
返回值:      double precision </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select atand(1);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>45
</code></pre></div>
<h6 id="atan2"><strong>atan2()</strong></h6>
<p>目的：y/x的反正切，结果为弧度</p>
<p>语法：</p>
<p>输入值:      double precision, double precision
返回值:      double precision</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select atan2(1,0);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>1.5707963267949
</code></pre></div>
<h6 id="atan2d"><strong>atan2d()</strong></h6>
<p>目的：y/x的反正切，结果为度数</p>
<p>语法：</p>
<p>输入值:      double precision, double precision
返回值:      double precision</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select atan2d(1,0);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>90
</code></pre></div>
<h6 id="cos"><strong>cos()</strong></h6>
<p>目的：余弦，参数为弧度</p>
<p>语法：</p>
<p>输入值:      double precision
返回值:      double precision </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select cos(0);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>1
</code></pre></div>
<h6 id="cosd"><strong>cosd()</strong></h6>
<p>目的：余弦，参数为度数</p>
<p>语法：</p>
<p>输入值:      double precision 
返回值:      double precision </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select cosd(60);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>0.5
</code></pre></div>
<h6 id="cot"><strong>cot()</strong></h6>
<p>目的：余切，参数为弧度</p>
<p>语法：</p>
<p>输入值:      double precision
返回值:      double precision </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select cot(0.5);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>1.83048772171245
</code></pre></div>
<h6 id="cotd"><strong>cotd()</strong></h6>
<p>目的：余切，参数为度数</p>
<p>语法：</p>
<p>输入值:     double precision 
返回值:     double precision  </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select cotd(45);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>1
</code></pre></div>
<h6 id="sin"><strong>sin()</strong></h6>
<p>目的：正弦，参数为弧度</p>
<p>语法：</p>
<p>输入值:      double precision
返回值:      double precision </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select sin(1);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>0.841470984807897
</code></pre></div>
<h6 id="sind"><strong>sind()</strong></h6>
<p>目的：正弦，参数为度数</p>
<p>语法：</p>
<p>输入值:      double precision
返回值:      double precision </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select sind(30);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>0.5
</code></pre></div>
<h6 id="tan"><strong>tan()</strong></h6>
<p>目的：正切，参数为弧度</p>
<p>语法：</p>
<p>输入值:      double precision
返回值:      double precision </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select tan(1);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>1.5574077246549
</code></pre></div>
<h6 id="tand"><strong>tand()</strong></h6>
<p>目的：正切，参数为度数</p>
<p>语法：</p>
<p>输入值:      double precision
返回值:      double precision </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select tand(45);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>1
</code></pre></div>
<h4 id="_220"><strong>数据类型格式化函数</strong></h4>
<h5 id="_221"><strong>格式化函数</strong></h5>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_to_char()_1">to_char()</a></td>
<td>根据给定的格式将时间戳转换为字符串。</td>
</tr>
<tr>
<td><a href="#_to_char()_2">to_char()</a></td>
<td>根据给定的格式将时间间隔转换为字符串。</td>
</tr>
<tr>
<td><a href="#_to_char()_3">to_char()</a></td>
<td>根据给定的格式将数字转换为字符串</td>
</tr>
<tr>
<td><a href="#_to_date()_1">to_date()</a></td>
<td>根据给定的格式将字符串转换为日期。</td>
</tr>
<tr>
<td><a href="#_to_number()">to_number()</a></td>
<td>根据给定的格式将字符串转换为数字。</td>
</tr>
<tr>
<td><a href="#_to_timestamp()_2">to_timestamp()</a></td>
<td>根据给定的格式将字符串转换为时间戳。</td>
</tr>
</tbody>
</table>
<h6 id="to_char_1"><strong>to_char()</strong></h6>
<p>详细描述信息，请参考数据类型date与time的<a href="#_格式化函数">格式化函数</a>的相关部分。</p>
<h6 id="to_char_2"><strong>to_char()</strong></h6>
<p>目的：根据给定的格式将时间间隔转换为字符串。</p>
<p>语法：</p>
<p>输入值:      integer, text
返回值:      text </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select to_char(interval &#39;15h 2m 12s&#39;, &#39;HH24:MI:SS&#39;); 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>15:02:12
</code></pre></div>
<h6 id="to_char_3"><strong>to_char()</strong></h6>
<p>目的：根据给定的格式将数字转换为字符串。</p>
<p>语法：</p>
<p>输入值:      bigint, text 
返回值:      text </p>
<p>或者</p>
<p>输入值:      double precision, text
返回值:      text </p>
<p>或者</p>
<p>输入值:      integer, text
返回值:      text </p>
<p>或者</p>
<p>输入值:      numeric, text
返回值:      text </p>
<p>或者</p>
<p>输入值:      real, text
返回值:      text </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select to_char(125.8::real, &#39;999D9&#39;); 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>125.8
</code></pre></div>
<h6 id="to_date_1"><strong>to_date()</strong></h6>
<p>详细描述信息，请参考数据类型date与time的<a href="#_格式化函数">格式化函数</a>的相关部分。</p>
<h6 id="to_number"><strong>to_number()</strong></h6>
<p>目的：根据给定的格式将字符串转换为数字。</p>
<p>输入值:      text, text
返回值:      numeric</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select to_number(&#39;12,454.8-&#39;, &#39;99G999D9S&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>-12454.8
</code></pre></div>
<h6 id="to_timestamp_2"><strong>to_timestamp()</strong></h6>
<p>详细描述信息，请参考数据类型date与time的<a href="#_格式化函数">格式化函数</a>的相关部分。</p>
<h5 id="_222"><strong>模板模式</strong></h5>
<p>用于数字格式化的模板模式如下：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>9</td>
<td>数位（如果无意义可以被删除）</td>
</tr>
<tr>
<td>0</td>
<td>数位（即便没有意义也不会被删除）</td>
</tr>
<tr>
<td>. (period)</td>
<td>小数点</td>
</tr>
<tr>
<td>, (comma)</td>
<td>分组（千）分隔符</td>
</tr>
<tr>
<td>PR</td>
<td>尖括号内的负值</td>
</tr>
<tr>
<td>S</td>
<td>带符号的数字（使用区域）</td>
</tr>
<tr>
<td>L</td>
<td>货币符号（使用区域）</td>
</tr>
<tr>
<td>D</td>
<td>小数点（使用区域）</td>
</tr>
<tr>
<td>G</td>
<td>分组分隔符（使用区域）</td>
</tr>
<tr>
<td>MI</td>
<td>在指定位置的负号（如果数字 &lt; 0）</td>
</tr>
<tr>
<td>PL</td>
<td>在指定位置的正号（如果数字 &gt; 0）</td>
</tr>
<tr>
<td>SG</td>
<td>在指定位置的正/负号</td>
</tr>
<tr>
<td>RN</td>
<td>罗马数字（输入在 1 和 3999 之间）</td>
</tr>
<tr>
<td>TH or th</td>
<td>序数后缀</td>
</tr>
<tr>
<td>V</td>
<td>移动指定位数（参阅注解）</td>
</tr>
<tr>
<td>EEEE</td>
<td>科学记数的指数</td>
</tr>
</tbody>
</table>
<p>数字格式化的用法须知：</p>
<ul>
<li>
<p>0指定一个总是被打印的数位，即便它包含前导/拖尾的零。9也指定一个数位，但是如果它是前导零则会被空格替换，而如果是拖尾零并且指定了填充模式则它会被删除（对于to_number()来说，这两种模式字符等效）。</p>
</li>
<li>
<p>模式字符S、L、D以及G表示当前locale定义的负号、货币符号、小数点以及数字分隔符字符。不管locale是什么，模式字符句号和逗号就表示小数点和数字分隔符。</p>
</li>
<li>
<p>对于to_char()的模式中的一个负号，如果没有明确的规定，将为该负号保留一列，并且它将被锚接到（出现在左边）那个数字。如果S正好出现在某个9的左边，它也将被锚接到那个数字。</p>
</li>
<li>
<p>使用SG、PL或MI格式化的符号并不挂在数字上面； 例如，to_char(-12, 'MI9999')生成'-  12'，而to_char(-12, 'S9999')生成 '  -12'。</p>
</li>
<li>
<p>TH不会转换小于零的数值，也不会转换小数。</p>
</li>
<li>
<p>PL、SG和TH是PostgreSQL扩展。</p>
</li>
<li>
<p>在to_number中，如果没有使用L或TH之类的非数据模板模式，相应数量的输入字符会被跳过，不管它们是否匹配模板模式，除非它们是数据字符（也就是数位、负号、小数点或者逗号）。例如，TH会跳过两个非数据字符。</p>
</li>
<li>
<p>带有to_char的V会把输入值乘上10^n，其中n是跟在V后面的位数。带有to_number的V以类似的方式做除法。to_char和to_number不支持使用结合小数点的V（例如，不允许99.9V99）。</p>
</li>
<li>
<p>EEEE（科学记数法）不能和任何其他格式化模式或修饰语（数字和小数点模式除外）组合在一起使用，并且必须位于格式化字符串的最后（例如9.99EEEE是一个合法的模式）。</p>
</li>
<li>
<p>某些修饰语可以被应用到任何模板来改变其行为。例如，FM99.99是带有FM修饰语的99.99模式。下表展示了用于数字格式化模式修饰语。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>修饰语</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>FM prefix</td>
<td>填充模式（抑制拖尾零和填充的空白）</td>
<td>FM99.99</td>
</tr>
<tr>
<td>TH suffix</td>
<td>大写序数后缀</td>
<td>999TH</td>
</tr>
<tr>
<td>th suffix</td>
<td>小写序数后缀</td>
<td>999th</td>
</tr>
</tbody>
</table>
<h4 id="_223"><strong>模式匹配</strong></h4>
<p>提供了三种独立的实现模式匹配的方法：SQL LIKE操作符、更近一些的SIMILAR TO操作符（SQL:1999 里添加进来的）和POSIX-风格的正则表达式。</p>
<h5 id="like"><strong>LIKE</strong></h5>
<p>语法：</p>
<p>string LIKE pattern [ESCAPE escape-character]
string NOT LIKE pattern [ESCAPE escape-character]</p>
<p>如果该string匹配了提供的pattern，那么LIKE表达式返回真（如果LIKE返回真，那么NOT LIKE表达式返回假，反之亦然。一个等效的表达式是NOT (string LIKE pattern)）。</p>
<p>如果pattern不包含百分号或者下划线，那么该模式只代表它本身的串；这时候LIKE的行为就象等号操作符。在pattern里的下划线 （_）代表（匹配）任何单个字符； 而一个百分号（%）匹配任何零或更多个字符的序列。</p>
<p>例如：</p>
<p>'abc' LIKE 'abc'    返回true
'abc' LIKE 'a%'    返回true
'abc' LIKE '<em>b</em>'    返回true
'abc' LIKE 'c'      返回false</p>
<p>LIKE模式匹配总是覆盖整个串。因此，要匹配在串内任何位置的序列，该模式必须以百分号开头和结尾。</p>
<p>要匹配文本的下划线或者百分号，而不是匹配其它字符，在pattern里相应的字符必须前导逃逸字符。缺省的逃逸字符是反斜线，但是你可以用ESCAPE子句指定一个不同的逃逸字符。要匹配逃逸字符本身，写两个逃逸字符。</p>
<p>请注意反斜线在串文本里已经有特殊含义了，所以如果你写一个包含反斜线的模式常量，那你就要在 SQL 语句里写两个反斜线。 因此，写一个匹配单个反斜线的模式实际上要在语句里写四个反斜线。 你可以通过用 ESCAPE 选择一个不同的逃逸字符 来避免这样；这样反斜线就不再是 LIKE 的特殊字符了。 但仍然是字符文本分析器的特殊字符，所以你还是需要两个反斜线。我们也可以通过写ESCAPE ''的方式不选择逃逸字符，这样可以有效地禁用逃逸机制，但是没有办法关闭下划线和百分号在模式中的特殊含义。</p>
<p>根据SQL标准，省略ESCAPE意味着没有转义字符(而不是默认为反斜杠)，并且不允许使用零长度的ESCAPE值。</p>
<p>关键字ILIKE可以用于替换LIKE，它令该匹配根据活动区域成为大小写无关。</p>
<p>操作符~~等效于LIKE， 而~~<em>对应ILIKE。 还有 !~~和!~~</em>操作符分别代表NOT LIKE和NOT ILIKE。
短语LIKE，ILIKE，NOT LIKE，和 NOT ILIKE通常被视为操作符。</p>
<p>还可参见前缀操作符^@和相应的starts_with函数，在需要简单匹配字符串开头的情况下比较有用。</p>
<h5 id="similar-to"><strong>SIMILAR TO正则表达式</strong></h5>
<p>语法：</p>
<p>string SIMILAR TO pattern [ESCAPE escape-character]
string NOT SIMILAR TO pattern [ESCAPE escape-character]</p>
<p>SIMILAR TO操作符根据自己的模式是否匹配给定串而返回真或者假。 它和LIKE非常类似，只不过它使用 SQL 标准定义的正则表达式理解模式。 </p>
<p>类似LIKE，SIMILAR TO操作符只有在它的模式匹配整个串的时候才能成功；这一点和普通的正则表达式的行为不同，在普通的正则表达式里，模式匹配串的任意部分。 和LIKE类似的地方还有，SIMILAR TO使用_和%作为分别代表任意单个字符和任意串的通配符。</p>
<p>除了这些从LIKE借用的功能之外，SIMILAR TO支持下面这些从 POSIX 正则表达式借用的模式匹配元字符：</p>
<ul>
<li>|表示选择（两个候选之一）。</li>
<li>*表示重复前面的项零次或更多次。</li>
<li>+表示重复前面的项一次或更多次。</li>
<li>?表示重复前面的项零次或一次。</li>
<li>{m}表示重复前面的项刚好m次。</li>
<li>{m,}表示重复前面的项m次或更多次。</li>
<li>{m,n}表示重复前面的项至少m次并且不超过n次。</li>
<li>可以使用圆括号()把多个项组合成一个逻辑项。</li>
<li>一个方括号表达式[...]声明一个字符类，就像 POSIX 正则表达式一样。</li>
<li>注意点号（.）不是SIMILAR TO的一个元字符。</li>
</ul>
<p>与LIKE一样，反斜杠将禁用这些元字符的特殊含义。 可以用 ESCAPE 来指定不同的转义字符，或者可以通过写 ESCAPE '' 来禁用转义功能。</p>
<p>根据SQL标准，省略ESCAPE意味着没有转义字符(而不是默认为反斜杠)，并且不允许使用零长度的ESCAPE值。</p>
<p>另一个非标准扩展是，在转义字符后面跟着一个字母或数字提供了对为POSIX正则表达式定义的转义序列的访问；参见下面的 表 9.20，表 9.21，和 表 9.22 。</p>
<p>例如：</p>
<p>'abc' SIMILAR TO 'abc'          返回true
'abc' SIMILAR TO 'a'            返回false
'abc' SIMILAR TO '%(b|d)%'      返回true
'abc' SIMILAR TO '(b|c)%'        返回false
'-abc-' SIMILAR TO '%\mabc\M%'  返回true
'xabcy' SIMILAR TO '%\mabc\M%'  返回false
带有三个参数的substring函数可以提取匹配SQL正则表达式模式的子字符串。</p>
<p>substring(string from pattern for escape-character)
或作为一个普通的三参数函数:</p>
<p>substring(string, pattern, escape-character)
与SIMILAR TO一样，指定的模式必须与整个数据字符串匹配，否则函数失败并返回空值。为了表示匹配的数据子字符串的模式中，模式中应该包含两个转义字符的出现，并在后面加上一个双引号(")。匹配成功后，将返回与这些分隔符之间的模式部分匹配的文本。</p>
<p>转义-双引号分隔符实际上是 将子字符串的模式分成三个独立的正则表达式；例如，竖条(|) 三节中的任何一节只影响到该节。此外，第一节和第三种正则表达式的定义是为了匹配最小的尽可能多的文字，而不是最大的文字，当有歧义的时候，就不应该是最大的文字。关于有多少数据字符串符合哪种模式。
作为对SQL标准的扩展，只允许有一个转义双引号分隔符，在这种情况下，第三个正则表达式被视为空；或者没有分隔符，在这种情况下，第一个和第三个正则表达式被视为空。</p>
<p>一些示例，使用#"定界返回串：</p>
<p>substring('foobar' from '%#"o_b#"%' for '#')   返回oob
substring('foobar' from '#"o_b#"%' for '#')     返回NULL</p>
<h5 id="posix"><strong>POSIX正则表达式</strong></h5>
<p>下表列出了所有可用于POSIX正则表达式模式匹配的操作符。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_~_3">~</a></td>
<td>字符串匹配正则表达式，大小写敏感</td>
</tr>
<tr>
<td><a href="#_~*">~*</a></td>
<td>字符串匹配正则表达式，大小写不敏感</td>
</tr>
<tr>
<td><a href="#_!~">!~</a></td>
<td>字符串不匹配正则表达式，大小写敏感</td>
</tr>
<tr>
<td><a href="#_!~*">!~*</a></td>
<td>字符串不匹配正则表达式，大小写不敏感</td>
</tr>
</tbody>
</table>
<h6 id="_224"><strong>操作符</strong></h6>
<h6 id="_225"># ~</h6>
<p>目的：字符串匹配正则表达式，大小写敏感</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;thomas&#39; ~ &#39;.*thom.*&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_226"># ~*</h6>
<p>目的：字符串匹配正则表达式，大小写不敏感</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;thomas&#39; ~* &#39;.*Thom.*&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="_227"># !~</h6>
<p>目的：字符串不匹配正则表达式，大小写敏感</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;thomas&#39; !~ &#39;.*thomas.*&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>f
</code></pre></div>
<h6 id="_228"># !~*</h6>
<p>目的：字符串不匹配正则表达式，大小写不敏感</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;thomas&#39; !~* &#39;.*vadim.*&#39;;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<p>POSIX正则表达式提供了比LIKE和SIMILAR TO操作符更强大的含义。</p>
<p>正则表达式是一个字符序列，它是定义一个串集合（一个正则集）的缩写。如果一个串是正则表达式描述的正则集中的一员时，我们就说这个串匹配该正则表达式。和LIKE一样，模式字符准确地匹配串字符，除非在正则表达式语言里有特殊字符 — 不过正则表达式用的 特殊字符和LIKE用的不同。和LIKE模式不一样的是，正则表达式允许匹配串里的任何位置，除非该正则表达式显式地挂接在串的开头或者结尾。</p>
<p>例如：</p>
<p>'abc' ~ 'abc'    返回true
'abc' ~ '^a'     返回true
'abc' ~ '(b|d)'   返回true
'abc' ~ '^(b|c)'  返回false</p>
<p>带两个参数的substring函数，即substring(string from pattern)，提供了抽取一个匹配 POSIX 正则表达式模式的子串的方法。如果没有匹配它返回空值，否则就是文本中匹配模式的那部分。但是如果该模式包含任何圆括号，那么将返回匹配第一对子表达式（对应第一个左圆括号的）的文本。如果你想在表达式里使用圆括号而又不想导致这个例外，那么你可以在整个表达式外边放上一对圆括号。如果你需要在想抽取的子表达式前有圆括号，参阅后文描述的非捕获性圆括号。</p>
<p>例如：</p>
<p>substring('foobar' from 'o.b')     返回oob
substring('foobar' from 'o(.)b')    返回o</p>
<h6 id="_229"><strong>函数</strong></h6>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>regexp_replace</td>
<td>将匹配 POSIX 正则表达式模式的子串替换为新文本</td>
</tr>
<tr>
<td>regexp_match</td>
<td>返回一个文本数组，它包含一个POSIX正则表达式模式与一个字符串第一个匹配所得到的子串</td>
</tr>
<tr>
<td>regexp_matches</td>
<td>返回一个文本数组的集合，其中包含着一个POSIX正则表达式模式与一个字符串匹配得到的子串</td>
</tr>
<tr>
<td>regexp_split_to_table</td>
<td>把一个 POSIX 正则表达式模式当作一个定界符来分离一个串</td>
</tr>
<tr>
<td>regexp_split_to_array</td>
<td>函数的行为和regexp_split_to_table相同，不过regexp_split_to_array会把它的结果以一个text数组的形式返回</td>
</tr>
</tbody>
</table>
<h6 id="regexp_replace_1"># regexp_replace</h6>
<p>目的：提供了将匹配 POSIX 正则表达式模式的子串替换为新文本的功能。</p>
<p>语法：</p>
<p>输入值:      text, text, text[, text]
返回值:      text</p>
<p>regexp_replace(source, pattern, replacement [, flags ])。如果没有匹配pattern，那么返回不加修改的source串。如果有匹配，则返回的source串里面的匹配子串将被replacement串替换掉。replacement串可以包含\n， 其中\n是 1 到 9，表明源串里匹配模式里第n个圆括号子表达式的子串应该被插入，并且它可以包含\&amp;表示应该插入匹配整个模式的子串。如果你需要放一个文字形式的反斜线在替换文本里，那么写\。flags参数是一个可选的文本串，它包含另个或更多单字母标志，这些标志可以改变函数的行为。标志i指定大小写无关的匹配，而标志g指定替换每一个匹配的子串而不仅仅是第一个。支持的标志（但不是g），参见下面的<a href="#_正则表达式元语法">正则表达式元语法</a>章节中表A中所示。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select regexp_replace(&#39;foobarbaz&#39;, &#39;b..&#39;, &#39;X&#39;);             
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>fooXbaz
</code></pre></div>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select regexp_replace(&#39;foobarbaz&#39;, &#39;b..&#39;, &#39;X&#39;, &#39;g&#39;);          
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>fooXX
</code></pre></div>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select regexp_replace(&#39;foobarbaz&#39;, &#39;b(..)&#39;, &#39;X\1Y&#39;, &#39;g&#39;) ;    
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>fooXarYXazY
</code></pre></div>
<h6 id="regexp_match_1"># regexp_match</h6>
<p>目的：返回一个文本数组，它包含一个POSIX正则表达式模式与一个字符串第一个匹配所得到的子串。</p>
<p>语法：</p>
<p>输入值:      text, text[, text]
返回值:      text</p>
<p>regexp_match(string, pattern [, flags ])。如果没有匹配，则结果为NULL。如果找到一个匹配并且pattern不包含带括号的子表达式，那么结果是一个单一元素的文本数组，其中包含匹配整个模式的子串。如果找到一个匹配并且pattern含有带括号的子表达式，那么结果是一个文本数组，其中第n个元素是与pattern的第n个圆括号子表达式匹配的子串。flags参数是一个可选的文本字符串，它包含零个或者更多个可以改变该函数行为的单字母标志。所支持的标志参见下面的<a href="#_正则表达式元语法">正则表达式元语法</a>章节中表A中所示。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select regexp_match(&#39;foobarbequebaz&#39;, &#39;bar.*que&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> {barbeque}
</code></pre></div>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select regexp_match(&#39;foobarbequebaz&#39;, &#39;(bar)(beque)&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> {bar,beque}
</code></pre></div>
<p>在通常情况下，只是想要匹配的子串或者NULL（没有匹配），可以写成这样：</p>
<div class="highlight"><pre><span></span><code>select (regexp_match(&#39;foobarbequebaz&#39;, &#39;bar.*que&#39;))[1];
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> barbeque
</code></pre></div>
<h6 id="regexp_matches_1"># regexp_matches</h6>
<p>目的：返回一个文本数组的集合，其中包含着一个POSIX正则表达式模式与一个字符串匹配得到的子串。它和regexp_match具有相同的语法。如果没有匹配，这个函数不会返回行。如果有一个匹配并且给定了g标志，则返回一行。如果有N个匹配并且给定了g标志，则返回N行。每一个返回的行都是一个文本数组，其中含有整个匹配的子串或者匹配pattern的圆括号子表达式的子串，这和上面对regexp_match的介绍一样。regexp_matches接受的所有标志，参见下面的<a href="#_正则表达式元语法">正则表达式元语法</a>章节中表A中所示，外加令它返回所有匹配而不仅仅是第一个匹配的g标志。</p>
<p>语法：</p>
<p>输入值:      text, text[, text]
返回值:      text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select regexp_matches(&#39;foo&#39;, &#39;not there&#39;);
</code></pre></div>
<p>无匹配信息返回</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select regexp_matches(&#39;foobarbequebazilbarfbonk&#39;, &#39;(b[^b]+)(b[^b]+)&#39;, &#39;g&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> {bar,beque}
 {bazil,barf}
</code></pre></div>
<h6 id="regexp_split_to_table_1"># regexp_split_to_table</h6>
<p>目的：把一个 POSIX 正则表达式模式当作一个定界符来分离一个串。</p>
<p>语法：</p>
<p>输入值:      text, text[, text]
返回值:      SETOF text</p>
<p>regexp_split_to_table(string, pattern [, flags ])。如果没有与pattern的匹配，该函数返回string。如果有至少有一个匹配，对每一个匹配它都返回从上一个匹配的末尾（或者串的开头）到这次匹配开头之间的文本。当没有更多匹配时，它返回从上一次匹配的末尾到串末尾之间的文本。flags参数是一个可选的文本串，它包含零个或更多单字母标志，这些标识可以改变该函数的行为。regexp_split_to_table所支持的标志，参见下面的<a href="#_正则表达式元语法">正则表达式元语法</a>章节中表A中所示。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select foo FROM regexp_split_to_table(&#39;the quick brown fox jumps over the lazy dog&#39;, &#39;\s+&#39;) AS foo;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> the    
 quick  
 brown  
 fox    
 jumps 
 over   
 the    
 lazy   
 dog  
</code></pre></div>
<h6 id="regexp_split_to_array_1"># regexp_split_to_array</h6>
<p>目的：regexp_split_to_array函数的行为和regexp_split_to_table相同，不过regexp_split_to_array会把它的结果以一个text数组的形式返回。</p>
<p>语法：</p>
<p>输入值:      text, text[, text]
返回值:      text[]</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select regexp_split_to_array(&#39;the quick brown fox jumps over the lazy dog&#39;, &#39;\s+&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> {the,quick,brown,fox,jumps,over,the,lazy,dog}
</code></pre></div>
<h6 id="_230"><strong>正则表达式细节</strong></h6>
<p>正则表达式（RE），在POSIX 1003.2 中定义，它有两种形式：扩展的RE或者是ERE，基本的RE或者是BRE。BSQL支持两种形式，并且还实现了一些POSIX标准中没有，但是在类似 Perl 或者 Tcl 这样的语言中得到广泛应用的一些扩展。使用了那些非POSIX扩展的RE叫高级RE，或者本文档里说的ARE。ARE 几乎完全是 ERE 的超集，但是 BRE 有几个符号上的不兼容（以及更多的限制）。</p>
<p>一个正则表达式被定义为一个或更多分支，它们之间被 | 分隔。只要能匹配其中一个分支的东西都能匹配正则表达式。</p>
<p>一个分支是一个或多个量化原子或者约束连接而成。一个原子匹配第一个，然后后面的原子匹配第二个， 以此类推；一个空分支匹配空串。</p>
<p>一个量化原子是一个原子， 后面可能跟着一个量词。没有量词的时候，它匹配一个原子， 有量词的时候，它可以匹配若干个原子。</p>
<p>正则表达式原子：</p>
<table>
<thead>
<tr>
<th>原子</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>(re)</td>
<td>（其中re是任何正则表达式）匹配一个对re的匹配，匹配将为可能的报告被记下</td>
</tr>
<tr>
<td>(?:re)</td>
<td>同上，但是匹配不会为了报告而被记下 （一个“非捕获”圆括号集） （只对 ARE）</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意单个字符</td>
</tr>
<tr>
<td>[chars]</td>
<td>一个方括号表达式， 匹配chars中的任意一个</td>
</tr>
<tr>
<td>\k</td>
<td>（其中k是一个非字母数字字符） 匹配一个被当作普通字符看待的特定字符， 例如，\匹配一个反斜线字符</td>
</tr>
<tr>
<td>\c</td>
<td>其中c是一个字母数字 （可能跟着其它字符），它是一个逃逸， 参阅第 9.7.3.3 节（仅对 ARE； 在 ERE 和 BRE 中，它匹配c）</td>
</tr>
<tr>
<td>{</td>
<td>如果后面跟着一个字符，而不是数字， 那么就匹配左花括弧{；如果跟着一个数字， 那么它是range的开始</td>
</tr>
<tr>
<td>x</td>
<td>其中x是一个没有其它意义的单个字符，则匹配该字符</td>
</tr>
</tbody>
</table>
<p>一个约束匹配一个空串，但只是在满足特定条件下才匹配。 约束可以在能够使用原子的地方使用，只是它不能跟着量词。</p>
<p>正则表达式量词：</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>一个由原子的 0 次或更多次匹配组成的序列</td>
</tr>
<tr>
<td>+</td>
<td>一个由原子的 1 次或更多次匹配组成的序列</td>
</tr>
<tr>
<td>?</td>
<td>一个由原子的 0 次或 1 次匹配组成的序列</td>
</tr>
<tr>
<td>{m}</td>
<td>一个由原子的正好m次匹配组成的序列</td>
</tr>
<tr>
<td>{m,}</td>
<td>一个由原子的m次或更多次匹配组成的序列</td>
</tr>
<tr>
<td>{m,n}</td>
<td>一个由原子的从m次到n次（包括）匹配组成的序列；m不能超过n</td>
</tr>
<tr>
<td>*?</td>
<td>*的非贪婪版本</td>
</tr>
<tr>
<td>+?</td>
<td>+的非贪婪版本</td>
</tr>
<tr>
<td>??</td>
<td>?的非贪婪版本</td>
</tr>
<tr>
<td>{m}?</td>
<td>{m}的非贪婪版本</td>
</tr>
<tr>
<td>{m,}?</td>
<td>{m,}的非贪婪版本</td>
</tr>
<tr>
<td>{m,n}?</td>
<td>{m,n}的非贪婪版本</td>
</tr>
</tbody>
</table>
<p>使用{...}的形式被称作范围。 一个范围内的数字m和n都是无符号十进制整数， 允许的数值从 0 到 255（包含）。</p>
<p>非贪婪的量词（只在 ARE 中可用）匹配对应的正常 （贪婪）模式，区别是它寻找最少的匹配，而不是最多的匹配。</p>
<p>正则表达式约束：</p>
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>串开头的匹配</td>
</tr>
<tr>
<td>$</td>
<td>串末尾的匹配</td>
</tr>
<tr>
<td>(?=re)</td>
<td>在匹配re的子串开始的任何点的positive lookahead匹配（只对 ARE）</td>
</tr>
<tr>
<td>(?!re)</td>
<td>在匹配re的子串开始的任何点的negative lookahead匹配（只对 ARE）</td>
</tr>
<tr>
<td>(?&lt;=re)</td>
<td>只要有一个点上有一个子串匹配re端， positive lookbehind就在这个点上匹配（只对 ARE）</td>
</tr>
<tr>
<td>(?&lt;!re)</td>
<td>只要有一个点上没有子串匹配re端， negative lookbehind就在这个点上匹配（只对 ARE）</td>
</tr>
</tbody>
</table>
<h6 id="_231"><strong>方括号表达式</strong></h6>
<p>方括号表达式是一个包围在[]中的字符列表。它通常匹配列表中的任意单个字符。 如果列表以^开头，它匹配任意单个不在该列表参与部分中的字符。如果该列表中两个字符用-隔开， 那它就是那两个字符（包括在内）之间的所有字符范围的缩写，例如，在ASCII中[0-9]匹配任何十进制数字。两个范围共享一个端点是非法的，例如，a-c-e。范围与字符集关系密切， 可移植的程序应该避免依靠它们。</p>
<p>想在列表中包含文本]，可以让它做列表的首字符（如果使用了^，需要放在其后）。 想在列表中包含文本-，可以让它做列表的首字符或者尾字符，或者一个范围的第二个端点。 想在列表中把文本-当做范围的起点，把它用[.和.]包围起来，这样它就成为一个排序元素。 除了这些字符本身、一些用[的组合以及逃逸（只在 ARE 中有效）以外，所有其它特殊字符 在方括号表达式里都失去它们的特殊含义。特别是，在 ERE 和 BRE 规则下\不是特殊的， 但在 ARE 里，它是特殊的（引入一个逃逸）。</p>
<p>在一个方括号表达式里，一个排序元素（一个字符、一个被当做一个单一字符排序的多字符序列，或者一个表示上面两种情况的排序序列名称） 包含在[.和.]里面的时候表示该排序元素的字符序列。该序列被当做该方括号列表的一个单一元素。这允许一个包含多字符排序元素的方括号表达式去匹配多于一个字符。例如，如果排序序列包含一个ch排序元素，那么 RE [[.ch.]]*c匹配chchcc的头五个字符。</p>
<p>在方括号表达式里，包围在[=和=]里的排序元素是一个等价类，代表等效于那一个的所有排序元素的字符序列，包括它本身（如果没有其它等效排序元素，那么就好象封装定界符是[.和 .]）。例如，如果o和^是一个等价类的成员，那么[[=o=]]、[[=^=]]和[o^]都是同义的。一个等价类不能是一个范围的端点。</p>
<p>在方括号表达式里，在[:和:]里面封装的字符类的名字代表属于该类的所有字符的列表。 字符类不能作为范围的端点使用。POSIX标准定义了这些字符类的名称： alnum (字符和数字), alpha (字符), blank (空格和制表符tab), cntrl (控制符), digit (数位数), graph (空格除外可打印字符), lower (小写字母), print (包含空格可打印字符), punct (标点符号), space (空白), upper (大写字母), 和 xdigit (十六进制数)。对于7位ASCII字符集中的字符来说，这些标准字符类的行为在不同平台上一般是一致的。一个给定的非ASCII字符是否被认为属于这些类别中的一个，取决于正则表达式函数或运算符使用的collation，或者默认情况下取决于数据库的LC_CTYPE locale设置。非ASCII字符的分类在不同的平台上会有不同的分类，即使是在类似命名的locale中也是如此。除了这些标准字符类之外，BSQL定义了ascii字符类，它完全包含7位ASCII字符集。</p>
<p>方括号表达式里有两个特例：方括号表达式[[:&lt;:]]和[[:&gt;:]]是约束，分别匹配一个单词开头和结束的空串。单词定义为一个单词字符序列，前面和后面都没有其它单词字符。单词字符是一个alnum字符或者一个下划线。</p>
<h6 id="_232"><strong>正则表达式逃逸</strong></h6>
<p>逃逸是以 \ 开头，后面跟着一个字母数字字符得特殊序列。逃逸有好几种变体：字符项、类缩写、约束逃逸以及后引用。在 ARE 里，如果一个\后面跟着一个字母数字，但是并未组成一个合法的逃逸，那么它是非法的。在 ERE 中没有逃逸：在方括号表达式之外，一个后面跟着字母数字字符的\只是表示该字符是一个普通的字符，而且在一个方括号表达式里，\是一个普通的字符（后者实际上在 ERE 和 ARE 不兼容）。</p>
<p>字符项逃逸用于便于我们在 RE 中声明那些不可打印的或其他习惯的字符。
正则表达式字符项逃逸:</p>
<table>
<thead>
<tr>
<th>逃逸</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>警告（响铃）字符，和 C 中一样</td>
</tr>
<tr>
<td>\b</td>
<td>退格，和 C 中一样</td>
</tr>
<tr>
<td>\B</td>
<td>反斜线（\）的同义词，用来减少双写反斜线</td>
</tr>
<tr>
<td>\cX</td>
<td>（其中X是任意字符）低序5位和X相同的字符，它的其他位都是零</td>
</tr>
<tr>
<td>\e</td>
<td>排序序列名为ESC的字符，如果无法做到该字符为八进制值 033</td>
</tr>
<tr>
<td>\f</td>
<td>换页，和 C 中一样</td>
</tr>
<tr>
<td>\n</td>
<td>新行，和 C 中一样</td>
</tr>
<tr>
<td>\r</td>
<td>回车，和 C 中一样</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表符，和 C 中一样</td>
</tr>
<tr>
<td>\uwxyz</td>
<td>（其中wxyz正好是四个十六进制位）十六进制值为0xwxyz的字符</td>
</tr>
<tr>
<td>\Ustuvwxyz</td>
<td>（其中stuvwxyz正好是八个十六进制位）十六进制值为0xstuvwxyz的字符</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符，和 C 中一样</td>
</tr>
<tr>
<td>\xhhh</td>
<td>（其中hhh是十六进制位的任意序列）十六进制值为0xhhh的字符（一个单一字符，不管用了多少个十六进制位）</td>
</tr>
<tr>
<td>\0</td>
<td>值为0（空字节）的字符</td>
</tr>
<tr>
<td>\xy</td>
<td>（其中xy正好是两个八进制位，并且不是一个后引用）八进制值为0xy的字符</td>
</tr>
<tr>
<td>\xyz</td>
<td>（其中xyz正好是三个八进制位，并且不是一个后引用）八进制值为0xyz的字符</td>
</tr>
<tr>
<td>十六进制位是0-9、a-f和A-F。八进制位是0-7。</td>
<td></td>
</tr>
</tbody>
</table>
<p>指定 ASCII 范围（0–127）之外的值的数字字符项转义的含义取决于数据库编码。 当编码是 UTF-8 时，转义值等价于 Unicode 代码点，例如 \u1234表示字符U+1234。对于其他多字节编码， 字符项转义通常只是指定该字符的字节值的串接。如果该转义值不对应数据库编码 中的任何合法字符，将不会发生错误，但是它不会匹配任何数据。</p>
<p>字符项逃逸总是被当作普通字符。例如，\135是 ASCII 中的]， 但\135并不终止一个方括号表达式。</p>
<p>类缩写逃逸用来提供一些常用的字符类缩写。
正则表达式类缩写逃逸:</p>
<table>
<thead>
<tr>
<th>逃逸</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\d</td>
<td>[[:digit:]]</td>
</tr>
<tr>
<td>\s</td>
<td>[[:space:]]</td>
</tr>
<tr>
<td>\w</td>
<td>[[:alnum:]_]（注意下划线是被包括的）</td>
</tr>
<tr>
<td>\D</td>
<td>[^[:digit:]]</td>
</tr>
<tr>
<td>\S</td>
<td>[^[:space:]]</td>
</tr>
<tr>
<td>\W</td>
<td>[^[:alnum:]_] （注意下划线是被包括的）</td>
</tr>
</tbody>
</table>
<p>在方括号表达式里，\d、\s和\w会失去它们的外层方括号，而\D、\S和 \W是非法的（也就是说，例如[a-c\d]等效于[a-c[:digit:]]。同样[a-c\D]等效于 [a-c^[:digit:]]的，也是非法的）。</p>
<p>约束逃逸是一个约束，如果满足特定的条件，它匹配该空串。</p>
<table>
<thead>
<tr>
<th>逃逸</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\A</td>
<td>只在串开头匹配</td>
</tr>
<tr>
<td>\m</td>
<td>只在一个词的开头匹配</td>
</tr>
<tr>
<td>\M</td>
<td>只在一个词的末尾匹配</td>
</tr>
<tr>
<td>\y</td>
<td>只在一个词的开头或末尾匹配</td>
</tr>
<tr>
<td>\Y</td>
<td>只在一个词的不是开头或末尾的点上匹配</td>
</tr>
<tr>
<td>\Z</td>
<td>只在串的末尾匹配</td>
</tr>
</tbody>
</table>
<p>一个词被定义成在上面[[:&lt;:]]和[[:&gt;:]]中的声明。在方括号表达式里，约束逃逸是非法的。</p>
<p>后引用（\n）匹配数字\n指定的被前面的圆括号子表达式匹配的同一个串（参阅下表）。例如， ([bc])\1匹配bb或者cc， 但是不匹配bc或者cb。RE 中子表达式必须完全在后引用前面。子表达式以它们的先导圆括号的顺序编号。非捕获圆括号并不定义子表达式。
正则表达式后引用：</p>
<table>
<thead>
<tr>
<th>逃逸</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\m</td>
<td>（其中m是一个非零位）一个到第m个子表达式的后引用</td>
</tr>
<tr>
<td>\mnn</td>
<td>（其中m是一个非零位，并且nn是一些更多的位，并且十六进制值mnn不超过目前能看到的封闭捕获圆括号的数目）一个到第mnn个子表达式的后引用</td>
</tr>
</tbody>
</table>
<h6 id="_233"><strong>正则表达式元语法</strong></h6>
<p>除了上面描述的主要语法之外，还有几种特殊形式和杂项语法。</p>
<p>如果一个 RE 以<strong><em>:开头，那么剩下的 RE 都被当作 ARE（这在BSQL中通常是无效的，因为 RE 被假定为 ARE，但是如果 ERE 或 BRE 模式通过flags参数被指定为一个正则表达式函数时，它确实能产生效果）。如果一个 RE 以</em></strong>=开头， 那么剩下的 RE 被当作一个文本串，所有的字符都被认为是一个普通字符。</p>
<p>一个 ARE 可以以嵌入选项开头：一个序列(?xyz)（这里的xyz是一个或多个字母字符）声明影响剩余 RE 的选项。 这些选项覆盖任何前面判断的选项 — 特别地，它们可以覆盖一个正则表达式操作符隐含的大小写敏感的行为，或者覆盖flags参数中的正则表达式函数。可用的选项字母在表A中显示。注意这些同样的选项字母也被用在正则表达式函数的flags参数中。</p>
<p>ARE 嵌入选项字母（表A）：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>b</td>
<td>RE的剩余部分是一个BRE</td>
</tr>
<tr>
<td>c</td>
<td>大小写敏感的匹配（覆盖操作符类型）</td>
</tr>
<tr>
<td>e</td>
<td>RE的剩余部分是一个ERE</td>
</tr>
<tr>
<td>i</td>
<td>大小写不敏感的匹配（覆盖操作符类型）</td>
</tr>
<tr>
<td>m</td>
<td>n的历史原因的同义词</td>
</tr>
<tr>
<td>n</td>
<td>新行敏感的匹配</td>
</tr>
<tr>
<td>p</td>
<td>部分新行敏感的匹配</td>
</tr>
<tr>
<td>q</td>
<td>RE的剩余部分是一个文字（“quoted”）串，全部是普通字符</td>
</tr>
<tr>
<td>s</td>
<td>非新行敏感的匹配（默认）</td>
</tr>
<tr>
<td>t</td>
<td>紧语法（默认）</td>
</tr>
<tr>
<td>w</td>
<td>逆部分新行敏感的匹配</td>
</tr>
<tr>
<td>x</td>
<td>扩展语法</td>
</tr>
</tbody>
</table>
<p>嵌入选项在终止序列时发生作用。它们只在 ARE 的开始处起作用 （在任何可能存在的***:控制器后面）。</p>
<p>除了通常的（紧）RE 语法（这种情况下所有字符都有效）， 还有一种扩展语法，可以通过声明嵌入的x选项获得。在扩展语法里，RE 中的空白字符被忽略，就像那些在#和其后的新行（或 RE 的末尾）之间的字符一样。这样就允许我们给一个复杂的 RE 分段和注释。不过这个基本规则有三种例外：</p>
<p>空白字符或前置了\的#将被保留</p>
<p>方括号表达式里的空白或者#将被保留</p>
<p>在多字符符号里面不能出现空白和注释，例如(?:</p>
<p>为了这个目的，空白是空格、制表符、新行和任何属于空白字符类的字符。</p>
<p>最后，在 ARE 里，方括号表达式外面，序列(?#ttt)（其中ttt是任意不包含一个))的文本）是一个注释， 它被完全忽略。同样，这样的东西是不允许出现在多字符符号的字符中间的，例如 (?:。这种注释更像是一种历史产物，并且它们的使用已经被废弃；请使用扩展语法来替代。</p>
<p>如果声明了一个初始的***=控制器，那么所有这些元语法扩展都不能使用，因为这样表示把用户输入当作一个文字串而不是 RE 对待。</p>
<h6 id="_234"><strong>正则表达式匹配规则</strong></h6>
<p>在RE可以在给定串中匹配多于一个子串的情况下，RE匹配串中最靠前的那个子串。如果 RE 可以匹配在那个位置开始的多个子串，要么是取最长的子串，要么是最短的，具体哪种，取决于 RE 是贪婪的还是非贪婪的。</p>
<p>一个 RE 是否贪婪取决于下面规则：</p>
<ul>
<li>大多数原子以及所有约束，都没有贪婪属性（因为它们毕竟无法匹配个数变化的文本）。</li>
<li>在一个 RE 周围加上圆括号并不会改变其贪婪性。</li>
<li>带一个固定重复次数量词 （{m}或者{m}?） 的量化原子和原子自身具有同样的贪婪性（可能是没有）。</li>
<li>一个带其他普通的量词（包括{m,n}中m等于n的情况）的量化原子是贪婪的（首选最长匹配）。</li>
<li>一个带非贪婪量词（包括{m,n}?中m等于 n的情况）的量化原子是非贪婪的（首选最短匹配）。</li>
<li>一个分支 — 也就是说，一个没有顶级 | 操作符的 RE — 和它里面的第一个有贪婪属性的量化原子有着同样的贪婪性。</li>
<li>一个由 | 操作符连接起来的两个或者更多分支组成的 RE 总是贪婪的。</li>
</ul>
<p>上面的规则所描述的贪婪属性不仅仅适用于独立的量化原子， 而且也适用于包含量化原子的分支和整个 RE。这里的意思是， 匹配是按照分支或者整个 RE 作为一个整体匹配最长或者最短的可能子串。 一旦整个匹配的长度确定，那么匹配任意特定子表达式的部分就基于该子表达式的贪婪属性进行判断，在 RE 里面靠前的子表达式的优先级高于靠后的子表达式。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select SUBSTRING(&#39;XY1234Z&#39;, &#39;Y*([0-9]{1,3})&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>123
</code></pre></div>
<div class="highlight"><pre><span></span><code>select SUBSTRING(&#39;XY1234Z&#39;, &#39;Y*?([0-9]{1,3})&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>1
</code></pre></div>
<p>在第一个示例里，RE 作为整体是贪婪的，因为Y<em>是贪婪的。它可以匹配从Y开始的东西，并且它匹配从这个位置开始的最长的串， 也就是，Y123。输出是这里的圆括号包围的部分，或者说是123。在第二个示例里， RE 总体上是一个非贪婪的 RE，因为Y</em>?是非贪婪的。它可以匹配从Y开始的最短的子串，也就是说Y1。子表达式[0-9]{1,3}是贪婪的，但是它不能修改总体匹配长度的决定； 因此它被迫只匹配1。</p>
<p>简而言之，如果一个 RE 同时包含贪婪和非贪婪的子表达式，那么总的匹配长度要么是尽可能长，要么是尽可能短，这取决于给整个 RE 赋予的属性。给子表达式赋予的属性只影响在这个匹配里，各个子表达式之间相互允许“吃掉”的多少。</p>
<p>量词{1,1}和{1,1}?可以分别用于在一个子表达式 或者整个 RE 上强制贪婪或者非贪婪。当需要整个 RE 具有不同于从其元素中 推导出的贪婪属性时，这很有用。例如，假设我们尝试将一个包含一些数字的 字符串分隔成数字以及在它们之前和之后的部分，我们可能会尝试这样做：</p>
<div class="highlight"><pre><span></span><code>select regexp_match(&#39;abc01234xyz&#39;, &#39;(.*)(\d+)(.*)&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>{abc0123,4,xyz}
</code></pre></div>
<p>这不会有用：第一个.*是贪婪的，因此它会“吃掉” 尽可能多的字符而留下\d+去匹配在最后一个可能位置上的最后一个数字。我们可能会通过让它变成非贪婪来修复：</p>
<div class="highlight"><pre><span></span><code>select regexp_match(&#39;abc01234xyz&#39;, &#39;(.*?)(\d+)(.*)&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>{abc,0,&quot;&quot;}
</code></pre></div>
<p>这也不会有用：因为现在 RE 作为整体来说是非贪婪的，因此它会尽快结束 全部的匹配。我们可以通过强制 RE 整体是贪婪的来得到我们想要的：</p>
<div class="highlight"><pre><span></span><code>select regexp_match(&#39;abc01234xyz&#39;, &#39;(?:(.*?)(\d+)(.*)){1,1}&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>{abc,01234,xyz}
</code></pre></div>
<p>独立于 RE 的组件的贪婪性之外控制 RE 的整体贪婪性为处理变长模式提供了很大的灵活性。</p>
<p>在决定更长或者更短的匹配时，匹配长度是以字符衡量的，而不是排序元素。一个空串会被认为比什么都不匹配长。例如：bb<em>匹配abbbc的中间三个字符；(week|wee)(night|knights)匹配weeknights的所有十个字符； 而(.</em>).<em>匹配 abc的时候，圆括号包围的子表达式匹配所有三个字符；当(a</em>)*被拿来匹配bc时，整个 RE 和圆括号 子表达式都匹配一个空串。</p>
<p>如果声明了大小写无关的匹配，那么效果就好像所有大小写区别在字母表中消失了。如果在多个情况中一个字母以一个普通字符的形式出现在方括号表达式外面，那么它实际上被转换成 一个包含大小写的方括号表达式，也就是说，x 变成 [xX]。 如果它出现在一个方括号表达式里面，那么它的所有大小写的同族都被加入 方括号表达式中，也就是说，x变成[xX]。当它出现在一个方括号表达式内时，它的所有大小写副本都被加入到方括号表达式中，例如， [x]会变成[xX]，而[^x]会变成[^xX]。</p>
<p>如果指定了新行敏感的匹配，.和使用^的方括号表达式 将永远不会匹配新行字符（这样，匹配就绝对不会跨越新行，除非 RE 显式地安排了这样的情况）并且^和$除了分别匹配串开头和结尾之外，还将分别匹配新行后面和前面的空串。但是 ARE 逃逸\A和\Z仍然只匹配串的开头和结尾。</p>
<p>如果指定了部分新行敏感的匹配，那么它影响.和方括号表达式，这个时候和新行敏感的匹配一样，但是不影响^和$。</p>
<p>如果指定了逆新行敏感匹配，那么它影响^和$，其作用和在新行敏感的匹配里一样，但是不影响.和方括号表达式。这个并不是很有用，只是为了满足对称性而提供的。</p>
<h4 id="_235"><strong>条件表达式</strong></h4>
<p>本节描述在BSQL中可用的SQL兼容的条件表达式。</p>
<h5 id="case"><strong>CASE</strong></h5>
<p>SQL CASE表达式是一种通用的条件表达式，类似于其它编程语言中的 if/else 语句。
语法：</p>
<p>CASE WHEN condition THEN result
     [WHEN ...]
     [ELSE result]
END</p>
<p>CASE子句可以用于任何表达式可以出现的地方。每一个condition是一个返回boolean结果的表达式。如果结果为真，那么CASE表达式的结果就是符合条件的result，并且剩下的CASE表达式不会被处理。如果条件的结果不为真，那么以相同方式搜寻任何随后的WHEN子句。如果没有WHEN condition为真，那么CASE表达式的值就是在ELSE子句里的result。如果省略了ELSE子句而且没有条件为真，结果为空。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select * FROM test;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 1
 2
 3
</code></pre></div>
<p>接下来，运行如下：</p>
<div class="highlight"><pre><span></span><code>select a,
       CASE WHEN a=1 THEN &#39;one&#39;
            WHEN a=2 THEN &#39;two&#39;
            ELSE &#39;other&#39;
       END
  FROM test;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> a | case
---+-------
 1 | one
 2 | two
 3 | other
</code></pre></div>
<p>所有result表达式的数据类型都必须可以转换成单一的输出类型。</p>
<p>下面这个形式的CASE表达式是上述通用形式的一个变种：</p>
<p>CASE expression
    WHEN value THEN result
    [WHEN ...]
    [ELSE result]
END</p>
<p>第一个expression会被计算，然后与所有在WHEN子句中的每一个value对比，直到找到一个相等的。如果没有找到匹配的，则返回在ELSE子句中的result（或者null）。 </p>
<p>上面的示例可以用简单CASE语法来写：</p>
<div class="highlight"><pre><span></span><code>select a,
       CASE a WHEN 1 THEN &#39;one&#39;
              WHEN 2 THEN &#39;two&#39;
              ELSE &#39;other&#39;
       END
  FROM test;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> a | case
---+-------
 1 | one
 2 | two
 3 | other
</code></pre></div>
<p>CASE表达式并不计算任何无助于判断结果的子表达式。例如，下面是一个可以避免被零除错误的方法：</p>
<p>select ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;</p>
<h5 id="coalesce"><strong>COALESCE</strong></h5>
<p>语法：</p>
<p>COALESCE(value [, ...])</p>
<p>COALESCE函数返回它的第一个非空参数的值。当且仅当所有参数都为空时才会返回空。它常用于在为显示目的检索数据时，用缺省值替换空值。例如：</p>
<div class="highlight"><pre><span></span><code>select COALESCE(description, short_description, &#39;(none)&#39;) ...
</code></pre></div>
<p>如果description不为空，这将会返回它的值，否则如果short_description非空则返回short_description的值，如果前两个都为空则返回(none)。</p>
<p>所有参数都必须转换为一个公共数据类型，它将是结果的数据类型。</p>
<p>和CASE表达式一样，COALESCE将不会计算无助于判断结果的参数；也就是说，在第一个非空参数右边的参数不会被计算。这个 SQL 标准函数提供了类似于NVL和IFNULL的能力，它们被用在某些其他数据库系统中。</p>
<h5 id="nullif"><strong>NULLIF</strong></h5>
<p>语法：</p>
<p>NULLIF(value1, value2)</p>
<p>当value1和value2相等时，NULLIF返回一个空值。否则它返回value1。这些可以用于执行前文给出的COALESCE示例的逆操作：</p>
<p>select NULLIF(value, '(none)') ...</p>
<p>在这个示例中，如果value是(none)，将返回空值，否则返回value的值。</p>
<p>这两个参数必须具有可比较的类型。具体来说，它们的比较与你写的 value1 = value2完全一样，因此必须有一个合适的 = 操作符可用。</p>
<p>结果的类型与第一个参数相同，但有一点细微的区别。实际上返回的是隐含 = 操作符的第一个参数，在某些情况下，它将被提升以匹配第二个参数的类型。 例如，NULLIF(1, 2.2) 生成 numeric，因为没有integer = numeric操作符，只有numeric = numeric。</p>
<h5 id="greatestleast"><strong>GREATEST和LEAST</strong></h5>
<p>语法：</p>
<p>GREATEST(value [, ...])
LEAST(value [, ...])</p>
<p>GREATEST和LEAST函数从一个任意的数字表达式列表里选取最大或者最小的数值。 这些表达式必须都可以转换成一个普通的数据类型，它将会是结果类型。列表中的 NULL 数值将被忽略。只有所有表达式的结果都是 NULL 的时候，结果才会是 NULL。</p>
<h4 id="_236"><strong>子查询表达式</strong></h4>
<p>本节描述BSQL中可用的SQL兼容的子查询表达式。</p>
<h5 id="exists"><strong>EXISTS</strong></h5>
<p>语法：</p>
<p>EXISTS (subquery)</p>
<p>EXISTS的参数是一个任意的SELECT语句，或者说子查询。系统对子查询进行运算以判断它是否返回行。如果它至少返回一行，那么EXISTS的结果就为“真”；如果子查询没有返回行，那么EXISTS的结果是“假”。</p>
<p>子查询可以引用来自周围的查询的变量，这些变量在该子查询的任何一次计算中都起常量的作用。</p>
<p>这个子查询通常只是运行到能判断它是否可以返回至少一行为止， 而不是等到全部结束。</p>
<p>因为结果只取决于是否会返回行，而不取决于这些行的内容，所以这个子查询的输出列表通常是无关紧要的。一个常用的编码习惯是用EXISTS(select 1 WHERE ...)的形式写所有的EXISTS测试。不过这条规则有例外，例如那些使用INTERSECT的子查询。</p>
<p>下面这个简单的示例类似在col2上的一次内联接，但是它为每个 tab1的行生成最多一个输出，即使存在多个匹配tab2的行也如此∶</p>
<div class="highlight"><pre><span></span><code>select col1
FROM tab1
WHERE EXISTS (select 1 FROM tab2 WHERE col2 = tab1.col2);
</code></pre></div>
<h5 id="in"><strong>IN</strong></h5>
<p>语法：</p>
<p>expression IN (subquery)</p>
<p>右边是一个圆括弧括起来的子查询，它必须正好只返回一个列。左边表达式将被计算并与子查询结果逐行进行比较。如果找到任何等于子查询行的情况，那么IN的结果就是“真”。如果没有找到相等行，那么结果是“假”（包括子查询没有返回任何行的情况）。</p>
<p>请注意如果左边表达式得到空值，或者没有相等的右边值，并且至少有一个右边行得到空值，那么IN结构的结果将是空值，而不是假。这个行为是遵照 SQL 处理空值的一般规则的。</p>
<p>row_constructor IN (subquery)</p>
<p>这种形式的IN的左边是一个行构造器。右边是一个圆括弧子查询，它必须返回和左边返回的行中表达式所构成的完全一样多的列。左边表达式将被计算并与子查询结果逐行进行比较。如果找到任意相等的子查询行，则IN的结果为“真”。如果没有找到相等行， 那么结果为“假”（包括子查询不返回行的情况）。</p>
<p>通常，表达式或者子查询行里的空值是按照 SQL 布尔表达式的一般规则进行组合的。如果两个行对应的成员都非空并且相等，那么认为这两行相等；如果任意对应成员为非空且不等，那么这两行不等；否则这样的行比较的结果是未知（空值）。如果所有行的结果要么是不等，要么是空值，并且至少有一个空值，那么IN的结果是空值。</p>
<h5 id="not-in"><strong>NOT IN</strong></h5>
<p>语法：</p>
<p>expression NOT IN (subquery)</p>
<p>右边是一个用圆括弧包围的子查询，它必须返回一个列。左边表达式将被计算并与子查询结果逐行进行比较。如果只找到不相等的子查询行（包括子查询不返回行的情况），那么NOT IN的结果是“真”。如果找到任何相等行，则结果为“假”。</p>
<p>请注意：如果左边表达式得到空值，或者没有相等的右边值，并且至少有一个右边行得到空值，那么NOT IN结构的结果将是空值，而不是真。这个行为是遵照 SQL 处理空值的一般规则的。</p>
<p>row_constructor NOT IN (subquery)</p>
<p>这种形式的NOT IN的左边是一个行构造器。右边是一个圆括弧子查询，它必须返回和左边返回的行中表达式所构成的完全一样多的列。左边表达式将被计算并与子查询结果逐行进行比较。如果找到不等于子查询行的行，则NOT IN的结果为“真”。如果找到相等行，那么结果为“假”（包括子查询不返回行的情况）。</p>
<p>通常，表达式或者子查询行里的空值是按照 SQL 布尔表达式的一般规则进行组合的。如果两个行对应的成员都非空并且相等，那么认为这两行相等；如果任意对应成员为非空且不等，那么这两行不等； 否则这样的行比较的结果是未知（空值）。如果所有行的结果要么是不等，要么是空值，并且至少有一个空值，那么NOT IN的结果是空值。</p>
<h5 id="anysome"><strong>ANY/SOME</strong></h5>
<p>语法：</p>
<p>expression operator ANY (subquery)
expression operator SOME (subquery)</p>
<p>这种形式的右边是一个圆括弧括起来的子查询，它必须返回正好一个列。左边表达式将被计算并使用给出的操作符对子查询结果逐行进行比较。如果获得任何真值结果，那么ANY的结果就是“真”。如果没有找到真值结果，那么结果是“假”（包括子查询没有返回任何行的情况）。</p>
<p>SOME是ANY的同义词。IN等价于 = ANY。</p>
<p>请注意如果没有任何成功，并且至少有一个右边行为该操作符结果生成空值 那么ANY结构的结果将是空值，而不是假。 这个行为是遵照 SQL 处理空值布尔组合的一般规则制定的。</p>
<p>row_constructor operator ANY (subquery)
row_constructor operator SOME (subquery)</p>
<p>这种形式的左边是一个行构造器。右边是一个圆括弧括起来的子查询，它必须返回和左边列表给出的表达式一样多的列。左边表达式将被计算并使用给出的操作符对子查询结果逐行进行比较。如果比较为任何子查询行返回真，则ANY的结果为“真”。如果比较对每一个子查询行都返回假，则结果为“假”（包括子查询不返回行的情况）。如果比较不对任何行返回真并且至少对一行返回 NULL，则结果为 NULL。</p>
<h5 id="all"><strong>ALL</strong></h5>
<p>语法：</p>
<p>expression operator ALL (subquery)</p>
<p>ALL 的这种形式的右边是一个圆括弧括起来的子查询，它必须只返回一列。左边表达式将被计算并使用给出的操作符对子查询结果逐行进行比较。该操作符必须生成布尔结果。如果所有行得到真（包括子查询没有返回任何行的情况），ALL的结果就是“真”。如果没有存在任何假值结果，那么结果是“假”。如果比较为任何行都不返回假并且对至少一行返回 NULL，则结果为 NULL。</p>
<p>NOT IN等价于 &lt;&gt; ALL。</p>
<p>和EXISTS一样，假设子查询将被完全运行是不明智的。</p>
<p>row_constructor operator ALL (subquery)</p>
<p>ALL的这种形式的左边是一个行构造器。右边是一个圆括弧括起来的子查询，它必须返回和左边行中表达式一样多的列。左边表达式将被计算并使用给出的操作符对子查询结果逐行进行比较。如果对所有子查询行该比较都返回真，那么ALL的结果就是“真”（包括子查询没有返回任何行的情况）。如果对任何子查询行比较返回假，则结果为“假”。如果比较对任何子查询行都不返回假并且对至少一行返回 NULL，则结果为 NULL。</p>
<h5 id="_237"><strong>单一行比较</strong></h5>
<p>语法：</p>
<p>row_constructor operator (subquery)</p>
<p>左边是一个行构造器，右边是一个圆括弧括起来的子查询，该查询必须返回和左边行中表达式数目完全一样的列。另外，该子查询不能返回超过一行的数量（如果它返回零行，那么结果就是空值）。左边被计算并逐行与右边的子查询结果行进行比较。</p>
<h4 id="_238"><strong>行和数组比较</strong></h4>
<p>本节描述几个特殊的结构，用于在值的组之间进行多重比较。这些形式语法上和前面一节的子查询形式相关，但是不涉及子查询。这种形式涉及的数组子表达式是BSQL的扩展； 其它的是SQL兼容的。所有本节记录的表达式形式都返回布尔（Boolean）结果（真/假）。</p>
<h5 id="in_1"><strong>IN</strong></h5>
<p>语法：</p>
<p>expression IN (value [, ...])</p>
<p>右边是一个圆括弧包围的标量列表。如果左边表达式的结果等于任何右边表达式中的一个，结果为“真”。它是下面形式的缩写</p>
<p>expression = value1
OR
expression = value2
OR
...</p>
<p>请注意如果左边表达式得到空值，或者没有相等的右边值并且至少有一个右边的表达式得到空值，那么IN结构的结果将为空值，而不是假。这符合 SQL 处理空值的布尔组合的一般规则。</p>
<h5 id="not-in_1"><strong>NOT IN</strong></h5>
<p>语法：</p>
<p>expression NOT IN (value [, ...])</p>
<p>右边是一个圆括弧包围的标量列表。如果左边表达式的结果不等于所有右边表达式，结果为“真”。它是下面形式的缩写</p>
<p>expression &lt;&gt; value1
AND
expression &lt;&gt; value2
AND
...</p>
<p>请注意如果左边表达式得到空值，或者没有相等的右边值并且至少有一个右边的表达式得到空值，那么NOT IN结构的结果将为空值，而不是我们可能认为的真值。这符合 SQL 处理空值的布尔组合的一般规则。</p>
<h5 id="anysome-array"><strong>ANY/SOME (array)</strong></h5>
<p>语法：</p>
<p>expression operator ANY (array expression)
expression operator SOME (array expression)</p>
<p>右边是一个圆括弧包围的表达式，它必须得到一个数组值。左边表达式被计算并且使用给出的操作符对数组的每个元素进行比较，这个操作符必须得到布尔结果。如果得到了任何真值结果，那么ANY的结果是“真”。 如果没有找到真值结果（包括数组只有零个元素的情况），那么结果是“假”。</p>
<p>如果数组表达式得到一个空数组，ANY的结果将为空值。如果左边的表达式得到空值，ANY通常是空值（尽管一个非严格比较操作符可能得到一个不同的结果）。另外，如果右边的数组包含任何空值元素或者没有得到真值比较结果，ANY的结果将是空值而不是假（再次，假设是一个严格的比较操作符）。这符合 SQL 对空值的布尔组合的一般规则。</p>
<p>SOME是ANY的同义词。</p>
<h5 id="all-array"><strong>ALL (array)</strong></h5>
<p>语法：</p>
<p>expression operator ALL (array expression)</p>
<p>右边是一个圆括弧包围的表达式，它必须得到一个数组值。左边表达式将被计算并使用给出的操作符与数组的每个元素进行比较，这个操作符必须得到一个布尔结果。如果所有比较都得到真值结果，那么ALL的结果是 “真”（包括数组只有零个元素的情况）。如果有任何假值结果，那么结果是“假”。</p>
<p>如果数组表达式得到一个空数组，ALL的结果将为空值。如果左边的表达式得到空值，ALL通常是空值（尽管一个非严格比较操作符可能得到一个不同的结果）。另外，如果右边的数组包含任何空值元素或者没有得到假值比较结果，ALL的结果将是空值而不是真（再次，假设是一个严格的比较操作符）。这符合 SQL 对空值的布尔组合的一般规则。</p>
<h5 id="_239"><strong>行构造器比较</strong></h5>
<p>语法：</p>
<p>row_constructor operator row_constructor</p>
<p>每一边都是一个行构造器。两个行值必须具有相同数量的域。每一边被计算并且被逐行比较。当操作符是 =、 &lt;&gt;、 &lt; &lt;=、 &gt;、 &gt;=时，允许进行行构造器比较。每一个行元素必须是具有一个默认 B 树操作符类的类型，否则尝试比较会产生一个错误。</p>
<p>=和&lt;&gt;情况略有不同。如果两行的所有对应成员都是非空且相等则这两行被认为相等；如果任何对应成员是非空但是不相等则这两行不相等；否则行比较的结果为未知（空值）。</p>
<p>对于&lt;、&lt;=、&gt;和&gt;=情况，行元素被从左至右比较，在找到一处不等的或为空的元素对就立刻停下来。如果这一对元素都为空值，则行比较的结果为未知（空值）；否则这一对元素的比较结果决定行比较的结果。例如，ROW(1,2,NULL) &lt; ROW(1,3,0)得到真，而不是空值，因为第三对元素并没有被考虑。</p>
<p>row_constructor IS DISTINCT FROM row_constructor</p>
<p>这个结构与&lt;&gt;行比较相似，但是它对于空值输入不会得到空值。任何空值被认为和任何非空值不相等（有区别），并且任意两个空值被认为相等（无区别）。因此结果将总是为真或为假，永远不会是空值。</p>
<p>row_constructor IS NOT DISTINCT FROM row_constructor</p>
<p>这个结构与=行比较相似，但是它对于空值输入不会得到空值。任何空值被认为和任何非空值不相等（有区别），并且任意两个空值被认为相等（无区别）。因此结果将总是为真或为假，永远不会是空值。</p>
<h5 id="_240"><strong>组合类型比较</strong></h5>
<p>语法：</p>
<p>record operator record</p>
<p>SQL 规范要求在结果依赖于比较两个 NULL 值或者一个 NULL 与一个非 NULL 时逐行比较返回 NULL。BSQL只有在比较两个行构造器的结果，或者比较一个行构造器与一个子查询的输出时才这样做。在其他比较两个组合类型值的环境中，两个 NULL 域值被认为相等，并且一个 NULL 被认为大于一个非 NULL。为了得到组合类型的一致的排序和索引行为，这样做是必要的。</p>
<p>每一边都会被计算并且它们会被逐行比较。当操作符是 =、 &lt;&gt;、 &lt;、 &lt;=、 &gt;或者 &gt;=时或者具有与这些类似的语义时，允许组合类型的比较（更准确地说，如果一个操作符是一个 B 树操作符类的成员，或者是一个 B 树操作符类的=成员的否定词，它就可以是一个行比较操作符）。上述操作符的行为与用于行构造器的IS [ NOT ] DISTINCT FROM相同。</p>
<p>为了支持包含无默认 B 树操作符类的元素的行匹配，为组合类型比较定义了下列操作符：<em>=、 </em>&lt;&gt;、 <em>&lt;、 </em>&lt;=、 <em>&gt;以及 </em>&gt;=。这些操作符比较两行的内部二进制表达。即使两行用相等操作符的比较为真，两行也可能具有不同的二进制表达。行在这些比较操作符之下的排序是决定性的，其他倒没什么意义。这些操作符在内部被用于物化视图，并且可能对其他如复制和B-树复制之类的特殊功能有用，但是它们并不打算用在书写查询这类普通用途中。</p>
<h4 id="_241"><strong>集合返回函数</strong></h4>
<p>本节描述那些可能返回多于一行的函数。目前这个类中被使用最广泛的是级数生成函数。</p>
<h5 id="_242"><strong>系列生成函数</strong></h5>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_generate_series()">generate_series()</a></td>
<td>从start到stop生成一系列的值。</td>
</tr>
<tr>
<td><a href="#_generate_series()_1">generate_series()</a></td>
<td>从start到stop生成一系列的值，步长为step。</td>
</tr>
<tr>
<td><a href="#_generate_series()_2">generate_series()</a></td>
<td>从start到stop生成一系列的值，步长为step。</td>
</tr>
</tbody>
</table>
<h6 id="generate_series"><strong>generate_series()</strong></h6>
<p>目的：从start到stop生成一系列的值。</p>
<p>语法：</p>
<p>输入值:      integer,integer
返回值:      setof integer</p>
<p>或者</p>
<p>输入值:      bigint,bigint<br />
返回值:      setof bigint </p>
<p>或者</p>
<p>输入值:      numeric,numeric
返回值:      setof numeric</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select * from generate_series(2,4);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>2
3
4
</code></pre></div>
<h6 id="generate_series_1"><strong>generate_series()</strong></h6>
<p>目的：从start到stop生成一系列的值，步长为step。</p>
<p>语法：</p>
<p>输入值:      integer,integer,integer
返回值:      setof integer</p>
<p>或者</p>
<p>输入值:      bigint,bigint,bigint<br />
返回值:      setof bigint </p>
<p>或者</p>
<p>输入值:      numeric,numeric,numeric
返回值:      setof numeric</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select * from generate_series(5,1,-2);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>5
3
1
</code></pre></div>
<h6 id="generate_series_2"><strong>generate_series()</strong></h6>
<p>目的：从start到stop生成一系列的值，步长为step。</p>
<p>语法：</p>
<p>输入值:      timestamp,timestamp,interval
返回值:      setof timestamp</p>
<p>或者</p>
<p>输入值:      timestamp with time zone,timestamp with time zone,interval
返回值:      setof timestamp with time zone</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select * from generate_series(&#39;2008-03-01 00:00&#39;::timestamp,&#39;2008-03-04 12:00&#39;::timestamp, &#39;10 hours&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 2008-03-01 00:00:00
 2008-03-01 10:00:00
 2008-03-01 20:00:00
 2008-03-02 06:00:00
 2008-03-02 16:00:00
 2008-03-03 02:00:00
 2008-03-03 12:00:00
 2008-03-03 22:00:00
 2008-03-04 08:00:00
</code></pre></div>
<h5 id="_243"><strong>下标生成函数</strong></h5>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>generate_subscripts()</td>
<td>生成一个包含给定数组第dim维度的有效下标的序列。</td>
</tr>
<tr>
<td>generate_subscripts()</td>
<td>生成一个包含给定数组第dim维度的有效下标的序列。当reverse为真时，以相反的顺序返回序列。</td>
</tr>
</tbody>
</table>
<h6 id="generate_subscripts_1"><strong>generate_subscripts()</strong></h6>
<p>目的：生成一个包含给定数组第dim维度的有效下标的序列。</p>
<p>语法：</p>
<p>输入值:      anyarray, integer
返回值:      SETOF integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select generate_subscripts(&#39;{NULL,1,NULL,2}&#39;::int[], 1) AS s;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 1
 2
 3
 4
</code></pre></div>
<h6 id="generate_subscripts_2"><strong>generate_subscripts()</strong></h6>
<p>目的：生成一个包含给定数组第dim维度的有效下标的序列。当reverse为真时，以相反的顺序返回序列。</p>
<p>语法：</p>
<p>输入值:      anyarray, integer, boolean
返回值:      SETOF integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select generate_subscripts(&#39;{NULL,1,NULL,2}&#39;::int[], 1,true) AS s;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 4
 3
 2
 1
</code></pre></div>
<h4 id="_244"><strong>窗口函数</strong></h4>
<p>窗口函数提供了跨越与当前查询行相关的行集执行计算的能力。 </p>
<h5 id="_245"><strong>特性</strong></h5>
<p>一个窗口函数在一系列与当前行有某种关联的表行上执行一种计算。这与一个聚集函数所完成的计算有可比之处。但是窗口函数并不会使多行被聚集成一个单独的输出行，这与通常的非窗口聚集函数不同。取而代之，行保留它们独立的标识。在这些现象背后，窗口函数可以访问的不仅仅是查询结果的当前行。</p>
<p>下面是一个示例用于展示如何将每一个员工的薪水与他/她所在部门的平均薪水进行比较：</p>
<div class="highlight"><pre><span></span><code>select depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>depname   | empno | salary  |          avg
---------------+---------+----------+-------------------------------
 develop   |    11 |   5200 | 5020.0000000000000000
 develop   |     7 |   4200 | 5020.0000000000000000
 develop   |     9 |   4500 | 5020.0000000000000000
 develop   |     8 |   6000 | 5020.0000000000000000
 develop   |    10 |   5200 | 5020.0000000000000000
 personnel  |     5 |   3500 | 3700.0000000000000000
 personnel  |     2 |   3900 | 3700.0000000000000000
 sales     |     3 |   4800 | 4866.6666666666666667
 sales     |     1 |   5000 | 4866.6666666666666667
 sales     |     4 |   4800 | 4866.6666666666666667
</code></pre></div>
<p>最开始的三个输出列直接来自于表empsalary，并且表中每一行都有一个输出行。第四列表示对与当前行具有相同depname值的所有表行取得平均值（这实际和非窗口avg聚集函数是相同的函数，但是OVER子句使得它被当做一个窗口函数处理并在一个合适的窗口帧上计算。）。</p>
<p>一个窗口函数调用总是包含一个直接跟在窗口函数名及其参数之后的OVER子句。这使得它从句法上和一个普通函数或非窗口函数区分开来。OVER子句决定究竟查询中的哪些行被分离出来由窗口函数处理。OVER子句中的PARTITION BY子句指定了将具有相同PARTITION BY表达式值的行分到组或者分区。对于每一行，窗口函数都会在当前行同一分区的行上进行计算。</p>
<p>我们可以通过OVER上的ORDER BY控制窗口函数处理行的顺序（窗口的ORDER BY并不一定要符合行输出的顺序。）。例如：</p>
<div class="highlight"><pre><span></span><code>select depname, empno, salary,
       rank() OVER (PARTITION BY depname ORDER BY salary DESC) FROM empsalary;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> depname  | empno | salary  | rank
---------------+--------+-----------+-------
 develop   |     8 |   6000 |    1
 develop   |    10 |   5200 |    2
 develop   |    11 |   5200 |    2
 develop   |     9 |   4500 |    4
 develop   |     7 |   4200 |    5
 personnel  |     2 |   3900 |    1
 personnel  |     5 |   3500 |    2
 sales      |     1 |   5000 |    1
 sales      |     4 |   4800 |    2
 sales      |     3 |   4800 |    2
</code></pre></div>
<p>如上所示，rank函数在当前行的分区内按照ORDER BY子句的顺序为每一个可区分的ORDER BY值产生了一个顺序号。rank不需要显式的参数，因为它的行为完全决定于OVER子句。</p>
<p>一个窗口函数所考虑的行属于那些通过查询的FROM子句产生并通过WHERE、GROUP BY、HAVING过滤的“虚拟表”。例如，一个由于不满足WHERE条件被删除的行是不会被任何窗口函数所见的。在一个查询中可以包含多个窗口函数，每个窗口函数都可以用不同的OVER子句来按不同方式划分数据，但是它们都作用在由虚拟表定义的同一个行集上。</p>
<p>我们已经看到如果行的顺序不重要时ORDER BY可以忽略。PARTITION BY同样也可以被忽略，在这种情况下会产生一个包含所有行的分区。</p>
<p>这里有一个与窗口函数相关的重要概念：对于每一行，在它的分区中的行集被称为它的窗口帧。 一些窗口函数只作用在窗口帧中的行上，而不是整个分区。默认情况下，如果使用ORDER BY，则帧包括从分区开始到当前行的所有行，以及后续任何与当前行在ORDER BY子句上相等的行。如果ORDER BY被忽略，则默认帧包含整个分区中所有的行。例如，下面是使用sum的示例：</p>
<div class="highlight"><pre><span></span><code>select salary, sum(salary) OVER () FROM empsalary;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> salary  |  sum
-----------+--------
   5200 | 47100
   5000 | 47100
   3500 | 47100
   4800 | 47100
   3900 | 47100
   4200 | 47100
   4500 | 47100
   4800 | 47100
   6000 | 47100
   5200 | 47100
</code></pre></div>
<p>如上所示，由于在OVER子句中没有ORDER BY，窗口帧和分区一样，而如果缺少PARTITION BY则和整个表一样。换句话说，每个合计都会在整个表上进行，这样我们为每一个输出行得到的都是相同的结果。但是如果我们加上一个ORDER BY子句，我们会得到非常不同的结果，例如：</p>
<div class="highlight"><pre><span></span><code>select salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> salary  |   sum    
-----------+------------
 3500.00 |  3500.00
 3900.00 |  7400.00
 4200.00 | 11600.00
 4500.00 | 16100.00
 4800.00 | 25700.00
 4800.00 | 25700.00
 5000.00 | 30700.00
 5200.00 | 41100.00
 5200.00 | 41100.00
 6000.00 | 47100.00
</code></pre></div>
<p>这里的合计是从第一个（最低的）薪水一直到当前行，包括任何与当前行相同的行（注意相同薪水行的结果）。</p>
<p>窗口函数只允许出现在查询的SELECT列表和ORDER BY子句中。它们不允许出现在其他地方，例如GROUP BY、HAVING和WHERE子句中。这是因为窗口函数的执行逻辑是在处理完这些子句之后。另外，窗口函数在非窗口聚集函数之后执行。这意味着可以在窗口函数的参数中包括一个聚集函数，但反过来不行。</p>
<p>如果需要在窗口计算执行后进行过滤或者分组，我们可以使用子查询。例如：</p>
<div class="highlight"><pre><span></span><code>select depname, empno, salary
FROM ( select depname, empno, salary,
          rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos
         FROM empsalary
      ) AS ss
WHERE pos &lt; 3;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>  depname  | empno | salary  
---------------+---------+---------
 develop   |     8 | 6000.00
 develop   |    10 | 5200.00
 personnel  |     2 | 3900.00
 personnel  |     5 | 3500.00
 sales      |     1 | 5000.00
 sales      |     3 | 4800.00
</code></pre></div>
<p>当一个查询涉及到多个窗口函数时，可以将每一个分别写在一个独立的OVER子句中。但如果多个函数要求同一个窗口行为时，这种做法是冗余的而且容易出错的。替代方案是，每一个窗口行为可以被放在一个命名的WINDOW子句中，然后在OVER中引用它。例如：</p>
<div class="highlight"><pre><span></span><code>select sum(salary) OVER w, avg(salary) OVER w
  FROM empsalary
  WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);
</code></pre></div>
<h5 id="_246"><strong>窗口函数语法</strong></h5>
<p>一个窗口函数调用表示在一个查询选择的行的某个部分上应用一个聚集类的函数。和非窗口聚集函数调用不同，这不会被约束为将被选择的行分组为一个单一的输出行 — 在查询输出中每一个行仍保持独立。不过，窗口函数能够根据窗口函数调用的分组声明（PARTITION BY列表）访问属于当前行所在分组中的所有行。
一个窗口函数调用的语法是下列之一：</p>
<p>function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER window_name
function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )
function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER window_name
function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER ( window_definition )</p>
<p>其中window_definition的语法是：</p>
<p>[ existing_window_name ]
[ PARTITION BY expression [, ...] ]
[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ frame_clause ]</p>
<p>可选的frame_clause是下列之一：</p>
<p>{ RANGE | ROWS | GROUPS } frame_start [ frame_exclusion ]
{ RANGE | ROWS | GROUPS } BETWEEN frame_start AND frame_end [ frame_exclusion ]</p>
<p>其中frame_start和frame_end可以是下面形式中的一种：</p>
<p>UNBOUNDED PRECEDING
offset PRECEDING
CURRENT ROW
offset FOLLOWING
UNBOUNDED FOLLOWING</p>
<p>而frame_exclusion可以是下列之一：</p>
<p>EXCLUDE CURRENT ROW
EXCLUDE GROUP
EXCLUDE TIES
EXCLUDE NO OTHERS</p>
<p>这里，expression表示任何自身不含有窗口函数调用的值表达式。</p>
<p>window_name是对定义在查询的WINDOW子句中的一个命名窗口声明的引用。还可以使用在WINDOW子句中定义命名窗口的相同语法在圆括号内给定一个完整的window_definition，详见SELECT参考页。值得指出的是，OVER wname并不严格地等价于OVER (wname ...)，后者表示复制并修改窗口定义，并且在被引用窗口声明包括一个帧子句时会被拒绝。</p>
<p>PARTITION BY选项将查询的行分组成为分区，窗口函数会独立地处理它们。PARTITION BY工作起来类似于一个查询级别的GROUP BY子句，不过它的表达式总是只是表达式并且不能是输出列的名称或编号。如果没有PARTITION BY，该查询产生的所有行被当作一个单一分区来处理。ORDER BY选项决定被窗口函数处理的一个分区中的行的顺序。它工作起来类似于一个查询级别的ORDER BY子句，但是同样不能使用输出列的名称或编号。如果没有ORDER BY，行将被以未指定的顺序被处理。</p>
<p>frame_clause指定构成窗口帧的行集合，它是当前分区的一个子集，窗口函数将作用在该帧而不是整个分区。帧中的行集合会随着哪一行是当前行而变化。在RANGE、ROWS或者GROUPS模式中可以指定帧，在每一种情况下，帧的范围都是从frame_start到frame_end。如果frame_end被省略，则末尾默认为CURRENT ROW。</p>
<p>UNBOUNDED PRECEDING的一个frame_start表示该帧开始于分区的第一行，类似地UNBOUNDED FOLLOWING的一个frame_end表示该帧结束于分区的最后一行。</p>
<p>在RANGE或GROUPS模式中，CURRENT ROW的一个frame_start表示帧开始于当前行的第一个平级行（被窗口的ORDER BY子句排序为与当前行等效的行），而CURRENT ROW的一个frame_end表示帧结束于当前行的最后一个平级行。在ROWS模式中，CURRENT ROW就表示当前行。</p>
<p>在offset PRECEDING以及offset FOLLOWING帧选项中，offset必须是一个不包含任何变量、聚集函数或者窗口函数的表达式。offset的含义取决于帧模式。</p>
<p>在ROWS模式中，offset必须得到一个非空、非负的整数，并且该选项表示帧开始于当前行之前或者之后指定数量的行。</p>
<p>在GROUPS模式中，offset也必须得到一个非空、非负的整数，并且该选项表示帧开始于当前行的平级组之前或者之后指定数量的平级组，这里平级组是在ORDER BY顺序中等效的行集合（要使用GROUPS模式，在窗口定义中就必须有一个ORDER BY子句）。</p>
<p>在RANGE模式中，这些选项要求ORDER BY子句正好指定一列。offset指定当前行中那一列的值与它在该帧中前面或后面的行中的列值的最大差值。offset表达式的数据类型会随着排序列的数据类型而变化。对于数字的排序列，它通常是与排序列相同的类型，但对于日期时间排序列它是一个interval。例如，如果排序列是类型date或者timestamp，我们可以写RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING。offset仍然要求是非空且非负，不过“非负”的含义取决于它的数据类型。</p>
<p>在任何一种情况下，到帧末尾的距离都受限于到分区末尾的距离，因此对于离分区末尾比较近的行来说，帧可能会包含比较少的行。</p>
<p>注意在ROWS以及GROUPS模式中，0 PRECEDING和0 FOLLOWING与CURRENT ROW等效。通常在RANGE模式中，这个结论也成立（只要有一种合适的、与数据类型相关的“零”的含义）。</p>
<p>frame_exclusion选项允许当前行周围的行被排除在帧之外，即便根据帧的开始和结束选项应该把它们包括在帧中。EXCLUDE CURRENT ROW会把当前行排除在帧之外。EXCLUDE GROUP会把当前行以及它在顺序上的平级行都排除在帧之外。EXCLUDE TIES把当前行的任何平级行都从帧中排除，但不排除当前行本身。EXCLUDE NO OTHERS只是明确地指定不排除当前行或其平级行的这种默认行为。</p>
<p>默认的帧选项是RANGE UNBOUNDED PRECEDING，它和RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW相同。如果使用ORDER BY，这会把该帧设置为从分区开始一直到当前行的最后一个ORDER BY平级行的所有行。如果不使用ORDER BY，就意味着分区中所有的行都被包括在窗口帧中，因为所有行都成为了当前行的平级行。</p>
<p>限制是frame_start不能是UNBOUNDED FOLLOWING、frame_end不能是UNBOUNDED PRECEDING，并且在上述frame_start和frame_end选项的列表中，frame_end选择不能早于frame_start选择出现。例如：不允许RANGE BETWEEN CURRENT ROW AND offset PRECEDING，但允许ROWS BETWEEN 7 PRECEDING AND 8 PRECEDING，虽然它不会选择任何行。</p>
<p>如果指定了FILTER，那么只有对filter_clause计算为真的输入行会被交给该窗口函数，其他行会被丢弃。只有是聚集的窗口函数才接受FILTER 。</p>
<p>使用 * 的语法被用来把参数较少的聚集函数当作窗口函数调用，例如count(<em>) OVER (PARTITION BY x ORDER BY y)。星号（</em>）通常不被用于窗口相关的函数。窗口相关的函数不允许在函数参数列表中使用DISTINCT或ORDER BY。</p>
<p>只有在SELECT列表和查询的ORDER BY子句中才允许窗口函数调用。</p>
<h5 id="_247"><strong>通用窗口函数</strong></h5>
<p>内置的窗口函数罗列在下表中。注意，这些函数必须使用窗口函数语法来调用，也就是说，需要一个OVER子句。
除了这些函数之外，任何内置的或用户定义的普通聚合(例如非有序集或假设集聚合)都可以作为窗口函数使用;关于内置聚合的列表，参见<a href="#_聚集函数">聚集函数</a>一节。 聚合函数只有在调用之后有一个OVER子句时才作为窗口函数;否则，它们充当普通的聚合，并为整个集合返回一行。
在下表中列出的所有函数都依赖于相关窗口定义的ORDER BY子句指定的排序顺序。 仅考虑ORDER BY列时不能区分的行被称为是同等行。 定义的这四个排名函数（包括 cume_dist），对于对等组的所有行的答案相同。
注意：first_value、last_value和nth_value只考虑“窗口帧”内的行，它默认情况下包含从分区的开始行直到当前行的最后一个同等行。这对last_value可能不会给出有用的结果，有时对nth_value也一样。 你可以通过向OVER子句增加一个合适的帧声明（RANGE或GROUPS）来重定义帧。
当一个聚集函数被用作窗口函数时，它将在当前行的窗口帧内的行上聚集。 一个使用ORDER BY和默认窗口帧定义的聚集产生一种“运行时求和”类型的行为，这可能是不想要的结果。为了获取在整个分区上的聚集，忽略ORDER BY或者使用ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING。 其它窗口帧声明可以用来获得其它的效果。
cume_dist计算小于或等于当前行及其对等行的分区行的分数，而percent_rank计算小于当前行的分区列的分数，假设当前行不存在于分区中。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_row_number()">row_number()</a></td>
<td>返回其分区内的当前行数，从1开始计数。</td>
</tr>
<tr>
<td><a href="#_rank()">rank()</a></td>
<td>返回当前行的排名，包含间隔;即对等组中第一行的row_number。</td>
</tr>
<tr>
<td><a href="#_dense_rank()">dense_rank()</a></td>
<td>返回当前行的排名，不包括间隔;这个功能有效地计数对等组。</td>
</tr>
<tr>
<td><a href="#_percent_rank()">percent_rank()</a></td>
<td>返回当前行的相对排名，即(rank - 1) / (总的分区行数- 1)。因此该值的范围从0到1(包含在内)</td>
</tr>
<tr>
<td><a href="#_cume_dist()">cume_dist()</a></td>
<td>返回累积分布，也就是(当前行之前或对等的分区行数)/(总的分区行数)。取值范围为1/N 到 1</td>
</tr>
<tr>
<td><a href="#_ntile()">ntile()</a></td>
<td>返回一个从1到参数值的整数，并将分区划分为尽可能相等的值。</td>
</tr>
<tr>
<td><a href="#_lag(value anyelement [, offset integer [, default anyelement ]])">lag()</a></td>
<td>返回分区中在当前行之前offset行的值</td>
</tr>
<tr>
<td><a href="#_lead()">lead()</a></td>
<td>返回分区中在当前行之后offset行的值</td>
</tr>
<tr>
<td><a href="#_first_value()">first_value()</a></td>
<td>返回在窗口框架的第一行求得的值。</td>
</tr>
<tr>
<td><a href="#_last_value()">last_value()</a></td>
<td>返回在窗口框架的最后一行求得的值。</td>
</tr>
<tr>
<td><a href="#_nth_value()">nth_value()</a></td>
<td>返回在窗口框架的第n行求得的值</td>
</tr>
</tbody>
</table>
<h6 id="row_number"><strong>row_number()</strong></h6>
<p>目的：返回其分区内的当前行数，从1开始计数。</p>
<p>语法：
返回值:      bigint</p>
<h6 id="rank"><strong>rank()</strong></h6>
<p>目的：返回当前行的排名，包含间隔;即对等组中第一行的row_number。</p>
<p>语法：</p>
<p>返回值:      bigint</p>
<h6 id="dense_rank"><strong>dense_rank()</strong></h6>
<p>目的：返回当前行的排名，不包括间隔;这个功能有效地计数对等组。</p>
<p>语法：</p>
<p>返回值:      bigint</p>
<h6 id="percent_rank"><strong>percent_rank()</strong></h6>
<p>目的：返回当前行的相对排名，即(rank - 1) / (总的分区行数 - 1)。因此，该值的范围从0到1(包含在内)。</p>
<p>语法：</p>
<p>返回值:      double precision</p>
<h6 id="cume_dist"><strong>cume_dist()</strong></h6>
<p>目的：返回累积分布，也就是(当前行之前或对等的分区行数)/(总的分区行数)。取值范围为1/N 到 1。</p>
<p>语法：</p>
<p>返回值:      double precision</p>
<h6 id="ntile"><strong>ntile()</strong></h6>
<p>目的：返回一个从1到参数值的整数，并将分区划分为尽可能相等的值。</p>
<p>语法：</p>
<p>输入值:      integer
返回值:      integer</p>
<h6 id="lag"><strong>lag()</strong></h6>
<p>目的：返回分区中在当前行之前offset行的值；如果没有这样的行，则返回default(必须与value具有相同的类型)。 offset和default都是针对当前行求值的。如果省略，offset默认为1，default为NULL。</p>
<p>语法：</p>
<p>输入值:      anyelement[, integer[, anyelement]]
返回值:      anyelement</p>
<h6 id="lead"><strong>lead()</strong></h6>
<p>目的：返回分区中在当前行之后offset行的值；如果没有这样的行，则返回default(必须与value具有相同的类型)。 offset和default都是针对当前行求值的。如果省略，offset默认为1，default为NULL。</p>
<p>语法：</p>
<p>输入值:      anyelement[, integer[, anyelement]]
返回值:      anyelement</p>
<h6 id="first_value"><strong>first_value()</strong></h6>
<p>目的：返回在窗口框架的第一行求得的值。</p>
<p>语法：</p>
<p>输入值:      anyelement
返回值:      anyelement</p>
<h6 id="last_value"><strong>last_value()</strong></h6>
<p>目的：返回在窗口框架的最后一行求得的值。</p>
<p>语法：</p>
<p>输入值:      anyelement
返回值:      anyelement</p>
<h6 id="nth_value"><strong>nth_value()</strong></h6>
<p>目的：返回在窗口框架的第n行求得的值(从1开始计数);如果没有这样的行，则返回NULL。</p>
<p>语法：</p>
<p>输入值:      anyelement,integer
返回值:      anyelement</p>
<h6 id="_248"><strong>示例</strong></h6>
<p>首先，创建表，及填充数据：</p>
<div class="highlight"><pre><span></span><code>create table empsalary(depname varchar(20), empno int, salary decimal(10,2));

insert into empsalary values (&#39;develop&#39;,11,5200),(&#39;develop&#39;,7,4200),(&#39;develop&#39;,9,4500),(&#39;develop&#39;,8,6000),(&#39;develop&#39;,10,5200),(&#39;personnel&#39;,5,3500),(&#39;personnel&#39;,2,3900),(&#39;sales&#39;,1,5000),(&#39;sales&#39;,3,4800),(&#39;sales&#39;,4,4800);
</code></pre></div>
<p>示例1：</p>
<div class="highlight"><pre><span></span><code>select depname
     , empno
     , salary
     , row_number() OVER (PARTITION BY depname order by salary desc )
     , rank() OVER (PARTITION BY depname order by salary desc ) 
     , dense_rank() OVER (PARTITION BY depname order by salary desc )
     , ntile(2) OVER (PARTITION BY depname order by salary desc )
FROM empsalary;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>  depname  | empno | salary  | row_number | rank | dense_rank  | ntile 
---------------+---------+---------+----------------+--------+----------------+---------
 develop   |     8 | 6000.00 |          1 |    1 |          1 |     1
 develop   |    10 | 5200.00 |          2 |    2 |          2 |     1
 develop   |    11 | 5200.00 |          3 |    2 |          2 |     1
 develop   |     9 | 4500.00 |          4 |    4 |          3 |     2
 develop   |     7 | 4200.00 |          5 |    5 |          4 |     2
 personnel  |     2 | 3900.00 |          1 |    1 |          1 |     1
 personnel  |     5 | 3500.00 |          2 |    2 |          2 |     2
 sales      |     1 | 5000.00 |          1 |    1 |          1 |     1
 sales      |     3 | 4800.00 |          2 |    2 |          2 |     1
 sales      |     4 | 4800.00 |          3 |    2 |          2 |     2
</code></pre></div>
<p>示例2：</p>
<div class="highlight"><pre><span></span><code>select depname
     , empno
     , salary
     , percent_rank() OVER (PARTITION BY depname order by salary desc )
     , cume_dist() OVER (PARTITION BY depname order by salary desc ) 
FROM empsalary;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> depname  | empno | salary  | percent_rank |     cume_dist     
---------------+--------+----------+----------------+-------------------------
 develop   |     8 | 6000.00 |          0 |              0.2
 develop   |    10 | 5200.00 |        0.25 |              0.6
 develop   |    11 | 5200.00 |        0.25 |              0.6
 develop   |     9 | 4500.00 |        0.75 |              0.8
 develop   |     7 | 4200.00 |          1 |                1
 personnel  |     2 | 3900.00 |          0 |              0.5
 personnel  |     5 | 3500.00 |          1 |                1
 sales      |     1 | 5000.00 |          0 | 0.333333333333333
 sales      |     3 | 4800.00 |         0.5 |                1
 sales      |     4 | 4800.00 |         0.5 |                1
</code></pre></div>
<p>示例3：</p>
<div class="highlight"><pre><span></span><code>select depname
     , empno
     , salary
     , lag(salary,1,0.0) OVER (PARTITION BY depname order by salary desc )
     , lead(salary,1,0.0) OVER (PARTITION BY depname order by salary desc ) 
FROM empsalary;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>  depname  | empno | salary  |   lag  |  lead   
---------------+---------+-----------+----------+---------
 develop   |     8 | 6000.00 |     0.0 | 5200.00
 develop   |    10 | 5200.00 | 6000.00 | 5200.00
 develop   |    11 | 5200.00 | 5200.00 | 4500.00
 develop   |     9 | 4500.00 | 5200.00 | 4200.00
 develop   |     7 | 4200.00 | 4500.00 |     0.0
 personnel  |     2 | 3900.00 |     0.0 | 3500.00
 personnel  |     5 | 3500.00 | 3900.00 |     0.0
 sales      |     1 | 5000.00 |     0.0 | 4800.00
 sales      |     3 | 4800.00 | 5000.00 | 4800.00
 sales      |     4 | 4800.00 | 4800.00 |     0.0
</code></pre></div>
<p>示例4：</p>
<div class="highlight"><pre><span></span><code>select depname
     , empno
     , salary
     , first_value(salary) OVER (PARTITION BY depname order by salary desc )
     , last_value(salary) OVER (PARTITION BY depname order by salary desc ) 
     , nth_value(salary,2) OVER (PARTITION BY depname order by salary desc ) 
FROM empsalary;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>  depname  | empno | salary  | first_value  | last_value  | nth_value 
---------------+---------+----------+----------------+----------------+-------------
 develop   |     8 | 6000.00 |     6000.00 |    6000.00 |          
 develop   |    10 | 5200.00 |     6000.00 |    5200.00 |   5200.00
 develop   |    11 | 5200.00 |     6000.00 |    5200.00 |   5200.00
 develop   |     9 | 4500.00 |     6000.00 |    4500.00 |   5200.00
 develop   |     7 | 4200.00 |     6000.00 |    4200.00 |   5200.00
 personnel  |     2 | 3900.00 |     3900.00 |    3900.00 |          
 personnel  |     5 | 3500.00 |     3900.00 |    3500.00 |   3500.00
 sales      |     1 | 5000.00 |     5000.00 |    5000.00 |          
 sales      |     3 | 4800.00 |     5000.00 |    4800.00 |   4800.00
 sales      |     4 | 4800.00 |     5000.00 |    4800.00 |   4800.00
</code></pre></div>
<h4 id="_249"><strong>聚集函数</strong></h4>
<p>聚集函数从一个输入值的集合计算出一个单一值。聚合函数分为如下四类：</p>
<h5 id="_250"><strong>通用聚集函数</strong></h5>
<p>此类中的聚合函数可以通过以下两种方式之一调用：</p>
<ul>
<li>“通常”在表中的所有行上，与GROUP BY连接，为行集返回单个值。
  在这种情况下，行排序通常无关紧要。例如，avg()具有此属性。有时，行排序确实很重要。例如，分组值的顺序通过array_agg()，确定数组索引和数组值之间的映射。</li>
<li>或者，作为带有OVER的窗口函数。
  在这种情况下，对窗口中的每一行计算聚合函数，排序总是很重要的。</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_array_agg()">array_agg()</a></td>
<td>返回一个数组，该数组的元素是聚合的各个值。更加详细的使用说明，请参见数据类型章节中数组函数的相关内容。</td>
</tr>
<tr>
<td><a href="#_avg()">avg()</a></td>
<td>计算所有非空输入值的平均值(算术平均值)。</td>
</tr>
<tr>
<td><a href="#_bit_and()">bit_and()</a></td>
<td>计算所有非空输入值的逐位AND。</td>
</tr>
<tr>
<td><a href="#_bit_or()">bit_or()</a></td>
<td>计算所有非空输入值的逐位OR。</td>
</tr>
<tr>
<td><a href="#_bool_and()">bool_and()</a></td>
<td>如果全部非空输入值都为真则返回真，否则返回假。</td>
</tr>
<tr>
<td><a href="#_bool_or()">bool_or()</a></td>
<td>如果任何非空输入值为真则返回真，否则返回假。</td>
</tr>
<tr>
<td><a href="#_count()">count()</a></td>
<td>计算集合中不为空的行的数量。</td>
</tr>
<tr>
<td><a href="#_every()">every()</a></td>
<td>等效bool_and()。</td>
</tr>
<tr>
<td><a href="#_jsonb_agg()">jsonb_agg()</a></td>
<td>收集所有输入值，包括空值，到一个JSON数组。更加详细的使用说明，请参见数据类型章节中json函数的相关内容。</td>
</tr>
<tr>
<td><a href="#_jsonb_object_agg()">jsonb_object_agg()</a></td>
<td>将所有键/值对收集到一个JSON对象中。关键参数强制转换为文本；值参数按照to_json或to_jsonb进行转换。 值可以为空，但键不能为空。更加详细的使用说明，请参见数据类型章节中json函数的相关内容。</td>
</tr>
<tr>
<td><a href="#_max()">max()</a></td>
<td>计算集合中值中的最大值。</td>
</tr>
<tr>
<td><a href="#_min()">min()</a></td>
<td>计算集合中值中的最小值。</td>
</tr>
<tr>
<td><a href="#_string_agg()">string_agg()</a></td>
<td>连接非空输入值到字符串中。第一个值之后的每个值前面都有相应的分隔符(delimiter)(如果它不为空)。</td>
</tr>
<tr>
<td><a href="#_sum()">sum()</a></td>
<td>计算非空输入值的总和。</td>
</tr>
</tbody>
</table>
<h6 id="avg-count-max-min-sum"><strong>avg() , count(), max(), min(), sum()</strong></h6>
<h6 id="avg"># avg()</h6>
<p>目的：计算所有非空输入值的平均值(算术平均值)。</p>
<p>语法：</p>
<p>输入值:      smallint, int, bigint, numeric, real, double precision, interval
返回值:      numeric, double precision, interval</p>
<p>输入和返回数据类型的列表给出了不同的类型。简言之，输入可以是平均值概念有意义的任何数据类型，包括值为整数的数据类型。例如，整数3和4的平均值是3.5，所以返回数据类型永远不会是其值被约束为整数的类型。以下是具体的映射：</p>
<table>
<thead>
<tr>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>smallint</td>
<td>numeric</td>
</tr>
<tr>
<td>int</td>
<td>numeric</td>
</tr>
<tr>
<td>bigint</td>
<td>numeric</td>
</tr>
<tr>
<td>numeric</td>
<td>numeric</td>
</tr>
<tr>
<td>real</td>
<td>double precision</td>
</tr>
<tr>
<td>double precision</td>
<td>double precision</td>
</tr>
<tr>
<td>interval</td>
<td>interval</td>
</tr>
</tbody>
</table>
<h6 id="count"># count()</h6>
<p>目的：计算集合中不为空的行的数量。</p>
<p>语法：</p>
<p>输入值:       "any"
返回值:      bigint</p>
<h6 id="max"># max()</h6>
<p>目的：计算集合中值中的最大值。</p>
<p>语法：</p>
<p>输入值:       smallint, int, bigint, numeric, real, double precision, money,
                character, varchar, text,
                 date, abstime, time with time zone, time without time zone,
                 timestamp with time zone, timestamp without time zone, tid,
                 interval, oid, inet, anyenum, anyarray</p>
<p>返回值:      除了输入是 "varchar"之外，返回值数据类型同输入值的数据类型 
                当输入是 "varchar",返回 "text" </p>
<h6 id="min"># min()</h6>
<p>目的：计算集合中值中的最小值。</p>
<p>语法：</p>
<p>输入值:      smallint, int, bigint, numeric, real, double precision, money,
             character, varchar, text,
             date, abstime, time with time zone, time without time zone,
             timestamp with time zone, timestamp without time zone, tid,
             interval, oid, inet, anyenum, anyarray</p>
<p>返回值:     除了输入是 "varchar"之外，返回值数据类型同输入值的数据类型 
当输入是 "varchar",返回 "text" </p>
<h6 id="sum"># sum()</h6>
<p>目的：计算非空输入值的总和。</p>
<p>语法：</p>
<p>输入值:      smallint, int, bigint, numeric, real, double precision, money, interval</p>
<p>返回值:      bigint, numeric, double precision, real, money, interval</p>
<p>输入和返回数据类型的列表给出了不同的类型。简言之，输入可以是求和概念有意义的任何数据类型。以下是具体的映射：</p>
<table>
<thead>
<tr>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>smallint</td>
<td>bigint</td>
</tr>
<tr>
<td>int</td>
<td>bigint</td>
</tr>
<tr>
<td>bigint</td>
<td>numeric</td>
</tr>
<tr>
<td>numeric</td>
<td>numeric</td>
</tr>
<tr>
<td>real</td>
<td>real</td>
</tr>
<tr>
<td>double precision</td>
<td>double precision</td>
</tr>
<tr>
<td>money</td>
<td>money</td>
</tr>
<tr>
<td>interval</td>
<td>interval</td>
</tr>
</tbody>
</table>
<h6 id="_251"># 示例</h6>
<p>首先，创建表，及填充数据：</p>
<div class="highlight"><pre><span></span><code>drop table if exists t cascade;
create table t(
  k      int      primary key,
  class   int      not null,
  n      numeric,
  t      text     not null);

insert into t(k, class, n, t)
select
  (1 + s.v),
  case (s.v) &lt; 5
    when true then 1
              else 2
  end,
  case (s.v) &lt;&gt; 4
    when true then (100.0 + s.v)::numeric
              else null
  end,
  chr(97 + s.v)
from generate_series(0, 9) as s(v);
</code></pre></div>
<h6 id="group-by">## <em>GROUP BY 语法</em></h6>
<div class="highlight"><pre><span></span><code>select
  class,
  to_char(avg(n), &#39;990.99&#39;)          as &quot;avg(n)&quot;,
  count(n)                       as &quot;count(n)&quot;,
  min(n)                        as &quot;min(n)&quot;,
  max(n)                        as &quot;max(n)&quot;,
  sum(n)                        as &quot;sum(n)&quot;,
  count((chr(n::int)||t)::text)         as &quot;count(expr)&quot;,
  min(t)                         as &quot;min(t)&quot;,
  max(t)                         as &quot;max(t)&quot;
from t
group by class
order by class;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> class | avg(n) | count(n) | min(n) | max(n) | sum(n) | count(expr) | min(t) | max(t) 
-------+----------+----------+--------+--------+---------+---------------+--------+--------
    1 | 101.50 |      4 |   100 |   103 |   406 |         4 | a     | e
    2 | 107.00 |      5 |   105 |   109 |   535 |         5 | f     | j
</code></pre></div>
<h6 id="over">## <em>OVER 语法</em></h6>
<div class="highlight"><pre><span></span><code>select
  class,
  n,
  to_char(avg(n) filter (where n not in (102, 107)) over w, &#39;990.99&#39;)     as &quot;avg(n)&quot;,
  count(n)      filter (where n not in (102, 107)) over w             as &quot;count(n)&quot;,
  min(n)       filter (where n not in (102, 107)) over w             as &quot;min(n)&quot;,
  max(n)       filter (where n not in (102, 107)) over w             as &quot;max(n)&quot;,
  sum(n)       filter (where n not in (102, 107)) over w             as &quot;sum(n)&quot;,

  t,
  count((chr(n::int)||t)::text) over w                as &quot;count(expr)&quot;,
  min(t) over w                                as &quot;min(t)&quot;,
  max(t) over w                                as &quot;max(t)&quot;
from t
window w as (partition by class order by n range between unbounded preceding and current row)
order by class;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>class |   n  | avg(n) | count(n) | min(n) | max(n) | sum(n) | t | count(expr) | min(t) | max(t) 
-------+-------+---------+----------+--------+---------+---------+---+-------------+--------+--------
1 |    100 |  100.00 |      1 |   100 |   100 |   100 | a |         1 | a    | a
1 |    101 |  100.50 |      2 |   100 |   101 |   201 | b |         2 | a    | b
1 |    102 |  100.50 |      2 |   100 |   101 |   201 | c |         3 | a    | c
1 |    103 |  101.33 |      3 |   100 |   103 |   304 | d |         4 | a    | d
1 |  &lt;null&gt; |  101.33 |      3 |   100 |   103 |   304 | e |         4 | a    | e
2 |    105 |  105.00 |      1 |   105 |   105 |   105 | f |         1 | f     | f
2 |    106 |  105.50 |      2 |   105 |   106 |   211 | g |         2 | f     | g
2 |    107 |  105.50 |      2 |   105 |   106 |   211 | h |         3 | f     | h
2 |    108 |  106.33 |      3 |   105 |   108 |   319 | i |         4 | f     | i
2 |    109 |  107.00 |      4 |   105 |   109 |   428 | j |         5 | f     | j
</code></pre></div>
<h6 id="bit_and-bit_or-bool_and-bool_or-every"><strong>bit_and(), bit_or(), bool_and(), bool_or(), every()</strong></h6>
<h6 id="bit_and"># bit_and()</h6>
<p>目的：计算所有非空输入值的逐位AND。</p>
<p>语法：</p>
<p>输入值:       bit, smallint, int, bigint
返回值:       bit, smallint, int, bigint</p>
<table>
<thead>
<tr>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>bit</td>
<td>bit</td>
</tr>
<tr>
<td>smallint</td>
<td>smallint</td>
</tr>
<tr>
<td>int</td>
<td>int</td>
</tr>
<tr>
<td>bigint</td>
<td>bigint</td>
</tr>
</tbody>
</table>
<h6 id="bit_or"># bit_or()</h6>
<p>目的：计算所有非空输入值的逐位OR。</p>
<p>语法：</p>
<p>输入值:       bit, smallint, int, bigint
返回值:       bit, smallint, int, bigint</p>
<table>
<thead>
<tr>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>bit</td>
<td>bit</td>
</tr>
<tr>
<td>smallint</td>
<td>smallint</td>
</tr>
<tr>
<td>int</td>
<td>int</td>
</tr>
<tr>
<td>bigint</td>
<td>bigint</td>
</tr>
</tbody>
</table>
<h6 id="bool_and"># bool_and()</h6>
<p>目的：如果全部非空输入值都为真则返回真，否则返回假。</p>
<p>语法：</p>
<p>输入值:      boolean
返回值:      boolean</p>
<h6 id="bool_or"># bool_or()</h6>
<p>目的：如果任何非空输入值为真则返回真，否则返回假。</p>
<p>语法：</p>
<p>输入值:      boolean
返回值:      boolean</p>
<h6 id="every"># every()</h6>
<p>目的：等效bool_and()。</p>
<h6 id="_252"># 示例</h6>
<p>首先，创建表，及填充数据：</p>
<div class="highlight"><pre><span></span><code>drop table if exists t cascade;
create table t(
  k     int    primary key,
  class int    not null,
  b1    bit(8),
  b2    boolean);

insert into t(k, class, b1, b2) values
  (1, 1, &#39;00000001&#39;, true),
  (2, 1, &#39;00000010&#39;, true),
  (3, 1, &#39;00000100&#39;, null),
  (4, 1, &#39;00001000&#39;, false),
  (5, 2, &#39;10011000&#39;, true),
  (6, 2, &#39;10100100&#39;, true),
  (7, 2, null,       true),
  (8, 2, &#39;10000001&#39;, true);
</code></pre></div>
<h6 id="group-by_1">## <em>GROUP BY 语法</em></h6>
<div class="highlight"><pre><span></span><code>select
  class,
  bit_and(b1)::text  as &quot;bit_and(b1)&quot;,
  bit_or(b1)::text   as &quot;bit_or(b1)&quot;,
  bool_and(b2)::text as &quot;bool_and(b2)&quot;,
  bool_or(b2)::text  as &quot;bool_or(b2)&quot;
from t
group by class
order by class;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> class | bit_and(b1) | bit_or(b1) | bool_and(b2) | bool_or(b2) 
-------+---------------+-------------+----------------+---------------
    1 | 00000000  | 00001111 | false        | true
    2 | 10000000  | 10111101 | true         | true
</code></pre></div>
<h6 id="over_1">## <em>OVER 语法</em></h6>
<div class="highlight"><pre><span></span><code>select
  k,
  class,
  (bit_and(b1)  over w)::text as &quot;bit_and(b1)&quot;,
  (bit_or(b1)   over w)::text as &quot;bit_or(b1)&quot;,
  (bool_and(b2) over w)::text as &quot;bool_and(b2)&quot;,
  (bool_or(b2)  over w)::text as &quot;bool_or(b2)&quot;
from t
window w as (
  partition by class
  order by k
  range between unbounded preceding and current row)
order by k, class;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> k | class | bit_and(b1)  | bit_or(b1) | bool_and(b2) | bool_or(b2)
---+-------+---------------+--------------+----------------+-------------
 1 |    1 | 00000001  | 00000001  | true        | true
 2 |    1 | 00000000  | 00000011  | true        | true
 3 |    1 | 00000000  | 00000111  | true        | true
 4 |    1 | 00000000  | 00001111  | false       | true
 5 |    2 | 10011000  | 10011000  | true        | true
 6 |    2 | 10000000  | 10111100  | true        | true
 7 |    2 | 10000000  | 10111100  | true        | true
 8 |    2 | 10000000  | 10111101  | true        | true
</code></pre></div>
<h6 id="array_agg-string_agg-jsonb_agg-jsonb_object_agg"><strong>array_agg(), string_agg(), jsonb_agg(), jsonb_object_agg()</strong></h6>
<h6 id="array_agg_3"># array_agg()</h6>
<p>目的：返回一个数组，该数组的元素是聚合的各个值。更加详细的使用说明，请参见数据类型章节中数组函数的相关内容。</p>
<h6 id="jsonb_agg_1"># jsonb_agg()</h6>
<p>目的：收集所有输入值，包括空值，到一个JSON数组。更加详细的使用说明，请参见数据类型章节中json函数的相关内容。</p>
<h6 id="jsonb_object_agg_1">#  jsonb_object_agg()</h6>
<p>目的：将所有键/值对收集到一个JSON对象中。关键参数强制转换为文本；值参数按照to_json或to_jsonb进行转换。 值可以为空，但键不能为空。更加详细的使用说明，请参见数据类型章节中json函数的相关内容。</p>
<h6 id="string_agg"># string_agg()</h6>
<p>目的：连接非空输入值到字符串中。第一个值之后的每个值前面都有相应的分隔符(delimiter)(如果它不为空)。</p>
<p>语法：</p>
<p>输入值:      text, text
返回值:      text</p>
<p>或者：</p>
<p>输入值:      bytea, bytea
返回值:      bytea</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>drop table if exists t cascade;
create table t(k int primary key, vt text not null, vb bytea not null);
insert into t(k, vt, vb) values
  (1, &#39;m&#39;, &#39;m&#39;::bytea),
  (2, &#39;o&#39;, &#39;o&#39;::bytea),
  (3, &#39;u&#39;, &#39;u&#39;::bytea),
  (4, &#39;s&#39;, &#39;s&#39;::bytea),
  (5, &#39;e&#39;, &#39;e&#39;::bytea);
</code></pre></div>
<div class="highlight"><pre><span></span><code>with a as (
  select
    string_agg(vt, null       order by k) as text_agg,
    string_agg(vb, &#39;.&#39;::bytea order by k) as bytea_agg
  from t)
select
  text_agg,
  bytea_agg,
  convert_from(bytea_agg, &#39;utf-8&#39;) as bytea_agg_text
from a;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> text_agg |      bytea_agg     | bytea_agg_text 
------------+----------------------------+----------------
 mouse  | \x6d2e6f2e752e732e65 | m.o.u.s.e
</code></pre></div>
<h6 id="_253"># 示例</h6>
<p>首先，创建表，及填充数据：</p>
<div class="highlight"><pre><span></span><code>drop table if exists t cascade;
create table t(
  k      int   primary key,
  class   int   not null,
  v      text  not null);

insert into t(k, class, v)
select
  (1 + s.v),
  case (s.v) &lt; 3
    when true then 1
              else 2
  end,
  chr(97 + s.v)
from generate_series(0, 5) as s(v);
</code></pre></div>
<h6 id="group-by_2">## <em>GROUP BY 语法</em></h6>
<div class="highlight"><pre><span></span><code>select
  class,
  array_agg(v         order by k desc) filter (where v &lt;&gt; &#39;b&#39;) as &quot;array_agg(v)&quot;,
  string_agg(v, &#39; ~ &#39;     order by k desc) filter (where v &lt;&gt; &#39;e&#39;) as &quot;string_agg(v)&quot;,
  jsonb_agg(v         order by v desc) filter (where v &lt;&gt; &#39;b&#39;) as &quot;jsonb_agg&quot;,
  jsonb_object_agg(v, k order by v desc) filter (where v &lt;&gt; &#39;e&#39;) as &quot;jsonb_object_agg(v, k)&quot;
from t
group by class
order by class;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> class | array_agg(v) | string_agg(v) |    jsonb_agg   |  jsonb_object_agg(v, k)  
-------+-----------------+-----------------+--------------------+--------------------------------
    1 | {c,a}       | c ~ b ~ a     | [&quot;c&quot;, &quot;a&quot;]      | {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}
    2 | {f,e,d}      | f ~ d        | [&quot;f&quot;, &quot;e&quot;, &quot;d&quot;]  | {&quot;d&quot;: 4, &quot;f&quot;: 6}
</code></pre></div>
<h6 id="over_2">## <em>OVER 语法</em></h6>
<div class="highlight"><pre><span></span><code>select
  class,
  (array_agg(v)          filter (where v &lt;&gt; &#39;b&#39;)   over w) as &quot;array_agg(v)&quot;,
  (string_agg(v, &#39; ~ &#39;)      filter (where v &lt;&gt; &#39;b&#39;)   over w) as &quot;string_agg(v)&quot;,
  (jsonb_agg(v)          filter (where v &lt;&gt; &#39;b&#39;)   over w) as &quot;string_agg(v)&quot;,
  (jsonb_object_agg(v, k)  filter (where v &lt;&gt; &#39;e&#39;) over w) as &quot;jsonb_object_agg(v, k)&quot;
from t
window w as (
  partition by class
  order by k desc
  range between unbounded preceding and current row)
order by 1;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> class | array_agg(v) | string_agg(v) |  string_agg(v)  |  jsonb_object_agg(v, k)  
-------+----------------+-----------------+---------------------+------------------------------
     1 | {c}       | c          | [&quot;c&quot;]           | {&quot;c&quot;: 3}
     1 | {c}       | c          | [&quot;c&quot;]           | {&quot;b&quot;: 2, &quot;c&quot;: 3}
     1 | {c,a}      | c ~ a       | [&quot;c&quot;, &quot;a&quot;]      | {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}
     2 | {f}        | f          | [&quot;f&quot;]          | {&quot;f&quot;: 6}
     2 | {f,e}      | f ~ e        | [&quot;f&quot;, &quot;e&quot;]      | {&quot;f&quot;: 6}
     2 | {f,e,d}     | f ~ e ~ d    | [&quot;f&quot;, &quot;e&quot;, &quot;d&quot;]   | {&quot;d&quot;: 4, &quot;f&quot;: 6}
</code></pre></div>
<h5 id="_254"><strong>统计性聚集函数</strong></h5>
<p>此类中的聚合函数可以通过以下两种方式之一调用：</p>
<ul>
<li>“通常”在表中的所有行上，与GROUP BY连接，为行集返回单个值，在这种情况下，行排序通常无关紧要。</li>
<li>或者，作为带有OVER的窗口函数。
  在这种情况下，对窗口中的每一行计算聚合函数，排序总是很重要的。</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_covar_pop()">covar_pop()</a></td>
<td>计算总体协方差。</td>
</tr>
<tr>
<td><a href="#_covar_samp()">covar_samp()</a></td>
<td>计算样本协方差。</td>
</tr>
<tr>
<td><a href="#_corr()">corr()</a></td>
<td>计算相关系数。</td>
</tr>
<tr>
<td><a href="#_regr_avgy()">regr_avgy()</a></td>
<td>返回两个参数都不为NULL的行的第一个参数的平均值。</td>
</tr>
<tr>
<td><a href="#_regr_avgx()">regr_avgx()</a></td>
<td>返回两个参数都不为NULL的行的第二个参数的平均值。</td>
</tr>
<tr>
<td><a href="#_regr_count()">regr_count()</a></td>
<td>返回两个参数均为NOT NULL的行数。</td>
</tr>
<tr>
<td><a href="#_regr_slope()">regr_slope()</a></td>
<td>根据"(y, x)"对，按照最小二乘法拟合成线性方程，然后返回该直线的斜率。</td>
</tr>
<tr>
<td><a href="#_regr_intercept()">regr_intercept()</a></td>
<td>根据"(y, x)"对，按照最小二乘法拟合成线性方程，然后返回该直线的Y-截距。</td>
</tr>
<tr>
<td><a href="#_regr_r2()">regr_r2()</a></td>
<td>返回相关系数corr()的平方。</td>
</tr>
<tr>
<td><a href="#_regr_syy()">regr_syy()</a></td>
<td>对于NOT NULL对，返回 regr_count(y, x)*var_pop(y) 。</td>
</tr>
<tr>
<td><a href="#_regr_sxx()">regr_sxx()</a></td>
<td>对于NOT NULL对，返回 regr_count(y, x)*var_pop(x) 。</td>
</tr>
<tr>
<td><a href="#_regr_sxy()">regr_sxy()</a></td>
<td>对于NOT NULL对，返回 regr_count(y, x)*covar_pop(y, x) 。</td>
</tr>
<tr>
<td><a href="#_var_samp()">variance()</a></td>
<td>var_samp 的别名，请参考var_samp()。</td>
</tr>
<tr>
<td><a href="#_var_pop">var_pop()</a></td>
<td>总体方差(总体标准差的平方)。</td>
</tr>
<tr>
<td><a href="#_var_samp()">var_samp()</a></td>
<td>样本方差(样本标准差的平方)。</td>
</tr>
<tr>
<td><a href="#_stddev_samp()">stddev()</a></td>
<td>stddev_samp的别名，请参考stddev_samp()</td>
</tr>
<tr>
<td><a href="#_stddev_pop()">stddev_pop()</a></td>
<td>总体标准差。</td>
</tr>
<tr>
<td><a href="#_stddev_samp()">stddev_samp()</a></td>
<td>样本标准差。</td>
</tr>
</tbody>
</table>
<h6 id="covar_pop-covar_samp-corr"><strong>covar_pop(), covar_samp(), corr()</strong></h6>
<h6 id="covar_pop"># covar_pop()</h6>
<p>目的：计算总体协方差。</p>
<p>语法：</p>
<p>输入值:      double precision, double precision 
返回值:      double precision</p>
<h6 id="covar_samp"># covar_samp()</h6>
<p>目的：计算样本协方差。</p>
<p>语法：</p>
<p>输入值:      double precision, double precision 
返回值:      double precision</p>
<h6 id="corr"># corr()</h6>
<p>目的：计算相关系数。这测量了“y”值与“x”值线性相关的程度。返回值为1.0表示完全相关。</p>
<p>语法：</p>
<p>输入值:      double precision, double precision 
返回值:      double precision</p>
<h6 id="_255"># 示例</h6>
<p>首先，创建表，及填充数据：</p>
<div class="highlight"><pre><span></span><code>CREATE EXTENSION tablefunc;

drop table if exists t cascade;

create table t(
  k      int primary key,
  x      double precision,
  y      double precision,
  delta  double precision);

with
 a1 as (
      select
        s.v        as k,
        s.v        as x,
        (s.v * 5.0) + 3.0 as y
      from generate_series(1, 100) as s(v)),
    a2 as (
      select (
        row_number() over()) as k,
        r.v as delta
      from normal_rand(100, 0.0, 20.0) as r(v))

  insert into t(k, x, y, delta)
  select
    k, x, a1.y, a2.delta
  from a1 inner join a2 using(k);

  insert into t(k, x, y, delta) values
    (101,    0, null, null),
    (102, null,    0, null);

select covar_pop(y+delta, x)
, covar_samp(y+delta, x)
, corr(y+delta, x)
 from t;
</code></pre></div>
<p>返回信息类似如下：</p>
<div class="highlight"><pre><span></span><code>    covar_pop     |   covar_samp  |       corr        
------------------------+-----------------------+-------------------------
 4165.26087127957 | 4207.3342134137 | 0.987742370564295
</code></pre></div>
<h6 id="regr_"><strong>regr_%()</strong></h6>
<p>本节介绍了用于线性回归分析的如下聚合函数： 
regr_avgy(), regr_avgx(), regr_count(), regr_slope(), regr_intercept(), regr_r2(), regr_syy(), regr_sxx(), regr_sxy()。</p>
<h6 id="regr_avgy"># regr_avgy()</h6>
<p>目的：返回两个参数都不为NULL的行的第一个参数的平均值,sum(Y)/N</p>
<h6 id="regr_avgx"># regr_avgx()</h6>
<p>目的：返回两个参数都不为NULL的行的第二个参数的平均值,sum(X)/N</p>
<p>语法：</p>
<p>输入值:      double precision, double precision 
返回值:      double precision</p>
<h6 id="regr_count"># regr_count()</h6>
<p>目的：返回两个参数均为NOT NULL的行数。</p>
<p>语法：</p>
<p>输入值:      double precision, double precision 
返回值:      bigint</p>
<h6 id="regr_slope"># regr_slope()</h6>
<p>目的：根据"(y, x)"对，按照最小二乘法拟合成线性方程，然后返回该直线的斜率。</p>
<p>语法：</p>
<p>输入值:      double precision, double precision 
返回值:      double precision</p>
<h6 id="regr_intercept"># regr_intercept()</h6>
<p>目的：根据"(y, x)"对，按照最小二乘法拟合成线性方程，然后返回该直线的Y-截距。</p>
<p>语法：</p>
<p>输入值:      double precision, double precision 
返回值:      double precision</p>
<h6 id="regr_r2"># regr_r2()</h6>
<p>目的：返回相关系数corr()的平方。</p>
<p>语法：</p>
<p>输入值:      double precision, double precision 
返回值:      double precision</p>
<h6 id="regr_syy"># regr_syy()</h6>
<p>目的：对于NOT NULL对，返回 regr_count(y, x)*var_pop(y) 。</p>
<p>语法：</p>
<p>输入值:      double precision, double precision 
返回值:      double precision</p>
<h6 id="regr_sxx"># regr_sxx()</h6>
<p>目的：对于NOT NULL对，返回 regr_count(y, x)*var_pop(x) 。</p>
<p>语法：</p>
<p>输入值:      double precision, double precision 
返回值:      double precision</p>
<h6 id="regr_sxy"># regr_sxy()</h6>
<p>目的：对于NOT NULL对，返回 regr_count(y, x)*covar_pop(y, x) 。</p>
<p>语法：</p>
<p>输入值:      double precision, double precision 
返回值:      double precision</p>
<h6 id="_256"># 示例</h6>
<p>首先，创建表，及填充数据：</p>
<div class="highlight"><pre><span></span><code>CREATE EXTENSION tablefunc;

drop table if exists t cascade;

create table t(
  k      int primary key,
  x      double precision,
  y      double precision,
  delta   double precision);

with
 a1 as (
      select
        s.v        as k,
        s.v        as x,
        (s.v * 5.0) + 3.0 as y
      from generate_series(1, 100) as s(v)),
    a2 as (
      select (
        row_number() over()) as k,
        r.v as delta
      from normal_rand(100, 0.0, 20.0) as r(v))

  insert into t(k, x, y, delta)
  select
    k, x, a1.y, a2.delta
  from a1 inner join a2 using(k);

  insert into t(k, x, y, delta) values
    (101,    0, null, null),
    (102, null,    0, null);

select regr_avgy(y, x),
     regr_avgx(y, x),
     regr_count(y, x)
 from t;
</code></pre></div>
<p>返回类似如下信息：</p>
<div class="highlight"><pre><span></span><code> regr_avgy | regr_avgx | regr_count 
-----------+------------+--------------
     255.5 |     50.5 |      100
</code></pre></div>
<div class="highlight"><pre><span></span><code>select regr_slope(y, x),
     regr_intercept(y, x)
 from t ;
</code></pre></div>
<p>返回类似如下信息：</p>
<div class="highlight"><pre><span></span><code> regr_slope | regr_intercept 
--------------+------------------
        5 |         3
</code></pre></div>
<div class="highlight"><pre><span></span><code>select regr_r2(y, x),
     corr(y, x)^2
 from t;
</code></pre></div>
<p>返回类似如下信息：</p>
<div class="highlight"><pre><span></span><code>       1 |        1
</code></pre></div>
<div class="highlight"><pre><span></span><code>select regr_syy(y, x),
     regr_count(y, x)*var_pop(y),
     regr_sxx(y, x),
     regr_count(y, x)*var_pop(x),
     regr_sxy(y, x),
     regr_count(y, x)*covar_pop(y, x)
 from t
where x is not null and y is not null;
</code></pre></div>
<p>返回类似如下信息：</p>
<div class="highlight"><pre><span></span><code> regr_syy | ?column? | regr_sxx | ?column? | regr_sxy | ?column? 
------------+------------+------------+------------+----------+------------
 2083125 |  2083125 |  83325 |   83325 |  416625 |  416625
</code></pre></div>
<h6 id="variance-var_pop-var_samp-stddev-stddev_pop-stddev_samp"><strong>variance(), var_pop(), var_samp(), stddev(), stddev_pop(), stddev_samp()</strong></h6>
<p>这些聚合函数中的每一个都使用相同的语法进行调用：</p>
<ul>
<li>使用简单语法，select aggregate_fun(expr) from t</li>
<li>或GROUP BY语法</li>
<li>或OVER语法</li>
</ul>
<p>这些聚合函数相同的语法如下：</p>
<p>输入值:      smallint, int, bigint, numeric, double precision, real
返回值:      numeric, double precision </p>
<table>
<thead>
<tr>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>smallint</td>
<td>numeric</td>
</tr>
<tr>
<td>int</td>
<td>numeric</td>
</tr>
<tr>
<td>bigint</td>
<td>numeric</td>
</tr>
<tr>
<td>numeric</td>
<td>numeric</td>
</tr>
<tr>
<td>double precision</td>
<td>double precision</td>
</tr>
<tr>
<td>real</td>
<td>double precision</td>
</tr>
</tbody>
</table>
<h6 id="variance"># variance()</h6>
<p>目的：var_samp 的别名，请参考var_samp()。</p>
<h6 id="var_pop"># var_pop</h6>
<p>目的：总体方差(总体标准差的平方)。</p>
<h6 id="var_samp"># var_samp()</h6>
<p>目的：样本方差(样本标准差的平方)。</p>
<h6 id="stddev"># stddev()</h6>
<p>目的：stddev_samp的别名，请参考stddev_samp()。</p>
<h6 id="stddev_pop"># stddev_pop()</h6>
<p>目的：总体标准差。</p>
<h6 id="stddev_samp"># stddev_samp()</h6>
<p>目的：样本标准差。</p>
<h6 id="_257"># 示例</h6>
<p>首先，创建表，及填充数据：</p>
<div class="highlight"><pre><span></span><code>drop table if exists t cascade;
create table t(
  k      int      primary key,
  class   int      not null,
  n      numeric,
  t      text     not null);

insert into t(k, class, n, t)
select
  (1 + s.v),
  case (s.v) &lt; 5
    when true then 1
              else 2
  end,
  case (s.v) &lt;&gt; 4
    when true then (100.0 + s.v)::numeric
              else null
  end,
  chr(97 + s.v)
from generate_series(0, 9) as s(v);
</code></pre></div>
<h6 id="group-by_3">## <em>GROUP BY 语法</em></h6>
<div class="highlight"><pre><span></span><code>select
  class,
  round(variance(n),2) as &quot;variance(n)&quot;,
 round(var_samp(n),2) as &quot;var_samp(n)&quot;,
 round(var_pop(n),2) as &quot;var_pop(n)&quot;, 
round(stddev(n),2) as &quot;stddev(n)&quot;, 
round(stddev_samp(n),2) as &quot;stddev_sampp(n)&quot;, 
round(stddev_pop(n),2) as &quot;stddev_pop(n)&quot;
from t
group by class
order by class;
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code> class | variance(n) | var_samp(n) | var_pop(n) | stddev(n) | stddev_sampp(n) | stddev_pop(n) 
-------+-------------+-----------------+---------------+-----------+---------------------+------------------
    1 |      1.67 |       1.67 |       1.25 |    1.29 |           1.29 |        1.12
    2 |      2.50 |       2.50 |       2.00 |    1.58 |           1.58 |        1.41
</code></pre></div>
<h6 id="over_3">## <em>OVER 语法</em></h6>
<div class="highlight"><pre><span></span><code>select
  class,
  n,
  round(variance(n) filter (where n not in (102, 107))  over w ,2)  as &quot;variance(n)&quot;,
  round(var_samp(n) filter (where n not in (102, 107)) over w ,2)  as &quot;var_samp(n)&quot;,
  round(var_pop(n) filter (where n not in (102, 107)) over w ,2) as &quot;var_pop(n)&quot;,
  round(stddev(n) filter (where n not in (102, 107)) over w ,2) as &quot;stddev(n)&quot;,
  round(stddev_samp(n) filter (where n not in (102, 107)) over w ,2) as &quot;stddev_sampp(n)&quot;,
  round(stddev_pop(n) filter (where n not in (102, 107)) over w ,2) as &quot;stddev_pop(n)&quot;,
  t
from t
window w as (partition by class order by n range between unbounded preceding and current row)
order by class;
</code></pre></div>
<p>返回如下信息：
 class |   n    | variance(n)  | var_samp(n) | var_pop(n) | stddev(n) | stddev_sampp(n) | stddev_pop(n) | t 
-------+------------+--------------+------------------+--------------+-----------+---------------------+-----------------+---
    1 |    100 |      <null> |      <null> |     0.00 |    <null> |        <null> |        0.00 | a
    1 |    101 |        0.50 |        0.50 |     0.25 |      0.71 |          0.71 |        0.50 | b
    1 |    102 |        0.50 |        0.50 |     0.25 |      0.71 |          0.71 |        0.50 | c
    1 |    103 |        2.33 |        2.33 |     1.56 |      1.53 |          1.53 |        1.25 | d
    1 |  <null> |        2.33 |        2.33 |     1.56 |      1.53 |          1.53 |        1.25 | e
    2 |    105 |      <null> |      <null> |     0.00 |    <null> |         <null> |        0.00 | f
    2 |    106 |        0.50 |        0.50 |     0.25 |      0.71 |          0.71 |        0.50 | g
    2 |    107 |        0.50 |        0.50 |     0.25 |      0.71 |          0.71 |        0.50 | h
    2 |    108 |        2.33 |        2.33 |     1.56 |      1.53 |          1.53 |        1.25 | i
    2 |    109 |        3.33 |        3.33 |     2.50 |      1.83 |          1.83 |        1.58 | j</p>
<h5 id="_258"><strong>组内有序集合聚合函数</strong></h5>
<p>这些函数有时被称为“逆分布”函数，只能使用专用的WITHIN GROUP (ORDER BY ...)语法调用它们，它们不能作为带有OVER的窗口函数调用。 </p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_mode()">mode()</a></td>
<td>返回“排序表达式”的最频繁值。如果有多个同样频繁的值，那么其中一个值将被选择。</td>
</tr>
<tr>
<td><a href="#_percentile_disc() ， percentile_cont()">percentile_disc()</a></td>
<td>离散变量。percentile_disc()的标量重载计算离散百分比，即聚合参数值的有序集合中的第一个值，该值在排序中的位置等于或超过指定的fraction。数组重载将计算多个离散百分位数。 结果是一个与fractions参数具有相同维数的数组，每个非空元素都被对应于该百分位的输入值替换。</td>
</tr>
<tr>
<td><a href="#_percentile_disc() ， percentile_cont()">percentile_cont()</a></td>
<td>连续变量。percentile_cont()的标量重载将计算连续的百分位数，该值对应于聚合参数值的有序集合中的指定分数(fraction)。数组重载将计算多个连续的百分位数。结果是一个与分数(fractions)参数具有相同维数的数组，每个非空元素都被对应于该百分位的(可能插值的)值所替换。</td>
</tr>
</tbody>
</table>
<p>它们具有相同的调用语法：</p>
<p>select
  grouping_column_1, grouping_column_1,...
  the_function(function-specific arg list) within group (order by ordering expression)
from t
group by grouping_column_1, grouping_column_1,...
order by grouping_column_1, grouping_column_1,...</p>
<h6 id="mode"># mode()</h6>
<p>目的：返回“排序表达式”的最频繁值。如果有多个同样频繁的值，那么其中一个值将被选择。</p>
<p>语法：</p>
<p>输入值:  <none>
         togther with "WITHIN GROUP" and "ORDER BY anyelement" invocation syntax
返回值:  anyelement</p>
<h6 id="group-by_4">## <em>无GROUP BY的示例</em></h6>
<div class="highlight"><pre><span></span><code>drop table if exists t cascade;
create table t(
  k     int   primary key,
  v1    text,
  v2    text);

insert into t(k, v1, v2) values
  (1, &#39;dog&#39;,   &#39;food&#39;),
  (2, &#39;cat&#39;,   &#39;flap&#39;),
  (3, null,    null),
  (4, &#39;zebra&#39;, &#39;stripe&#39;),
  (5, &#39;frog&#39;,  &#39;man&#39;),
  (6, &#39;fish&#39;,  &#39;soup&#39;),
  (7, &#39;ZEB&#39;,   &#39;RASTRIPE&#39;);
</code></pre></div>
<p>首先，通常使用count（*）来确定所选表达式产生的每个值的出现频率。</p>
<div class="highlight"><pre><span></span><code>\pset null &lt;null&gt;

select
  lower(v1||v2) as &quot;ordering expr&quot;,
  count(*) as n
from t
group by lower(v1||v2)
order by n desc, lower(v1||v2) asc nulls last;
</code></pre></div>
<p>接下来，获取最频繁的值：</p>
<div class="highlight"><pre><span></span><code>select
  mode() within group (order by lower(v1||v2))  
from t;
</code></pre></div>
<h6 id="group-by_5">## <em>使用GROUP BY的示例</em></h6>
<p>在如下示例中，该表有一个分组列，用于显示如何将WITHIN GROUP ORDER BY语法与GROUP BY子句一起使用。数据的设计，使得值“v=37”在“class=1”中出现两次，而值“v=42”在“class=2”中出现三次。其它的情况下，“v”的每个不同值只出现一次。</p>
<div class="highlight"><pre><span></span><code>drop table if exists t cascade;
create table t(
  k     int  primary key,
  class int  not null,
  v     int  not null);

insert into t(k, class, v)
select
  s.v,
  1,
  case s.v between 5 and 6
    when true then 37
              else s.v
  end
from generate_series(1, 10) as s(v)
union all
select
  s.v,
  2,
  case s.v between 15 and 17
    when true then 42
              else s.v
  end
from generate_series(11, 20) as s(v);
</code></pre></div>
<p>借助dense_rank()，来找出频率最高的：</p>
<div class="highlight"><pre><span></span><code>with
  a1 as (
    select class, v, count(*) as n
    from t
    group by class, v),

  a2 as (
    select
      class,
      n,
      v,
      dense_rank() over (partition by class order by n desc) as r
    from a1)

select class, n, v
from a2
where r = 1
order by class;

这里使用mode()来找出频率最高的：
select
  class,
  mode() within group (order by v)
from t
group by class
order by class;
</code></pre></div>
<p>上述均返回信息如下：</p>
<div class="highlight"><pre><span></span><code> class | n  | v  
-------+----+----
     1 | 2 | 37
     2 | 3 | 42
</code></pre></div>
<h6 id="percentile_disc-percentile_cont"># percentile_disc() ， percentile_cont()</h6>
<p>这两个聚合函数密切相关。简单地说，它们实现了percent_rank（）窗口函数实现的相反功能。因此，它们有时被称为“逆分布”函数。</p>
<p>语法：</p>
<p>重载一：
输入值:   double precision
          togther with "WITHIN GROUP" and "ORDER BY anyelement" invocation syntax
返回值:   anyelement</p>
<p>重载二：
输入值:   double precision[]
          togther with "WITHIN GROUP" and "ORDER BY anyelement" invocation syntax
返回值:   anyarray</p>
<h6 id="_259">## <em>使用标量重载的基本示例</em></h6>
<p>首先，创建表，及填充数据：</p>
<div class="highlight"><pre><span></span><code>drop table if exists t cascade;
create table t(v double precision primary key);

insert into t(v)
values (47), (53), (59), (61), (67), (71), (73), (83), (89), (97);
</code></pre></div>
<p>首先，先看一下percent_rank()产生的结果：</p>
<div class="highlight"><pre><span></span><code>with a as (
  select
    v,
    percent_rank() over (order by v) as pr
  from t)
select
  to_char(v,  &#39;90.99&#39;)              as v,
  to_char(pr, &#39;90.999999999999999&#39;) as pr
from a;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>   v   |         pr
----------+------------------------------
  47.00 |   0.00000000000000
  53.00 |   0.11111111111111
  59.00 |   0.22222222222222
  61.00 |   0.33333333333333
  67.00 |   0.44444444444444
  71.00 |   0.55555555555556
  73.00 |   0.66666666666667
  83.00 |   0.77777777777778
  89.00 |   0.88888888888889
  97.00 |   1.00000000000000
</code></pre></div>
<p>接下来，从上述结果中，选择“pr”列值0.66666666667，对应于“v”列中的值73.00。使用所选的“pr”值作为percentile_disc()和percentile_cont()的标量重载的输入。</p>
<div class="highlight"><pre><span></span><code>with a as (
  select
    percentile_disc(0.66666666666667) within group (order by v) as p_disc,
    percentile_cont(0.66666666666667) within group (order by v) as p_cont
  from t)
select
  to_char(a.p_disc, &#39;90.99&#39;) as pd,
  to_char(a.p_cont, &#39;90.99&#39;) as pc
from a;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>   pd  |   pc
----------+----------
  73.00 |  73.00
</code></pre></div>
<p>接下来，选择值0.61111111111112，它不存在于“pr”列中，值位于0.55555555555556和0.66666666666667之间，分别对应“v”列中的71.00和73.00。</p>
<div class="highlight"><pre><span></span><code>with a as (
  select
    percentile_disc(0.61111111111112) within group (order by v) as p_disc,
    percentile_cont(0.61111111111112) within group (order by v) as p_cont
  from t)
select
  to_char(a.p_disc, &#39;90.99&#39;) as pd,
  to_char(a.p_cont, &#39;90.99&#39;) as pc
from a;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>   pd   |   pc
-----------+-----------
  73.00  |  72.00
</code></pre></div>
<p>请注意，“pd”值73.00是第一个大于72.00的“v”值，并且“pc”值72.00已在71.00和73.00之间插值。</p>
<h6 id="group-by_6">## <em>使用GROUP BY的标量重载的基本示例</em></h6>
<p>首先，创建表，及填充数据：</p>
<div class="highlight"><pre><span></span><code>drop table if exists t2 cascade;
create table t2(
  class   int,
  v      double precision,
  constraint t_pk primary key(class, v));

insert into t2(class, v) values
  (1, 47), (1, 53), (1, 59), (1, 61), (1, 67),
  (2, 47), (2, 53), (2, 59), (2, 61), (2, 67), (2, 71);
</code></pre></div>
<p>首先，先看一下percent_rank()产生的结果：</p>
<div class="highlight"><pre><span></span><code>with a as (
  select
    class,
    v,
    percent_rank() over (partition by class order by v) as pr
  from t2)
select
                          class,
  to_char(v,  &#39;90.99&#39;) as v,
  to_char(pr, &#39;90.99&#39;) as pr
from a
order by class, v;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>   class |   v  |   pr
---------+----------+---------
     1 |  47.00 |   0.00
     1 |  53.00 |   0.25
     1 |  59.00 |   0.50
     1 |  61.00 |   0.75
     1 |  67.00 |   1.00
     2 |  47.00 |   0.00
     2 |  53.00 |   0.20
     2 |  59.00 |   0.40
     2 |  61.00 |   0.60
     2 |  67.00 |   0.80
     2 |  71.00 |   1.00
</code></pre></div>
<p>接下来，从“pr”列中选择值0.50。请注意，当“class=1”时，这对应于“v”列中的值59.00，当“class=2”时，它对应于“v”列中介于59.00和61.00之间的值。 
使用所选的“pr”值作为percentile_disc（）和percentile_cont（）的标量重载的输入。</p>
<div class="highlight"><pre><span></span><code>with a as (
  select
    class,
    percentile_disc(0.50) within group (order by v) as p_disc,
    percentile_cont(0.50) within group (order by v) as p_cont
  from t2
  group by class)
select
  to_char(a.p_disc, &#39;90.99&#39;) as pd,
  to_char(a.p_cont, &#39;90.99&#39;) as pc
from a;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>   pd   |   pc
------------+--------
  59.00  |  59.00
  59.00  |  60.00
</code></pre></div>
<p>在找到时，percentile_disc()返回精确的“v”值，在没有找到时，立即返回下一个更大的值。在找到时，percentile_cont()返回了精确的“v”值，并且在没有找到时，立即在较小值和较大值之间进行插值。</p>
<h6 id="_260">## <em>中值确定</em></h6>
<p>中值简单地定义为，当值按大小顺序排序时，将该集划分为两个大小相同的子集的值。松散地说，它是有序集中的“中间”值。较小一侧的值都小于或等于中值。较大一侧的值都大于或等于中值。边缘情况，例如，当集合具有偶数个唯一值时，通过对规则语句的细化来适应。
在描述数据时使用中值，而不是使用均值（由avg()聚合函数实现）带来的好处是，它不会因极小比例的极小值而产生太大的偏差。
某些SQL数据库系统具有内置的median()聚合函数。但是PostgreSQL，以及AiSQL并没有此函数。然而，根据定义，percentile_cont(0.5)返回中值。
例如：
首先，创建表，及填充数据：</p>
<div class="highlight"><pre><span></span><code>drop table if exists t cascade;

create table t(v double precision primary key);
insert into t(v)
select s.v from generate_series(11, 19) as s(v);
</code></pre></div>
<p>执行如下：</p>
<div class="highlight"><pre><span></span><code>with a as (
select
  avg(v)   as avg,
  percentile_cont(0.5) within group (order by v) as median
from t)
select
  (select count(*) from t) as &quot;count&quot;,
  to_char(a.avg,    &#39;90.99&#39;) as &quot;avg&quot;,
  to_char(a.median, &#39;90.99&#39;) as &quot;median&quot;,
  (select count(*) from t where v &lt;= a.median) as &quot;count l.e. median&quot;,
  (select count(*) from t where v &gt;= a.median) as &quot;count g.e. median&quot;
from a;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> count  |  avg   | median | count l.e. median | count g.e. median 
-------+------------+--------+---------------------+-------------------------
     9  |  15.00 |  15.00 |             5 |             5
</code></pre></div>
<p>注意，这里，存在奇数个唯一的输入值，并且中值在这些值之间。现在插入一个额外的唯一值，并重复上述过程： </p>
<div class="highlight"><pre><span></span><code>insert into t(v) values(20);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> count |  avg   | median | count l.e. median | count g.e. median
---------+----------+----------+---------------------+---------------------
    10 |  15.50 |  15.50 |              5 |            5
</code></pre></div>
<p>这里，存在偶数个唯一的输入值，并且中值不在这些值之间。相反，它位于两个现有值之间。</p>
<p>在前两个示例中，中值和平均值是相同的。但存在极端情况，由于单个值1000.00的倾斜效应，中值与平均值有很大差异。
继续执行，如下示例 </p>
<div class="highlight"><pre><span></span><code>drop table if exists t cascade;
create table t(k serial primary key, v double precision not null);
insert into t(v)
select 1 from generate_series(1, 3)
union all
select 2 from generate_series(1, 10)
union all
select 3 from generate_series(1, 5)
union all
select 1000;
</code></pre></div>
<p>再次执行如下：</p>
<div class="highlight"><pre><span></span><code>with a as (
select
  avg(v)   as avg,
  percentile_cont(0.5) within group (order by v) as median
from t)
select
  (select count(*) from t) as &quot;count&quot;,
  to_char(a.avg,    &#39;90.99&#39;) as &quot;avg&quot;,
  to_char(a.median, &#39;90.99&#39;) as &quot;median&quot;,
  (select count(*) from t where v &lt;= a.median) as &quot;count l.e. median&quot;,
  (select count(*) from t where v &gt;= a.median) as &quot;count g.e. median&quot;
from a;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> count |  avg   | median | count l.e. median | count g.e. median 
---------+----------+----------+---------------------+-----------------------
    19 |  54.63 |   2.00 |             13 |             16
</code></pre></div>
<h6 id="_261">## <em>使用数组重载的示例</em></h6>
<p>首先，创建表，及填充数据：</p>
<div class="highlight"><pre><span></span><code>drop table if exists t cascade;
create table t(v double precision primary key);

insert into t(v)
values (47), (53), (59), (61), (67), (71), (73), (83), (89), (97);
</code></pre></div>
<p>创建如下函数：</p>
<div class="highlight"><pre><span></span><code>create or replace function pr_vals()
  returns double precision[]
  language plpgsql
as $body$
declare
  a constant double precision[] := (
    with a as (
      select percent_rank() over (order by v) as v from t)
    select array_agg(v order by v) from a);
begin
  return a;
end;
$body$;

Then inner-join these three relations. These comments are key:

    Think of the original table &quot;t(v double precision)&quot; as an array &quot;v[]&quot;.
    Define the relation &quot;i, percent_rank(v[i])&quot;.
    Define the relation &quot;i, percentile_disc(percent_rank(v[i]))&quot;.
    Define the relation &quot;i, percentile_cont(percent_rank(v[i]))&quot;.
    Inner join them all using &quot;i&quot;.
</code></pre></div>
<p>在WITH子句中定义三个关系，它们对应于“pr”值，以及这些输入的percentile_disc()和percentile_cont()的输出，然后，内连接这三种关系：</p>
<ul>
<li>将原始表“t(v double precision)”做为数组“v[]”。</li>
<li>定义关系式“i，percent_rank(v[i])”。</li>
<li>定义关系“i, percentile_disc(percent_rank(v[i]))”。</li>
<li>定义关系“i, percentile_cont(percent_rank(v[i]))”。</li>
<li>使用“i”内连接它们。</li>
</ul>
<div class="highlight"><pre><span></span><code>with
  pr_vals as (
    select
      g.i,
      (pr_vals())[g.i] as v
    from generate_subscripts(pr_vals(), 1) as g(i)),

  pd_arr as (
    select
      percentile_disc(pr_vals()) within group (order by v) as v
    from t),
  pd_vals as (
    select
      g.i,
      (select v from pd_arr)[i] as v
    from generate_subscripts((select v from pd_arr), 1) as g(i)),

  pc_arr as (
    select
      percentile_cont(pr_vals()) within group (order by v) as v
    from t),
  pc_vals as (
    select
      g.i,
      (select v from pc_arr)[i] as v
    from generate_subscripts((select v from pc_arr), 1) as g(i))

select
  to_char(pr_vals.v, &#39;90.999999999999999&#39;)  as pr,
  to_char(pd_vals.v, &#39;90.99&#39;)               as &quot;pd(pr)&quot;,
  to_char(pc_vals.v, &#39;90.99&#39;)               as &quot;pc(pr)&quot;
from
  pr_vals
  inner join
  pd_vals using(i)
  inner join
  pc_vals using(i);
</code></pre></div>
<p>返回如下信息：</p>
<div class="highlight"><pre><span></span><code>         pr         | pd(pr) | pc(pr)
----------------------------+----------+--------
   0.00000000000000 |  47.00 |  47.00
   0.11111111111111 |  53.00 |  53.00
   0.22222222222222 |  59.00 |  59.00
   0.33333333333333 |  61.00 |  61.00
   0.44444444444444 |  67.00 |  67.00
   0.55555555555556 |  71.00 |  71.00
   0.66666666666667 |  73.00 |  73.00
   0.77777777777778 |  83.00 |  83.00
   0.88888888888889 |  89.00 |  89.00
   1.00000000000000 |  97.00 |  97.00
</code></pre></div>
<h4 id="_262"><strong>系统信息函数和运算符</strong></h4>
<h5 id="_263"><strong>会话信息函数</strong></h5>
<p>下表展示了多个可以抽取会话和系统信息的函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_current_catalog">current_catalog</a></td>
<td>返回当前数据库的名称。</td>
</tr>
<tr>
<td><a href="#_current_database()">current_database()</a></td>
<td>返回当前数据库的名称。</td>
</tr>
<tr>
<td><a href="#_current_query()">current_query()</a></td>
<td>返回当前所执行查询的文本，由客户端提交的(可能包含一个以上的语句)。</td>
</tr>
<tr>
<td><a href="#_current_role">current_role</a></td>
<td>等同于 current_user。</td>
</tr>
<tr>
<td><a href="#_current_schema[()]">current_schema[()]</a></td>
<td>返回在搜索路径中的第一个模式的名称(如果搜索路径为空则返回空值)</td>
</tr>
<tr>
<td><a href="#_current_schemas(boolean)">current_schemas()</a></td>
<td>返回当前在有效搜索路径中的所有模式的名称的数组，以优先级顺序。</td>
</tr>
<tr>
<td><a href="#_current_user">current_user</a></td>
<td>返回当前执行上下文的用户名。</td>
</tr>
<tr>
<td><a href="#_inet_client_addr()">inet_client_addr()</a></td>
<td>返回当前客户端的IP地址，如果当前连接是通过Unix-域套接字则返回NULL</td>
</tr>
<tr>
<td><a href="#_inet_client_port()">inet_client_port()</a></td>
<td>返回当前客户端的IP端口号，如果当前连接是通过Unix-域套接字则返回NULL。</td>
</tr>
<tr>
<td><a href="#_inet_server_addr()">inet_server_addr()</a></td>
<td>返回服务器接受当前连接的IP地址，如果当前连接是通过Unix-域套接字则返回NULL。</td>
</tr>
<tr>
<td><a href="#_inet_server_port()">inet_server_port()</a></td>
<td>返回服务器接受当前连接的IP端口号，如果当前连接是通过Unix-域套接字则返回NULL。</td>
</tr>
<tr>
<td><a href="#_pg_backend_pid()">pg_backend_pid()</a></td>
<td>返回附加到当前会话的服务器进程的进程ID。</td>
</tr>
<tr>
<td><a href="#_pg_blocking_pids(int)">pg_blocking_pids()</a></td>
<td>返回阻止服务器进程的会话的进程ID数组，该进程ID与指定的进程ID一起获取锁定，如果没有这样的服务器进程或者没有被阻塞，则返回一个空数组。</td>
</tr>
<tr>
<td><a href="#_pg_conf_load_time()">pg_conf_load_time()</a></td>
<td>返回服务器配置文件最后加载的时间。</td>
</tr>
<tr>
<td><a href="#_pg_current_logfile([text])">pg_current_logfile()</a></td>
<td>返回日志采集器当前使用的日志文件的路径名。</td>
</tr>
<tr>
<td><a href="#_pg_my_temp_schema()">pg_my_temp_schema()</a></td>
<td>返回当前会话的临时模式的OID，如果没有则返回0。</td>
</tr>
<tr>
<td><a href="#_pg_is_other_temp_schema(oid)">pg_is_other_temp_schema()</a></td>
<td>如果给定的OID是另一个会话的临时模式的OID则返回真。</td>
</tr>
<tr>
<td><a href="#_pg_jit_available()">pg_jit_available()</a></td>
<td>如果JIT编译器扩展可用，并且jit配置参数设置为on，则返回真。</td>
</tr>
<tr>
<td><a href="#_pg_listening_channels()">pg_listening_channels()</a></td>
<td>返回当前会话正在侦听的异步通知通道的名称集。</td>
</tr>
<tr>
<td><a href="#_pg_notification_queue_usage()">pg_notification_queue_usage()</a></td>
<td>返回当前被等待处理的通知所占用的异步通知队列最大尺寸的分数(0–1)。</td>
</tr>
<tr>
<td><a href="#_pg_postmaster_start_time()">pg_postmaster_start_time()</a></td>
<td>返回服务器启动时的时间。</td>
</tr>
<tr>
<td><a href="#_pg_safe_snapshot_blocking_pids(int)">pg_safe_snapshot_blocking_pids()</a></td>
<td>返回一个进程ID数组</td>
</tr>
<tr>
<td><a href="#_pg_trigger_depth()">pg_trigger_depth()</a></td>
<td>返回当前嵌套层次的触发器。</td>
</tr>
<tr>
<td><a href="#_session_user">session_user</a></td>
<td>返回会话用户名</td>
</tr>
<tr>
<td><a href="#_user">user</a></td>
<td>同current_user</td>
</tr>
<tr>
<td><a href="#_version()">version()</a></td>
<td>返回描述服务器版本的字符串。</td>
</tr>
</tbody>
</table>
<h6 id="current_catalog"><strong>current_catalog</strong></h6>
<p>目的：返回当前数据库的名称。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select current_catalog;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>postgres
</code></pre></div>
<h6 id="current_database"><strong>current_database()</strong></h6>
<p>目的：返回当前数据库的名称。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select current_database();
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>postgres
</code></pre></div>
<h6 id="current_query"><strong>current_query()</strong></h6>
<p>目的：返回当前所执行查询的文本，由客户端提交的(可能包含一个以上的语句)。</p>
<p>语法：</p>
<p>返回值:      text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select current_query();
</code></pre></div>
<p>返回信息类似如下：</p>
<div class="highlight"><pre><span></span><code>select current_query();
</code></pre></div>
<h6 id="current_role"><strong>current_role</strong></h6>
<p>目的：等同于 current_user。</p>
<h6 id="current_schema"><strong>current_schema[()]</strong></h6>
<p>目的：返回在搜索路径中的第一个模式的名称(如果搜索路径为空则返回空值)。</p>
<p>语法：</p>
<p>返回值:      name</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select current_schema ;
</code></pre></div>
<p>或者</p>
<div class="highlight"><pre><span></span><code>select current_schema() ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>public
</code></pre></div>
<h6 id="current_schemas"><strong>current_schemas()</strong></h6>
<p>目的：返回当前在有效搜索路径中的所有模式的名称的数组，以优先级顺序。</p>
<p>语法：</p>
<p>输入值:      boolean
返回值:      name[]</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select current_schemas(true);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>{pg_catalog,public}
</code></pre></div>
<h6 id="current_user"><strong>current_user</strong></h6>
<p>目的：返回当前执行上下文的用户名。</p>
<p>语法：</p>
<p>返回值:      name</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select current_user;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>tester
</code></pre></div>
<h6 id="inet_client_addr"><strong>inet_client_addr()</strong></h6>
<p>目的：返回当前客户端的IP地址，如果当前连接是通过Unix-域套接字则返回NULL</p>
<p>语法：</p>
<p>返回值:      inet</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet_client_addr();
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>127.0.0.1
</code></pre></div>
<h6 id="inet_client_port"><strong>inet_client_port()</strong></h6>
<p>目的：返回当前客户端的IP端口号，如果当前连接是通过Unix-域套接字则返回NULL。</p>
<p>语法：</p>
<p>返回值:      integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet_client_port(); 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>59122
</code></pre></div>
<h6 id="inet_server_addr"><strong>inet_server_addr()</strong></h6>
<p>目的：返回服务器接受当前连接的IP地址，如果当前连接是通过Unix-域套接字则返回NULL。</p>
<p>语法：</p>
<p>返回值:      inet</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet_server_addr(); 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>127.0.0.1
</code></pre></div>
<h6 id="inet_server_port"><strong>inet_server_port()</strong></h6>
<p>目的：返回服务器接受当前连接的IP端口号，如果当前连接是通过Unix-域套接字则返回NULL。</p>
<p>语法：</p>
<p>返回值:      integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select inet_client_port(); 
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>5433
</code></pre></div>
<h6 id="pg_backend_pid"><strong>pg_backend_pid()</strong></h6>
<p>目的：返回附加到当前会话的服务器进程的进程ID。</p>
<p>语法：</p>
<p>返回值:      integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_backend_pid();
</code></pre></div>
<p>返回信息类似如下：</p>
<div class="highlight"><pre><span></span><code>24472
</code></pre></div>
<h6 id="pg_blocking_pids"><strong>pg_blocking_pids()</strong></h6>
<p>目的：返回阻止服务器进程的会话的进程ID数组，该进程ID与指定的进程ID一起获取锁定，如果没有这样的服务器进程或者没有被阻塞，则返回一个空数组。</p>
<p>如果一个服务器进程持有一个与被阻塞进程的锁请求冲突的锁(硬阻塞)，或者正在等待一个与被阻塞进程的锁请求冲突并且在等待队列中位于其前面的锁(软阻塞)，那么这个服务器进程就会阻塞另一个服务器进程。 当使用并行查询时结果总是列出客户端可见的进程ID(即pg_backend_pid的结果)，即使实际的锁是由子工作进程持有或等待的。 因此，结果中可能存在重复的pid。还要注意当准备好的事务持有冲突锁时，它将用零进程ID表示。</p>
<p>语法：</p>
<p>输入值:      integer
返回值:      integer[]</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_blocking_pids();
</code></pre></div>
<p>返回信息类似如下：</p>
<div class="highlight"><pre><span></span><code>{}
</code></pre></div>
<h6 id="pg_conf_load_time"><strong>pg_conf_load_time()</strong></h6>
<p>目的：返回服务器配置文件最后加载的时间。如果当前会话当时是活跃的，那么这将是会话本身重新读取配置文件的时间(因此在不同的会话中读取会稍有不同)。 </p>
<p>返回值:      timestamp with time zone</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_conf_load_time();
</code></pre></div>
<p>返回信息类似如下：</p>
<div class="highlight"><pre><span></span><code>2023-09-07 09:38:45.394418+08
</code></pre></div>
<h6 id="pg_current_logfile"><strong>pg_current_logfile()</strong></h6>
<p>目的：返回日志采集器当前使用的日志文件的路径名。</p>
<p>语法：</p>
<p>输入值:      text
返回值:      text</p>
<p>或者：</p>
<p>返回值:      text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_current_logfile();
</code></pre></div>
<p>返回信息类似如下：</p>
<div class="highlight"><pre><span></span><code>~/tserver/logs/postgresql-2023-09-07_093845.log
</code></pre></div>
<h6 id="pg_my_temp_schema"><strong>pg_my_temp_schema()</strong></h6>
<p>目的：返回当前会话的临时模式的OID，如果没有则返回0。</p>
<p>语法：</p>
<p>返回值:      oid</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_my_temp_schema();
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>0
</code></pre></div>
<h6 id="pg_is_other_temp_schema"><strong>pg_is_other_temp_schema()</strong></h6>
<p>目的：如果给定的OID是另一个会话的临时模式的OID则返回真。</p>
<p>语法：</p>
<p>输入值:      oid
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_is_other_temp_schema(0);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>f
</code></pre></div>
<h6 id="pg_jit_available"><strong>pg_jit_available()</strong></h6>
<p>目的：如果JIT编译器扩展可用，并且jit配置参数设置为on，则返回真。</p>
<p>语法：</p>
<p>返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_jit_available();
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>f
</code></pre></div>
<h6 id="pg_listening_channels"><strong>pg_listening_channels()</strong></h6>
<p>目的：返回当前会话正在侦听的异步通知通道的名称集。</p>
<p>语法：</p>
<p>返回值:      SETOF text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_listening_channels();
</code></pre></div>
<h6 id="pg_notification_queue_usage"><strong>pg_notification_queue_usage()</strong></h6>
<p>目的：返回当前被等待处理的通知所占用的异步通知队列最大尺寸的分数(0–1)。</p>
<p>语法：</p>
<p>返回值:      double precision</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_notification_queue_usage();
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>0
</code></pre></div>
<h6 id="pg_postmaster_start_time"><strong>pg_postmaster_start_time()</strong></h6>
<p>目的：返回服务器启动时的时间。</p>
<p>语法：</p>
<p>返回值:      timestamp with time zone</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_postmaster_start_time();
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> 2023-09-07 09:38:45.448681+08
</code></pre></div>
<h6 id="pg_safe_snapshot_blocking_pids"><strong>pg_safe_snapshot_blocking_pids()</strong></h6>
<p>目的：返回一个进程ID数组，该进程ID是阻塞服务器进程获取安全快照的会话的进程ID数组，如果没有这样的服务器进程或者没有阻塞，则返回一个空数组。</p>
<p>运行SERIALIZABLE事务的会话会阻止SERIALIZABLE READ ONLY DEFERRABLE事务获取快照，直到后者确定可以安全地避免获取谓词锁。
语法：</p>
<p>输入值:      integer 
返回值:      integer[]</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_safe_snapshot_blocking_pids(0);
</code></pre></div>
<h6 id="pg_trigger_depth"><strong>pg_trigger_depth()</strong></h6>
<p>目的：返回当前嵌套层次的触发器。</p>
<p>语法：</p>
<p>返回值:      integer</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_trigger_depth();
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>0
</code></pre></div>
<h6 id="session_user"><strong>session_user</strong></h6>
<p>目的：返回会话用户名。</p>
<p>语法：</p>
<p>返回值:      name</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select session_user;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>tester
</code></pre></div>
<h6 id="user"><strong>user</strong></h6>
<p>目的：同current_user，请参考<a href="#_current_user">current_user</a></p>
<h6 id="version"><strong>version()</strong></h6>
<p>目的：返回描述服务器版本的字符串。</p>
<p>语法：</p>
<p>返回值:      text</p>
<p>例如：</p>
<p>select version();</p>
<h5 id="_264"><strong>访问权限查询函数</strong></h5>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_has_any_column_privilege(user, table, privilege)">has_any_column_privilege()</a></td>
<td>用户是否对表的列有权限。</td>
</tr>
<tr>
<td><a href="#_has_column_privilege()">has_column_privilege()</a></td>
<td>用户对指定的表列是否有权限。</td>
</tr>
<tr>
<td><a href="#_has_database_privilege()">has_database_privilege()</a></td>
<td>用户对数据库是否有权限。</td>
</tr>
<tr>
<td><a href="#_has_foreign_data_wrapper_privilege()">has_foreign_data_wrapper_privilege()</a></td>
<td>用户是否有外部数据包封装器的权限。</td>
</tr>
<tr>
<td><a href="#_has_function_privilege()">has_function_privilege()</a></td>
<td>用户是否对函数有权限。</td>
</tr>
<tr>
<td><a href="#_has_language_privilege()">has_language_privilege()</a></td>
<td>用户对语言是否有权限。</td>
</tr>
<tr>
<td><a href="#_has_schema_privilege()">has_schema_privilege()</a></td>
<td>用户是否对模式有权限。</td>
</tr>
<tr>
<td><a href="#_has_sequence_privilege()">has_sequence_privilege()</a></td>
<td>用户是否有序列权限。</td>
</tr>
<tr>
<td><a href="#_has_server_privilege()">has_server_privilege()</a></td>
<td>用户是否对外部服务器有权限。</td>
</tr>
<tr>
<td><a href="#_has_table_privilege()">has_table_privilege()</a></td>
<td>用户是否对表有权限。</td>
</tr>
<tr>
<td><a href="#_has_tablespace_privilege()">has_tablespace_privilege()</a></td>
<td>用户对表空间是否有权限。</td>
</tr>
<tr>
<td><a href="#_has_type_privilege()">has_type_privilege()</a></td>
<td>用户对数据类型是否有权限。</td>
</tr>
<tr>
<td><a href="#_pg_has_role()">pg_has_role()</a></td>
<td>用户对角色是否有权限。</td>
</tr>
<tr>
<td><a href="#_row_security_active(table)">row_security_active()</a></td>
<td>在当前用户和当前环境的上下文之中，指定表的行级安全是否是活动的</td>
</tr>
</tbody>
</table>
<h6 id="has_any_column_privilege"><strong>has_any_column_privilege()</strong></h6>
<p>目的：用户是否对表的列有权限。如果对整个表持有权限，或者对至少一个列有列级的权限授予，则会成功。允许的权限类型为SELECT, INSERT,UPDATE, 和 REFERENCES</p>
<p>语法：</p>
<p>输入值:      name, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      name, text, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, text, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      text, text
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select has_any_column_privilege(&#39;postgres&#39;, &#39;table_test&#39;, &#39;SELECT&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="has_column_privilege"><strong>has_column_privilege()</strong></h6>
<p>目的：用户对指定的表列是否有权限。如果对整个表持有权限，或者对列授予了列级别的权限，则会成功。可以通过名称或属性编号(pg_attribute.attnum)指定列。允许的权限类型为SELECT, INSERT,UPDATE, 和 REFERENCES。</p>
<p>语法：</p>
<p>输入值:      name, oid, smallint, text 
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      name, oid, text, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      name, text, smallint, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      name, text, text, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, oid, smallint, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, oid, text, text 
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, smallint, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, text, smallint, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, text, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, text, text, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      text, smallint, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      text, text, text
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select has_column_privilege(&#39;postgres&#39;, &#39;table_test&#39;, 1::smallint, &#39;SELECT&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="has_database_privilege"><strong>has_database_privilege()</strong></h6>
<p>目的：用户对数据库是否有权限。允许的权限类型为CREATE,CONNECT,TEMPORARY, 和TEMP (相当于TEMPORARY)。</p>
<p>语法：</p>
<p>输入值:      name, oid, text 
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      name, text, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, text, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      text, text 
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select has_database_privilege(&#39;postgres&#39;, &#39;test&#39;, &#39;CONNECT&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="has_foreign_data_wrapper_privilege"><strong>has_foreign_data_wrapper_privilege()</strong></h6>
<p>目的：用户是否有外部数据包封装器的权限。唯一允许的权限类型是USAGE。</p>
<p>语法：</p>
<p>输入值:      name, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      name, text, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, text
返回值:      boolean</p>
<p>输入值:      oid, text, text 
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      text, text
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select has_foreign_data_wrapper_privilege(&#39;postgres&#39;, &#39;postgres_fdw&#39;, &#39;USAGE&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="has_function_privilege"><strong>has_function_privilege()</strong></h6>
<p>目的：用户是否对函数有权限。唯一允许的权限类型是EXECUTE。</p>
<p>语法：</p>
<p>输入值:      name, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      name, text, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, text
返回值:      boolean</p>
<p>输入值:      oid, text, text 
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      text, text
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select has_function_privilege(&#39;postgres&#39;, &#39;add(int, int)&#39;, &#39;execute&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="has_language_privilege"><strong>has_language_privilege()</strong></h6>
<p>目的：用户对语言是否有权限。唯一允许的权限类型是USAGE。</p>
<p>语法：</p>
<p>输入值:      name, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      name, text, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, text
返回值:      boolean</p>
<p>输入值:      oid, text, text 
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      text, text
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select has_language_privilege(&#39;postgres&#39;, &#39;sql&#39;, &#39;USAGE&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="has_schema_privilege"><strong>has_schema_privilege()</strong></h6>
<p>目的：用户是否对模式有权限。允许的权限类型是CREATE 和USAGE。</p>
<p>语法：</p>
<p>输入值:      name, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      name, text, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, text
返回值:      boolean</p>
<p>输入值:      oid, text, text 
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      text, text
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select has_schema_privilege(&#39;postgres&#39;, &#39;p_c&#39;, &#39;USAGE&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="has_sequence_privilege"><strong>has_sequence_privilege()</strong></h6>
<p>目的：用户是否有序列权限。允许的权限类型有USAGE, SELECT, 和UPDATE。</p>
<p>语法：</p>
<p>输入值:      name, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      name, text, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, text
返回值:      boolean</p>
<p>输入值:      oid, text, text 
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      text, text
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select has_sequence_privilege(&#39;postgres&#39;, &#39;s_serial&#39;, &#39;SELECT&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="has_server_privilege"><strong>has_server_privilege()</strong></h6>
<p>目的：用户是否对外部服务器有权限。唯一允许的权限类型是USAGE。</p>
<p>语法：</p>
<p>输入值:      name, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      name, text, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, text
返回值:      boolean</p>
<p>输入值:      oid, text, text 
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      text, text
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select has_server_privilege(&#39;postgres&#39;, &#39;myserver&#39;, &#39;USAGE&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="has_table_privilege"><strong>has_table_privilege()</strong></h6>
<p>目的：用户是否对表有权限。允许的权限类型有SELECT, INSERT,UPDATE, DELETE,TRUNCATE, REFERENCES,和 TRIGGER。</p>
<p>语法：</p>
<p>输入值:      name, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      name, text, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, text
返回值:      boolean</p>
<p>输入值:      oid, text, text 
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      text, text
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select has_table_privilege(&#39;postgres&#39;, &#39;table_test&#39;, &#39;SELECT&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="has_tablespace_privilege"><strong>has_tablespace_privilege()</strong></h6>
<p>目的：用户对表空间是否有权限。唯一允许的权限类型是CREATE。</p>
<p>语法：</p>
<p>输入值:      name, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      name, text, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, text
返回值:      boolean</p>
<p>输入值:      oid, text, text 
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      text, text
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select has_tablespace_privilege (&#39;postgres&#39;, &#39;pg_global&#39;, &#39;CREATE&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="has_type_privilege"><strong>has_type_privilege()</strong></h6>
<p>目的： 用户对数据类型是否有权限。唯一允许的权限类型是 USAGE。</p>
<p>语法：</p>
<p>输入值:      name, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      name, text, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, text
返回值:      boolean</p>
<p>输入值:      oid, text, text 
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      text, text
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select has_type_privilege (&#39;postgres&#39;, &#39;int&#39;, &#39;USAGE&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="pg_has_role"><strong>pg_has_role()</strong></h6>
<p>目的：用户对角色是否有权限。允许的权限类型是MEMBER 和 USAGE。 MEMBER表示角色中的直接或间接成员关系(即执行SET ROLE的权利)，而USAGE表示不执行SET ROLE情况下是否立即可用角色的特权。此函数不允许特殊情况下将user设置为public，因为PUBLIC伪角色永远不能成为真实角色的成员。</p>
<p>语法：</p>
<p>输入值:      name, name, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      name, oid, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      name, text
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, name, text
返回值:      boolean</p>
<p>输入值:      oid, oid, text 
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      oid, text
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_has_role(&#39;postgres&#39;, &#39;tester&#39;, &#39;USAGE&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="row_security_active"><strong>row_security_active()</strong></h6>
<p>目的：在当前用户和当前环境的上下文之中，指定表的行级安全是否是活动的。</p>
<p>语法：</p>
<p>输入值:      oid
返回值:      boolean</p>
<p>或者</p>
<p>输入值:      text
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_has_role(&#39;table_test&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>f
</code></pre></div>
<h5 id="aclitem"><strong>aclitem 操作符</strong></h5>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_=_3">=</a></td>
<td>aclitem是否相等</td>
</tr>
<tr>
<td><a href="#_@&gt;_4">@&gt;</a></td>
<td>aclitem数组是否包含指定的权限。</td>
</tr>
</tbody>
</table>
<h6 id="_265"><strong>=</strong></h6>
<p>目的：aclitem是否相等。注意，aclitem类型缺少比较操作符的通常集合，它只有相等。 反而言之，aclitem数组只能进行相等比较。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;tester=r*w/tester&#39;::aclitem = &#39;tester=r*w*/tester&#39;::aclitem ;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>f
</code></pre></div>
<h6 id="_266"><strong>@&gt;</strong></h6>
<p>目的：aclitem数组是否包含指定的权限。如果有一个数组条目与aclitem的被授权人和授予人相匹配，并且至少有一个指定的权限集，则为真。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select &#39;{tester=r*w/tester,tester=r*w*/postgres}&#39;::aclitem[] @&gt; &#39;tester=r*/tester&#39;::aclitem;
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h5 id="aclitem_1"><strong>aclitem 函数</strong></h5>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_acldefault()">acldefault()</a></td>
<td>构造一个aclitem数组</td>
</tr>
<tr>
<td><a href="#_aclexplode()">aclexplode()</a></td>
<td>以行集的形式返回aclitem数组。</td>
</tr>
<tr>
<td><a href="#_makeaclitem()">makeaclitem()</a></td>
<td>使用给定的属性构造 aclitem 。</td>
</tr>
</tbody>
</table>
<h6 id="acldefault"><strong>acldefault()</strong></h6>
<p>目的：构造一个aclitem数组，该数组持有type类型对象的默认访问权限，该对象属于OID为ownerId的角色。 这表示当对象的ACL条目为空时所假定的访问权限。type 参数必须是下列中的一个 'c' 对应 COLUMN，'r' 对应 TABLE 和类表对象， 's' 对应 SEQUENCE， 'd' 对应 DATABASE， 'f' 对应 FUNCTION 或 PROCEDURE， 'l' 对应 LANGUAGE，'L' 对应 LARGE OBJECT， 'n' 对应 SCHEMA，'t' 对应 TABLESPACE， 'F' 对应 FOREIGN DATA WRAPPER， 'S' 对应 FOREIGN SERVER，'T' 对应 TYPE 或 DOMAIN。</p>
<p>语法：</p>
<p>输入值:      "char", oid 
返回值:      aclitem[] </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select acldefault(&#39;d&#39;,10);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>{=Tc/postgres,postgres=CTc/postgres}
</code></pre></div>
<h6 id="aclexplode"><strong>aclexplode()</strong></h6>
<p>目的：以行集的形式返回aclitem数组。如果受让人是伪角色PUBLIC，则在grantee列中用0表示。 每个被授予的权限都表示为SELECT, INSERT等。 注意，每个权限被分割成单独的一行，因此在privilege_type列中只出现一个关键字。</p>
<p>语法：</p>
<p>输入值:      acl aclitem[], OUT grantor oid, OUT grantee oid, OUT privilege_type text, OUT is_grantable boolean
返回值:      SETOF record </p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select aclexplode(&#39;{=Tc/postgres,postgres=CTc/postgres}&#39;::aclitem[]);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code> (10,0,TEMPORARY,f)
 (10,0,CONNECT,f)
 (10,10,CREATE,f)
 (10,10,TEMPORARY,f)
 (10,10,CONNECT,f)
</code></pre></div>
<h6 id="makeaclitem"><strong>makeaclitem()</strong></h6>
<p>目的：使用给定的属性构造 aclitem 。</p>
<p>语法：</p>
<p>输入值:      oid, oid, text, boolean
返回值:      aclitem</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select makeaclitem(10,10,&#39;CREATE&#39;,&#39;f&#39;);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>postgres=C/postgres
</code></pre></div>
<h5 id="_267"><strong>模式可见性查询函数</strong></h5>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_pg_collation_is_visible()">pg_collation_is_visible()</a></td>
<td>排序规则在搜索路径中是否可见。</td>
</tr>
<tr>
<td><a href="#_pg_conversion_is_visible()">pg_conversion_is_visible()</a></td>
<td>转换在搜索路径中是否可见。</td>
</tr>
<tr>
<td><a href="#_pg_function_is_visible()">pg_function_is_visible()</a></td>
<td>函数在搜索路径中是否可见。</td>
</tr>
<tr>
<td><a href="#_pg_opclass_is_visible()">pg_opclass_is_visible()</a></td>
<td>操作符类在搜索路径中是否可见。</td>
</tr>
<tr>
<td><a href="#_pg_opfamily_is_visible()">pg_opfamily_is_visible()</a></td>
<td>操作符族在搜索路径中是否可见。</td>
</tr>
<tr>
<td><a href="#_pg_table_is_visible()">pg_table_is_visible()</a></td>
<td>表在搜索路径中是否可见。</td>
</tr>
<tr>
<td><a href="#_pg_ts_config_is_visible()">pg_ts_config_is_visible()</a></td>
<td>文本搜索配置在搜索路径是否可见。</td>
</tr>
<tr>
<td><a href="#_pg_ts_dict_is_visible()">pg_ts_dict_is_visible()</a></td>
<td>文本搜索字典在搜索路径是否可见。</td>
</tr>
<tr>
<td><a href="#_pg_ts_parser_is_visible()">pg_ts_parser_is_visible()</a></td>
<td>文本搜索解析器在搜索路径中是否可见。</td>
</tr>
<tr>
<td><a href="#_pg_ts_template_is_visible()">pg_ts_template_is_visible()</a></td>
<td>文本搜索模板在搜索路径是否可见。</td>
</tr>
<tr>
<td><a href="#_pg_type_is_visible()">pg_type_is_visible()</a></td>
<td>类型(或域)在搜索路径中是否可见。</td>
</tr>
</tbody>
</table>
<h6 id="pg_collation_is_visible"><strong>pg_collation_is_visible()</strong></h6>
<p>目的：排序规则在搜索路径中是否可见。</p>
<p>语法：</p>
<p>输入值:      oid
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_collation_is_visible(100);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="pg_conversion_is_visible"><strong>pg_conversion_is_visible()</strong></h6>
<p>目的：转换在搜索路径中是否可见。</p>
<p>语法：</p>
<p>输入值:      oid
返回值:      boolean</p>
<h6 id="pg_function_is_visible"><strong>pg_function_is_visible()</strong></h6>
<p>目的：函数在搜索路径中是否可见。</p>
<p>语法：</p>
<p>输入值:      oid
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_function_is_visible(16395);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="pg_opclass_is_visible"><strong>pg_opclass_is_visible()</strong></h6>
<p>目的：操作符类在搜索路径中是否可见。</p>
<p>语法：</p>
<p>输入值:      oid
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_opclass_is_visible(10020);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="pg_operator_is_visible"><strong>pg_operator_is_visible()</strong></h6>
<p>目的：操作符在搜索路径中是否可见。</p>
<p>语法：</p>
<p>输入值:      oid
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_operator_is_visible(15);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="pg_opfamily_is_visible"><strong>pg_opfamily_is_visible()</strong></h6>
<p>目的：操作符族在搜索路径中是否可见。</p>
<p>语法：</p>
<p>输入值:      oid
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_opfamily_is_visible(424);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="pg_statistics_obj_is_visible"><strong>pg_statistics_obj_is_visible()</strong></h6>
<p>目的：统计对象在搜索路径中是否可见。</p>
<p>语法：</p>
<p>输入值:      oid
返回值:      boolean</p>
<h6 id="pg_table_is_visible"><strong>pg_table_is_visible()</strong></h6>
<p>目的：表在搜索路径中是否可见。这适用于所有类型的关系，包括视图、物化视图、索引、序列和外部表。</p>
<p>语法：</p>
<p>输入值:      oid
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_table_is_visible(16388);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="pg_ts_config_is_visible"><strong>pg_ts_config_is_visible()</strong></h6>
<p>目的：文本搜索配置在搜索路径是否可见。</p>
<p>语法：</p>
<p>输入值:      oid
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_ts_config_is_visible(13033);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="pg_ts_dict_is_visible"><strong>pg_ts_dict_is_visible()</strong></h6>
<p>目的：文本搜索字典在搜索路径是否可见。</p>
<p>语法：</p>
<p>输入值:      oid
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_ts_dict_is_visible(13032);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="pg_ts_parser_is_visible"><strong>pg_ts_parser_is_visible()</strong></h6>
<p>目的：文本搜索解析器在搜索路径中是否可见。</p>
<p>语法：</p>
<p>输入值:      oid
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_ts_parser_is_visible(3722);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="pg_ts_template_is_visible"><strong>pg_ts_template_is_visible()</strong></h6>
<p>目的：文本搜索模板在搜索路径是否可见。</p>
<p>语法：</p>
<p>输入值:      oid
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_ts_template_is_visible(3727);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h6 id="pg_type_is_visible"><strong>pg_type_is_visible()</strong></h6>
<p>目的：类型(或域)在搜索路径中是否可见。</p>
<p>语法：</p>
<p>输入值:      oid
返回值:      boolean</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select pg_type_is_visible(16);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>t
</code></pre></div>
<h5 id="_268"><strong>系统目录信息函数</strong></h5>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#_format_type()">format_type()</a></td>
<td>返回由其类型OID和可能的类型修饰符标识的数据类型的SQL名称。</td>
</tr>
<tr>
<td><a href="#_pg_get_constraintdef()">pg_get_constraintdef()</a></td>
<td>重构约束的创建命令。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="format_type"><strong>format_type()</strong></h6>
<p>目的：返回由其类型OID和可能的类型修饰符标识的数据类型的SQL名称。如果没有已知的类型修饰符，则传递NULL值给类型修饰符。</p>
<p>语法：</p>
<p>输入值:      oid, integer
返回值:      text</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>select format_type(16,-1);
</code></pre></div>
<p>返回信息如下：</p>
<div class="highlight"><pre><span></span><code>boolean
</code></pre></div>
<h6 id="pg_get_constraintdef"><strong>pg_get_constraintdef()</strong></h6>
<p>目的：重构约束的创建命令。</p>
<p>语法：</p>
<p>输入值:      oid[, boolean]
返回值:      text</p>
<p>例如：</p>
<h3 id="_269"><strong>关键词</strong></h3>
<p>SQL区分保留关键词和非保留关键词。根据标准，保留关键词才是真正的关键词，它们绝不会被允许作为标识符。非关键词仅仅是在特定上下文中具有特殊的含义并且可以在其他上下文中被用作标识符。大部分非保留关键词实际上是SQL指定的内建表和内建函数的名字。非保留关键词的概念存在的意义上实际上是声明某些上下文中的一个词被附加了某种预定义的含义。</p>
<table>
<thead>
<tr>
<th>关键词</th>
<th>Usage</th>
<th>Exceptions</th>
</tr>
</thead>
<tbody>
<tr>
<td>ABORT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ABSOLUTE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ACCESS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ACTION</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ADD</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ADMIN</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>AFTER</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>AGGREGATE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ALL</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ALSO</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ALTER</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ALWAYS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ANALYSE</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ANALYZE</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>AND</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ANY</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ARRAY</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>AS</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ASC</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ASSERTION</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ASSIGNMENT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ASYMMETRIC</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>AT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ATTACH</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ATTRIBUTE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>AUTHORIZATION</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>BACKWARD</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>BEFORE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>BEGIN</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>BETWEEN</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>BIGINT</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>BINARY</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>BIT</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>BOOLEAN</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>BOTH</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>BY</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CACHE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CALLED</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CASCADE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CASCADED</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CASE</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CAST</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CATALOG</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CHAIN</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CHAR</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>CHARACTER</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>CHARACTERISTICS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CHECK</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CHECKPOINT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CLASS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CLOSE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CLUSTER</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>COALESCE</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>COLLATE</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>COLLATION</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>COLUMN</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>COLUMNS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>COMMENT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>COMMENTS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>COMMIT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>COMMITTED</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CONCURRENTLY</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>CONFIGURATION</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CONFLICT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CONNECTION</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CONSTRAINT</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CONSTRAINTS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CONTENT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CONTINUE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CONVERSION</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>COPY</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>COST</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CREATE</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CROSS</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>CSV</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CUBE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CURRENT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CURRENT_CATALOG</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CURRENT_DATE</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CURRENT_ROLE</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CURRENT_SCHEMA</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>CURRENT_TIME</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CURRENT_TIMESTAMP</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CURRENT_USER</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CURSOR</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>CYCLE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DATA</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DATABASE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DAY</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DEALLOCATE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DEC</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>DECIMAL</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>DECLARE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DEFAULT</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DEFAULTS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DEFERRABLE</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DEFERRED</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DEFINER</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DELETE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DELIMITER</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DELIMITERS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DEPENDS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DESC</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DETACH</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DICTIONARY</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DISABLE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DISCARD</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DISTINCT</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DO</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DOCUMENT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DOMAIN</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>DROP</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>EACH</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ELSE</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ENABLE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ENCODING</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ENCRYPTED</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>END</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ENUM</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ESCAPE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>EVENT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>EXCEPT</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>EXCLUDE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>EXCLUDING</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>EXCLUSIVE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>EXECUTE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>EXISTS</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>EXPLAIN</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>EXTENSION</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>EXTERNAL</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>EXTRACT</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>FALSE</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>FAMILY</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>FETCH</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>FILTER</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>FIRST</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>FLOAT</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>FOLLOWING</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>FOR</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>FORCE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>FOREIGN</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>FORWARD</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>FREEZE</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>FROM</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>FULL</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>FUNCTION</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>FUNCTIONS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>GENERATED</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>GLOBAL</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>GRANT</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>GRANTED</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>GREATEST</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>GROUP</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>GROUPING</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>HANDLER</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>HAVING</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>HEADER</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>HOLD</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>HOUR</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>IDENTITY</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>IF</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ILIKE</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>IMMEDIATE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>IMMUTABLE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>IMPLICIT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>IMPORT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>IN</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>INCLUDING</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>INCREMENT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>INDEX</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>INDEXES</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>INHERIT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>INHERITS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>INITIALLY</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>INLINE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>INNER</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>INOUT</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>INPUT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>INSENSITIVE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>INSERT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>INSTEAD</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>INT</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>INTEGER</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>INTERSECT</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>INTERVAL</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>INTO</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>INVOKER</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>IS</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>ISNULL</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>ISOLATION</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>JOIN</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>KEY</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LABEL</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LANGUAGE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LARGE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LAST</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LATERAL</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LEADING</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LEAKPROOF</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LEAST</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>LEFT</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>LEVEL</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LIKE</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>LIMIT</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LISTEN</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LOAD</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LOCAL</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LOCALTIME</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LOCALTIMESTAMP</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LOCATION</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LOCK</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LOCKED</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>LOGGED</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>MAPPING</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>MATCH</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>MATERIALIZED</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>MAXVALUE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>METHOD</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>MINUTE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>MINVALUE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>MODE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>MONTH</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>MOVE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>NAME</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>NAMES</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>NATIONAL</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>NATURAL</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>NCHAR</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>NEW</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>NEXT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>无例外</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>NONE</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>NOT</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>NOTHING</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>NOTIFY</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>NOTNULL</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>NOWAIT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>NULL</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>NULLIF</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>NULLS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>NUMERIC</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>OBJECT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>OF</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>OFF</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>OFFSET</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>OIDS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>OLD</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ON</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ONLY</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>OPERATOR</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>OPTION</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>OR</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ORDER</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ORDINALITY</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>OUT</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>OUTER</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>OVER</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>OVERLAPS</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>OVERLAY</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>OVERRIDING</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>OWNED</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>OWNER</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PARALLEL</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PARSER</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PARTIAL</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PARTITION</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PASSING</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PASSWORD</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PLACING</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PLANS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>POLICY</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>POSITION</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>PRECEDING</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PRECISION</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>PREPARE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PREPARED</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PRESERVE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PRIOR</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PRIVILEGES</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PROCEDURAL</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PROCEDURE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PROGRAM</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>PUBLICATION</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>QUOTE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>RANGE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>READ</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>REAL</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>REASSIGN</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>RECHECK</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>RECURSIVE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>REF</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>REFERENCES</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>REFERENCING</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>REFRESH</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>REINDEX</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>RELATIVE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>RELEASE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>RENAME</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>REPEATABLE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>REPLACE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>REPLICA</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>RESET</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>RESTART</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>RESTRICT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>RETURNING</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>RETURNS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>REVOKE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>RIGHT</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>ROLE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ROLLBACK</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ROLLUP</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ROW</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>ROWS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>RULE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SAVEPOINT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SCHEMA</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SCHEMAS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SCROLL</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SEARCH</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SECOND</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SECURITY</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>select</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SEQUENCE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SEQUENCES</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SERVER</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SESSION</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SESSION_USER</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SET</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SETOF</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>SETS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SHARE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SHOW</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SIMILAR</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>SIMPLE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SKIP</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>SNAPSHOT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SOME</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SQL</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>STABLE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>STANDALONE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>START</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>STATEMENT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>STATISTICS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>STDIN</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>STDOUT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>STORAGE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>STRICT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>STRIP</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SUBSCRIPTION</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SUBSTRING</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>SYMMETRIC</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SYSID</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>SYSTEM</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>TABLE</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>TABLES</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>TABLESAMPLE</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>TABLESPACE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>TEMP</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>TEMPLATE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>TEMPORARY</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>TEXT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>THEN</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>TIME</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>TO</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>TRAILING</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>TRANSACTION</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>TRANSFORM</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>TREAT</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>TRIGGER</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>TRIM</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>TRUE</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>TRUNCATE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>TRUSTED</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>TYPE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>TYPES</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>UNBOUNDED</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>UNCOMMITTED</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>UNENCRYPTED</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>UNION</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>UNIQUE</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>UNKNOWN</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>UNLISTEN</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>UNLOGGED</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>UNTIL</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>UPDATE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>USER</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>USING</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>VACUUM</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>VALID</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>VALIDATE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>VALIDATOR</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>VALUE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>VALUES</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>VARIADIC</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>VARYING</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>VERBOSE</td>
<td>保留</td>
<td>可用于函数、类型或别名</td>
</tr>
<tr>
<td>VERSION</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>VIEW</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>VIEWS</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>VOLATILE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>WHEN</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>WHERE</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>WHITESPACE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>WINDOW</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>WITH</td>
<td>保留</td>
<td>无例外</td>
</tr>
<tr>
<td>WITHIN</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>WITHOUT</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>WORK</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>WRAPPER</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>WRITE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>XML</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>XMLATTRIBUTES</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>XMLCONCAT</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>XMLELEMENT</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>XMLEXISTS</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>XMLFOREST</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>XMLNAMESPACES</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>XMLPARSE</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>XMLPI</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>XMLROOT</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>XMLSERIALIZE</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>XMLTABLE</td>
<td>不保留</td>
<td>不用于函数或类型名称</td>
</tr>
<tr>
<td>YEAR</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>YES</td>
<td>不保留</td>
<td>无例外</td>
</tr>
<tr>
<td>ZONE</td>
<td>不保留</td>
<td>无例外</td>
</tr>
</tbody>
</table>
<h3 id="_270"><strong>保留名称</strong></h3>
<p>BSQL保留以下名称供内部使用。当使用这些名称时，即使它们被双引号引用，也会引发异常。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>系统列</td>
</tr>
<tr>
<td>tableoid</td>
<td>系统列</td>
</tr>
<tr>
<td>xmin</td>
<td>系统列</td>
</tr>
<tr>
<td>cmin</td>
<td>系统列</td>
</tr>
<tr>
<td>xmax</td>
<td>系统列</td>
</tr>
<tr>
<td>cmax</td>
<td>系统列</td>
</tr>
<tr>
<td>ctid</td>
<td>系统列</td>
</tr>
<tr>
<td>bmctid</td>
<td>虚拟列</td>
</tr>
<tr>
<td>前缀为pg_</td>
<td>系统数据库对象</td>
</tr>
<tr>
<td>前缀为bm_</td>
<td>系统数据库对象</td>
</tr>
</tbody>
</table>
<h3 id="_271"><strong>系统表/视图</strong></h3>
<h4 id="pg_aggregate"><strong>pg_aggregate</strong></h4>
<p>pg_aggregate存储关于聚集函数的信息。聚集函数是对一个数值集合（典型的是每个匹配查询条件的行中的同一个列的值） 进行操作的函数，它返回从这些值中计算出的一个数值。 典型的聚集函数是 sum、count和max。pg_aggregate里的每个项都是一个pg_proc项的扩展。pg_proc项记载该聚集的名字、输入和输出数据类型，以及其他一些和普通函数类似的信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>aggfnoid</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>聚集函数在pg_proc中的OID</td>
</tr>
<tr>
<td>aggkind</td>
<td>char</td>
<td></td>
<td>聚集类型： n表示“普通”聚集， o表示“有序集”聚集，或者 h表示“假想集”聚集</td>
</tr>
<tr>
<td>aggnumdirectargs</td>
<td>int2</td>
<td></td>
<td>一个有序集或者假想集聚集的直接（非聚集）参数的数量，一个可变数组算作一个参数。 如果等于pronargs，该聚集必定是可变的并且该可变数组描述聚集参数以 及最终直接参数。对于普通聚集总是为零。</td>
</tr>
<tr>
<td>aggtransfn</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>转移函数</td>
</tr>
<tr>
<td>aggfinalfn</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>最终函数（如果没有就为零）</td>
</tr>
<tr>
<td>aggcombinefn</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>结合函数（如果没有就为零）</td>
</tr>
<tr>
<td>aggserialfn</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>序列化函数（如果没有就为零）</td>
</tr>
<tr>
<td>aggdeserialfn</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>反序列化函数（如果没有就为零）</td>
</tr>
<tr>
<td>aggmtransfn</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>用于移动聚集模式的向前转移函数（如果没有就为零）</td>
</tr>
<tr>
<td>aggminvtransfn</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>用于移动聚集模式的反向转移函数（如果没有就为零）</td>
</tr>
<tr>
<td>aggmfinalfn</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>用于移动聚集模式的最终函数（如果没有就为零）</td>
</tr>
<tr>
<td>aggfinalextra</td>
<td>bool</td>
<td></td>
<td>为真则向 aggfinalfn传递额外的哑参数</td>
</tr>
<tr>
<td>aggmfinalextra</td>
<td>bool</td>
<td></td>
<td>为真则向 aggmfinalfn传递额外的哑参数</td>
</tr>
<tr>
<td>aggfinalmodify</td>
<td>char</td>
<td></td>
<td>aggfinalfn是否修改传递状态值： 如果是只读则为r， 如果不能在aggfinalfn之后应用aggtransfn则为s， 如果它修改该值则为w</td>
</tr>
<tr>
<td>aggmfinalmodify</td>
<td>char</td>
<td></td>
<td>和aggfinalmodify类似，但是用于aggmfinalfn</td>
</tr>
<tr>
<td>aggsortop</td>
<td>oid</td>
<td>pg_operator.oid</td>
<td>相关联的排序操作符（如果没有则为0）</td>
</tr>
<tr>
<td>aggtranstype</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>聚集函数的内部转移（状态）数据的数据类型</td>
</tr>
<tr>
<td>aggtransspace</td>
<td>int4</td>
<td></td>
<td>转移状态数据的近似平均尺寸（字节），或者为零表示使用一个默认估算值</td>
</tr>
<tr>
<td>aggmtranstype</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>聚集函数用于移动聚集欧氏的内部转移（状态）数据的数据类型（如果没有则为零）</td>
</tr>
<tr>
<td>aggmtransspace</td>
<td>int4</td>
<td></td>
<td>转移状态数据的近似平均尺寸（字节），或者为零表示使用一个默认估算值</td>
</tr>
<tr>
<td>agginitval</td>
<td>text</td>
<td></td>
<td>转移状态的初始值。这是一个文本域，它包含初始值的外部字符串表现形式。如果这个域为空，则转移状态值从空值开始。</td>
</tr>
<tr>
<td>aggminitval</td>
<td>text</td>
<td></td>
<td>用于移动聚集模式的转移状态初值。这是一个文本域，它包含了以其文本字符串形式表达的初值。 如果这个域为空，则转移状态值从空值开始。</td>
</tr>
</tbody>
</table>
<h4 id="pg_am"><strong>pg_am</strong></h4>
<p>pg_am存储有关系引访问方法的信息。系统支持的每种访问方法在这个目录中都有一行。当前，只有索引拥有访问方法。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>amname</td>
<td>name</td>
<td></td>
<td>访问方法的名字</td>
</tr>
<tr>
<td>amhandler</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>负责提供有关该访问方法信息的处理器函数的 OID</td>
</tr>
<tr>
<td>amtype</td>
<td>char</td>
<td></td>
<td>当前总是i，表示是一个索引访问方法。未来可能会允许其他值</td>
</tr>
</tbody>
</table>
<h4 id="pg_amop"><strong>pg_amop</strong></h4>
<p>pg_amop存储关于与访问方法操作符族相关的操作符信息。对于一个操作符族中的每一个成员即操作符都在这个目录中有一行。一个成员可以是一个搜索操作符或者一个排序操作符。一个操作符可以出现在多个族中，但在同一个组中既不能出现在多个搜索位置也不能出现在多个排序位置（虽然不太可能出现，但是允许一个操作符同时用于搜索和排序目的）。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>amopfamily</td>
<td>oid</td>
<td>pg_opfamily.oid</td>
<td>这个项所在的操作符族</td>
</tr>
<tr>
<td>amoplefttype</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>操作符的左手输入数据类型</td>
</tr>
<tr>
<td>amoprighttype</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>操作符的右手输入数据类型</td>
</tr>
<tr>
<td>amopstrategy</td>
<td>int2</td>
<td></td>
<td>操作符策略号</td>
</tr>
<tr>
<td>amoppurpose</td>
<td>char</td>
<td></td>
<td>操作符目的，s表示搜索，o表示排序</td>
</tr>
<tr>
<td>amopopr</td>
<td>oid</td>
<td>pg_operator.oid</td>
<td>操作符的OID</td>
</tr>
<tr>
<td>amopmethod</td>
<td>oid</td>
<td>pg_am.oid</td>
<td>使用此操作符族的索引访问方法</td>
</tr>
<tr>
<td>amopsortfamily</td>
<td>oid</td>
<td>pg_opfamily.oid</td>
<td>如果是一个排序操作符，该项会根据这个 B树操作符族排序，如果是一个搜索操作符则为0</td>
</tr>
</tbody>
</table>
<h4 id="pg_amproc"><strong>pg_amproc</strong></h4>
<p>pg_amproc存储关于访问方法操作符族相关的支持函数。属于一个操作符族的每一个支持函数在这个目录中都有一行。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>amprocfamily</td>
<td>oid</td>
<td>pg_opfamily.oid</td>
<td>使用这个项的操作符族</td>
</tr>
<tr>
<td>amproclefttype</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>相关操作符的左手输入数据类型</td>
</tr>
<tr>
<td>amprocrighttype</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>相关操作符的右手输入数据类型</td>
</tr>
<tr>
<td>amprocnum</td>
<td>int2</td>
<td></td>
<td>支持过程编号</td>
</tr>
<tr>
<td>amproc</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>过程的OID</td>
</tr>
</tbody>
</table>
<h4 id="pg_attrdef"><strong>pg_attrdef</strong></h4>
<p>pg_attrdef存储列的默认值。列的主要信息存储在pg_attribute。只有那些显式指定了一个默认值的列（在表创建时或列增加时）才会在这个目录中有一个项。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>adrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>该列所属的表</td>
</tr>
<tr>
<td>adnum</td>
<td>int2</td>
<td>pg_attribute.attnum</td>
<td>列号</td>
</tr>
<tr>
<td>adbin</td>
<td>pg_node_tree</td>
<td></td>
<td>列默认值的内部表示</td>
</tr>
<tr>
<td>adsrc</td>
<td>text</td>
<td></td>
<td>默认值的人类可读的表示</td>
</tr>
</tbody>
</table>
<h4 id="pg_attribute"><strong>pg_attribute</strong></h4>
<p>pg_attribute存储有关表列的信息。数据库中的每一个表的每一个列都恰好在pg_attribute中有一行。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>attrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>列所属的表</td>
</tr>
<tr>
<td>attname</td>
<td>name</td>
<td></td>
<td>列名</td>
</tr>
<tr>
<td>atttypid</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>列的数据类型</td>
</tr>
<tr>
<td>attstattarget</td>
<td>int4</td>
<td></td>
<td>attstattarget控制由ANALYZE对此列收集的统计信息的细节层次。0值表示不会收集任何统计信息。一个负值则说明直接使用系统默认的目标。正值的确切含义取决于数据类型。对于标量数据类型，attstattarget既是要收集的“最常见值”的目标号，也是要创建的柱状图容器的目标号。</td>
</tr>
<tr>
<td>attlen</td>
<td>int2</td>
<td></td>
<td>本列类型的pg_type.typlen一个拷贝</td>
</tr>
<tr>
<td>attnum</td>
<td>int2</td>
<td></td>
<td>列的编号。一般列从1开始向上编号。系统列（如oid）则拥有（任意）负值编号。</td>
</tr>
<tr>
<td>attndims</td>
<td>int4</td>
<td></td>
<td>如果该列是一个数组类型，这里就是其维度数；否则为0。（在目前一个数组的维度数并不被强制，因此任何非零值都能有效地表明“这是一个数组”。）</td>
</tr>
<tr>
<td>attcacheoff</td>
<td>int4</td>
<td></td>
<td>在存储中总是为-1，但是当被载入到一个内存中的行描述符后，这里可能会被更新为属性在行内的偏移</td>
</tr>
<tr>
<td>atttypmod</td>
<td>int4</td>
<td></td>
<td>atttypmod记录了在表创建时提供的类型相关数据（例如一个varchar列的最大长度）。它会被传递给类型相关的输入函数和长度强制函数。对于那些不需要atttypmod的类型，这个值通常总是为-1。</td>
</tr>
<tr>
<td>attbyval</td>
<td>bool</td>
<td></td>
<td>该列类型的pg_type.typbyval的一个拷贝</td>
</tr>
<tr>
<td>attstorage</td>
<td>char</td>
<td></td>
<td>通常是该列类型的pg_type.typstorage的一个拷贝。对于可TOAST的数据类型，这可以在列创建后被修改以控制存储策略。</td>
</tr>
<tr>
<td>attalign</td>
<td>char</td>
<td></td>
<td>该列类型的pg_type.typalign的一个拷贝</td>
</tr>
<tr>
<td>attnotnull</td>
<td>bool</td>
<td></td>
<td>这表示一个非空约束。</td>
</tr>
<tr>
<td>atthasdef</td>
<td>bool</td>
<td></td>
<td>该列有一个默认值，在此情况下在pg_attrdef目录中会有一个对应项来真正记录默认值。</td>
</tr>
<tr>
<td>atthasmissing</td>
<td>bool</td>
<td></td>
<td>该列在行中完全缺失时会用到这个列的值，如果在行创建之后增加一个有非易失DEFAULT值的列，就会发生这种情况。实际使用的值被存放在attmissingval列中。</td>
</tr>
<tr>
<td>attidentity</td>
<td>char</td>
<td></td>
<td>如果是一个零字节（''），则不是一个标识列。否则，a = 总是生成，d = 默认生成。</td>
</tr>
<tr>
<td>attisdropped</td>
<td>bool</td>
<td></td>
<td>该列被删除且不再有效。一个删除的列仍然物理存在于表中，但是会被分析器忽略并因此无法通过SQL访问。</td>
</tr>
<tr>
<td>attislocal</td>
<td>bool</td>
<td></td>
<td>该列是由关系本地定义的。注意一个列可以同时是本地定义和继承的。</td>
</tr>
<tr>
<td>attinhcount</td>
<td>int4</td>
<td></td>
<td>该列的直接祖先的编号。一个具有非零编号祖先的列不能被删除或者重命名。</td>
</tr>
<tr>
<td>attcollation</td>
<td>oid</td>
<td>pg_collation.oid</td>
<td>该列被定义的排序规则，如果该列不是一个可排序数据类型则为0。</td>
</tr>
<tr>
<td>attacl</td>
<td>aclitem[]</td>
<td></td>
<td>列级访问权限</td>
</tr>
<tr>
<td>attoptions</td>
<td>text[]</td>
<td></td>
<td>属性级选项，以“keyword=value”形式的字符串</td>
</tr>
<tr>
<td>attfdwoptions</td>
<td>text[]</td>
<td></td>
<td>属性级的外部数据包装器选项，以“keyword=value”形式的字符串</td>
</tr>
<tr>
<td>attmissingval</td>
<td>anyarray</td>
<td></td>
<td>这个列中是一个含有一个元素的数组，其中的值被用于该列在行中完全缺失时，如果在行创建之后增加一个有非易失DEFAULT值的列，就会发生这种情况。只有当atthasmissing为真时才使用这个值。如果没有值则该列为空。</td>
</tr>
</tbody>
</table>
<h4 id="pg_auth_members"><strong>pg_auth_members</strong></h4>
<p>pg_auth_members展示了角色之间的成员关系。允许任何无环的关系集合。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>roleid</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>拥有成员的角色的ID</td>
</tr>
<tr>
<td>member</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>roleid的成员角色的ID</td>
</tr>
<tr>
<td>grantor</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>授权此成员关系的角色的ID</td>
</tr>
<tr>
<td>admin_option</td>
<td>bool</td>
<td></td>
<td>如果member能把roleid的成员关系授予他人，则为真</td>
</tr>
</tbody>
</table>
<h4 id="pg_authid"><strong>pg_authid</strong></h4>
<p>pg_authid包含关于数据库授权标识符（角色）的信息。角色把“用户”和“组”的概念包含在内。一个用户实际上就是一个rolcanlogin标志被设置的角色。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>rolname</td>
<td>name</td>
<td>角色名</td>
</tr>
<tr>
<td>rolsuper</td>
<td>bool</td>
<td>角色是否拥有超级用户权限</td>
</tr>
<tr>
<td>rolinherit</td>
<td>bool</td>
<td>如果本角色是另一个角色的成员，本角色是否自动另一个角色的权限</td>
</tr>
<tr>
<td>rolcreaterole</td>
<td>bool</td>
<td>角色是否能创建更多角色</td>
</tr>
<tr>
<td>rolcreatedb</td>
<td>bool</td>
<td>角色是否能创建数据库</td>
</tr>
<tr>
<td>rolcanlogin</td>
<td>bool</td>
<td>角色是否能登录。即该角色是否能够作为初始会话授权标识符</td>
</tr>
<tr>
<td>rolreplication</td>
<td>bool</td>
<td>角色是一个复制角色。复制角色可以启动复制连接并且创建和删除复制槽。</td>
</tr>
<tr>
<td>rolbypassrls</td>
<td>bool</td>
<td>角色是否可以绕过所有的行级安全性策略。</td>
</tr>
<tr>
<td>rolconnlimit</td>
<td>int4</td>
<td>对于可以登录的角色，本列设置该角色可以同时发起最大连接数。-1表示无限制。</td>
</tr>
<tr>
<td>rolpassword</td>
<td>text</td>
<td>口令（可能被加密过），如果没有口令则为空。格式取决于使用的加密方法的形式。</td>
</tr>
<tr>
<td>rolvaliduntil</td>
<td>timestamptz</td>
<td>口令过期时间（只用于口令鉴定），如果永不过期则为空</td>
</tr>
</tbody>
</table>
<h4 id="pg_available_extension_versions"><strong>pg_available_extension_versions</strong></h4>
<p>pg_available_extension_versions视图列出了可用于安装的指定扩展版本。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>name</td>
<td>扩展名</td>
</tr>
<tr>
<td>version</td>
<td>text</td>
<td>版本名</td>
</tr>
<tr>
<td>installed</td>
<td>bool</td>
<td>如果此版本的扩展当前已安装则为真</td>
</tr>
<tr>
<td>superuser</td>
<td>bool</td>
<td>如果只有超级用户被允许安装此扩展则为真</td>
</tr>
<tr>
<td>relocatable</td>
<td>bool</td>
<td>如果扩展能被重定位到另一个模式则为真</td>
</tr>
<tr>
<td>schema</td>
<td>name</td>
<td>此扩展必须被安装到的模式名，如果此扩展是部分或者全部可以重定位的，此列为NULL</td>
</tr>
<tr>
<td>requires</td>
<td>name[]</td>
<td>先决条件扩展的名字，如果没有则为NULL</td>
</tr>
<tr>
<td>comment</td>
<td>text</td>
<td>来自于扩展的控制文件的注释字符串</td>
</tr>
</tbody>
</table>
<h4 id="pg_available_extensions"><strong>pg_available_extensions</strong></h4>
<p>pg_available_extensions视图列出了可用于安装的扩展，pg_available_extensions视图是只读的。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>name</td>
<td>扩展名</td>
</tr>
<tr>
<td>default_version</td>
<td>text</td>
<td>默认版本的名字，如果没有指定则为NULL</td>
</tr>
<tr>
<td>installed_version</td>
<td>text</td>
<td>当前已安装的扩展版本，如果没有安装则为NULL</td>
</tr>
<tr>
<td>comment</td>
<td>text</td>
<td>来自于扩展的控制文件的注释字符串</td>
</tr>
</tbody>
</table>
<h4 id="pg_backend_memory_contexts"><strong>pg_backend_memory_contexts</strong></h4>
<p>pg_backend_memory_contexts视图显示附加到当前会话的服务器进程所有的内存上下文。pg_backend_memory_contexts 对每个内存上下文包含一行。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>text</td>
<td>内存上下文的名称</td>
</tr>
<tr>
<td>ident</td>
<td>text</td>
<td>内存上下文的标识信息。这个字段被截断为1024字节</td>
</tr>
<tr>
<td>parent</td>
<td>text</td>
<td>内存上下文的父级名称</td>
</tr>
<tr>
<td>level</td>
<td>int4</td>
<td>上下文树中TopMemoryContext的距离</td>
</tr>
<tr>
<td>total_bytes</td>
<td>int8</td>
<td>分配给这个内存上下文的总字节数</td>
</tr>
<tr>
<td>total_nblocks</td>
<td>int8</td>
<td>分配给这个内存上下文的总块数</td>
</tr>
<tr>
<td>free_bytes</td>
<td>int8</td>
<td>可用空间，按字节计</td>
</tr>
<tr>
<td>free_chunks</td>
<td>int8</td>
<td>可用大块的总数量</td>
</tr>
<tr>
<td>used_bytes</td>
<td>int8</td>
<td>已用空间，按字节计</td>
</tr>
</tbody>
</table>
<h4 id="pg_bm_catalog_version"><strong>pg_bm_catalog_version</strong></h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>db_oid</td>
<td>oid</td>
<td>适用于的数据库的oid</td>
</tr>
<tr>
<td>current_version</td>
<td>bigint</td>
<td>目录的当前版本</td>
</tr>
<tr>
<td>last_breaking_version</td>
<td>bigint</td>
<td>使正在进行的事务无效的最后版本（更改）</td>
</tr>
</tbody>
</table>
<h4 id="pg_bm_migration"><strong>pg_bm_migration</strong></h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>major</td>
<td>int4</td>
<td>应用程序迁移的主要版本</td>
</tr>
<tr>
<td>minor</td>
<td>int4</td>
<td>在备份目录更改时使用，以避免在主要版本上发生冲突</td>
</tr>
<tr>
<td>name</td>
<td>name</td>
<td>迁移的名称，或者“<baseline>”（如果它是由initdb生成的）。</td>
</tr>
<tr>
<td>time_applied</td>
<td>bigint</td>
<td>迁移应用程序日期的时间戳（以毫秒为单位），基线为NULL。</td>
</tr>
</tbody>
</table>
<h4 id="pg_bm_profile"><strong>pg_bm_profile</strong></h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>prfname</td>
<td>name</td>
<td>配置文件名称</td>
</tr>
<tr>
<td>prfmaxfailedloginattempts</td>
<td>int4</td>
<td>允许的尝试次数</td>
</tr>
<tr>
<td>prfpasswordlocktime</td>
<td>int4</td>
<td>锁定帐户时间（秒）</td>
</tr>
</tbody>
</table>
<h4 id="pg_bm_role_profile"><strong>pg_bm_role_profile</strong></h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rolprfrole</td>
<td>oid</td>
<td>角色的oid</td>
</tr>
<tr>
<td>rolprfprofile</td>
<td>oid</td>
<td>配置文件的oid</td>
</tr>
<tr>
<td>rolprfstatus</td>
<td>char</td>
<td>参考状态</td>
</tr>
<tr>
<td>rolprffailedloginattempts</td>
<td>int4</td>
<td>失败的尝试次数</td>
</tr>
<tr>
<td>rolprflockeduntil</td>
<td>timestamp with time zone</td>
<td>锁定超时过期时间（如果有的话）</td>
</tr>
</tbody>
</table>
<h4 id="pg_bm_tablegroup"><strong>pg_bm_tablegroup</strong></h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>grpname</td>
<td>name</td>
<td>表组名称</td>
</tr>
<tr>
<td>grpowner</td>
<td>oid</td>
<td>表组的拥有者</td>
</tr>
<tr>
<td>grptablespace</td>
<td>oid</td>
<td>表组的表空间</td>
</tr>
<tr>
<td>grpacl</td>
<td>aclitem[]</td>
<td>访问权限</td>
</tr>
<tr>
<td>grpoptions</td>
<td>text[]</td>
<td>每一个表组的操作</td>
</tr>
</tbody>
</table>
<h4 id="pg_cast"><strong>pg_cast</strong></h4>
<p>pg_cast存储数据类型转换路径，包括内建的和用户定义的类型。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>castsource</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>源数据类型的OID</td>
</tr>
<tr>
<td>casttarget</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>目标数据类型的OID</td>
</tr>
<tr>
<td>castfunc</td>
<td>oid</td>
<td>pg_proc.oid</td>
<td>执行该转换的函数的OID。如果该转换方法不需要一个函数则存储0。</td>
</tr>
<tr>
<td>castcontext</td>
<td>char</td>
<td></td>
<td>指示该转换能被调用的环境。 e表示仅能作为一个显式转换（使用CAST或::语法）。 a表示在赋值给目标列时隐式调用， 和显式调用一样。 i表示在表达式中隐式调用，和其他转换一样。</td>
</tr>
<tr>
<td>castmethod</td>
<td>char</td>
<td></td>
<td>指示转换如何被执行。 f表明使用castfunc中指定的函数。 i表明使用输入/输出函数。 b表明该类型是二进制可转换的，因此不需要转换。</td>
</tr>
</tbody>
</table>
<h4 id="pg_class"><strong>pg_class</strong></h4>
<p>pg_class记录表和几乎所有具有列或者像表的东西。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td></td>
<td>表、索引、视图等的名字</td>
</tr>
<tr>
<td>relnamespace</td>
<td>oid</td>
<td>pg_namespace.oid</td>
<td>包含该关系的名字空间的OID</td>
</tr>
<tr>
<td>reltype</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>可能存在的表行类型所对应数据类型的OID（对索引为0，索引没有pg_type项）</td>
</tr>
<tr>
<td>reloftype</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>对于有类型的表，为底层组合类型的OID，对于其他所有关系为0</td>
</tr>
<tr>
<td>relowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>关系的拥有者</td>
</tr>
<tr>
<td>relam</td>
<td>oid</td>
<td>pg_am.oid</td>
<td>如果这是一个索引，表示索引使用的访问方法（B树、哈希等）</td>
</tr>
<tr>
<td>relfilenode</td>
<td>oid</td>
<td></td>
<td>该关系的磁盘文件的名字，0表示这是一个“映射”关系，其磁盘文件名取决于低层状态</td>
</tr>
<tr>
<td>reltablespace</td>
<td>oid</td>
<td>pg_tablespace.oid</td>
<td>该关系所存储的表空间。如果为0，使用数据库的默认表空间。（如果关系无磁盘文件时无意义）</td>
</tr>
<tr>
<td>relpages</td>
<td>int4</td>
<td></td>
<td>该表磁盘表示的尺寸，以页面计（页面尺寸为BLCKSZ）。这只是一个由规划器使用的估计值。它被VACUUM、ANALYZE以及一些DDL命令（如CREATE INDEX）所更新。</td>
</tr>
<tr>
<td>reltuples</td>
<td>float4</td>
<td></td>
<td>表中的存活行数。这只是一个由规划器使用的估计值。它被VACUUM、ANALYZE以及一些DDL命令（如CREATE INDEX）所更新。</td>
</tr>
<tr>
<td>relallvisible</td>
<td>int4</td>
<td></td>
<td>在表的可见性映射表中被标记为全可见的页数。这只是一个由规划器使用的估计值。它被VACUUM、ANALYZE以及一些DDL命令（如CREATE INDEX）所更新。</td>
</tr>
<tr>
<td>reltoastrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>与该表相关联的TOAST表的OID，如果没有则为0。TOAST表将大属性“线外”存储在一个二级表中。</td>
</tr>
<tr>
<td>relhasindex</td>
<td>bool</td>
<td></td>
<td>如果这是一个表并且其上建有（或最近建有）索引则为真</td>
</tr>
<tr>
<td>relisshared</td>
<td>bool</td>
<td></td>
<td>如果该表在集簇中的所有数据库间共享则为真。只有某些系统目录（如pg_database）是共享的。</td>
</tr>
<tr>
<td>relpersistence</td>
<td>char</td>
<td></td>
<td>p = 永久表，u = 无日志表， t = 临时表</td>
</tr>
<tr>
<td>relkind</td>
<td>char</td>
<td></td>
<td>r = 普通表， i = 索引， S = 序列， t = TOAST表， v = 视图， m = 物化视图， c = 组合类型， f = 外部表， p = 分区表， I = 分区索引</td>
</tr>
<tr>
<td>relnatts</td>
<td>int2</td>
<td></td>
<td>关系中用户列的数目（系统列不计算在内）。在pg_attribute中必须有这么多对应的项。</td>
</tr>
<tr>
<td>relchecks</td>
<td>int2</td>
<td></td>
<td>表上CHECK约束的数目，参见pg_constraint目录</td>
</tr>
<tr>
<td>relhasoids</td>
<td>bool</td>
<td></td>
<td>如果为关系的每一行生成一个OID则为真</td>
</tr>
<tr>
<td>relhasrules</td>
<td>bool</td>
<td></td>
<td>如果表有（或曾有）规则则为真，参见 pg_rewrite</td>
</tr>
<tr>
<td>relhastriggers</td>
<td>bool</td>
<td></td>
<td>如果表有（或曾有）触发器则为真，参见 pg_trigger</td>
</tr>
<tr>
<td>relhassubclass</td>
<td>bool</td>
<td></td>
<td>如果表有（或曾有）任何继承子女则为真</td>
</tr>
<tr>
<td>relrowsecurity</td>
<td>bool</td>
<td></td>
<td>如果表上启用了行级安全性则为真，参见 pg_policy</td>
</tr>
<tr>
<td>relforcerowsecurity</td>
<td>bool</td>
<td></td>
<td>如果行级安全性（启用时）也适用于表拥有者则为真，参见 pg_policy</td>
</tr>
<tr>
<td>relispopulated</td>
<td>bool</td>
<td></td>
<td>如果表已被填充则为真（对于所有关系该列都为真，但对于某些物化视图却不是）</td>
</tr>
<tr>
<td>relreplident</td>
<td>char</td>
<td></td>
<td>用来为行形成“replica identity”的列： d = 默认 (主键，如果存在), n = 无, f = 所有列 i = 索引的indisreplident被设置或者为默认</td>
</tr>
<tr>
<td>relispartition</td>
<td>bool</td>
<td></td>
<td>如果表或索引是一个分区，则为真</td>
</tr>
<tr>
<td>relrewrite</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>对于在要求表重写的DDL操作期间被写入的新关系，这个域包含原始关系的OID，否则为0。那种状态仅在内部可见，对于一个用户可见的关系这个域应该从不包含不是0的值。</td>
</tr>
<tr>
<td>relfrozenxid</td>
<td>xid</td>
<td></td>
<td>在此之前的所有事务ID在表中已经被替换为一个永久的（“冻结的”) 事务ID。这用于跟踪表是否需要被清理，以便阻止事务ID回卷或者允许pg_xact被收缩。如果该关系不是一个表则为0（InvalidTransactionId）。</td>
</tr>
<tr>
<td>relminmxid</td>
<td>xid</td>
<td></td>
<td>在此之前的多事务ID在表中已经被替换为一个事务ID。这被用于跟踪表是否需要被清理，以阻止 多事务ID回卷或者允许pg_multixact被收缩。如果关系不是一个表则 为0（InvalidMultiXactId）。</td>
</tr>
<tr>
<td>relacl</td>
<td>aclitem[]</td>
<td></td>
<td>访问权限，更多信息参见 GRANT和 REVOKE</td>
</tr>
<tr>
<td>reloptions</td>
<td>text[]</td>
<td></td>
<td>访问方法相关的选项，以“keyword=value”字符串形式</td>
</tr>
<tr>
<td>relpartbound</td>
<td>pg_node_tree</td>
<td></td>
<td>如果表示一个分区，分区边界的内部表达</td>
</tr>
</tbody>
</table>
<h4 id="pg_collation"><strong>pg_collation</strong></h4>
<p>pg_collation描述了可用的排序规则，其本质是从一个SQL名字到操作系统locale分类的映射。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>collname</td>
<td>name</td>
<td></td>
<td>排序规则名字（在每一个名字空间和编码中唯一）</td>
</tr>
<tr>
<td>collnamespace</td>
<td>oid</td>
<td>pg_namespace.oid</td>
<td>包含该排序规则的名字空间的OID</td>
</tr>
<tr>
<td>collowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>排序规则的拥有者</td>
</tr>
<tr>
<td>collprovider</td>
<td>char</td>
<td></td>
<td>排序规则的提供者：d = 数据库默认，c = libc，i = icu</td>
</tr>
<tr>
<td>collencoding</td>
<td>int4</td>
<td></td>
<td>该排序规则可应用的编码，-1表示它可用于任何编码</td>
</tr>
<tr>
<td>collcollate</td>
<td>name</td>
<td></td>
<td>该排序规则对象的LC_COLLATE</td>
</tr>
<tr>
<td>collctype</td>
<td>name</td>
<td></td>
<td>该排序规则对象的LC_CTYPE</td>
</tr>
<tr>
<td>collversion</td>
<td>text</td>
<td></td>
<td>排序规则的提供者相关的版本。这是在排序规则创建时记录下来的，并且在使用排序规则时会被检查以检测可能导致数据损坏的排序规则定义的改变。</td>
</tr>
</tbody>
</table>
<h4 id="pg_config"><strong>pg_config</strong></h4>
<p>视图pg_config描述了当前安装的版本中的编译时配置参数。默认情况下，pg_config视图只能由超级用户读取。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>text</td>
<td>参数名</td>
</tr>
<tr>
<td>setting</td>
<td>text</td>
<td>参数值</td>
</tr>
</tbody>
</table>
<h4 id="pg_constraint"><strong>pg_constraint</strong></h4>
<p>pg_constraint存储表上的检查、主键、唯一、外键和排他约束（列约束也不会被特殊对待。每一个列约束都等同于某种表约束。）。非空约束不在这里，而是在pg_attribute中表示。
用户定义的约束触发器（使用CREATE CONSTRAINT TRIGGER创建）也会在这个表中产生一项。
域上的检查约束也存储在这里。 </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>conname</td>
<td>name</td>
<td></td>
<td>约束名字（不需要唯一！）</td>
</tr>
<tr>
<td>connamespace</td>
<td>oid</td>
<td>pg_namespace.oid</td>
<td>包含此约束的名字空间的OID</td>
</tr>
<tr>
<td>contype</td>
<td>char</td>
<td></td>
<td>c = 检查约束， f = 外键约束， p = 主键约束， u = 唯一约束， t = 约束触发器， x = 排他约束</td>
</tr>
<tr>
<td>condeferrable</td>
<td>bool</td>
<td></td>
<td>该约束是否能被延迟？</td>
</tr>
<tr>
<td>condeferred</td>
<td>bool</td>
<td></td>
<td>该约束是否默认被延迟？</td>
</tr>
<tr>
<td>convalidated</td>
<td>bool</td>
<td></td>
<td>此约束是否被验证过？当前对于外键和检查约束只能是假</td>
</tr>
<tr>
<td>conrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>该约束所在的表，如果不是表约束则为0</td>
</tr>
<tr>
<td>contypid</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>该约束所在的域，如果不是域约束则为0</td>
</tr>
<tr>
<td>conindid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>如果该约束是唯一、主键、外键或排他约束，此列表示支持此约束的索引，否则为0</td>
</tr>
<tr>
<td>conparentid</td>
<td>oid</td>
<td>pg_constraint.oid</td>
<td>如果这是一个分区中的约束，则是父分区表中对应的约束；否则为0</td>
</tr>
<tr>
<td>confrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>如果此约束是一个外键约束，此列为被引用的表，否则为0</td>
</tr>
<tr>
<td>confupdtype</td>
<td>char</td>
<td></td>
<td>外键更新动作代码： a = 无动作， r = 限制， c = 级联， n = 置空， d = 置为默认值</td>
</tr>
<tr>
<td>confdeltype</td>
<td>char</td>
<td></td>
<td>外键删除动作代码： a = 无动作， r = 限制， c = 级联， n = 置空， d = 置为默认值</td>
</tr>
<tr>
<td>confmatchtype</td>
<td>char</td>
<td></td>
<td>外键匹配类型： f = 完全， p = 部分， s = 简单</td>
</tr>
<tr>
<td>conislocal</td>
<td>bool</td>
<td></td>
<td>此约束是定义在关系本地。注意一个约束可以同时是本地定义和继承。</td>
</tr>
<tr>
<td>coninhcount</td>
<td>int4</td>
<td></td>
<td>此约束的直接继承祖先数目。一个此列非零的约束不能被删除或重命名。</td>
</tr>
<tr>
<td>connoinherit</td>
<td>bool</td>
<td></td>
<td>为真表示此约束被定义在关系本地。它是一个不可继承约束。</td>
</tr>
<tr>
<td>conkey</td>
<td>int2[]</td>
<td>pg_attribute.attnum</td>
<td>如果是一个表约束（包括外键但不包括约束触发器），此列是被约束列的列表</td>
</tr>
<tr>
<td>confkey</td>
<td>int2[]</td>
<td>pg_attribute.attnum</td>
<td>如果是一个外键，此列是被引用列的列表</td>
</tr>
<tr>
<td>conpfeqop</td>
<td>oid[]</td>
<td>pg_operator.oid</td>
<td>如果是一个外键，此列是用于PK = FK比较的等值操作符的列表</td>
</tr>
<tr>
<td>conppeqop</td>
<td>oid[]</td>
<td>pg_operator.oid</td>
<td>如果是一个外键，此列是用于PK = PK比较的等值操作符的列表</td>
</tr>
<tr>
<td>conffeqop</td>
<td>oid[]</td>
<td>pg_operator.oid</td>
<td>如果是一个外键，此列是用于FK = FK比较的等值操作符的列表</td>
</tr>
<tr>
<td>conexclop</td>
<td>oid[]</td>
<td>pg_operator.oid</td>
<td>如果是一个排他约束，此列是没列排他操作符的列表</td>
</tr>
<tr>
<td>conbin</td>
<td>pg_node_tree</td>
<td></td>
<td>如果是一个检查约束，此列是表达式的一个内部表示</td>
</tr>
<tr>
<td>consrc</td>
<td>text</td>
<td></td>
<td>如果是一个检查约束，此列是表达式的一个人类可读的表示</td>
</tr>
</tbody>
</table>
<h4 id="pg_conversion"><strong>pg_conversion</strong></h4>
<p>pg_conversion描述编码转换函数</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>conname</td>
<td>name</td>
<td></td>
<td>转换的名字（在一个名字空间内唯一）</td>
</tr>
<tr>
<td>connamespace</td>
<td>oid</td>
<td>pg_namespace.oid</td>
<td>包含此转换的名字空间的OID</td>
</tr>
<tr>
<td>conowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>转换的拥有者</td>
</tr>
<tr>
<td>conforencoding</td>
<td>int4</td>
<td></td>
<td>源编码ID</td>
</tr>
<tr>
<td>contoencoding</td>
<td>int4</td>
<td></td>
<td>目标编码ID</td>
</tr>
<tr>
<td>conproc</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>转换函数</td>
</tr>
<tr>
<td>condefault</td>
<td>bool</td>
<td></td>
<td>如果这是默认转换则为真</td>
</tr>
</tbody>
</table>
<h4 id="pg_cursors"><strong>pg_cursors</strong></h4>
<p>pg_cursors视图列出了当前可用的游标。游标可以以几种方式定义：</p>
<ul>
<li>通过SQL中的DECLARE语句</li>
<li>通过前端/后端协议中的绑定消息</li>
<li>通过服务器编程接口（SPI）</li>
</ul>
<p>pg_cursors视图显示由任何这些方式创建的游标。视图只存在于定义它们的事务期间，除非声明了WITH HOLD。因此非保持游标只在它们的创建事务结束前存在于这个视图中。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>text</td>
<td>游标名</td>
</tr>
<tr>
<td>statement</td>
<td>text</td>
<td>提交用于定义此游标的查询语句</td>
</tr>
<tr>
<td>is_holdable</td>
<td>boolean</td>
<td>如果游标是可保持的（即，它可以在其定义事务提交后被访问）则为true，否则为否</td>
</tr>
<tr>
<td>is_binary</td>
<td>boolean</td>
<td>如果游标被声明为BINARY则为true，否则为false</td>
</tr>
<tr>
<td>is_scrollable</td>
<td>boolean</td>
<td>如果游标是可滚动的（即，允许以一种非顺序的方式检索行）则为true，否则为false</td>
</tr>
<tr>
<td>creation_time</td>
<td>timestamptz</td>
<td>游标被声明的时间</td>
</tr>
</tbody>
</table>
<h4 id="pg_database"><strong>pg_database</strong></h4>
<p>pg_database存储有关可用数据库的信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>datname</td>
<td>name</td>
<td></td>
<td>数据库名字</td>
</tr>
<tr>
<td>datdba</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>数据库的拥有者，通常是创建它的用户</td>
</tr>
<tr>
<td>encoding</td>
<td>int4</td>
<td></td>
<td>此数据库的字符编码的编号（pg_encoding_to_char()可将此编号转换成编码的名字）</td>
</tr>
<tr>
<td>datcollate</td>
<td>name</td>
<td></td>
<td>此数据库的LC_COLLATE</td>
</tr>
<tr>
<td>datctype</td>
<td>name</td>
<td></td>
<td>此数据库的LC_CTYPE</td>
</tr>
<tr>
<td>datistemplate</td>
<td>bool</td>
<td></td>
<td>如果为真，则此数据库可被任何具有CREATEDB特权的用户克隆；如果为假，则只有 超级用户或者该数据库的属主能够克隆它。</td>
</tr>
<tr>
<td>datallowconn</td>
<td>bool</td>
<td></td>
<td>如果为假则没有人能连接到这个数据库。这可以用来保护template0数据库不被修改。</td>
</tr>
<tr>
<td>datconnlimit</td>
<td>int4</td>
<td></td>
<td>设置能够连接到这个数据库的最大并发连接数。-1表示没有限制。</td>
</tr>
<tr>
<td>datlastsysoid</td>
<td>oid</td>
<td></td>
<td>数据库中最后一个系统OID，对pg_dump特别有用</td>
</tr>
<tr>
<td>datfrozenxid</td>
<td>xid</td>
<td></td>
<td>在此之前的所有事务ID在数据库中已经被替换为一个永久的（“冻结的”) 事务ID。这用于跟踪数据库是否需要被清理，以便组织事务ID回环或者允许pg_xact被收缩。它是此数据库中所有表的pg_class.relfrozenxid值的最小值。</td>
</tr>
<tr>
<td>datminmxid</td>
<td>xid</td>
<td></td>
<td>在此之前的所有多事务ID在数据库中已经被替换为一个事务ID。这用于跟踪数据库是否需要被 清理，以便组织事务ID回环或者允许pg_multixact被收缩。它是此数据库中 所有表的pg_class.relminmxid值的最小值。</td>
</tr>
<tr>
<td>dattablespace</td>
<td>oid</td>
<td>pg_tablespace.oid</td>
<td>此数据库的默认表空间。在此数据库中，所有pg_class.reltablespace为0的表都将被存储在这个表空间中，尤其是非共享系统目录都会在其中。</td>
</tr>
<tr>
<td>datacl</td>
<td>aclitem[]</td>
<td></td>
<td>访问权限，更多信息参见 GRANT和 REVOKE</td>
</tr>
</tbody>
</table>
<h4 id="pg_db_role_setting"><strong>pg_db_role_setting</strong></h4>
<p>pg_db_role_setting为每一个角色和数据库组合记录被设置到运行时配置变量的默认值。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>setdatabase</td>
<td>oid</td>
<td>pg_database.oid</td>
<td>此设置可用的数据库OID，如果不与具体数据库相关则为0</td>
</tr>
<tr>
<td>setrole</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>此设置可用的角色OID，如果不与具体角色相关则为0</td>
</tr>
<tr>
<td>setconfig</td>
<td>text[]</td>
<td></td>
<td>运行时配置变量的默认值</td>
</tr>
</tbody>
</table>
<h4 id="pg_default_acl"><strong>pg_default_acl</strong></h4>
<p>pg_default_acl存储要被分配给新创建对象的初始权限。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>defaclrole</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>与此项相关的角色的OID</td>
</tr>
<tr>
<td>defaclnamespace</td>
<td>oid</td>
<td>pg_namespace.oid</td>
<td>与此项相关的名字空间的OID，如果没有则为0</td>
</tr>
<tr>
<td>defaclobjtype</td>
<td>char</td>
<td></td>
<td>此项适合的对象类型： r = 关系（表、视图）， S = 序列， f = 函数， T = 类型， n = 方案</td>
</tr>
<tr>
<td>defaclacl</td>
<td>aclitem[]</td>
<td></td>
<td>此类对象在创建时应用有的访问权限</td>
</tr>
</tbody>
</table>
<h4 id="pg_depend"><strong>pg_depend</strong></h4>
<p>pg_depend记录数据库对象之间的依赖关系。这些信息允许DROP命令查找必须被DROP CASCADE删除的其他对象，或者在DROP RESTRICT情况下阻止删除。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>classid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>依赖对象所在的系统目录OID</td>
</tr>
<tr>
<td>objid</td>
<td>oid</td>
<td>任意OID列</td>
<td>指定依赖对象的OID</td>
</tr>
<tr>
<td>objsubid</td>
<td>int4</td>
<td></td>
<td>对于一个表列，这里是列号（objid和classid指表本身）。对于所有其他对象类型，此列为0。</td>
</tr>
<tr>
<td>refclassid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>被引用对象所在的系统目录的OID</td>
</tr>
<tr>
<td>refobjid</td>
<td>oid</td>
<td>任意OID列</td>
<td>指定被引用对象的OID</td>
</tr>
<tr>
<td>refobjsubid</td>
<td>int4</td>
<td></td>
<td>对于一个表列，这里是列号（refobjid和refclassid指表本身）。对于所有其他对象类型，此列为0。</td>
</tr>
<tr>
<td>deptype</td>
<td>char</td>
<td></td>
<td>定义此依赖关系语义的一个代码</td>
</tr>
</tbody>
</table>
<h4 id="pg_description"><strong>pg_description</strong></h4>
<p>pg_description存储对每一个数据库对象可选的描述（注释）。描述可以通过COMMENT操作，并可使用psql的\d命令查看。在pg_description的初始内容中提供了很多内建系统对象的描述。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>objoid</td>
<td>oid</td>
<td>任意OID列</td>
<td>描述所属对象的OID</td>
</tr>
<tr>
<td>classoid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>对象所述的系统目录的OID</td>
</tr>
<tr>
<td>objsubid</td>
<td>int4</td>
<td></td>
<td>对于一个表列上的一个注释，这里是列号（objoid和classoid指表本身）。对所有其他对象类型，此列为0。</td>
</tr>
<tr>
<td>description</td>
<td>text</td>
<td></td>
<td>作为该对象描述的任意文本</td>
</tr>
</tbody>
</table>
<h4 id="pg_enum"><strong>pg_enum</strong></h4>
<p>pg_enum目录包含每一个枚举类型的项，其中包括了值和标签。一个给定枚举值的内部表示实际上是它在pg_enum中的相关行的OID。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>enumtypid</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>包含此枚举值的pg_type项的OID</td>
</tr>
<tr>
<td>enumsortorder</td>
<td>float4</td>
<td></td>
<td>此枚举值在其枚举类型中的排序位置</td>
</tr>
<tr>
<td>enumlabel</td>
<td>name</td>
<td></td>
<td>此枚举值的文本标签</td>
</tr>
</tbody>
</table>
<h4 id="pg_event_trigger"><strong>pg_event_trigger</strong></h4>
<p>pg_event_trigger存储事件触发器。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>evtname</td>
<td>name</td>
<td></td>
<td>触发器名（必须唯一）</td>
</tr>
<tr>
<td>evtevent</td>
<td>name</td>
<td></td>
<td>此触发器触发的事件的标识符</td>
</tr>
<tr>
<td>evtowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>事件触发器的拥有者</td>
</tr>
<tr>
<td>evtfoid</td>
<td>oid</td>
<td>pg_proc.oid</td>
<td>将被调用的函数</td>
</tr>
<tr>
<td>evtenabled</td>
<td>char</td>
<td></td>
<td>控制事件触发器触发的session_replication_role模式。 O = 触发器在“origin”和“local”模式触发， D = 触发器被禁用， R = 触发器在“replica”模式触发， A = 触发器总是触发。</td>
</tr>
<tr>
<td>evttags</td>
<td>text[]</td>
<td></td>
<td>此触发器将触发的命令标签。如果为空，此触发器的触发不受命令标签的限制。</td>
</tr>
</tbody>
</table>
<h4 id="pg_extension"><strong>pg_extension</strong></h4>
<p>pg_extension存储有关已安装扩展的信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>extname</td>
<td>name</td>
<td></td>
<td>扩展的名字</td>
</tr>
<tr>
<td>extowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>扩展的拥有者</td>
</tr>
<tr>
<td>extnamespace</td>
<td>oid</td>
<td>pg_namespace.oid</td>
<td>包含此扩展的导出对象的模式</td>
</tr>
<tr>
<td>extrelocatable</td>
<td>bool</td>
<td></td>
<td>如果扩展可被重定位到另一个模式则为真</td>
</tr>
<tr>
<td>extversion</td>
<td>text</td>
<td></td>
<td>扩展的版本名字</td>
</tr>
<tr>
<td>extconfig</td>
<td>oid[]</td>
<td>pg_class.oid</td>
<td>扩展的配置表的regclass项的OID数组，如果没有配置表则为NULL</td>
</tr>
<tr>
<td>extcondition</td>
<td>text[]</td>
<td></td>
<td>扩展的配置表的WHERE子句过滤条件的数组，如果没有则为NULL</td>
</tr>
</tbody>
</table>
<h4 id="pg_file_settings"><strong>pg_file_settings</strong></h4>
<p>视图pg_file_settings提供了服务器配置文件内容的概要。默认情况下，pg_file_settings视图只有超级用户可读。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sourcefile</td>
<td>text</td>
<td>配置文件的完整路径名</td>
</tr>
<tr>
<td>sourceline</td>
<td>integer</td>
<td>该项在配置文件中出现的行号</td>
</tr>
<tr>
<td>seqno</td>
<td>integer</td>
<td>项被处理的顺序（1..n）</td>
</tr>
<tr>
<td>name</td>
<td>text</td>
<td>配置参数名</td>
</tr>
<tr>
<td>setting</td>
<td>text</td>
<td>被赋予给参数的值</td>
</tr>
<tr>
<td>applied</td>
<td>boolean</td>
<td>为真表示值已被成功应用</td>
</tr>
<tr>
<td>error</td>
<td>text</td>
<td>如果非空，表示一个错误消息，它说明为什么这个项不能被应用</td>
</tr>
</tbody>
</table>
<h4 id="pg_foreign_data_wrapper"><strong>pg_foreign_data_wrapper</strong></h4>
<p>pg_foreign_data_wrapper存储外部数据包装器定义。外部数据包装器是一种访问位于外部服务器上数据的机制。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>fdwname</td>
<td>name</td>
<td></td>
<td>外部数据包装器的名字</td>
</tr>
<tr>
<td>fdwowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>外部数据包装器的拥有者</td>
</tr>
<tr>
<td>fdwhandler</td>
<td>oid</td>
<td>pg_proc.oid</td>
<td>指一个负责为外部数据包装器提供执行例程的处理函数。如果没有提供处理函数则为0</td>
</tr>
<tr>
<td>fdwvalidator</td>
<td>oid</td>
<td>pg_proc.oid</td>
<td>指一个负责检查传给外部数据包装器的选项的有效性的验证函数，包括外部服务器选项以及使用外部数据包装器的用户映射。如果没有提供验证函数则为0</td>
</tr>
<tr>
<td>fdwacl</td>
<td>aclitem[]</td>
<td></td>
<td>访问权限，详见GRANT和REVOKE</td>
</tr>
<tr>
<td>fdwoptions</td>
<td>text[]</td>
<td></td>
<td>外部数据包装器特定选项，以“keyword=value”字符串形式</td>
</tr>
</tbody>
</table>
<h4 id="pg_foreign_server"><strong>pg_foreign_server</strong></h4>
<p>pg_foreign_server存储外部服务器定义。外部服务器定义了外部数据的来源，例如一个远程服务器。外部服务器通过外部数据包装器来访问。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>srvname</td>
<td>name</td>
<td></td>
<td>外部服务器的名字</td>
</tr>
<tr>
<td>srvowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>外部服务器的拥有者</td>
</tr>
<tr>
<td>srvfdw</td>
<td>oid</td>
<td>pg_foreign_data_wrapper.oid</td>
<td>此外部服务器的外部数据包装器的OID</td>
</tr>
<tr>
<td>srvtype</td>
<td>text</td>
<td></td>
<td>服务器的类型（可选）</td>
</tr>
<tr>
<td>srvversion</td>
<td>text</td>
<td></td>
<td>服务器的版本（可选）</td>
</tr>
<tr>
<td>srvacl</td>
<td>aclitem[]</td>
<td></td>
<td>访问权限，详见GRANT和REVOKE</td>
</tr>
<tr>
<td>srvoptions</td>
<td>text[]</td>
<td></td>
<td>外部服务器特定选项，以“keyword=value”字符串形式</td>
</tr>
</tbody>
</table>
<h4 id="pg_foreign_table"><strong>pg_foreign_table</strong></h4>
<p>pg_foreign_table包含关于外部表的辅助信息。一个外部表和普通表一样，主要由一个pg_class项表示。它的pg_foreign_table项包含外部表所特有的信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ftrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>外部表的pg_class项的OID</td>
</tr>
<tr>
<td>ftserver</td>
<td>oid</td>
<td>pg_foreign_server.oid</td>
<td>外部表所在的外部服务器的OID</td>
</tr>
<tr>
<td>ftoptions</td>
<td>text[]</td>
<td></td>
<td>外部表选项，以“keyword=value”字符串形式</td>
</tr>
</tbody>
</table>
<h4 id="pg_group"><strong>pg_group</strong></h4>
<p>视图pg_group显示所有角色的名称和未被标记rolcanlogin的成员，它是被用做组的角色集合的近似。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>groname</td>
<td>name</td>
<td>pg_authid.rolname</td>
<td>组名</td>
</tr>
<tr>
<td>grosysid</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>组ID</td>
</tr>
<tr>
<td>grolist</td>
<td>oid[]</td>
<td>pg_authid.oid</td>
<td>包含此组中角色ID的一个数组</td>
</tr>
</tbody>
</table>
<h4 id="pg_hba_file_rules"><strong>pg_hba_file_rules</strong></h4>
<p>视图pg_hba_file_rules提供客户端认证配置文件sql_hba.conf内容的摘要。该文件中每个非空、非注释行都会在这个视图中出现一行，行中还有标记表示该规则是否被成功地应用。
这个视图可用来检查认证配置文件中按计划的更改是否起作用，或者诊断之前的失败。注意这个视图报告的是该文件的当前内容，而不是服务器最后一次载入的内容。默认情况下，只有超级用户可以读取pg_hba_file_rules视图。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>line_number</td>
<td>integer</td>
<td>这条规则在sql_hba.conf中的行号</td>
</tr>
<tr>
<td>type</td>
<td>text</td>
<td>连接类型</td>
</tr>
<tr>
<td>database</td>
<td>text[]</td>
<td>这条规则应用的数据库名列表</td>
</tr>
<tr>
<td>user_name</td>
<td>text[]</td>
<td>这条规则应用的用户及组名列表</td>
</tr>
<tr>
<td>address</td>
<td>text</td>
<td>主机名或IP地址，或者all、samehost、samenet之一，对于本地连接为空</td>
</tr>
<tr>
<td>netmask</td>
<td>text</td>
<td>IP地址掩码，如果不适用则为空</td>
</tr>
<tr>
<td>auth_method</td>
<td>text</td>
<td>认证方法</td>
</tr>
<tr>
<td>options</td>
<td>text[]</td>
<td>为认证方法指定的选项（如果有）</td>
</tr>
<tr>
<td>error</td>
<td>text</td>
<td>如果非空，则是一个错误消息，它表示为什么这一行无法被处理</td>
</tr>
</tbody>
</table>
<h4 id="pg_index"><strong>pg_index</strong></h4>
<p>pg_index包含关于索引的部分信息。其他信息大部分在pg_class中。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>indexrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>此索引的pg_class项的OID</td>
</tr>
<tr>
<td>indrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>此索引的基表的pg_class项的OID</td>
</tr>
<tr>
<td>indnatts</td>
<td>int2</td>
<td></td>
<td>索引中的总列数（与pg_class.relnatts重复），这个数目包括键和被包括的属性</td>
</tr>
<tr>
<td>indnkeyatts</td>
<td>int2</td>
<td></td>
<td>索引中键列的编号，不计入任何的内含列，它们只是被存储但不参与索引的语义</td>
</tr>
<tr>
<td>indisunique</td>
<td>bool</td>
<td></td>
<td>表示是否为唯一索引</td>
</tr>
<tr>
<td>indisprimary</td>
<td>bool</td>
<td></td>
<td>表示索引是否表示表的主键（如果此列为真，indisunique也总是为真）</td>
</tr>
<tr>
<td>indisexclusion</td>
<td>bool</td>
<td></td>
<td>表示索引是否支持一个排他约束</td>
</tr>
<tr>
<td>indimmediate</td>
<td>bool</td>
<td></td>
<td>表示唯一性检查是否在插入时立即被执行（如果indisunique为假，此列无关）</td>
</tr>
<tr>
<td>indisclustered</td>
<td>bool</td>
<td></td>
<td>如果为真，表示表最后以此索引进行了聚簇</td>
</tr>
<tr>
<td>indisvalid</td>
<td>bool</td>
<td></td>
<td>如果为真，此索引当前可以用于查询。为假表示此索引可能不完整：它肯定还在被INSERT/UPDATE操作所修改，但它不能安全地被用于查询。如果索引是唯一索引，唯一性属性也不能被保证。</td>
</tr>
<tr>
<td>indcheckxmin</td>
<td>bool</td>
<td></td>
<td>如果为真，直到此pg_index行的xmin低于查询的TransactionXmin视界之前，查询都不能使用此索引，因为表可能包含具有它们可见的不相容行的损坏HOT链</td>
</tr>
<tr>
<td>indisready</td>
<td>bool</td>
<td></td>
<td>如果为真，表示此索引当前可以用于插入。为假表示索引必须被INSERT/UPDATE操作忽略。</td>
</tr>
<tr>
<td>indislive</td>
<td>bool</td>
<td></td>
<td>如果为假，索引正处于被删除过程中，并且必须被所有处理忽略（包括HOT安全的决策）</td>
</tr>
<tr>
<td>indisreplident</td>
<td>bool</td>
<td></td>
<td>如果为真，这个索引被选择为使用ALTER TABLE ... REPLICA IDENTITY USING INDEX ...的“replica identity”</td>
</tr>
<tr>
<td>indkey</td>
<td>int2vector</td>
<td>pg_attribute.attnum</td>
<td>这是一个indnatts值的数组，它表示了此索引索引的表列。例如一个1 3值可能表示表的第一和第三列组成了索引项。键列出现在非键（内含）列前面。数组中的一个0表示对应的索引属性是一个在表列上的表达式，而不是一个简单的列引用。</td>
</tr>
<tr>
<td>indcollation</td>
<td>oidvector</td>
<td>pg_collation.oid</td>
<td>对于索引键（indnkeyatts值）中的每一列，这包含要用于该索引的排序规则的OID，如果该列不是一种可排序数据类型则为零。</td>
</tr>
<tr>
<td>indclass</td>
<td>oidvector</td>
<td>pg_opclass.oid</td>
<td>对于索引键中的每一列（indnkeyatts值），这里包含了要使用的操作符类的OID。详见pg_opclass。</td>
</tr>
<tr>
<td>indoption</td>
<td>int2vector</td>
<td></td>
<td>这是一个indnkeyatts值的数组，用于存储每列的标志位。位的意义由索引的访问方法定义。</td>
</tr>
<tr>
<td>indexprs</td>
<td>pg_node_tree</td>
<td></td>
<td>非简单列引用索引属性的表达式树（以nodeToString()形式）。对于indkey中每一个为0的项，这个列表中都有一个元素。如果所有的索引属性都是简单引用，此列为空。</td>
</tr>
<tr>
<td>indpred</td>
<td>pg_node_tree</td>
<td></td>
<td>部分索引谓词的表达式树（以nodeToString()形式）。如果不是部分索引，此列为空。</td>
</tr>
</tbody>
</table>
<h4 id="pg_indexes"><strong>pg_indexes</strong></h4>
<p>视图pg_indexes提供对于数据库中每一个索引信息的访问。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>schemaname</td>
<td>name</td>
<td>pg_namespace.nspname</td>
<td>包含表和索引的模式名</td>
</tr>
<tr>
<td>tablename</td>
<td>name</td>
<td>pg_class.relname</td>
<td>此索引的基表的名字</td>
</tr>
<tr>
<td>indexname</td>
<td>name</td>
<td>pg_class.relname</td>
<td>索引名</td>
</tr>
<tr>
<td>tablespace</td>
<td>name</td>
<td>pg_tablespace.spcname</td>
<td>包含索引的表空间名（如果是数据库的默认值则为空）</td>
</tr>
<tr>
<td>indexdef</td>
<td>text</td>
<td></td>
<td>索引定义（CREATE INDEX命令的重构）</td>
</tr>
</tbody>
</table>
<h4 id="pg_inherits"><strong>pg_inherits</strong></h4>
<p>pg_inherits记录有关表继承层次的信息。数据库中每一个直接父子关系在这里都有一项（非直接继承可以通过顺着项构成的链来决定）。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>inhrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>孩子表的OID</td>
</tr>
<tr>
<td>inhparent</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>父表的OID</td>
</tr>
<tr>
<td>inhseqno</td>
<td>int4</td>
<td></td>
<td>如果一个孩子表有多于一个直接父表（多继承），这个数字说明了继承列被排列的顺序。计数从1开始。</td>
</tr>
</tbody>
</table>
<h4 id="pg_init_privs"><strong>pg_init_privs</strong></h4>
<p>pg_init_privs记录系统中对象的初始特权。数据库中每一个具有非默认（非-NULL）初始特权集合的对象都有一个条目在其中。</p>
<p>对象可以在系统初始化（initdb）时获得其初始特权，也可以在CREATE EXTENSION期间创建该对象并且在扩展脚本中用GRANT来设置对象的初始特权。注意系统将自动处理扩展脚本执行期间对特权的记录，扩展的作者们只需要在他们的脚本中使用GRANT以及REVOKE语句以便特权被记录下来。privtype列表示初始特权是被initdb设置还是在一次CREATE EXTENSION命令期间被设置。</p>
<p>具有被initdb设置的初始特权的对象的条目中privtype是'i'，而具有被CREATE EXTENSION设置的初始特权的对象的条目中privtype为'e'。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>objoid</td>
<td>oid</td>
<td>任何 OID 列</td>
<td>指定对象的 OID</td>
</tr>
<tr>
<td>classoid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>对象所在的系统目录的 OID</td>
</tr>
<tr>
<td>objsubid</td>
<td>int4</td>
<td></td>
<td>对于一个表列，这里是列编号（objoid和classoid指向表本身）。对于所有其他对象类型，这列为零。</td>
</tr>
<tr>
<td>privtype</td>
<td>char</td>
<td></td>
<td>定义这个对象初始特权类型的代码，见文字说明</td>
</tr>
<tr>
<td>initprivs</td>
<td>aclitem[]</td>
<td></td>
<td>初始的访问特权，详见GRANT和REVOKE</td>
</tr>
</tbody>
</table>
<h4 id="pg_language"><strong>pg_language</strong></h4>
<p>pg_language注册了可用于编写函数或存储过程的语言。 </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>lanname</td>
<td>name</td>
<td></td>
<td>语言的名字</td>
</tr>
<tr>
<td>lanowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>语言的拥有者</td>
</tr>
<tr>
<td>lanispl</td>
<td>bool</td>
<td></td>
<td>内部语言为假（如SQL），用户定义语言为真。当前，pg_dump仍然使用这个列来决定要转储哪些语言，但在未来这可能会被一种不同的机制所取代。</td>
</tr>
<tr>
<td>lanpltrusted</td>
<td>bool</td>
<td></td>
<td>为真表示这是一种可信的语言，即它被相信不会向普通SQL执行环境之外的任何东西授予权限。只有超级用户可以在非可信语言中创建函数。</td>
</tr>
<tr>
<td>lanplcallfoid</td>
<td>oid</td>
<td>pg_proc.oid</td>
<td>对于非内部语言，此列引用语言处理器，它是一个特殊函数负责执行所有用这种语言编写的函数</td>
</tr>
<tr>
<td>laninline</td>
<td>oid</td>
<td>pg_proc.oid</td>
<td>此列引用一个负责执行“内联”匿名代码块的函数（DO 块）。如果不支持内联块则为0。</td>
</tr>
<tr>
<td>lanvalidator</td>
<td>oid</td>
<td>pg_proc.oid</td>
<td>此列引用一个负责在函数创建时对其进行语法和可用性检查的语言验证函数。如果没有提供验证器则为0。</td>
</tr>
<tr>
<td>lanacl</td>
<td>aclitem[]</td>
<td></td>
<td>访问权限，详情参见GRANT和REVOKE</td>
</tr>
</tbody>
</table>
<h4 id="pg_largeobject"><strong>pg_largeobject</strong></h4>
<p>pg_largeobject保存构成“大对象”的数据。一个大对象在被创建时会被分配一个OID。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>loid</td>
<td>oid</td>
<td>pg_largeobject_metadata.oid</td>
<td>包含此页的大对象的标识符</td>
</tr>
<tr>
<td>pageno</td>
<td>int4</td>
<td></td>
<td>此页在它所属大对象中的页号（从0开始计）</td>
</tr>
<tr>
<td>data</td>
<td>bytea</td>
<td></td>
<td>实际存储在大对象中的数据。它从不会超过LOBLKSIZE字节，也可能更少。</td>
</tr>
</tbody>
</table>
<h4 id="pg_largeobject_metadata"><strong>pg_largeobject_metadata</strong></h4>
<p>pg_largeobject_metadata保持着与大对象有关的元数据。真正的大对象数据被存储在pg_largeobject中。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>lomowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>大对象的拥有者</td>
</tr>
<tr>
<td>lomacl</td>
<td>aclitem[]</td>
<td></td>
<td>访问权限，详见GRANT和REVOKE</td>
</tr>
</tbody>
</table>
<h4 id="pg_locks"><strong>pg_locks</strong></h4>
<p>视图pg_locks提供了数据库服务器上活动进程中保持的锁的信息。
pg_locks中对每一个活动可锁对象、请求锁模式和相关进程的组合都有一行。因此，如果多个进程持有或者正在等待一个可锁对象上的锁，同一个可锁对象可能出现很多次。但是，一个当前没有被锁的对象根本不会出现。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>locktype</td>
<td>text</td>
<td></td>
<td>可锁对象的类型： relation， extend， page， tuple， transactionid， virtualxid， object， userlock或 advisory</td>
</tr>
<tr>
<td>database</td>
<td>oid</td>
<td>pg_database.oid</td>
<td>锁目标存在的数据库的OID，如果目标是一个共享对象则为0，如果目标是一个事务ID则为空</td>
</tr>
<tr>
<td>relation</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>作为锁目标的关系的OID，如果目标不是一个关系或者只是关系的一部分则此列为空</td>
</tr>
<tr>
<td>page</td>
<td>integer</td>
<td></td>
<td>作为锁目标的页在关系中的页号，如果目标不是一个关系页或元组则此列为空</td>
</tr>
<tr>
<td>tuple</td>
<td>smallint</td>
<td></td>
<td>作为锁目标的元组在页中的元组号，如果目标不是一个元组则此列为空</td>
</tr>
<tr>
<td>virtualxid</td>
<td>text</td>
<td></td>
<td>作为锁目标的事务虚拟ID，如果目标不是一个虚拟事务ID则此列为空</td>
</tr>
<tr>
<td>transactionid</td>
<td>xid</td>
<td></td>
<td>作为锁目标的事务ID，如果目标不是一个事务ID则此列为空ID</td>
</tr>
<tr>
<td>classid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>包含锁目标的系统目录的OID，如果目标不是一个普通数据库对象则此列为空</td>
</tr>
<tr>
<td>objid</td>
<td>oid</td>
<td>任意OID列</td>
<td>锁目标在它的系统目录中的OID，如果目标不是一个普通数据库对象则为空</td>
</tr>
<tr>
<td>objsubid</td>
<td>smallint</td>
<td></td>
<td>锁的目标列号（classid和objid指表本身），如果目标是某种其他普通数据库对象则此列为0，如果目标不是一个普通数据库对象则此列为空</td>
</tr>
<tr>
<td>virtualtransaction</td>
<td>text</td>
<td></td>
<td>保持这个锁或者正在等待这个锁的事务的虚拟ID</td>
</tr>
<tr>
<td>pid</td>
<td>integer</td>
<td></td>
<td>保持这个锁或者正在等待这个锁的服务器进程的PID，如果此锁被一个预备事务所持有则此列为空</td>
</tr>
<tr>
<td>mode</td>
<td>text</td>
<td></td>
<td>此进程已持有或者希望持有的锁模式</td>
</tr>
<tr>
<td>granted</td>
<td>boolean</td>
<td></td>
<td>如果锁已授予则为真，如果锁被等待则为假</td>
</tr>
<tr>
<td>fastpath</td>
<td>boolean</td>
<td></td>
<td>如果锁通过快速路径获得则为真，通过主锁表获得则为假</td>
</tr>
</tbody>
</table>
<h4 id="pg_matviews"><strong>pg_matviews</strong></h4>
<p>视图pg_matviews提供了关于数据库中每一个物化视图的信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>schemaname</td>
<td>name</td>
<td>pg_namespace.nspname</td>
<td>包含物化视图的模式的名字</td>
</tr>
<tr>
<td>matviewname</td>
<td>name</td>
<td>pg_class.relname</td>
<td>物化视图的名字</td>
</tr>
<tr>
<td>matviewowner</td>
<td>name</td>
<td>pg_authid.rolname</td>
<td>物化视图拥有者的名字</td>
</tr>
<tr>
<td>tablespace</td>
<td>name</td>
<td>pg_tablespace.spcname</td>
<td>包含物化视图的表空间名（如使用数据库默认表空间则为空）</td>
</tr>
<tr>
<td>hasindexes</td>
<td>boolean</td>
<td></td>
<td>如果物化视图有（或者最近有过）任何索引，则此列为真</td>
</tr>
<tr>
<td>ispopulated</td>
<td>boolean</td>
<td></td>
<td>如果物化视图当前已被填充，则此列为真</td>
</tr>
<tr>
<td>definition</td>
<td>text</td>
<td></td>
<td>物化视图的定义（一个重构的SELECT查询）</td>
</tr>
</tbody>
</table>
<h4 id="pg_namespace"><strong>pg_namespace</strong></h4>
<p>pg_namespace存储名字空间。名字空间是SQL模式之下的结构：每个名字空间拥有一个独立的表、类型等的集合，且其中没有名字冲突。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>nspname</td>
<td>name</td>
<td></td>
<td>名字空间的名字</td>
</tr>
<tr>
<td>nspowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>名字空间的拥有者</td>
</tr>
<tr>
<td>nspacl</td>
<td>aclitem[]</td>
<td></td>
<td>访问权限，详见GRANT和REVOKE</td>
</tr>
</tbody>
</table>
<h4 id="pg_opclass"><strong>pg_opclass</strong></h4>
<p>pg_opclass定义索引访问方法的操作符类。每一个操作符类定义了一种特定数据类型和一种特定索引访问方法的索引列的语义。一个操作符类实际上指定了一个特定的操作符族可以用于一个特定可索引列数据类型。该族中可用于索引列的操作符能够接受该列的数据类型作为它们的左输入。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>opcmethod</td>
<td>oid</td>
<td>pg_am.oid</td>
<td>操作符类所属的索引访问方法</td>
</tr>
<tr>
<td>opcname</td>
<td>name</td>
<td></td>
<td>操作符类的名称</td>
</tr>
<tr>
<td>opcnamespace</td>
<td>oid</td>
<td>pg_namespace.oid</td>
<td>操作符类所属的名字空间</td>
</tr>
<tr>
<td>opcowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>操作符类的拥有者</td>
</tr>
<tr>
<td>opcfamily</td>
<td>oid</td>
<td>pg_opfamily.oid</td>
<td>包含此操作符类的操作符族</td>
</tr>
<tr>
<td>opcintype</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>操作符类索引的数据类型</td>
</tr>
<tr>
<td>opcdefault</td>
<td>bool</td>
<td></td>
<td>如果此操作符类为opcintype的默认值则为真</td>
</tr>
<tr>
<td>opckeytype</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>存储在索引中的数据的类型，如果值为0表示与opcintype相同</td>
</tr>
</tbody>
</table>
<h4 id="pg_operator"><strong>pg_operator</strong></h4>
<p>pg_operator存储关于操作符的信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>oprname</td>
<td>name</td>
<td></td>
<td>操作符的名称</td>
</tr>
<tr>
<td>oprnamespace</td>
<td>oid</td>
<td>pg_namespace.oid</td>
<td>操作符所属的名字空间的OID</td>
</tr>
<tr>
<td>oprowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>操作符的拥有者</td>
</tr>
<tr>
<td>oprkind</td>
<td>char</td>
<td></td>
<td>b = 中缀 (“并”), l = 前缀 (“左”), r = 后缀 (“右”)</td>
</tr>
<tr>
<td>oprcanmerge</td>
<td>bool</td>
<td></td>
<td>该操作符是否支持归并连接</td>
</tr>
<tr>
<td>oprcanhash</td>
<td>bool</td>
<td></td>
<td>该操作符是否支持哈希连接</td>
</tr>
<tr>
<td>oprleft</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>左操作数类型</td>
</tr>
<tr>
<td>oprright</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>右操作数类型</td>
</tr>
<tr>
<td>oprresult</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>结果类型</td>
</tr>
<tr>
<td>oprcom</td>
<td>oid</td>
<td>pg_operator.oid</td>
<td>该操作符的交换子（如果存在）</td>
</tr>
<tr>
<td>oprnegate</td>
<td>oid</td>
<td>pg_operator.oid</td>
<td>该操作符的否定（如果存在）</td>
</tr>
<tr>
<td>oprcode</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>实现该操作符的函数</td>
</tr>
<tr>
<td>oprrest</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>该操作符的限制选择度估算函数</td>
</tr>
<tr>
<td>oprjoin</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>该操作符的连接选择度估算函数</td>
</tr>
</tbody>
</table>
<h4 id="pg_opfamily"><strong>pg_opfamily</strong></h4>
<p>pg_opfamily定义了操作符族。每一个操作符族是操作符和相关支持例程的集合，支持例程用于实现一个特定索引访问方法的语义。此外，按照访问方法指定的某种方式，一个族内的操作符都是“兼容的”。操作符族概念允许在索引中使用跨数据类型操作符，并可以使用访问方法语义的知识推导出。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>opfmethod</td>
<td>oid</td>
<td>pg_am.oid</td>
<td>操作符族适用的索引访问方法</td>
</tr>
<tr>
<td>opfname</td>
<td>name</td>
<td></td>
<td>操作符族的名字</td>
</tr>
<tr>
<td>opfnamespace</td>
<td>oid</td>
<td>pg_namespace.oid</td>
<td>操作符族所属的名字空间</td>
</tr>
<tr>
<td>opfowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>操作符族的拥有者</td>
</tr>
</tbody>
</table>
<h4 id="pg_partitioned_table"><strong>pg_partitioned_table</strong></h4>
<p>pg_partitioned_table存放有关表如何被分区的信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>partrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>这个分区表的pg_class项的OID</td>
</tr>
<tr>
<td>partstrat</td>
<td>char</td>
<td></td>
<td>分区策略；h = 哈希分区表，l = 列表分区表，r = 范围分区表</td>
</tr>
<tr>
<td>partnatts</td>
<td>int2</td>
<td></td>
<td>分区键中的列数</td>
</tr>
<tr>
<td>partdefid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>这个分区表的默认分区的pg_class项的OID，如果这个分区表没有默认分区则为零。</td>
</tr>
<tr>
<td>partattrs</td>
<td>int2vector</td>
<td>pg_attribute.attnum</td>
<td>这是一个长度为partnatts值的数组，它指示哪些表列是分区键的组成部分。例如，值1 3表示第一个和第三个表列组成了分区键。这个数组中的零表示对应的分区键列是一个表达式而不是简单的列引用。</td>
</tr>
<tr>
<td>partclass</td>
<td>oidvector</td>
<td>pg_opclass.oid</td>
<td>对于分区键中的每一个列，这个域包含要使用的操作符类的OID。详见pg_opclass。</td>
</tr>
<tr>
<td>partcollation</td>
<td>oidvector</td>
<td>pg_opclass.oid</td>
<td>对于分区键中的每一个列，这个域包含要用于分区的排序规则的OID，如果该列不是一种可排序数据类型则为零。</td>
</tr>
<tr>
<td>partexprs</td>
<td>pg_node_tree</td>
<td></td>
<td>非简单列引用的分区键列的表达式树（以nodeToString()的表达方式）。这是一个列表，partattrs中每一个零项都有一个元素。如果所有分区键列都是简单列引用，则这个域为空。</td>
</tr>
</tbody>
</table>
<h4 id="pg_pltemplate"><strong>pg_pltemplate</strong></h4>
<p>pg_pltemplate存储了过程语言的“模板”信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>tmplname</td>
<td>name</td>
<td>该模板适用的语言名字</td>
</tr>
<tr>
<td>tmpltrusted</td>
<td>boolean</td>
<td>如果语言被认为是可信的则为真</td>
</tr>
<tr>
<td>tmpldbacreate</td>
<td>boolean</td>
<td>如果语言可以被一个数据库拥有者创建则为真</td>
</tr>
<tr>
<td>tmplhandler</td>
<td>text</td>
<td>调用处理函数的名字</td>
</tr>
<tr>
<td>tmplinline</td>
<td>text</td>
<td>匿名阻塞处理函数的名字，如果没有则为空</td>
</tr>
<tr>
<td>tmplvalidator</td>
<td>text</td>
<td>验证函数的名字，如果没有则为空</td>
</tr>
<tr>
<td>tmpllibrary</td>
<td>text</td>
<td>实现语言的共享库的路径</td>
</tr>
<tr>
<td>tmplacl</td>
<td>aclitem[]</td>
<td>模板的访问权限（并未真正使用）</td>
</tr>
</tbody>
</table>
<h4 id="pg_policies"><strong>pg_policies</strong></h4>
<p>pg_policies提供了有关数据库中行级安全性策略的信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>schemaname</td>
<td>name</td>
<td>pg_namespace.nspname</td>
<td>包含策略所在表的模式的名称</td>
</tr>
<tr>
<td>tablename</td>
<td>name</td>
<td>pg_class.relname</td>
<td>策略所在表的名称</td>
</tr>
<tr>
<td>policyname</td>
<td>name</td>
<td>pg_policy.polname</td>
<td>策略名称</td>
</tr>
<tr>
<td>polpermissive</td>
<td>text</td>
<td></td>
<td>策略是宽容性的还是限制性的？</td>
</tr>
<tr>
<td>roles</td>
<td>name[]</td>
<td></td>
<td>这个策略适用的角色</td>
</tr>
<tr>
<td>cmd</td>
<td>text</td>
<td></td>
<td>这个策略适用的命令类型</td>
</tr>
<tr>
<td>qual</td>
<td>text</td>
<td></td>
<td>作为这个策略适用的查询的安全屏障条件增加的表达式</td>
</tr>
<tr>
<td>with_check</td>
<td>text</td>
<td></td>
<td>作为尝试向该表增加行的查询的 WITH CHECK 条件增加的表达式</td>
</tr>
</tbody>
</table>
<h4 id="pg_policy"><strong>pg_policy</strong></h4>
<p>pg_policy存储着表的行级安全性策略。 一个策略包括它适用于的命令种类（可能适用于所有命令）、它适用于的角色、 被作为安全屏障条件增加到包括该表的查询的表达式以及被作为 WITH CHECK选项增加到尝试向表增加新纪录的查询的表达式。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>polname</td>
<td>name</td>
<td></td>
<td>策略的名称</td>
</tr>
<tr>
<td>polrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>策略适用的表</td>
</tr>
<tr>
<td>polcmd</td>
<td>char</td>
<td></td>
<td>策略适用的命令类型： r表示SELECT， a表示INSERT， w表示UPDATE， d表示DELETE， *表示所有命令类型</td>
</tr>
<tr>
<td>polpermissive</td>
<td>boolean</td>
<td></td>
<td>策略是宽容性的还是限制性的？</td>
</tr>
<tr>
<td>polroles</td>
<td>oid[]</td>
<td>pg_authid.oid</td>
<td>策略适用的角色</td>
</tr>
<tr>
<td>polqual</td>
<td>pg_node_tree</td>
<td></td>
<td>被作为安全屏障条件增加到使用该表的查询的表达式树</td>
</tr>
<tr>
<td>polwithcheck</td>
<td>pg_node_tree</td>
<td></td>
<td>被作为WITH CHECK 条件增加到尝试向表增加行的查询的表达式树</td>
</tr>
</tbody>
</table>
<h4 id="pg_prepared_statements"><strong>pg_prepared_statements</strong></h4>
<p>pg_prepared_statements视图显示在当前会话中可用的所有预备语句。
pg_prepared_statements为每一个预备语句包含一行。当一个新的预备语句被创建时在此视图中会增加一行，反之当一个预备语句被释放时在此视图中会删除一行（例如，通过DEALLOCATE命令）。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>text</td>
<td>预备语句的标识符</td>
</tr>
<tr>
<td>statement</td>
<td>text</td>
<td>客户端提交用于创建此预备语句的查询语句。对于通过SQL创建的预备语句，这里是由客户端提交的PREPARE语句。对于通过前端/后端协议创建的预备语句，这里是预备语句本身的文本。</td>
</tr>
<tr>
<td>prepare_time</td>
<td>timestamptz</td>
<td>预备语句被创建的时间</td>
</tr>
<tr>
<td>parameter_types</td>
<td>regtype[]</td>
<td>预备语句期望的参数类型，以一个regtype数组的形式。这个数组中一个元素所对应的OID可通过将regtype值转换为oid获得。</td>
</tr>
<tr>
<td>from_sql</td>
<td>boolean</td>
<td>如果预备语句通过SQL命令PREPARE创建，则为true；如果预备语句通过前端/后端协议创建，则为false</td>
</tr>
</tbody>
</table>
<h4 id="pg_prepared_xacts"><strong>pg_prepared_xacts</strong></h4>
<p>视图pg_prepared_xacts显示关于两阶段提交（详见PREPARE TRANSACTION）的当前准备好事务的信息。
pg_prepared_xacts为每一个预备事务包含一行。当事务被提交或回滚时，相应的项将被移除。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>transaction</td>
<td>xid</td>
<td></td>
<td>预备事务的数字事务标识符</td>
</tr>
<tr>
<td>gid</td>
<td>text</td>
<td></td>
<td>分配给事务的全局标识符</td>
</tr>
<tr>
<td>prepared</td>
<td>timestamp with time zone</td>
<td></td>
<td>此事务为提交准备好的时间</td>
</tr>
<tr>
<td>owner</td>
<td>name</td>
<td>pg_authid.rolname</td>
<td>执行此事务的用户名</td>
</tr>
<tr>
<td>database</td>
<td>name</td>
<td>pg_database.datname</td>
<td>执行此事务所在数据库的名字</td>
</tr>
</tbody>
</table>
<p>​             </p>
<h4 id="pg_proc"><strong>pg_proc</strong></h4>
<p>pg_proc存放有关函数、过程、聚集函数以及窗口函数（共称为例程）的信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>proname</td>
<td>name</td>
<td></td>
<td>函数的名字</td>
</tr>
<tr>
<td>pronamespace</td>
<td>oid</td>
<td>pg_namespace.oid</td>
<td>函数所属的名字空间的OID</td>
</tr>
<tr>
<td>proowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>函数的拥有者</td>
</tr>
<tr>
<td>prolang</td>
<td>oid</td>
<td>pg_language.oid</td>
<td>实现语言或该函数的调用接口</td>
</tr>
<tr>
<td>procost</td>
<td>float4</td>
<td></td>
<td>估计的执行代价（以cpu_operator_cost为单位），如果proretset为真，这是每行返回的代价</td>
</tr>
<tr>
<td>prorows</td>
<td>float4</td>
<td></td>
<td>估计的结果行数量（如果proretset为假，该值为0）</td>
</tr>
<tr>
<td>provariadic</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>可变数组参数的元素的数据类型，如果函数没有可变参数则为0</td>
</tr>
<tr>
<td>protransform</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>调用该函数时可以通过此列指定的函数来简化（见第 38.10.10 节）</td>
</tr>
<tr>
<td>prokind</td>
<td>char</td>
<td></td>
<td>f表示普通函数，p表示过程，a表示聚集函数，w表示窗口函数</td>
</tr>
<tr>
<td>prosecdef</td>
<td>bool</td>
<td></td>
<td>函数是一个安全性定义者（即，一个“setuid”函数）</td>
</tr>
<tr>
<td>proleakproof</td>
<td>bool</td>
<td></td>
<td>该函数没有副作用。除了通过返回值，没有关于参数的信息被传播。任何会抛出基于其参数值的错误信息的函数都不是泄露验证的。</td>
</tr>
<tr>
<td>proisstrict</td>
<td>bool</td>
<td></td>
<td>当任意调用函数为空时，函数是否会返回空值。在那种情况下函数实际上根本不会被调用。非“strict”函数必须准备好处理空值输入。</td>
</tr>
<tr>
<td>proretset</td>
<td>bool</td>
<td></td>
<td>函数是否返回一个集合（即，指定数据类型的多个值）</td>
</tr>
<tr>
<td>provolatile</td>
<td>char</td>
<td></td>
<td>provolatile说明函数是仅仅只依赖于它的输入参数，还是会被外部因素影响。值i表示“不变的”函数，它对于相同的输入总是输出相同的结果。值s表示“稳定的”函数，它的结果（对于固定输入）在一次扫描内不会变化。值v表示“不稳定的”函数，它的结果在任何时候都可能变化（使用v页表示函数具有副作用，所以对它们的调用无法得到优化）</td>
</tr>
<tr>
<td>proparallel</td>
<td>char</td>
<td></td>
<td>proparallel说明该函数在并行模式下是否能安全地运行。对于能在并行模式下不受限制安全运行的函数，这列是s。对于可以在并行模式下运行但是只限于由并行分组的领导者执行的函数，这列是r。对于在并行模式中不安全的函数，这列是u，这种函数的存在会强制一个顺序执行计划。</td>
</tr>
<tr>
<td>pronargs</td>
<td>int2</td>
<td></td>
<td>输入参数的个数</td>
</tr>
<tr>
<td>pronargdefaults</td>
<td>int2</td>
<td></td>
<td>具有默认值的参数个数</td>
</tr>
<tr>
<td>prorettype</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>返回值的数据类型</td>
</tr>
<tr>
<td>proargtypes</td>
<td>oidvector</td>
<td>pg_type.oid</td>
<td>一个函数参数的数据类型的数组。这只包括输入参数（含INOUT和VARIADIC参数），因此也表现了函数的调用特征。</td>
</tr>
<tr>
<td>proallargtypes</td>
<td>oid[]</td>
<td>pg_type.oid</td>
<td>一个函数参数的数据类型的数组。这包括所有参数（含OUT和INOUT参数）。但是，如果所有参数都是IN参数，这个域将为空。注意下标是从1开始 ，然而由于历史原因proargtypes的下标是从0开始。</td>
</tr>
<tr>
<td>proargmodes</td>
<td>char[]</td>
<td></td>
<td>一个函数参数的模式的数组。编码为： i表示IN参数 ， o表示OUT参数， b表示INOUT参数， v表示VARIADIC参数， t表示TABLE参数。 如果所有的参数都是IN参数，这个域为空。注意这里的下标对应着proallargtypes而不是proargtypes中的位置。</td>
</tr>
<tr>
<td>proargnames</td>
<td>text[]</td>
<td></td>
<td>一个函数参数的名字的数组。没有名字的参数在数组中设置为空字符串。如果没有一个参数有名字，这个域为空。注意这里的下标对应着proallargtypes而不是proargtypes中的位置。</td>
</tr>
<tr>
<td>proargdefaults</td>
<td>pg_node_tree</td>
<td></td>
<td>默认值的表达式树（按照nodeToString()的表现方式）。这是一个pronargdefaults元素的列表，对应于最后N个input参数（即最后N个proargtypes位置）。如果没有一个参数具有默认值，这个域为空。</td>
</tr>
<tr>
<td>protrftypes</td>
<td>oid[]</td>
<td></td>
<td>要在其上应用转换的数据类型的 OID。</td>
</tr>
<tr>
<td>prosrc</td>
<td>text</td>
<td></td>
<td>这个域告诉函数处理者如何调用该函数。它可能是针对解释型语言的真实源码、一个符号链接、一个文件名或任何其他东西，这取决于实现语言/调用规范。</td>
</tr>
<tr>
<td>probin</td>
<td>text</td>
<td></td>
<td>关于如何调用函数的附加信息。其解释是与语言相关的。</td>
</tr>
<tr>
<td>proconfig</td>
<td>text[]</td>
<td></td>
<td>函数对于运行时配置变量的本地设置值</td>
</tr>
<tr>
<td>proacl</td>
<td>aclitem[]</td>
<td></td>
<td>访问权限，详见GRANT和REVOKE</td>
</tr>
</tbody>
</table>
<h4 id="pg_publication"><strong>pg_publication</strong></h4>
<p>pg_publication包含数据库中创建的所有publication。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择）</td>
</tr>
<tr>
<td>pubname</td>
<td>name</td>
<td></td>
<td>publication的名称</td>
</tr>
<tr>
<td>pubowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>publication的拥有者</td>
</tr>
<tr>
<td>puballtables</td>
<td>bool</td>
<td></td>
<td>如果为真，这个publication自动包括数据库中的所有表，包括未来将会创建的任何表。</td>
</tr>
<tr>
<td>pubinsert</td>
<td>bool</td>
<td></td>
<td>如果为真，为publication中的表复制INSERT操作。</td>
</tr>
<tr>
<td>pubupdate</td>
<td>bool</td>
<td></td>
<td>如果为真，为publication中的表复制UPDATE操作。</td>
</tr>
<tr>
<td>pubdelete</td>
<td>bool</td>
<td></td>
<td>如果为真，为publication中的表复制DELETE操作。</td>
</tr>
<tr>
<td>pubtruncate</td>
<td>bool</td>
<td></td>
<td>如果为真，为publication中的表复制TRUNCATE操作。</td>
</tr>
</tbody>
</table>
<h4 id="pg_publication_rel"><strong>pg_publication_rel</strong></h4>
<p>pg_publication_rel包含数据库中关系和publication之间的映射。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>prpubid</td>
<td>oid</td>
<td>pg_publication.oid</td>
<td>对publication的引用</td>
</tr>
<tr>
<td>prrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>对关系的引用</td>
</tr>
</tbody>
</table>
<h4 id="pg_publication_tables"><strong>pg_publication_tables</strong></h4>
<p>视图pg_publication_tables提供publication与其所包含的表之间的映射信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pubname</td>
<td>name</td>
<td>pg_publication.pubname</td>
<td>publication名称</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>pg_namespace.nspname</td>
<td>包含表的方案名称</td>
</tr>
<tr>
<td>tablename</td>
<td>name</td>
<td>pg_class.relname</td>
<td>表名</td>
</tr>
</tbody>
</table>
<h4 id="pg_range"><strong>pg_range</strong></h4>
<p>目录pg_range存储关于范围类型的信息。它是类型在pg_type中项的补充。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rngtypid</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>范围类型的OID</td>
</tr>
<tr>
<td>rngsubtype</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>该范围类型的元素类型（子类型）的OID</td>
</tr>
<tr>
<td>rngcollation</td>
<td>oid</td>
<td>pg_collation.oid</td>
<td>用于范围比较的排序规则的OID，如果没有则为0</td>
</tr>
<tr>
<td>rngsubopc</td>
<td>oid</td>
<td>pg_opclass.oid</td>
<td>用于范围比较的子类型的操作符类的OID</td>
</tr>
<tr>
<td>rngcanonical</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>将一个范围值转换为规范形式的函数的OID，如果没有则为0</td>
</tr>
<tr>
<td>rngsubdiff</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>以双精度返回两个元素值不同的函数的OID，如果没有则为0</td>
</tr>
</tbody>
</table>
<h4 id="pg_replication_origin"><strong>pg_replication_origin</strong></h4>
<p>pg_replication_origin目录包含所有已创建的复制源。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>roident</td>
<td>oid</td>
<td></td>
<td>一个集簇范围内唯一的复制源标识符。应该绝不会脱离系统。</td>
</tr>
<tr>
<td>roname</td>
<td>text</td>
<td></td>
<td>外部的由用户定义的复制源名称。</td>
</tr>
</tbody>
</table>
<h4 id="pg_replication_origin_status"><strong>pg_replication_origin_status</strong></h4>
<p>pg_replication_origin_status视图包含有关一个特定源已经重放了多少的信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>local_id</td>
<td>oid</td>
<td>pg_replication_origin.roident</td>
<td>内部的节点标识符</td>
</tr>
<tr>
<td>external_id</td>
<td>text</td>
<td>pg_replication_origin.roname</td>
<td>外部的节点标识符</td>
</tr>
<tr>
<td>remote_lsn</td>
<td>pg_lsn</td>
<td></td>
<td>源节点的 LSN，到这个位置的数据都已经被复制。</td>
</tr>
<tr>
<td>local_lsn</td>
<td>pg_lsn</td>
<td></td>
<td>这个节点的 LSN，remote_lsn已经被复制到这里。使用异步提交时，在将数据持久化到磁盘前用它来刷入提交记录。</td>
</tr>
</tbody>
</table>
<h4 id="pg_replication_slots"><strong>pg_replication_slots</strong></h4>
<p>pg_replication_slots视图提供了当前存在于数据库集簇上的所有复制槽的列表，其中也包括复制槽的当前状态。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>slot_name</td>
<td>name</td>
<td></td>
<td>一个唯一的、集簇范围内的复制槽标识符</td>
</tr>
<tr>
<td>plugin</td>
<td>name</td>
<td></td>
<td>包含这个逻辑槽正在使用的输出插件的共享对象基础名称，这个列对于物理槽为空值。</td>
</tr>
<tr>
<td>slot_type</td>
<td>text</td>
<td></td>
<td>槽类型 - physical（物理）或者logical（逻辑）</td>
</tr>
<tr>
<td>datoid</td>
<td>oid</td>
<td>pg_database.oid</td>
<td>与这个槽相关的数据库的OID，或者为空值。只有逻辑槽具有相关的数据库。</td>
</tr>
<tr>
<td>database</td>
<td>text</td>
<td>pg_database.datname</td>
<td>与这个槽相关的数据库的名称，或者为空值。只有逻辑槽具有相关的数据库。</td>
</tr>
<tr>
<td>temporary</td>
<td>boolean</td>
<td></td>
<td>如果这是一个临时复制槽则为真。临时槽不会被保存在磁盘上并且会在出错或会话结束时自动被删除掉。</td>
</tr>
<tr>
<td>active</td>
<td>boolean</td>
<td></td>
<td>如果这个槽当前正在被使用则为真</td>
</tr>
<tr>
<td>active_pid</td>
<td>integer</td>
<td></td>
<td>如果槽当前正在被使用，则记录使用这个槽的会话的进程 ID。如果槽没有被使用则为NULL。</td>
</tr>
<tr>
<td>xmin</td>
<td>xid</td>
<td></td>
<td>这个槽要需要数据库保留的最旧事务。VACUUM不能移除被其后续事务删除的元组。</td>
</tr>
<tr>
<td>catalog_xmin</td>
<td>xid</td>
<td></td>
<td>这个槽要需要数据库保留的影响系统目录的最旧事务。VACUUM不能移除被其后续事务删除的目录元组。</td>
</tr>
<tr>
<td>restart_lsn</td>
<td>pg_lsn</td>
<td></td>
<td>可能仍被这个槽的消费者要求的最旧WAL地址（LSN），并且因此不会在检查点期间自动被移除。如果这个槽的LSN从未被保留过，则为NULL。</td>
</tr>
<tr>
<td>confirmed_flush_lsn</td>
<td>pg_lsn</td>
<td></td>
<td>代表逻辑槽的消费者已经确认接收数据到什么位置的地址（LSN）。比这个地址更旧的数据已经不再可用。对于物理槽这里是NULL。</td>
</tr>
</tbody>
</table>
<h4 id="pg_rewrite"><strong>pg_rewrite</strong></h4>
<p>pg_rewrite存储对于表和视图的重写规则。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>rulename</td>
<td>name</td>
<td></td>
<td>规则名称</td>
</tr>
<tr>
<td>ev_class</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>使用该规则的表</td>
</tr>
<tr>
<td>ev_type</td>
<td>char</td>
<td></td>
<td>使用该规则的事件类型：1 = SELECT，2 = UPDATE，3 = INSERT，4 = DELETE</td>
</tr>
<tr>
<td>ev_enabled</td>
<td>char</td>
<td></td>
<td>控制在哪种session_replication_role模式中触发该规则。 O = 规则在“origin”和“local”模式触发， D = 规则被禁用， R = 规则在“replica”模式触发， A = 规则总是被触发。</td>
</tr>
<tr>
<td>is_instead</td>
<td>bool</td>
<td></td>
<td>为真表示是一个INSTEAD规则</td>
</tr>
<tr>
<td>ev_qual</td>
<td>pg_node_tree</td>
<td></td>
<td>规则条件的表达式树（按照nodeToString()的表现形式）</td>
</tr>
<tr>
<td>ev_action</td>
<td>pg_node_tree</td>
<td></td>
<td>规则动作的查询树（按照nodeToString()的表现形式）</td>
</tr>
</tbody>
</table>
<h4 id="pg_roles"><strong>pg_roles</strong></h4>
<p>视图pg_roles提供了关于数据库角色的信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>rolname</td>
<td>name</td>
<td></td>
<td>角色名</td>
</tr>
<tr>
<td>rolsuper</td>
<td>bool</td>
<td></td>
<td>角色是否具有超级用户权限？</td>
</tr>
<tr>
<td>rolinherit</td>
<td>bool</td>
<td></td>
<td>如果此角色是另一个角色的成员，角色是否能自动继承另一个角色的权限？</td>
</tr>
<tr>
<td>rolcreaterole</td>
<td>bool</td>
<td></td>
<td>角色能否创建更多角色？</td>
</tr>
<tr>
<td>rolcreatedb</td>
<td>bool</td>
<td></td>
<td>角色能否创建数据库？</td>
</tr>
<tr>
<td>rolcanlogin</td>
<td>bool</td>
<td></td>
<td>角色是否能登录？即此角色能否被作为初始会话授权标识符？</td>
</tr>
<tr>
<td>rolreplication</td>
<td>bool</td>
<td></td>
<td>角色是一个复制角色。复制角色可以开启复制连接并且创建和删除复制槽。</td>
</tr>
<tr>
<td>rolconnlimit</td>
<td>int4</td>
<td></td>
<td>对于一个可登录的角色，这里设置角色可以发起的最大并发连接数。-1表示无限制。</td>
</tr>
<tr>
<td>rolpassword</td>
<td>text</td>
<td></td>
<td>不是口令（看起来是）</td>
</tr>
<tr>
<td>rolvaliduntil</td>
<td>timestamptz</td>
<td></td>
<td>口令失效时间（只用于口令认证），如果永不失效则为空</td>
</tr>
<tr>
<td>rolbypassrls</td>
<td>bool</td>
<td></td>
<td>绕过每一条行级安全性策略的角色，详见第 5.7 节。</td>
</tr>
<tr>
<td>rolconfig</td>
<td>text[]</td>
<td></td>
<td>运行时配置变量的角色特定默认值</td>
</tr>
<tr>
<td>oid</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>角色的ID</td>
</tr>
</tbody>
</table>
<h4 id="pg_rules"><strong>pg_rules</strong></h4>
<p>视图pg_rules提供对查询重写规则的信息访问。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>schemaname</td>
<td>name</td>
<td>pg_namespace.nspname</td>
<td>包含表的模式名</td>
</tr>
<tr>
<td>tablename</td>
<td>name</td>
<td>pg_class.relname</td>
<td>规则适用的表名</td>
</tr>
<tr>
<td>rulename</td>
<td>name</td>
<td>pg_rewrite.rulename</td>
<td>规则名</td>
</tr>
<tr>
<td>definition</td>
<td>text</td>
<td></td>
<td>规则定义（创建命令的重构）</td>
</tr>
</tbody>
</table>
<h4 id="pg_seclabel"><strong>pg_seclabel</strong></h4>
<p>pg_seclabel存储数据库对象上的安全标签。安全标签可以通过SECURITY LABEL命令操纵。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>objoid</td>
<td>oid</td>
<td>任意OID列</td>
<td>该安全标签依附的对象的OID</td>
</tr>
<tr>
<td>classoid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>该对象所出现的系统目录的OID</td>
</tr>
<tr>
<td>objsubid</td>
<td>int4</td>
<td></td>
<td>对于一个在表列上的安全标签，这将是列号（objoid和classoid指表本身）。对于所有其他对象类型，本列为0。</td>
</tr>
<tr>
<td>provider</td>
<td>text</td>
<td></td>
<td>与该标签相关的标签提供者。</td>
</tr>
<tr>
<td>label</td>
<td>text</td>
<td></td>
<td>应用于该对象的安全标签。</td>
</tr>
</tbody>
</table>
<h4 id="pg_seclabels"><strong>pg_seclabels</strong></h4>
<p>视图pg_seclabels提供对安全标签的信息访问。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>objoid</td>
<td>oid</td>
<td>任意OID列</td>
<td>安全标签所属对象的OID</td>
</tr>
<tr>
<td>classoid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>对象出现的系统目录的OID</td>
</tr>
<tr>
<td>objsubid</td>
<td>int4</td>
<td></td>
<td>对于一个表列上的安全标签，这里是列号（objoid和classoid指表本身）。对于所有其他对象类型，此列为0。</td>
</tr>
<tr>
<td>objtype</td>
<td>text</td>
<td></td>
<td>此标签应用的对象类型，以文本方式。</td>
</tr>
<tr>
<td>objnamespace</td>
<td>oid</td>
<td>pg_namespace.oid</td>
<td>如果适用，为此对象的名字空间的OID；否则为空。</td>
</tr>
<tr>
<td>objname</td>
<td>text</td>
<td></td>
<td>此标签应用的对象名，以文本形式。</td>
</tr>
<tr>
<td>provider</td>
<td>text</td>
<td>pg_seclabel.provider</td>
<td>与此标签相关的标签提供者。</td>
</tr>
<tr>
<td>label</td>
<td>text</td>
<td>pg_seclabel.label</td>
<td>应用于此对象的安全标签。</td>
</tr>
</tbody>
</table>
<h4 id="pg_sequence"><strong>pg_sequence</strong></h4>
<p>pg_sequence包含有关序列的信息。一些序列的信息（例如名称和方案）放在pg_class中。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>seqrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>这个序列的pg_class项的OID</td>
</tr>
<tr>
<td>seqtypid</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>序列的数据类型</td>
</tr>
<tr>
<td>seqstart</td>
<td>int8</td>
<td></td>
<td>序列的起始值</td>
</tr>
<tr>
<td>seqincrement</td>
<td>int8</td>
<td></td>
<td>序列的增量值</td>
</tr>
<tr>
<td>seqmax</td>
<td>int8</td>
<td></td>
<td>序列的最大值</td>
</tr>
<tr>
<td>seqmin</td>
<td>int8</td>
<td></td>
<td>序列的最小值</td>
</tr>
<tr>
<td>seqcache</td>
<td>int8</td>
<td></td>
<td>序列的缓冲尺寸</td>
</tr>
<tr>
<td>seqcycle</td>
<td>bool</td>
<td></td>
<td>序列是否循环</td>
</tr>
</tbody>
</table>
<h4 id="pg_sequences"><strong>pg_sequences</strong></h4>
<p>视图pg_sequences提供对数据库中每个序列的信息的访问。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>schemaname</td>
<td>name</td>
<td>pg_namespace.nspname</td>
<td>包含序列的方案名</td>
</tr>
<tr>
<td>sequencename</td>
<td>name</td>
<td>pg_class.relname</td>
<td>序列的名称</td>
</tr>
<tr>
<td>sequenceowner</td>
<td>name</td>
<td>pg_authid.rolname</td>
<td>序列的拥有者的名称</td>
</tr>
<tr>
<td>data_type</td>
<td>regtype</td>
<td>pg_type.oid</td>
<td>序列的数据类型</td>
</tr>
<tr>
<td>start_value</td>
<td>bigint</td>
<td></td>
<td>序列的起始值</td>
</tr>
<tr>
<td>min_value</td>
<td>bigint</td>
<td></td>
<td>序列的最小值</td>
</tr>
<tr>
<td>max_value</td>
<td>bigint</td>
<td></td>
<td>序列的最大值</td>
</tr>
<tr>
<td>increment_by</td>
<td>bigint</td>
<td></td>
<td>序列的增量值</td>
</tr>
<tr>
<td>cycle</td>
<td>boolean</td>
<td></td>
<td>序列是否循环</td>
</tr>
<tr>
<td>cache_size</td>
<td>bigint</td>
<td></td>
<td>序列的缓冲尺寸</td>
</tr>
<tr>
<td>last_value</td>
<td>bigint</td>
<td></td>
<td>最后一个被写入到磁盘的序列值。如果使用了缓冲，这个值可能比从序列中取出的最后一个值大。如果还没有从该序列读取过，则为空。此外，如果当前用户没有该序列上的USAGE或SELECT特权，则这个值为空。</td>
</tr>
</tbody>
</table>
<h4 id="pg_settings"><strong>pg_settings</strong></h4>
<p>视图pg_settings提供了对服务器上运行时参数的访问。它本质上是SHOW和SET命令的可替换接口。它还提供了SHOW不能提供的关于每一个参数的一些现实，例如最大值和最小值。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>text</td>
<td>运行时配置参数名</td>
</tr>
<tr>
<td>setting</td>
<td>text</td>
<td>参数的当前值</td>
</tr>
<tr>
<td>unit</td>
<td>text</td>
<td>参数的隐式单元</td>
</tr>
<tr>
<td>category</td>
<td>text</td>
<td>参数的逻辑组</td>
</tr>
<tr>
<td>short_desc</td>
<td>text</td>
<td>参数的简短描述</td>
</tr>
<tr>
<td>extra_desc</td>
<td>text</td>
<td>附加的参数的详细描述</td>
</tr>
<tr>
<td>context</td>
<td>text</td>
<td>要求设置此参数值的上下文</td>
</tr>
<tr>
<td>vartype</td>
<td>text</td>
<td>参数类型（bool、enum、 integer、real或string）</td>
</tr>
<tr>
<td>source</td>
<td>text</td>
<td>当前参数值的来源</td>
</tr>
<tr>
<td>min_val</td>
<td>text</td>
<td>参数的最小允许值（对非数字值为空）</td>
</tr>
<tr>
<td>max_val</td>
<td>text</td>
<td>参数的最大允许值（对非数字值为空）</td>
</tr>
<tr>
<td>enumvals</td>
<td>text[]</td>
<td>一个枚举参数的允许值（对非数字值为空）</td>
</tr>
<tr>
<td>boot_val</td>
<td>text</td>
<td>如果参数没有被别的其他设置，此列为在服务器启动时设定的参数值</td>
</tr>
<tr>
<td>reset_val</td>
<td>text</td>
<td>在当前会话中，RESET将会设置的参数值</td>
</tr>
<tr>
<td>sourcefile</td>
<td>text</td>
<td>当前值被设置的配置文件（空值表示从非配置文件的其他来源设置，由不是超级用户也不是pg_read_all_settings成员的用户检查时也为空值），在配置文件中使用include指令时有用</td>
</tr>
<tr>
<td>sourceline</td>
<td>integer</td>
<td>当前值被设置的配置文件中的行号（空值表示从非配置文件的其他来源设置，由不是超级用户也不是pg_read_all_settings成员的用户检查时也为空值）。</td>
</tr>
<tr>
<td>pending_restart</td>
<td>boolean</td>
<td>如果配置文件中修改了该值但需要重启，则为true， 否则为false。</td>
</tr>
</tbody>
</table>
<h4 id="pg_shadow"><strong>pg_shadow</strong></h4>
<p>视图pg_shadow显示pg_authid中所有被标记为rolcanlogin的角色的属性。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>usename</td>
<td>name</td>
<td>pg_authid.rolname</td>
<td>用户名</td>
</tr>
<tr>
<td>usesysid</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>用户的ID</td>
</tr>
<tr>
<td>usecreatedb</td>
<td>bool</td>
<td></td>
<td>用户能否创建数据库</td>
</tr>
<tr>
<td>usesuper</td>
<td>bool</td>
<td></td>
<td>用户是否为一个超级用户</td>
</tr>
<tr>
<td>userepl</td>
<td>bool</td>
<td></td>
<td>用户能否开启流复制并将系统设置或者取消备份模式。</td>
</tr>
<tr>
<td>usebypassrls</td>
<td>bool</td>
<td></td>
<td>用户能否绕过所有的行级安全性策略，详见 第 5.7 节。</td>
</tr>
<tr>
<td>passwd</td>
<td>text</td>
<td></td>
<td>口令（可能被加密），如果没有则为空。关于加密口令如何存储请参见pg_authid。</td>
</tr>
<tr>
<td>valuntil</td>
<td>abstime</td>
<td></td>
<td>口令过期时间（仅用于口令认证）</td>
</tr>
<tr>
<td>useconfig</td>
<td>text[]</td>
<td></td>
<td>运行时配置变量的会话默认值</td>
</tr>
</tbody>
</table>
<h4 id="pg_shdepend"><strong>pg_shdepend</strong></h4>
<p>pg_shdepend记录数据库对象和共享对象之间的依赖关系，例如角色。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>dbid</td>
<td>oid</td>
<td>pg_database.oid</td>
<td>依赖者对象所在的数据库OID，如果是一个共享对象则值为0</td>
</tr>
<tr>
<td>classid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>依赖者对象所在的系统目录的OID</td>
</tr>
<tr>
<td>objid</td>
<td>oid</td>
<td>任意OID列</td>
<td>依赖者对象的OID</td>
</tr>
<tr>
<td>objsubid</td>
<td>int4</td>
<td></td>
<td>对于一个表列，这将是列号（objid和classid指向表本身）。对于所有其他对象类型，该列值为0。</td>
</tr>
<tr>
<td>refclassid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>被引用对象所在的系统目录的OID（必须是一个共享的目录）</td>
</tr>
<tr>
<td>refobjid</td>
<td>oid</td>
<td>任意OID列</td>
<td>被引用对象的OID</td>
</tr>
<tr>
<td>deptype</td>
<td>char</td>
<td></td>
<td>定义该依赖关系的特定语义的代码，见表后的说明</td>
</tr>
</tbody>
</table>
<h4 id="pg_shdescription"><strong>pg_shdescription</strong></h4>
<p>pg_shdescription存储共享数据库对象的可选描述（注释）。描述可以通过COMMENT命令操作，并且可以使用psql的\d命令来查看。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>objoid</td>
<td>oid</td>
<td>任意OID列</td>
<td>该描述所属的对象的OID</td>
</tr>
<tr>
<td>classoid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>该对象所在系统目录的OID</td>
</tr>
<tr>
<td>description</td>
<td>text</td>
<td></td>
<td>作为该对象描述的任意文本</td>
</tr>
</tbody>
</table>
<h4 id="pg_shseclabel"><strong>pg_shseclabel</strong></h4>
<p>pg_shseclabel存储共享数据库对象上的安全标签。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>objoid</td>
<td>oid</td>
<td>任意OID列</td>
<td>该安全标签所属对象的OID</td>
</tr>
<tr>
<td>classoid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>对象所属系统目录的OID</td>
</tr>
<tr>
<td>provider</td>
<td>text</td>
<td></td>
<td>与此标签关联的标签提供者</td>
</tr>
<tr>
<td>label</td>
<td>text</td>
<td></td>
<td>应用到该对象的安全标签</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_activity"><strong>pg_stat_activity</strong></h4>
<p>pg_stat_activity视图将为每一个服务器进程有一行显示与该进程的当前活动相关的信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>datid</td>
<td>oid</td>
<td>这个后端连接到的数据库的OID</td>
</tr>
<tr>
<td>datname</td>
<td>name</td>
<td>这个后端连接到的数据库的名称</td>
</tr>
<tr>
<td>pid</td>
<td>integer</td>
<td>这个后端的进程 ID</td>
</tr>
<tr>
<td>usesysid</td>
<td>oid</td>
<td>登录到这个后端的用户的 OID</td>
</tr>
<tr>
<td>usename</td>
<td>name</td>
<td>登录到这个后端的用户的名称</td>
</tr>
<tr>
<td>application_name</td>
<td>text</td>
<td>连接到这个后端的应用的名称</td>
</tr>
<tr>
<td>client_addr</td>
<td>inet</td>
<td>连接到这个后端的客户端的 IP 地址。如果这个域为空，它表示客户端通过服务器机器上的一个 Unix 套接字连接或者这是一个内部进程（如自动清理）。</td>
</tr>
<tr>
<td>client_hostname</td>
<td>text</td>
<td>已连接的客户端的主机名，由client_addr的反向 DNS 查找报告。这个域将只对 IP 连接非空，并且只有log_hostname被启用时才会非空。</td>
</tr>
<tr>
<td>client_port</td>
<td>integer</td>
<td>客户端用以和这个后端通信的 TCP 端口号，如果使用 Unix 套接字则为-1</td>
</tr>
<tr>
<td>backend_start</td>
<td>timestamp with time zone</td>
<td>这个进程被启动的时间。对客户端后端来说就是客户端连接到服务器的时间。</td>
</tr>
<tr>
<td>xact_start</td>
<td>timestamp with time zone</td>
<td>这个进程的当前事务被启动的时间，如果没有活动事务则为空。如果当前查询是它的第一个事务，这一列等于query_start。</td>
</tr>
<tr>
<td>query_start</td>
<td>timestamp with time zone</td>
<td>当前活动查询被开始的时间，如果state不是active，这个域为上一个查询被开始的时间</td>
</tr>
<tr>
<td>state_change</td>
<td>timestamp with time zone</td>
<td>state上一次被改变的时间</td>
</tr>
<tr>
<td>wait_event_type</td>
<td>text</td>
<td>后端正在等待的事件类型，如果不存在则为 NULL。可能的值有：LWLock：后端正在等待一个轻量级锁。每一个这样的锁保护着共享内存中的一个特殊数据结构。wait_event将含有一个标识该轻量级锁目的的名称（一些锁具有特定的名称，其他是一组具有类似目的的锁中的一部分）。Lock：后端正在等待一个重量级锁。重量级锁，也称为锁管理器锁或者简单锁，主要保护 SQL 可见的对象，例如表。不过，它们也被用于确保特定内部操作的互斥，例如关系扩展。wait_event将标识等待的锁的类型。BufferPin：服务器进程正在等待访问一个数据缓冲区，而此时没有其他进程正在检查该缓冲区。如果另一个进程持有一个最终从要访问的缓冲区中读取数据的打开的游标，缓冲区 pin 等待可能会被拖延。Activity：服务器进程处于闲置状态。这被用于在其主处理循环中等待活动的系统进程。wait_event将标识特定的等待点。Extension：服务器进程正在一个扩展模块中等待活动。这一个分类被用于要跟踪自定义等待点的模块。Client：服务器进程正在一个套接字上等待来自用户应用的某种活动，并且该服务器预期某种与其内部处理无关的事情发生。wait_event将标识特定的等待点。IPC：服务器进程正在等待来自服务器中另一个进程的某种活动。wait_event将标识特定的等待点。Timeout：服务器进程正在等待一次超时发生。wait_event将标识特定的等待点。IO：服务器进程正在等待一次IO完成。wait_event将标识特定的等待点。</td>
</tr>
<tr>
<td>wait_event</td>
<td>text</td>
<td>如果后端当前正在等待，则是等待事件的名称，否则为 NULL。详见下表。</td>
</tr>
<tr>
<td>state</td>
<td>text</td>
<td>这个后端的当前总体状态。可能的值是：active：后端正在执行一个查询。idle：后端正在等待一个新的客户端命令。idle in transaction：后端在一个事务中，但是当前没有正在执行一个查询。idle in transaction (aborted)：这个状态与idle in transaction相似，不过在该事务中的一个语句导致了一个错误。fastpath function call：后端正在执行一个 fast-path 函数。disabled：如果在这个后端中track_activities被禁用，则报告这个状态。</td>
</tr>
<tr>
<td>backend_xid</td>
<td>xid</td>
<td>这个后端的顶层事务标识符（如果存在）。</td>
</tr>
<tr>
<td>backend_xmin</td>
<td>xid</td>
<td>当前后端的xmin范围。</td>
</tr>
<tr>
<td>query</td>
<td>text</td>
<td>这个后端最近查询的文本。如果state为active，这个域显示当前正在执行的查询。在所有其他状态下，它显示上一个被执行的查询。默认情况下，查询文本会被截断至1024个字符，这个值可以通过参数track_activity_query_size更改。</td>
</tr>
<tr>
<td>backend_type</td>
<td>text</td>
<td>当前后端的类型。可能的类型是 autovacuum launcher, autovacuum worker, logical replication launcher, logical replication worker, parallel worker, background writer, client backend, checkpointer, startup, walreceiver, walsender 以及 walwriter。 除此以外，由扩展注册的后台Worker可能有额外的类型。</td>
</tr>
</tbody>
</table>
<p>wait_event 描述：</p>
<table>
<thead>
<tr>
<th>等待事件类型</th>
<th>等待事件名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>LWLock</td>
<td>ShmemIndexLock</td>
<td>正等待在共享内存中查找或者分配空间。</td>
</tr>
<tr>
<td>OidGenLock</td>
<td>正等待分配或者赋予一个 OID。</td>
<td></td>
</tr>
<tr>
<td>XidGenLock</td>
<td>正等待分配或者赋予一个事务 ID。</td>
<td></td>
</tr>
<tr>
<td>ProcArrayLock</td>
<td>正等待在事务结尾得到一个快照或者清除事务 ID。</td>
<td></td>
</tr>
<tr>
<td>SInvalReadLock</td>
<td>正等待从共享无效消息队列中检索或者移除消息。</td>
<td></td>
</tr>
<tr>
<td>SInvalWriteLock</td>
<td>正等待在共享无效消息队列中增加一个消息。</td>
<td></td>
</tr>
<tr>
<td>WALBufMappingLock</td>
<td>正等待在 WAL 缓冲区中替换一个页面。</td>
<td></td>
</tr>
<tr>
<td>WALWriteLock</td>
<td>正等待 WAL 缓冲区被写入到磁盘。</td>
<td></td>
</tr>
<tr>
<td>ControlFileLock</td>
<td>正等待读取或者更新控制文件或创建一个新的 WAL 文件。</td>
<td></td>
</tr>
<tr>
<td>CheckpointLock</td>
<td>正等待执行检查点。</td>
<td></td>
</tr>
<tr>
<td>CLogControlLock</td>
<td>正等待读取或者更新事务状态。</td>
<td></td>
</tr>
<tr>
<td>SubtransControlLock</td>
<td>正等待读取或者更新子事务信息。</td>
<td></td>
</tr>
<tr>
<td>MultiXactGenLock</td>
<td>正等待读取或者更新共享多事务状态。</td>
<td></td>
</tr>
<tr>
<td>MultiXactOffsetControlLock</td>
<td>正等待读取或者更新多事务偏移映射。</td>
<td></td>
</tr>
<tr>
<td>MultiXactMemberControlLock</td>
<td>正等待读取或者更新多事务成员映射。</td>
<td></td>
</tr>
<tr>
<td>RelCacheInitLock</td>
<td>正等待读取或者写入关系缓冲区初始化文件。</td>
<td></td>
</tr>
<tr>
<td>CheckpointerCommLock</td>
<td>正等待管理 fsync 请求。</td>
<td></td>
</tr>
<tr>
<td>TwoPhaseStateLock</td>
<td>正等待读取或者更新预备事务的状态。</td>
<td></td>
</tr>
<tr>
<td>TablespaceCreateLock</td>
<td>正等待创建或者删除表空间。</td>
<td></td>
</tr>
<tr>
<td>BtreeVacuumLock</td>
<td>正等待读取或者更新一个 B-树索引的 vacuum 相关的信息。</td>
<td></td>
</tr>
<tr>
<td>AddinShmemInitLock</td>
<td>正等待管理共享内存中的空间分配。</td>
<td></td>
</tr>
<tr>
<td>AutovacuumLock</td>
<td>自动清理工作者或者启动器正等待更新或者读取自动清理工作者的当前状态。</td>
<td></td>
</tr>
<tr>
<td>AutovacuumScheduleLock</td>
<td>正等待确认选中进行清理的表仍需要清理。</td>
<td></td>
</tr>
<tr>
<td>SyncScanLock</td>
<td>正等待为同步扫描得到一个表上扫描的开始位置。</td>
<td></td>
</tr>
<tr>
<td>RelationMappingLock</td>
<td>正等待更新用来存储目录到文件节点映射的关系映射文件。</td>
<td></td>
</tr>
<tr>
<td>AsyncCtlLock</td>
<td>正等待读取或者更新共享通知状态。</td>
<td></td>
</tr>
<tr>
<td>AsyncQueueLock</td>
<td>正等待读取或者更新通知消息。</td>
<td></td>
</tr>
<tr>
<td>SerializableXactHashLock</td>
<td>正等待检索或者存储有关可序列化事务的信息。</td>
<td></td>
</tr>
<tr>
<td>SerializableFinishedListLock</td>
<td>正等待访问已结束可序列化事务的列表。</td>
<td></td>
</tr>
<tr>
<td>SerializablePredicateLockListLock</td>
<td>正等待在由可序列化事务持有的所列表上执行一个操作。</td>
<td></td>
</tr>
<tr>
<td>OldSerXidLock</td>
<td>正等待读取或者记录冲突的可序列化事务。</td>
<td></td>
</tr>
<tr>
<td>SyncRepLock</td>
<td>正等待读取或者更新有关同步复制的信息。</td>
<td></td>
</tr>
<tr>
<td>BackgroundWorkerLock</td>
<td>正等待读取或者更新后台工作者状态。</td>
<td></td>
</tr>
<tr>
<td>DynamicSharedMemoryControlLock</td>
<td>正等待读取或者更新动态共享内存状态。</td>
<td></td>
</tr>
<tr>
<td>AutoFileLock</td>
<td>正等待更新postgresql.auto.conf文件。</td>
<td></td>
</tr>
<tr>
<td>ReplicationSlotAllocationLock</td>
<td>正等待分配或者释放一个复制槽。</td>
<td></td>
</tr>
<tr>
<td>ReplicationSlotControlLock</td>
<td>正等待读取或者更新复制槽状态。</td>
<td></td>
</tr>
<tr>
<td>CommitTsControlLock</td>
<td>正等待读取或者更新事务提交时间戳。</td>
<td></td>
</tr>
<tr>
<td>CommitTsLock</td>
<td>正等待读取或者更新事务时间戳的最新设置值。</td>
<td></td>
</tr>
<tr>
<td>ReplicationOriginLock</td>
<td>正等待设置、删除或者使用复制源头。</td>
<td></td>
</tr>
<tr>
<td>MultiXactTruncationLock</td>
<td>正等待读取或者阶段多事务信息。</td>
<td></td>
</tr>
<tr>
<td>OldSnapshotTimeMapLock</td>
<td>正等待读取或者更新旧的快照控制信息。</td>
<td></td>
</tr>
<tr>
<td>BackendRandomLock</td>
<td>正等待产生一个随机数。</td>
<td></td>
</tr>
<tr>
<td>LogicalRepWorkerLock</td>
<td>正等待逻辑复制工作者上的动作完成。</td>
<td></td>
</tr>
<tr>
<td>CLogTruncationLock</td>
<td>正等待截断预写式日志或者等待预写式日志截断操作完成。</td>
<td></td>
</tr>
<tr>
<td>clog</td>
<td>正在等地clog (事务状态)缓冲区上的I/O。</td>
<td></td>
</tr>
<tr>
<td>commit_timestamp</td>
<td>正等待提交时间戳缓冲区上的 I/O。</td>
<td></td>
</tr>
<tr>
<td>subtrans</td>
<td>正等待子事务缓冲区上的 I/O。</td>
<td></td>
</tr>
<tr>
<td>multixact_offset</td>
<td>正等待多事务偏移缓冲区上的 I/O。</td>
<td></td>
</tr>
<tr>
<td>multixact_member</td>
<td>正等待多事务成员缓冲区上的 I/O。</td>
<td></td>
</tr>
<tr>
<td>async</td>
<td>正等待 async（通知）缓冲区上的 I/O。</td>
<td></td>
</tr>
<tr>
<td>oldserxid</td>
<td>正等待 oldserxid 缓冲区上的 I/O。</td>
<td></td>
</tr>
<tr>
<td>wal_insert</td>
<td>正等待把 WAL 插入到一个内存缓冲区。</td>
<td></td>
</tr>
<tr>
<td>buffer_content</td>
<td>正等待读取或者写入内存中的一个数据页。</td>
<td></td>
</tr>
<tr>
<td>buffer_io</td>
<td>正等待一个数据页面上的 I/O。</td>
<td></td>
</tr>
<tr>
<td>replication_origin</td>
<td>正等待读取或者更新复制进度。</td>
<td></td>
</tr>
<tr>
<td>replication_slot_io</td>
<td>正等待一个复制槽上的 I/O。</td>
<td></td>
</tr>
<tr>
<td>proc</td>
<td>正等待读取或者更新 fast-path 锁信息。</td>
<td></td>
</tr>
<tr>
<td>buffer_mapping</td>
<td>正等待把一个数据块与缓冲池中的一个缓冲区关联。</td>
<td></td>
</tr>
<tr>
<td>lock_manager</td>
<td>正等待增加或者检查用于后端的锁，或者正等待加入或者退出一个锁定组（并行查询使用）。</td>
<td></td>
</tr>
<tr>
<td>predicate_lock_manager</td>
<td>正等待增加或者检查谓词锁信息。</td>
<td></td>
</tr>
<tr>
<td>parallel_query_dsa</td>
<td>正等待并行查询动态共享内存分配锁。</td>
<td></td>
</tr>
<tr>
<td>tbm</td>
<td>正等待TBM共享迭代器锁。</td>
<td></td>
</tr>
<tr>
<td>parallel_append</td>
<td>在Parallel Append计划执行期间等待选择下一个子计划。</td>
<td></td>
</tr>
<tr>
<td>parallel_hash_join</td>
<td>在Parallel Hash计划执行期间等待分配或交换一块内存或者更新计数器。</td>
<td></td>
</tr>
<tr>
<td>Lock</td>
<td>relation</td>
<td>正等待获得一个关系上的锁。</td>
</tr>
<tr>
<td>extend</td>
<td>正等待扩展一个关系。</td>
<td></td>
</tr>
<tr>
<td>page</td>
<td>正等待获得一个关系上的页面的锁。</td>
<td></td>
</tr>
<tr>
<td>tuple</td>
<td>正等待获得一个元组上的锁。</td>
<td></td>
</tr>
<tr>
<td>transactionid</td>
<td>正等待一个事务结束。</td>
<td></td>
</tr>
<tr>
<td>virtualxid</td>
<td>正等待获得一个虚拟 xid 锁。</td>
<td></td>
</tr>
<tr>
<td>speculative token</td>
<td>正等待获取一个 speculative insertion lock。</td>
<td></td>
</tr>
<tr>
<td>object</td>
<td>正等待获得一个非关系数据库对象上的锁。</td>
<td></td>
</tr>
<tr>
<td>userlock</td>
<td>正等待获得一个用户锁。</td>
<td></td>
</tr>
<tr>
<td>advisory</td>
<td>正等待获得一个咨询用户锁。</td>
<td></td>
</tr>
<tr>
<td>BufferPin</td>
<td>BufferPin</td>
<td>正等待在一个缓冲区上加 pin。</td>
</tr>
<tr>
<td>Activity</td>
<td>ArchiverMain</td>
<td>正在归档进程的主循环中等待。</td>
</tr>
<tr>
<td>AutoVacuumMain</td>
<td>正在autovacuum启动器进程的主循环中等待。</td>
<td></td>
</tr>
<tr>
<td>BgWriterHibernate</td>
<td>正在后台写入器进程中等待，休眠中。</td>
<td></td>
</tr>
<tr>
<td>BgWriterMain</td>
<td>正在后台写入器进程的后台工作者的主循环中等待。</td>
<td></td>
</tr>
<tr>
<td>CheckpointerMain</td>
<td>正在检查点进程的主循环中等待。</td>
<td></td>
</tr>
<tr>
<td>LogicalApplyMain</td>
<td>正在逻辑应用进程的主循环中等待。</td>
<td></td>
</tr>
<tr>
<td>LogicalLauncherMain</td>
<td>正在逻辑启动器进程的主循环中等待。</td>
<td></td>
</tr>
<tr>
<td>PgStatMain</td>
<td>正在统计收集器进程的主循环中等待。</td>
<td></td>
</tr>
<tr>
<td>RecoveryWalAll</td>
<td>在恢复时等待来自于任意类型来源（本地、归档或流）的WAL。</td>
<td></td>
</tr>
<tr>
<td>RecoveryWalStream</td>
<td>在恢复时等待来自于一个流的WAL。</td>
<td></td>
</tr>
<tr>
<td>SysLoggerMain</td>
<td>正在系统日志进程的主循环中等待。</td>
<td></td>
</tr>
<tr>
<td>WalReceiverMain</td>
<td>正在WAL接收器进程的主循环中等待。</td>
<td></td>
</tr>
<tr>
<td>WalSenderMain</td>
<td>正在WAL发送器进程的主循环中等待。</td>
<td></td>
</tr>
<tr>
<td>WalWriterMain</td>
<td>正在WAL写入器进程的主循环中等待。</td>
<td></td>
</tr>
<tr>
<td>Client</td>
<td>ClientRead</td>
<td>正等待从客户端读取数据。</td>
</tr>
<tr>
<td>ClientWrite</td>
<td>正等待向客户端写入数据。</td>
<td></td>
</tr>
<tr>
<td>LibPQWalReceiverConnect</td>
<td>正在WAL接收器中等待建立与远程服务器的连接。</td>
<td></td>
</tr>
<tr>
<td>LibPQWalReceiverReceive</td>
<td>正在WAL接收器中等待从远程服务器接收数据。</td>
<td></td>
</tr>
<tr>
<td>SSLOpenServer</td>
<td>正在尝试连接期间等待SSL。</td>
<td></td>
</tr>
<tr>
<td>WalReceiverWaitStart</td>
<td>正等待startup进程发送流复制的初始数据。</td>
<td></td>
</tr>
<tr>
<td>WalSenderWaitForWAL</td>
<td>正在WAL发送器进程中等待WAL被刷写。</td>
<td></td>
</tr>
<tr>
<td>WalSenderWriteData</td>
<td>在WAL发送器进程中处理来自WAL接收器的回复时等待任意活动。</td>
<td></td>
</tr>
<tr>
<td>Extension</td>
<td>Extension</td>
<td>正在一个扩展中等待。</td>
</tr>
<tr>
<td>IPC</td>
<td>BgWorkerShutdown</td>
<td>正等待后台工作者关闭。</td>
</tr>
<tr>
<td>BgWorkerStartup</td>
<td>正等待后台工作者启动。</td>
<td></td>
</tr>
<tr>
<td>BtreePage</td>
<td>正等待继续并行B-树扫描所需的页号变得可用。</td>
<td></td>
</tr>
<tr>
<td>ClogGroupUpdate</td>
<td>正等待组领袖在事务结束时更新事务状态。</td>
<td></td>
</tr>
<tr>
<td>ExecuteGather</td>
<td>在执行Gather节点时等待来自子进程的活动。</td>
<td></td>
</tr>
<tr>
<td>Hash/Batch/Allocating</td>
<td>正等待一个选出的Parallel Hash参与者分配哈希表。</td>
<td></td>
</tr>
<tr>
<td>Hash/Batch/Electing</td>
<td>正在选出一个Parallel Hash参与者来分配一个哈希表。</td>
<td></td>
</tr>
<tr>
<td>Hash/Batch/Loading</td>
<td>正等待其他Parallel Hash参与者完成装载哈希表。</td>
<td></td>
</tr>
<tr>
<td>Hash/Build/Allocating</td>
<td>正等待一个选出的Parallel Hash参与者分配初始哈希表。</td>
<td></td>
</tr>
<tr>
<td>Hash/Build/Electing</td>
<td>正在选出一个Parallel Hash参与者以分配初始哈希表。</td>
<td></td>
</tr>
<tr>
<td>Hash/Build/HashingInner</td>
<td>正等待其他Parallel Hash参与者完成对内关系的哈希操作。</td>
<td></td>
</tr>
<tr>
<td>Hash/Build/HashingOuter</td>
<td>正等待其他Parallel Hash参与者完成对外关系的哈希操作。</td>
<td></td>
</tr>
<tr>
<td>Hash/GrowBatches/Allocating</td>
<td>正等待一个选出的Parallel Hash参与者分配更多批次。</td>
<td></td>
</tr>
<tr>
<td>Hash/GrowBatches/Deciding</td>
<td>正在选出一个Parallel Hash参与者决定未来的批次增长。</td>
<td></td>
</tr>
<tr>
<td>Hash/GrowBatches/Electing</td>
<td>正在选出一个Parallel Hash参与者分配更多批次。</td>
<td></td>
</tr>
<tr>
<td>Hash/GrowBatches/Finishing</td>
<td>正在等待一个选出的Parallel Hash参与者决定未来的批次增长。</td>
<td></td>
</tr>
<tr>
<td>Hash/GrowBatches/Repartitioning</td>
<td>正等待其他Parallel Hash参与者完成重新分区。</td>
<td></td>
</tr>
<tr>
<td>Hash/GrowBuckets/Allocating</td>
<td>正等待一个选出的Parallel Hash参与者完成更多桶的分配。</td>
<td></td>
</tr>
<tr>
<td>Hash/GrowBuckets/Electing</td>
<td>正在选出一个Parallel Hash参与者分配更多桶。</td>
<td></td>
</tr>
<tr>
<td>Hash/GrowBuckets/Reinserting</td>
<td>正等待其他Parallel Hash参与者完成将元组插入到新桶的操作。</td>
<td></td>
</tr>
<tr>
<td>LogicalSyncData</td>
<td>正等待逻辑复制的远程服务器发送用于初始表同步的数据。</td>
<td></td>
</tr>
<tr>
<td>LogicalSyncStateChange</td>
<td>正等待逻辑复制的远程服务器更改状态。</td>
<td></td>
</tr>
<tr>
<td>MessageQueueInternal</td>
<td>正等待其他进程被挂接到共享消息队列。</td>
<td></td>
</tr>
<tr>
<td>MessageQueuePutMessage</td>
<td>正等待把一个协议消息写到一个共享消息队列。</td>
<td></td>
</tr>
<tr>
<td>MessageQueueReceive</td>
<td>正等待从一个共享消息队列接收字节。</td>
<td></td>
</tr>
<tr>
<td>MessageQueueSend</td>
<td>正等待向一个共享消息队列中发送字节。</td>
<td></td>
</tr>
<tr>
<td>ParallelBitmapScan</td>
<td>正等待并行位图扫描被初始化。</td>
<td></td>
</tr>
<tr>
<td>ParallelCreateIndexScan</td>
<td>正等待并行CREATE INDEX工作者完成堆扫描。</td>
<td></td>
</tr>
<tr>
<td>ParallelFinish</td>
<td>正等待并行工作者完成计算。</td>
<td></td>
</tr>
<tr>
<td>ProcArrayGroupUpdate</td>
<td>正等待组领袖在事务结束时清除事务ID。</td>
<td></td>
</tr>
<tr>
<td>ReplicationOriginDrop</td>
<td>正等待一个复制源头变得不活跃以便被删除。</td>
<td></td>
</tr>
<tr>
<td>ReplicationSlotDrop</td>
<td>正等待一个复制槽变得不活跃以便被删除。</td>
<td></td>
</tr>
<tr>
<td>SafeSnapshot</td>
<td>正等待一个用于READ ONLY DEFERRABLE事务的快照。</td>
<td></td>
</tr>
<tr>
<td>SyncRep</td>
<td>正在同步复制期间等待来自远程服务器的确认。</td>
<td></td>
</tr>
<tr>
<td>Timeout</td>
<td>BaseBackupThrottle</td>
<td>当有限流活动时在基础备份期间等待。</td>
</tr>
<tr>
<td>PgSleep</td>
<td>正在调用pg_sleep的进程中等待。</td>
<td></td>
</tr>
<tr>
<td>RecoveryApplyDelay</td>
<td>在恢复时等待应用WAL，因为它被延迟了。</td>
<td></td>
</tr>
<tr>
<td>IO</td>
<td>BufFileRead</td>
<td>正等待从一个缓存的文件中读取。</td>
</tr>
<tr>
<td>BufFileWrite</td>
<td>正等待向一个缓存的文件中写入。</td>
<td></td>
</tr>
<tr>
<td>ControlFileRead</td>
<td>正等待从控制文件中读取。</td>
<td></td>
</tr>
<tr>
<td>ControlFileSync</td>
<td>正等待控制文件到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>ControlFileSyncUpdate</td>
<td>正等待对控制文件的更新到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>ControlFileWrite</td>
<td>正等待一个对控制文件的写入。</td>
<td></td>
</tr>
<tr>
<td>ControlFileWriteUpdate</td>
<td>正等待一个写操作更新控制文件。</td>
<td></td>
</tr>
<tr>
<td>CopyFileRead</td>
<td>正在文件拷贝操作期间等待一个读操作。</td>
<td></td>
</tr>
<tr>
<td>CopyFileWrite</td>
<td>正在文件拷贝操作期间等待一个写操作。</td>
<td></td>
</tr>
<tr>
<td>DataFileExtend</td>
<td>正等待一个关系数据文件被扩充。</td>
<td></td>
</tr>
<tr>
<td>DataFileFlush</td>
<td>正等待一个关系数据文件到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>DataFileImmediateSync</td>
<td>正等待一个关系数据文件的立即同步到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>DataFilePrefetch</td>
<td>正等待从一个关系数据文件中的一次异步预取。</td>
<td></td>
</tr>
<tr>
<td>DataFileRead</td>
<td>正等待一次对一个关系数据文件的读操作。</td>
<td></td>
</tr>
<tr>
<td>DataFileSync</td>
<td>正等待对一个关系数据文件的更改到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>DataFileTruncate</td>
<td>正等待一个关系数据文件被截断。</td>
<td></td>
</tr>
<tr>
<td>DataFileWrite</td>
<td>正等待一次对一个关系数据文件的写操作。</td>
<td></td>
</tr>
<tr>
<td>DSMFillZeroWrite</td>
<td>等待向一个动态共享内存备份文件中写零字节。</td>
<td></td>
</tr>
<tr>
<td>LockFileAddToDataDirRead</td>
<td>在向数据目录锁文件中增加一行时等待一个读操作。</td>
<td></td>
</tr>
<tr>
<td>LockFileAddToDataDirSync</td>
<td>在向数据目录锁文件中增加一行时等待数据到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>LockFileAddToDataDirWrite</td>
<td>在向数据目录锁文件中增加一行时等待一个写操作。</td>
<td></td>
</tr>
<tr>
<td>LockFileCreateRead</td>
<td>在创建数据目录锁文件期间等待读取。</td>
<td></td>
</tr>
<tr>
<td>LockFileCreateSync</td>
<td>在创建数据目录锁文件期间等待数据到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>LockFileCreateWrite</td>
<td>在创建数据目录锁文件期间等待一个写操作。</td>
<td></td>
</tr>
<tr>
<td>LockFileReCheckDataDirRead</td>
<td>在重新检查数据目录锁文件的过程中等待一个读操作。</td>
<td></td>
</tr>
<tr>
<td>LogicalRewriteCheckpointSync</td>
<td>在一个检查点期间等待逻辑重写映射到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>LogicalRewriteMappingSync</td>
<td>在一次逻辑重写期间等待映射数据到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>LogicalRewriteMappingWrite</td>
<td>在一次逻辑重写期间等待对映射数据的写操作。</td>
<td></td>
</tr>
<tr>
<td>LogicalRewriteSync</td>
<td>正等待逻辑重写映射到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>LogicalRewriteWrite</td>
<td>正等待对逻辑重写映射的写操作。</td>
<td></td>
</tr>
<tr>
<td>RelationMapRead</td>
<td>正等待对关系映射文件的读操作。</td>
<td></td>
</tr>
<tr>
<td>RelationMapSync</td>
<td>正等待关系映射文件到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>RelationMapWrite</td>
<td>正等待对关系映射文件的写操作。</td>
<td></td>
</tr>
<tr>
<td>ReorderBufferRead</td>
<td>在重排序缓冲区管理期间等待一个读操作。</td>
<td></td>
</tr>
<tr>
<td>ReorderBufferWrite</td>
<td>在重排序缓冲区管理期间等待一个写操作。</td>
<td></td>
</tr>
<tr>
<td>ReorderLogicalMappingRead</td>
<td>在重排序缓冲区管理期间等待对一个逻辑映射的读操作。</td>
<td></td>
</tr>
<tr>
<td>ReplicationSlotRead</td>
<td>正等待对一个复制槽控制文件的读操作。</td>
<td></td>
</tr>
<tr>
<td>ReplicationSlotRestoreSync</td>
<td>在把一个复制槽控制文件恢复到内存的过程中等待它到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>ReplicationSlotSync</td>
<td>正等待一个复制槽控制文件到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>ReplicationSlotWrite</td>
<td>正等待对一个复制槽控制文件的写操作。</td>
<td></td>
</tr>
<tr>
<td>SLRUFlushSync</td>
<td>在检查点或者数据库关闭期间等待SLRU数据到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>SLRURead</td>
<td>正等待对一个SLRU页面的读操作。</td>
<td></td>
</tr>
<tr>
<td>SLRUSync</td>
<td>正等待SLRU数据在一个页面写之后到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>SLRUWrite</td>
<td>正等待一个SLRU页面上的写操作。</td>
<td></td>
</tr>
<tr>
<td>SnapbuildRead</td>
<td>正等待一个序列化历史目录快照的读操作。</td>
<td></td>
</tr>
<tr>
<td>SnapbuildSync</td>
<td>正等待一个序列化历史目录快照到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>SnapbuildWrite</td>
<td>正等待一个序列化历史目录快照的写操作。</td>
<td></td>
</tr>
<tr>
<td>TimelineHistoryFileSync</td>
<td>正等待一个通过流复制接收到的时间线历史文件到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>TimelineHistoryFileWrite</td>
<td>正等待一个通过流复制接收到的时间线历史文件的读操作。</td>
<td></td>
</tr>
<tr>
<td>TimelineHistoryRead</td>
<td>正等待一个时间线历史文件上的读操作。</td>
<td></td>
</tr>
<tr>
<td>TimelineHistorySync</td>
<td>正等待一个新创建的时间线历史文件达到稳定存储。</td>
<td></td>
</tr>
<tr>
<td>TimelineHistoryWrite</td>
<td>正等待一个新创建的时间线历史文件上的写操作。</td>
<td></td>
</tr>
<tr>
<td>TwophaseFileRead</td>
<td>正等待一个两阶段状态文件的读操作。</td>
<td></td>
</tr>
<tr>
<td>TwophaseFileSync</td>
<td>正等待一个两阶段状态文件到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>TwophaseFileWrite</td>
<td>正等待一个两阶段状态文件的写操作。</td>
<td></td>
</tr>
<tr>
<td>WALBootstrapSync</td>
<td>在自举期间等待WAL到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>WALBootstrapWrite</td>
<td>在自举期间等待一个WAL页面的写操作。</td>
<td></td>
</tr>
<tr>
<td>WALCopyRead</td>
<td>在通过拷贝一个已有WAL段创建一个新的WAL段时等待一个读操作。</td>
<td></td>
</tr>
<tr>
<td>WALCopySync</td>
<td>正等待一个通过拷贝已有WAL段创建的新WAL段到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>WALCopyWrite</td>
<td>在通过拷贝一个已有WAL段创建一个新的WAL段时等待一个写操作。</td>
<td></td>
</tr>
<tr>
<td>WALInitSync</td>
<td>正等待一个新初始化的WAL文件到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>WALInitWrite</td>
<td>在初始化一个新的WAL文件期间等待一个写操作。</td>
<td></td>
</tr>
<tr>
<td>WALRead</td>
<td>正等待一次对一个WAL文件的读操作。</td>
<td></td>
</tr>
<tr>
<td>WALSenderTimelineHistoryRead</td>
<td>在walsender的时间线命令期间等待对一个时间线历史文件的读操作。</td>
<td></td>
</tr>
<tr>
<td>WALSyncMethodAssign</td>
<td>在指派WAL同步方法时等待数据到达稳定存储。</td>
<td></td>
</tr>
<tr>
<td>WALWrite</td>
<td>正等待一次对一个WAL文件的写操作。</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_all_indexes"><strong>pg_stat_all_indexes</strong></h4>
<p>pg_stat_all_indexes视图将为当前数据库中的每个索引包含一行，该行显示关于对该索引访问的统计信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>这个索引的基表的 OID</td>
</tr>
<tr>
<td>indexrelid</td>
<td>oid</td>
<td>这个索引的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个索引所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个索引的基表的名称</td>
</tr>
<tr>
<td>indexrelname</td>
<td>name</td>
<td>这个索引的名称</td>
</tr>
<tr>
<td>idx_scan</td>
<td>bigint</td>
<td>在这个索引上发起的索引扫描次数</td>
</tr>
<tr>
<td>idx_tup_read</td>
<td>bigint</td>
<td>在这个索引上由扫描返回的索引项数量</td>
</tr>
<tr>
<td>idx_tup_fetch</td>
<td>bigint</td>
<td>被使用这个索引的简单索引扫描取得的活着的表行数量</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_all_tables"><strong>pg_stat_all_tables</strong></h4>
<p>pg_stat_all_tables视图将为当前数据库中的每一个表（包括 TOAST 表）包含一行，该行显示与对该表的访问相关的统计信息。pg_stat_user_tables和pg_stat_sys_tables视图包含相同的信息，但是被过滤得分别只显示用户和系统表。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>一个表的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个表所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个表的名称</td>
</tr>
<tr>
<td>seq_scan</td>
<td>bigint</td>
<td>在这个表上发起的顺序扫描的次数</td>
</tr>
<tr>
<td>seq_tup_read</td>
<td>bigint</td>
<td>被顺序扫描取得的活着的行的数量</td>
</tr>
<tr>
<td>idx_scan</td>
<td>bigint</td>
<td>在这个表上发起的索引扫描的次数</td>
</tr>
<tr>
<td>idx_tup_fetch</td>
<td>bigint</td>
<td>被索引扫描取得的活着的行的数量</td>
</tr>
<tr>
<td>n_tup_ins</td>
<td>bigint</td>
<td>被插入的行数</td>
</tr>
<tr>
<td>n_tup_upd</td>
<td>bigint</td>
<td>被更新的行数（包括 HOT 更新的行）</td>
</tr>
<tr>
<td>n_tup_del</td>
<td>bigint</td>
<td>被删除的行数</td>
</tr>
<tr>
<td>n_tup_hot_upd</td>
<td>bigint</td>
<td>被更新的 HOT 行数（即不要求独立索引更新的行更新）</td>
</tr>
<tr>
<td>n_live_tup</td>
<td>bigint</td>
<td>活着的行的估计数量</td>
</tr>
<tr>
<td>n_dead_tup</td>
<td>bigint</td>
<td>死亡行的估计数量</td>
</tr>
<tr>
<td>n_mod_since_analyze</td>
<td>bigint</td>
<td>从这个表最后一次被分析后备修改的行的估计数量</td>
</tr>
<tr>
<td>last_vacuum</td>
<td>timestamp with time zone</td>
<td>上次这个表被手动清理的时间（不统计VACUUM FULL）</td>
</tr>
<tr>
<td>last_autovacuum</td>
<td>timestamp with time zone</td>
<td>上次这个表被自动清理守护进程清理的时间</td>
</tr>
<tr>
<td>last_analyze</td>
<td>timestamp with time zone</td>
<td>上次这个表被手动分析的时间</td>
</tr>
<tr>
<td>last_autoanalyze</td>
<td>timestamp with time zone</td>
<td>上次这个表被自动清理守护进程分析的时间</td>
</tr>
<tr>
<td>vacuum_count</td>
<td>bigint</td>
<td>这个表已被手工清理的次数（不统计VACUUM FULL）</td>
</tr>
<tr>
<td>autovacuum_count</td>
<td>bigint</td>
<td>这个表已被自动清理守护进程清理的次数</td>
</tr>
<tr>
<td>analyze_count</td>
<td>bigint</td>
<td>这个表已被手工分析的次数</td>
</tr>
<tr>
<td>autoanalyze_count</td>
<td>bigint</td>
<td>这个表已被自动清理守护进程分析的次数</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_archiver"><strong>pg_stat_archiver</strong></h4>
<p>pg_stat_archiver视图将总是一个单一的行， 该行包含着有关集簇的归档进程的数据。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>archived_count</td>
<td>bigint</td>
<td>已被成功归档的 WAL 文件数量</td>
</tr>
<tr>
<td>last_archived_wal</td>
<td>text</td>
<td>最后一个被成功归档的 WAL 文件名称</td>
</tr>
<tr>
<td>last_archived_time</td>
<td>timestamp with time zone</td>
<td>最后一次成功归档操作的时间</td>
</tr>
<tr>
<td>failed_count</td>
<td>bigint</td>
<td>失败的归档 WAL 文件尝试的数量</td>
</tr>
<tr>
<td>last_failed_wal</td>
<td>text</td>
<td>最后一次失败的归档操作的 WAL 文件名称</td>
</tr>
<tr>
<td>last_failed_time</td>
<td>timestamp with time zone</td>
<td>最后一次失败的归档操作的时间</td>
</tr>
<tr>
<td>stats_reset</td>
<td>timestamp with time zone</td>
<td>这些统计信息最后一次被重置的时间</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_bgwriter"><strong>pg_stat_bgwriter</strong></h4>
<p>pg_stat_bgwriter视图将总是只有单独的一行，它包含集簇的全局数据。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>checkpoints_timed</td>
<td>bigint</td>
<td>已经被执行的计划中检查点的数量</td>
</tr>
<tr>
<td>checkpoints_req</td>
<td>bigint</td>
<td>已经被执行的请求检查点的数量</td>
</tr>
<tr>
<td>checkpoint_write_time</td>
<td>double precision</td>
<td>在文件被写入磁盘的检查点处理部分花费的总时间，以毫秒计</td>
</tr>
<tr>
<td>checkpoint_sync_time</td>
<td>double precision</td>
<td>在文件被同步到磁盘中的检查点处理部分花费的总时间，以毫秒计</td>
</tr>
<tr>
<td>buffers_checkpoint</td>
<td>bigint</td>
<td>在检查点期间被写的缓冲区数目</td>
</tr>
<tr>
<td>buffers_clean</td>
<td>bigint</td>
<td>被后台写进程写的缓冲区数目</td>
</tr>
<tr>
<td>maxwritten_clean</td>
<td>bigint</td>
<td>后台写进程由于已经写了太多缓冲区而停止清洁扫描的次数</td>
</tr>
<tr>
<td>buffers_backend</td>
<td>bigint</td>
<td>被一个后端直接写的缓冲区数量</td>
</tr>
<tr>
<td>buffers_backend_fsync</td>
<td>bigint</td>
<td>一个后端不得不自己执行fsync调用的次数（通常即使后端自己进行写操作，后台写进程也会处理这些）</td>
</tr>
<tr>
<td>buffers_alloc</td>
<td>bigint</td>
<td>被分配的缓冲区数量</td>
</tr>
<tr>
<td>stats_reset</td>
<td>timestamp with time zone</td>
<td>这些统计信息上次被重置的时间</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_database"><strong>pg_stat_database</strong></h4>
<p>pg_stat_database视图将为集簇中的每一个数据库包含有一行，每一行显示数据库范围的统计信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>datid</td>
<td>oid</td>
<td>一个数据库的 OID</td>
</tr>
<tr>
<td>datname</td>
<td>name</td>
<td>这个数据库的名称</td>
</tr>
<tr>
<td>numbackends</td>
<td>integer</td>
<td>当前连接到这个数据库的后端数量。这是在这个视图中唯一一个返回反映当前状态值的列。所有其他列返回从上次重置以来积累的值。</td>
</tr>
<tr>
<td>xact_commit</td>
<td>bigint</td>
<td>在这个数据库中已经被提交的事务的数量</td>
</tr>
<tr>
<td>xact_rollback</td>
<td>bigint</td>
<td>在这个数据库中已经被回滚的事务的数量</td>
</tr>
<tr>
<td>blks_read</td>
<td>bigint</td>
<td>在这个数据库中被读取的磁盘块的数量</td>
</tr>
<tr>
<td>blks_hit</td>
<td>bigint</td>
<td>磁盘块被发现已经在缓冲区中的次数，这样不需要一次读取（这只包括 PostgreSQL 缓冲区中的命中，而不包括在操作系统文件系统缓冲区中的命中）</td>
</tr>
<tr>
<td>tup_returned</td>
<td>bigint</td>
<td>在这个数据库中被查询返回的行数</td>
</tr>
<tr>
<td>tup_fetched</td>
<td>bigint</td>
<td>在这个数据库中被查询取出的行数</td>
</tr>
<tr>
<td>tup_inserted</td>
<td>bigint</td>
<td>在这个数据库中被查询插入的行数</td>
</tr>
<tr>
<td>tup_updated</td>
<td>bigint</td>
<td>在这个数据库中被查询更新的行数</td>
</tr>
<tr>
<td>tup_deleted</td>
<td>bigint</td>
<td>在这个数据库中被查询删除的行数</td>
</tr>
<tr>
<td>conflicts</td>
<td>bigint</td>
<td>由于与恢复冲突而在这个数据库中被取消的查询的数目（冲突只发生在后备服务器上，详见pg_stat_database_conflicts）。</td>
</tr>
<tr>
<td>temp_files</td>
<td>bigint</td>
<td>在这个数据库中被查询创建的临时文件的数量。所有临时文件都被统计，不管为什么创建这些临时文件（如排序或哈希），并且不管log_temp_files设置。</td>
</tr>
<tr>
<td>temp_bytes</td>
<td>bigint</td>
<td>在这个数据库中被查询写到临时文件中的数据总量。所有临时文件都被统计，不管为什么创建这些临时文件（如排序或哈希），并且不管log_temp_files设置。</td>
</tr>
<tr>
<td>deadlocks</td>
<td>bigint</td>
<td>在这个数据库中被检测到的死锁数</td>
</tr>
<tr>
<td>blk_read_time</td>
<td>double precision</td>
<td>在这个数据库中后端花费在读取数据文件块的时间，以毫秒计</td>
</tr>
<tr>
<td>blk_write_time</td>
<td>double precision</td>
<td>在这个数据库中后端花费在写数据文件块的时间，以毫秒计</td>
</tr>
<tr>
<td>stats_reset</td>
<td>timestamp with time zone</td>
<td>这些统计信息上次被重置的时间</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_database_conflicts"><strong>pg_stat_database_conflicts</strong></h4>
<p>pg_stat_database_conflicts视图为每一个 数据库包含一行，用来显示数据库范围内由于与后备服务器上的恢复过程 冲突而被取消的查询的统计信息。 </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>datid</td>
<td>oid</td>
<td>一个数据库的 OID</td>
</tr>
<tr>
<td>datname</td>
<td>name</td>
<td>这个数据库的名称</td>
</tr>
<tr>
<td>confl_tablespace</td>
<td>bigint</td>
<td>这个数据库中由于表空间被删掉而取消的查询数量</td>
</tr>
<tr>
<td>confl_lock</td>
<td>bigint</td>
<td>这个数据库中由于锁超时而取消的查询数量</td>
</tr>
<tr>
<td>confl_snapshot</td>
<td>bigint</td>
<td>这个数据库中由于旧快照而取消的查询数量</td>
</tr>
<tr>
<td>confl_bufferpin</td>
<td>bigint</td>
<td>这个数据库中由于被占用的缓冲区而取消的查询数量</td>
</tr>
<tr>
<td>confl_deadlock</td>
<td>bigint</td>
<td>这个数据库中由于死锁而取消的查询数量</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_progress_copy"><strong>pg_stat_progress_copy</strong></h4>
<p>当COPY正在运行时，pg_stat_progress_copy视图将包含一行,为了当前正在运行COPY命令的每个后端。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pid</td>
<td>integer</td>
<td>后端的进程ID。</td>
</tr>
<tr>
<td>datid</td>
<td>oid</td>
<td>此后端所连接的数据库的OID。</td>
</tr>
<tr>
<td>datname</td>
<td>name</td>
<td>此后端所连接的数据库的名称。</td>
</tr>
<tr>
<td>relid</td>
<td>oid</td>
<td>执行COPY命令的表的OID。 如果从SELECT查询中复制，它被设置为0。</td>
</tr>
<tr>
<td>command</td>
<td>text</td>
<td>正在运行的命令: COPY FROM, 或 COPY TO。</td>
</tr>
<tr>
<td>type</td>
<td>text</td>
<td>数据被读取或写入的io类型:FILE, PROGRAM, PIPE (对于COPY FROM STDIN 和 COPY TO STDOUT)，或 CALLBACK(例如在逻辑复制中初始表同步期间使用)。</td>
</tr>
<tr>
<td>bytes_processed</td>
<td>bigint</td>
<td>已经被COPY命令处理的字节数。</td>
</tr>
<tr>
<td>bytes_total</td>
<td>bigint</td>
<td>COPY FROM命令的源文件大小，以字节计。 如果不可用则设置为0。</td>
</tr>
<tr>
<td>tuples_processed</td>
<td>bigint</td>
<td>已经被COPY命令处理的元组数。</td>
</tr>
<tr>
<td>tuples_excluded</td>
<td>bigint</td>
<td>没有处理的元组数，因为它们被COPY命令的WHERE子句所排除。</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_progress_create_index"><strong>pg_stat_progress_create_index</strong></h4>
<p>每当运行CREATE INDEX或REINDEX时，pg_stat_progress_create_index视图将包含当前正在创建索引的每个后端的一行。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pid</td>
<td>integer</td>
<td>后端的进程ID。</td>
</tr>
<tr>
<td>datid</td>
<td>oid</td>
<td>后端连接到的数据库的OID。</td>
</tr>
<tr>
<td>datname</td>
<td>name</td>
<td>后端连接到的数据库的名称。</td>
</tr>
<tr>
<td>relid</td>
<td>oid</td>
<td>正在创建索引的表的OID。</td>
</tr>
<tr>
<td>index_relid</td>
<td>oid</td>
<td>正在创建或重建索引的OID。在非并发 CREATE INDEX的时候，此为 0。</td>
</tr>
<tr>
<td>command</td>
<td>text</td>
<td>在运行的命令: CREATE INDEX,CREATE INDEX CONCURRENTLY, REINDEX, 或 REINDEX CONCURRENTLY.</td>
</tr>
<tr>
<td>phase</td>
<td>text</td>
<td>索引创建的当前处理阶段。 参见下表</td>
</tr>
<tr>
<td>lockers_total</td>
<td>bigint</td>
<td>在适用的情况下，需要等待的储物柜总数</td>
</tr>
<tr>
<td>lockers_done</td>
<td>bigint</td>
<td>已经等待的储物柜数量。</td>
</tr>
<tr>
<td>current_locker_pid</td>
<td>bigint</td>
<td>目前正在等待的储物柜的进程ID。</td>
</tr>
<tr>
<td>blocks_total</td>
<td>bigint</td>
<td>本阶段要处理的区块总数。</td>
</tr>
<tr>
<td>blocks_done</td>
<td>bigint</td>
<td>当前阶段已经处理的区块数量。</td>
</tr>
<tr>
<td>tuples_total</td>
<td>bigint</td>
<td>当前阶段要处理的元组总数。</td>
</tr>
<tr>
<td>tuples_done</td>
<td>bigint</td>
<td>在当前阶段已经处理的元组数量。</td>
</tr>
<tr>
<td>partitions_total</td>
<td>bigint</td>
<td>在分区表上创建索引时，该列被设置为要在其上创建索引的分区总数。 在REINDEX期间，此字段为0。</td>
</tr>
<tr>
<td>partitions_done</td>
<td>bigint</td>
<td>当在分区表上创建索引时，该列被设置为在其上建立索引的分区数。 在REINDEX期间，此字段为0。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>phase</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始化</td>
<td>CREATE INDEX或REINDEX正在准备创建索引。 这个阶段预计会非常短暂。</td>
</tr>
<tr>
<td>构建前等待读写器</td>
<td>CREATE INDEX CONCURRENTLY或REINDEX CONCURRENTLY正在等待有可能看到表的写锁的事务完成。 当不在并发模式时，这个阶段会被跳过。lockers_total、 lockers_done 和 current_locker_pid 列包含了这个阶段的进度信息。</td>
</tr>
<tr>
<td>新建索引</td>
<td>索引是由访问方法专用代码建立的。 在这一阶段，支持进度报告的访问方法填写自己的进度数据，子阶段在这一栏中表示。 通常情况下，blocks_total和blocks_done将包含进度数据，也可能包含tuples_total和tuples_done。</td>
</tr>
<tr>
<td>在验证前等待读写器</td>
<td>CREATE INDEX CONCURRENTLY或REINDEX CONCURRENTLY正在等待有可能写入表的事务完成写锁的事务。当不在并发模式时，这个阶段会被跳过。lockers_total、 lockers_done 和 current_locker_pid 列包含了这个阶段的进度信息。</td>
</tr>
<tr>
<td>索引验证：扫描索引</td>
<td>CREATE INDEX CONCURRENTLY正在扫描索引，搜索需要验证的图元组。如果不是在并发模式下，这个阶段会被跳过。列 blocks_total（设置为索引的总大小）和 blocks_done包含了这个阶段的进度信息。</td>
</tr>
<tr>
<td>指数验证：排序元组</td>
<td>CREATE INDEX CONCURRENTLY正在对索引扫描阶段的输出进行排序。</td>
</tr>
<tr>
<td>索引验证：扫描表</td>
<td>CREATE INDEX CONCURRENTLY正在扫描表，以验证前两个阶段收集的索引图元。当不在并发模式时，这个阶段被跳过。blocks_total列（设置为表的总大小）和blocks_done列包含这个阶段的进度信息。</td>
</tr>
<tr>
<td>等待旧照</td>
<td>CREATE INDEX CONCURRENTLY或REINDEX CONCURRENTLY正在等待可能看到表的事务释放快照。 当不处于并发模式时，这个阶段会被跳过。 lockers_total、lockers_done 和 current_locker_pid 列包含了这个阶段的进度信息。</td>
</tr>
<tr>
<td>标记 dead之前等待</td>
<td>REINDEX CONCURRENTLY等待表上有读锁的事务完成后，再将旧索引标记为死索引。当不在并发模式时，这个阶段被跳过。lockers_total、lockers_done 和 current_locker_pid 列包含了这个阶段的进度信息。</td>
</tr>
<tr>
<td>在 dropping之前等待readers</td>
<td>REINDEX CONCURRENTLY等待表上有读锁的事务完成后，再丢弃旧索引。当不在并发模式时，这个阶段被跳过。列 lockers_total、lockers_done 和 current_locker_pid包含了这个阶段的进度信息。</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_progress_vacuum"><strong>pg_stat_progress_vacuum</strong></h4>
<p>只要VACUUM正在运行，每一个当前正在清理的后端（包括autovacuum工作者进程）在pg_stat_progress_vacuum视图中都会有一行。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pid</td>
<td>integer</td>
<td>后端的进程ID。</td>
</tr>
<tr>
<td>datid</td>
<td>oid</td>
<td>这个后端连接的数据库的OID。</td>
</tr>
<tr>
<td>datname</td>
<td>name</td>
<td>这个后端连接的数据库的名称。</td>
</tr>
<tr>
<td>relid</td>
<td>oid</td>
<td>被vacuum的表的OID。</td>
</tr>
<tr>
<td>phase</td>
<td>text</td>
<td>vacuum的当前处理阶段。参见下表。</td>
</tr>
<tr>
<td>heap_blks_total</td>
<td>bigint</td>
<td>该表中堆块的总数。这个数字在扫描开始时报告，之后增加的块将不会（并且不需要）被这个VACUUM访问。</td>
</tr>
<tr>
<td>heap_blks_scanned</td>
<td>bigint</td>
<td>被扫描的堆块数量。由于visibility map被用来优化扫描，一些块将被跳过而不做检查， 被跳过的块会被包括在这个总数中，因此当清理完成时这个数字最终将会等于heap_blks_total。 仅当处于扫描堆阶段时这个计数器才会前进。</td>
</tr>
<tr>
<td>heap_blks_vacuumed</td>
<td>bigint</td>
<td>被清理的堆块数量。除非表没有索引，这个计数器仅在处于清理堆阶段时才会前进。 不包含死亡元组的块会被跳过，因此这个计数器可能有时会向前跳跃一个比较大的增量。</td>
</tr>
<tr>
<td>index_vacuum_count</td>
<td>bigint</td>
<td>已完成的索引清理周期数。</td>
</tr>
<tr>
<td>max_dead_tuples</td>
<td>bigint</td>
<td>在需要执行一个索引清理周期之前我们可以存储的死亡元组数，取决于maintenance_work_mem。</td>
</tr>
<tr>
<td>num_dead_tuples</td>
<td>bigint</td>
<td>从上一个索引清理周期以来收集的死亡元组数。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>阶段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始化</td>
<td>VACUUM正在准备开始扫描堆。这个阶段应该很简短。</td>
</tr>
<tr>
<td>扫描堆</td>
<td>VACUUM正在扫描堆。如果需要，它将会对每个页面进行修建以及碎片整理，并且可能会执行冻结动作。heap_blks_scanned列可以用来监控扫描的进度。</td>
</tr>
<tr>
<td>清理索引</td>
<td>VACUUM当前正在清理索引。 如果一个表拥有索引，那么每次清理时这个阶段会在堆扫描完成后至少发生一次。 如果maintenance_work_mem不足以存放找到的死亡元组(或者, 在autovacuum情况下，如果设置了autovacuum_work_mem) ，则每次清理时会多次清理索引。</td>
</tr>
<tr>
<td>清理堆</td>
<td>VACUUM当前正在清理堆。清理堆与扫描堆不是同一个概念，清理堆发生在每一次清理索引的实例之后。如果heap_blks_scanned小于heap_blks_total，系统将在这个阶段完成之后回去扫描堆；否则，系统将在这个阶段完成后开始清理索引。</td>
</tr>
<tr>
<td>清除索引</td>
<td>VACUUM当前正在清除索引。这个阶段发生在堆被完全扫描并且对堆和索引的所有清理都已经完成以后。</td>
</tr>
<tr>
<td>截断堆</td>
<td>VACUUM正在截断堆，以便把关系尾部的空页面返还给操作系统。这个阶段发生在清除完索引之后。</td>
</tr>
<tr>
<td>执行最后的清除</td>
<td>VACUUM在执行最终的清除。在这个阶段中，VACUUM将清理空闲空间映射、更新pg_class中的统计信息并且将统计信息报告给统计收集器。当这个阶段完成时，VACUUM也就结束了。</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_replication"><strong>pg_stat_replication</strong></h4>
<p>pg_stat_replication视图中将为每一个 WAL 发送进程包含一行，用来显示与该发送进程连接的后备服务器的复制统计信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pid</td>
<td>integer</td>
<td>一个 WAL 发送进程的进程 ID</td>
</tr>
<tr>
<td>usesysid</td>
<td>oid</td>
<td>登录到这个 WAL 发送进程的用户的 OID</td>
</tr>
<tr>
<td>usename</td>
<td>name</td>
<td>登录到这个 WAL 发送进程的用户的名称</td>
</tr>
<tr>
<td>application_name</td>
<td>text</td>
<td>连接到这个 WAL 发送进程的应用的名称</td>
</tr>
<tr>
<td>client_addr</td>
<td>inet</td>
<td>连接到这个 WAL 发送进程的客户端的 IP 地址。 如果这个域为空，它表示该客户端通过服务器机器上的一个 Unix 套接字连接。</td>
</tr>
<tr>
<td>client_hostname</td>
<td>text</td>
<td>连接上的客户端的主机名，由一次对client_addr 的逆向 DNS 查找报告。这个域将只对 IP 连接非空，并且只有在 log_hostname被启用时非空</td>
</tr>
<tr>
<td>client_port</td>
<td>integer</td>
<td>客户端用来与这个 WAL 发送进程通讯的 TCP 端口号， 如果使用 Unix 套接字则为-1</td>
</tr>
<tr>
<td>backend_start</td>
<td>timestamp with time zone</td>
<td>这个进程开始的时间，即客户端是何时连接到这个 WAL 发送进程的</td>
</tr>
<tr>
<td>backend_xmin</td>
<td>xid</td>
<td>由hot_standby_feedback报告 的这个后备机的xmin水平线。</td>
</tr>
<tr>
<td>state</td>
<td>text</td>
<td>当前的 WAL 发送进程状态。 可能的值是：startup：这个WAL发送器正在启动。catchup：这个WAL发送器连接的后备机正在追赶主服务器。streaming：这个WAL发送器在它连接的后备服务器追上主服务器之后用流传送更改。backup：这个WAL发送器正在发送一个备份。stopping：这个WAL发送器正在停止。</td>
</tr>
<tr>
<td>sent_lsn</td>
<td>pg_lsn</td>
<td>在这个连接上发送的最后一个预写式日志的位置</td>
</tr>
<tr>
<td>write_lsn</td>
<td>pg_lsn</td>
<td>被这个后备服务器写入到磁盘的最后一个预写式日志的位置</td>
</tr>
<tr>
<td>flush_lsn</td>
<td>pg_lsn</td>
<td>被这个后备服务器刷入到磁盘的最后一个预写式日志的位置</td>
</tr>
<tr>
<td>replay_lsn</td>
<td>pg_lsn</td>
<td>被重放到这个后备服务器上的数据库中的最后一个预写式日志的位置</td>
</tr>
<tr>
<td>write_lag</td>
<td>interval</td>
<td>在本地刷写近期的WAL与接收到后备服务器已经写入它（但还没有刷写或者应用）的通知之间流逝的时间。如果这台服务器被配置为一个同步后备，这可以用来计量在提交时synchronous_commit的级别remote_write所导致的延迟。</td>
</tr>
<tr>
<td>flush_lag</td>
<td>interval</td>
<td>在本地刷写近期的WAL与接收到后备服务器已经写入并且刷写它（但还没有应用）的通知之间流逝的时间。如果这台服务器被配置为一个同步后备，这可以用来计量在提交时synchronous_commit的级别on所导致的延迟。</td>
</tr>
<tr>
<td>replay_lag</td>
<td>interval</td>
<td>在本地刷写近期的WAL与接收到后备服务器已经写入它、刷写它并且应用它的通知之间流逝的时间。如果这台服务器被配置为一个同步后备，这可以用来计量在提交时synchronous_commit的级别remote_apply所导致的延迟。</td>
</tr>
<tr>
<td>sync_priority</td>
<td>integer</td>
<td>在基于优先的同步复制中，这台后备服务器被选为同步后备的优先级。在基于规定数量的同步复制中，这个值没有效果。</td>
</tr>
<tr>
<td>sync_state</td>
<td>text</td>
<td>这一台后备服务器的同步状态。 可能的值是：async：这台后备服务器是异步的。potential：这台后备服务器现在是异步的，但可能在当前的同步后备失效时变成同步的。sync：这台后备服务器是同步的。quorum：这台后备服务器被当做规定数量后备服务器的候选。</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_ssl"><strong>pg_stat_ssl</strong></h4>
<p>pg_stat_ssl视图将为每一个后端或者 WAL 发送进程 包含一行，用来显示这个连接上的 SSL 使用情况。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pid</td>
<td>integer</td>
<td>一个后端或者 WAL 发送进程的进程 ID</td>
</tr>
<tr>
<td>ssl</td>
<td>boolean</td>
<td>如果在这个连接上使用了 SSL 则为真</td>
</tr>
<tr>
<td>version</td>
<td>text</td>
<td>在用的 SSL 版本，如果这个连接上没有使用 SSL 则为 NULL</td>
</tr>
<tr>
<td>cipher</td>
<td>text</td>
<td>在用的 SSL 密码的名称，如果这个连接上没有使用 SSL 则为 NULL</td>
</tr>
<tr>
<td>bits</td>
<td>integer</td>
<td>使用的加密算法中的位数，如果这个连接上没有使用 SSL 则为 NULL</td>
</tr>
<tr>
<td>compression</td>
<td>boolean</td>
<td>如果使用了 SSL 压缩则为真，否则为假， 如果这个连接上没有使用 SSL 则为 NULL</td>
</tr>
<tr>
<td>clientdn</td>
<td>text</td>
<td>来自所使用的客户端证书的识别名（DN）域， 如果没有提供客户端证书或者这个连接上没有使用 SSL 则为 NULL。如果 DN 域长度超过 NAMEDATALEN（标准编译 中是 64 个字符），则它会被截断。</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_statements"><strong>pg_stat_statements</strong></h4>
<p>pg_stat_statements模块提供一种方法追踪一个服务器所执行的所有 SQL 语句的执行统计信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>userid</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>执行该语句的用户的 OID</td>
</tr>
<tr>
<td>dbid</td>
<td>oid</td>
<td>pg_database.oid</td>
<td>在其中执行该语句的数据库的 OID</td>
</tr>
<tr>
<td>queryid</td>
<td>bigint</td>
<td></td>
<td>内部哈希码，从语句的解析树计算得来</td>
</tr>
<tr>
<td>query</td>
<td>text</td>
<td></td>
<td>语句的文本形式</td>
</tr>
<tr>
<td>calls</td>
<td>bigint</td>
<td></td>
<td>被执行的次数</td>
</tr>
<tr>
<td>total_time</td>
<td>double precision</td>
<td></td>
<td>在该语句中花费的总时间，以毫秒计</td>
</tr>
<tr>
<td>min_time</td>
<td>double precision</td>
<td></td>
<td>在该语句中花费的最小时间，以毫秒计</td>
</tr>
<tr>
<td>max_time</td>
<td>double precision</td>
<td></td>
<td>在该语句中花费的最大时间，以毫秒计</td>
</tr>
<tr>
<td>mean_time</td>
<td>double precision</td>
<td></td>
<td>在该语句中花费的平均时间，以毫秒计</td>
</tr>
<tr>
<td>stddev_time</td>
<td>double precision</td>
<td></td>
<td>在该语句中花费时间的总体标准偏差，以毫秒计</td>
</tr>
<tr>
<td>rows</td>
<td>bigint</td>
<td></td>
<td>该语句检索或影响的行总数</td>
</tr>
<tr>
<td>shared_blks_hit</td>
<td>bigint</td>
<td></td>
<td>该语句造成的共享块缓冲命中总数</td>
</tr>
<tr>
<td>shared_blks_read</td>
<td>bigint</td>
<td></td>
<td>该语句读取的共享块的总数</td>
</tr>
<tr>
<td>shared_blks_dirtied</td>
<td>bigint</td>
<td></td>
<td>该语句弄脏的共享块的总数</td>
</tr>
<tr>
<td>shared_blks_written</td>
<td>bigint</td>
<td></td>
<td>该语句写入的共享块的总数</td>
</tr>
<tr>
<td>local_blks_hit</td>
<td>bigint</td>
<td></td>
<td>该语句造成的本地块缓冲命中总数</td>
</tr>
<tr>
<td>local_blks_read</td>
<td>bigint</td>
<td></td>
<td>该语句读取的本地块的总数</td>
</tr>
<tr>
<td>local_blks_dirtied</td>
<td>bigint</td>
<td></td>
<td>该语句弄脏的本地块的总数</td>
</tr>
<tr>
<td>local_blks_written</td>
<td>bigint</td>
<td></td>
<td>该语句写入的本地块的总数</td>
</tr>
<tr>
<td>temp_blks_read</td>
<td>bigint</td>
<td></td>
<td>该语句读取的临时块的总数</td>
</tr>
<tr>
<td>temp_blks_written</td>
<td>bigint</td>
<td></td>
<td>该语句写入的临时块的总数</td>
</tr>
<tr>
<td>blk_read_time</td>
<td>double precision</td>
<td></td>
<td>该语句花在读取块上的总时间，以毫秒计（如果track_io_timing被启用，否则为零）</td>
</tr>
<tr>
<td>blk_write_time</td>
<td>double precision</td>
<td></td>
<td>该语句花在写入块上的总时间，以毫秒计（如果track_io_timing被启用，否则为零）</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_subscription"><strong>pg_stat_subscription</strong></h4>
<p>每一个订阅的主工作者都在pg_stat_subscription视图中有一行（如果工作者没有运行则PID为空），处理被订阅表的初始数据拷贝操作的工作者还会有额外的行。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>subid</td>
<td>oid</td>
<td>订阅的OID</td>
</tr>
<tr>
<td>subname</td>
<td>text</td>
<td>订阅的名称</td>
</tr>
<tr>
<td>pid</td>
<td>integer</td>
<td>订阅工作者进程的进程ID</td>
</tr>
<tr>
<td>relid</td>
<td>Oid</td>
<td>工作者正在同步的关系的OID，对于主应用工作者为空</td>
</tr>
<tr>
<td>received_lsn</td>
<td>pg_lsn</td>
<td>接收到的最后一个预写式日志位置，这个字段的初始值是0</td>
</tr>
<tr>
<td>last_msg_send_time</td>
<td>timestamp with time zone</td>
<td>从源头WAL发送器接收到的最后一个消息的发送时间</td>
</tr>
<tr>
<td>last_msg_receipt_time</td>
<td>timestamp with time zone</td>
<td>从源头WAL发送器接收到的最后一个消息的接收时间</td>
</tr>
<tr>
<td>latest_end_lsn</td>
<td>pg_lsn</td>
<td>最后一个报告给源头WAL发送器的预写式日志位置</td>
</tr>
<tr>
<td>latest_end_time</td>
<td>timestamp with time zone</td>
<td>报告给源头WAL发送器的最后一个预写式日志位置的时间</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_sys_indexes"><strong>pg_stat_sys_indexes</strong></h4>
<p>和pg_stat_all_indexes一样，但只显示系统表上的索引。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>这个索引的基表的 OID</td>
</tr>
<tr>
<td>indexrelid</td>
<td>oid</td>
<td>这个索引的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个索引所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个索引的基表的名称</td>
</tr>
<tr>
<td>indexrelname</td>
<td>name</td>
<td>这个索引的名称</td>
</tr>
<tr>
<td>idx_scan</td>
<td>bigint</td>
<td>在这个索引上发起的索引扫描次数</td>
</tr>
<tr>
<td>idx_tup_read</td>
<td>bigint</td>
<td>在这个索引上由扫描返回的索引项数量</td>
</tr>
<tr>
<td>idx_tup_fetch</td>
<td>bigint</td>
<td>被使用这个索引的简单索引扫描取得的活着的表行数量</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_sys_tables"><strong>pg_stat_sys_tables</strong></h4>
<p>和pg_stat_all_tables一样，但只显示系统表。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>一个表的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个表所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个表的名称</td>
</tr>
<tr>
<td>seq_scan</td>
<td>bigint</td>
<td>在这个表上发起的顺序扫描的次数</td>
</tr>
<tr>
<td>seq_tup_read</td>
<td>bigint</td>
<td>被顺序扫描取得的活着的行的数量</td>
</tr>
<tr>
<td>idx_scan</td>
<td>bigint</td>
<td>在这个表上发起的索引扫描的次数</td>
</tr>
<tr>
<td>idx_tup_fetch</td>
<td>bigint</td>
<td>被索引扫描取得的活着的行的数量</td>
</tr>
<tr>
<td>n_tup_ins</td>
<td>bigint</td>
<td>被插入的行数</td>
</tr>
<tr>
<td>n_tup_upd</td>
<td>bigint</td>
<td>被更新的行数（包括 HOT 更新的行）</td>
</tr>
<tr>
<td>n_tup_del</td>
<td>bigint</td>
<td>被删除的行数</td>
</tr>
<tr>
<td>n_tup_hot_upd</td>
<td>bigint</td>
<td>被更新的 HOT 行数（即不要求独立索引更新的行更新）</td>
</tr>
<tr>
<td>n_live_tup</td>
<td>bigint</td>
<td>活着的行的估计数量</td>
</tr>
<tr>
<td>n_dead_tup</td>
<td>bigint</td>
<td>死亡行的估计数量</td>
</tr>
<tr>
<td>n_mod_since_analyze</td>
<td>bigint</td>
<td>从这个表最后一次被分析后备修改的行的估计数量</td>
</tr>
<tr>
<td>last_vacuum</td>
<td>timestamp with time zone</td>
<td>上次这个表被手动清理的时间（不统计VACUUM FULL）</td>
</tr>
<tr>
<td>last_autovacuum</td>
<td>timestamp with time zone</td>
<td>上次这个表被自动清理守护进程清理的时间</td>
</tr>
<tr>
<td>last_analyze</td>
<td>timestamp with time zone</td>
<td>上次这个表被手动分析的时间</td>
</tr>
<tr>
<td>last_autoanalyze</td>
<td>timestamp with time zone</td>
<td>上次这个表被自动清理守护进程分析的时间</td>
</tr>
<tr>
<td>vacuum_count</td>
<td>bigint</td>
<td>这个表已被手工清理的次数（不统计VACUUM FULL）</td>
</tr>
<tr>
<td>autovacuum_count</td>
<td>bigint</td>
<td>这个表已被自动清理守护进程清理的次数</td>
</tr>
<tr>
<td>analyze_count</td>
<td>bigint</td>
<td>这个表已被手工分析的次数</td>
</tr>
<tr>
<td>autoanalyze_count</td>
<td>bigint</td>
<td>这个表已被自动清理守护进程分析的次数</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_user_functions"><strong>pg_stat_user_functions</strong></h4>
<p>pg_stat_user_functions视图将为每一个被追踪的函数包含一行，该行显示有关该函数执行的统计信息。track_functions参数控制到底哪些函数被跟踪。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>funcid</td>
<td>oid</td>
<td>一个函数的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个函数所在的模式的名称</td>
</tr>
<tr>
<td>funcname</td>
<td>name</td>
<td>这个函数的名称</td>
</tr>
<tr>
<td>calls</td>
<td>bigint</td>
<td>这个函数已经被调用的次数</td>
</tr>
<tr>
<td>total_time</td>
<td>double precision</td>
<td>在这个函数以及它所调用的其他函数中花费的总时间，以毫秒计</td>
</tr>
<tr>
<td>self_time</td>
<td>double precision</td>
<td>在这个函数本身花费的总时间，不包括被它调用的其他函数，以毫秒计</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_user_indexes"><strong>pg_stat_user_indexes</strong></h4>
<p>和pg_stat_all_indexes一样，但只显示用户表上的索引。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>这个索引的基表的 OID</td>
</tr>
<tr>
<td>indexrelid</td>
<td>oid</td>
<td>这个索引的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个索引所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个索引的基表的名称</td>
</tr>
<tr>
<td>indexrelname</td>
<td>name</td>
<td>这个索引的名称</td>
</tr>
<tr>
<td>idx_scan</td>
<td>bigint</td>
<td>在这个索引上发起的索引扫描次数</td>
</tr>
<tr>
<td>idx_tup_read</td>
<td>bigint</td>
<td>在这个索引上由扫描返回的索引项数量</td>
</tr>
<tr>
<td>idx_tup_fetch</td>
<td>bigint</td>
<td>被使用这个索引的简单索引扫描取得的活着的表行数量</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_user_tables"><strong>pg_stat_user_tables</strong></h4>
<p>和pg_stat_all_tables一样，但只显示用户表。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>一个表的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个表所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个表的名称</td>
</tr>
<tr>
<td>seq_scan</td>
<td>bigint</td>
<td>在这个表上发起的顺序扫描的次数</td>
</tr>
<tr>
<td>seq_tup_read</td>
<td>bigint</td>
<td>被顺序扫描取得的活着的行的数量</td>
</tr>
<tr>
<td>idx_scan</td>
<td>bigint</td>
<td>在这个表上发起的索引扫描的次数</td>
</tr>
<tr>
<td>idx_tup_fetch</td>
<td>bigint</td>
<td>被索引扫描取得的活着的行的数量</td>
</tr>
<tr>
<td>n_tup_ins</td>
<td>bigint</td>
<td>被插入的行数</td>
</tr>
<tr>
<td>n_tup_upd</td>
<td>bigint</td>
<td>被更新的行数（包括 HOT 更新的行）</td>
</tr>
<tr>
<td>n_tup_del</td>
<td>bigint</td>
<td>被删除的行数</td>
</tr>
<tr>
<td>n_tup_hot_upd</td>
<td>bigint</td>
<td>被更新的 HOT 行数（即不要求独立索引更新的行更新）</td>
</tr>
<tr>
<td>n_live_tup</td>
<td>bigint</td>
<td>活着的行的估计数量</td>
</tr>
<tr>
<td>n_dead_tup</td>
<td>bigint</td>
<td>死亡行的估计数量</td>
</tr>
<tr>
<td>n_mod_since_analyze</td>
<td>bigint</td>
<td>从这个表最后一次被分析后备修改的行的估计数量</td>
</tr>
<tr>
<td>last_vacuum</td>
<td>timestamp with time zone</td>
<td>上次这个表被手动清理的时间（不统计VACUUM FULL）</td>
</tr>
<tr>
<td>last_autovacuum</td>
<td>timestamp with time zone</td>
<td>上次这个表被自动清理守护进程清理的时间</td>
</tr>
<tr>
<td>last_analyze</td>
<td>timestamp with time zone</td>
<td>上次这个表被手动分析的时间</td>
</tr>
<tr>
<td>last_autoanalyze</td>
<td>timestamp with time zone</td>
<td>上次这个表被自动清理守护进程分析的时间</td>
</tr>
<tr>
<td>vacuum_count</td>
<td>bigint</td>
<td>这个表已被手工清理的次数（不统计VACUUM FULL）</td>
</tr>
<tr>
<td>autovacuum_count</td>
<td>bigint</td>
<td>这个表已被自动清理守护进程清理的次数</td>
</tr>
<tr>
<td>analyze_count</td>
<td>bigint</td>
<td>这个表已被手工分析的次数</td>
</tr>
<tr>
<td>autoanalyze_count</td>
<td>bigint</td>
<td>这个表已被自动清理守护进程分析的次数</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_wal_receiver"><strong>pg_stat_wal_receiver</strong></h4>
<p>pg_stat_wal_receiver事务只包含一行，它显示了从 WAL 接收器所连接的服务器得到的有关该接收器的统计信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pid</td>
<td>integer</td>
<td>WAL 接收器进程的进程 ID</td>
</tr>
<tr>
<td>status</td>
<td>text</td>
<td>WAL 接收器进程的活动状态</td>
</tr>
<tr>
<td>receive_start_lsn</td>
<td>pg_lsn</td>
<td>WAL 接收器启动时使用的第一个预写式日志位置</td>
</tr>
<tr>
<td>receive_start_tli</td>
<td>integer</td>
<td>WAL 接收器启动时使用的第一个时间线编号</td>
</tr>
<tr>
<td>received_lsn</td>
<td>pg_lsn</td>
<td>已经接收到并且已经被刷入磁盘的最后一个预写式日志的位置，这个域的初始值是 WAL 接收器启动时使用的第一个日志位置</td>
</tr>
<tr>
<td>received_tli</td>
<td>integer</td>
<td>已经接收到并且已经被刷入磁盘的最后一个预写式日志的时间线编号，这个域的初始值是 WAL 接收器启动时使用的第一个日志所在的时间线编号</td>
</tr>
<tr>
<td>last_msg_send_time</td>
<td>timestamp with time zone</td>
<td>从源头 WAL 发送器接收到的最后一个消息的发送时间</td>
</tr>
<tr>
<td>last_msg_receipt_time</td>
<td>timestamp with time zone</td>
<td>从源头 WAL 发送器接收到的最后一个消息的接收时间</td>
</tr>
<tr>
<td>latest_end_lsn</td>
<td>pg_lsn</td>
<td>报告给源头 WAL 发送器的最后一个预写式日志位置</td>
</tr>
<tr>
<td>latest_end_time</td>
<td>timestamp with time zone</td>
<td>报告给源头 WAL 发送器最后一个事务日志位置的时间</td>
</tr>
<tr>
<td>slot_name</td>
<td>text</td>
<td>这个 WAL 接收器使用的复制槽的名称</td>
</tr>
<tr>
<td>sender_host</td>
<td>text</td>
<td>这个WAL接收器连接到的PostgreSQL实例的主机。这可以是一个主机名、一个IP地址，如果连接是通过Unix套接字则是一个目录路径（为目录的情况可以被辨别出来，因为路径将总是一个绝对路径并且以/开头）。</td>
</tr>
<tr>
<td>sender_port</td>
<td>integer</td>
<td>这个WAL接收器连接到的PostgreSQL实例的端口号。</td>
</tr>
<tr>
<td>conninfo</td>
<td>text</td>
<td>这个 WAL 接收器使用的连接串，安全相关的域会被隐去。</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_xact_all_tables"><strong>pg_stat_xact_all_tables</strong></h4>
<p>和pg_stat_all_tables相似，但计数动作只在当前事务内发生（还没有被包括在pg_stat_all_tables和相关视图中）。用于生存和死亡行数量的列以及清理和分析动作在此视图中不出现。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>一个表的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个表所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个表的名称</td>
</tr>
<tr>
<td>seq_scan</td>
<td>bigint</td>
<td>在这个表上发起的顺序扫描的次数</td>
</tr>
<tr>
<td>seq_tup_read</td>
<td>bigint</td>
<td>被顺序扫描取得的活着的行的数量</td>
</tr>
<tr>
<td>idx_scan</td>
<td>bigint</td>
<td>在这个表上发起的索引扫描的次数</td>
</tr>
<tr>
<td>idx_tup_fetch</td>
<td>bigint</td>
<td>被索引扫描取得的活着的行的数量</td>
</tr>
<tr>
<td>n_tup_ins</td>
<td>bigint</td>
<td>被插入的行数</td>
</tr>
<tr>
<td>n_tup_upd</td>
<td>bigint</td>
<td>被更新的行数（包括 HOT 更新的行）</td>
</tr>
<tr>
<td>n_tup_del</td>
<td>bigint</td>
<td>被删除的行数</td>
</tr>
<tr>
<td>n_tup_hot_upd</td>
<td>bigint</td>
<td>被更新的 HOT 行数（即不要求独立索引更新的行更新）</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_xact_sys_tables"><strong>pg_stat_xact_sys_tables</strong></h4>
<p>和pg_stat_xact_all_tables一样，但只显示系统表。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>一个表的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个表所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个表的名称</td>
</tr>
<tr>
<td>seq_scan</td>
<td>bigint</td>
<td>在这个表上发起的顺序扫描的次数</td>
</tr>
<tr>
<td>seq_tup_read</td>
<td>bigint</td>
<td>被顺序扫描取得的活着的行的数量</td>
</tr>
<tr>
<td>idx_scan</td>
<td>bigint</td>
<td>在这个表上发起的索引扫描的次数</td>
</tr>
<tr>
<td>idx_tup_fetch</td>
<td>bigint</td>
<td>被索引扫描取得的活着的行的数量</td>
</tr>
<tr>
<td>n_tup_ins</td>
<td>bigint</td>
<td>被插入的行数</td>
</tr>
<tr>
<td>n_tup_upd</td>
<td>bigint</td>
<td>被更新的行数（包括 HOT 更新的行）</td>
</tr>
<tr>
<td>n_tup_del</td>
<td>bigint</td>
<td>被删除的行数</td>
</tr>
<tr>
<td>n_tup_hot_upd</td>
<td>bigint</td>
<td>被更新的 HOT 行数（即不要求独立索引更新的行更新）</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_xact_user_functions"><strong>pg_stat_xact_user_functions</strong></h4>
<p>和pg_stat_user_functions相似，但是只统计在当前事务期间的调用（还没有被包括在pg_stat_user_functions中）。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>funcid</td>
<td>oid</td>
<td>一个函数的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个函数所在的模式的名称</td>
</tr>
<tr>
<td>funcname</td>
<td>name</td>
<td>这个函数的名称</td>
</tr>
<tr>
<td>calls</td>
<td>bigint</td>
<td>这个函数已经被调用的次数</td>
</tr>
<tr>
<td>total_time</td>
<td>double precision</td>
<td>在这个函数以及它所调用的其他函数中花费的总时间，以毫秒计</td>
</tr>
<tr>
<td>self_time</td>
<td>double precision</td>
<td>在这个函数本身花费的总时间，不包括被它调用的其他函数，以毫秒计</td>
</tr>
</tbody>
</table>
<h4 id="pg_stat_xact_user_tables"><strong>pg_stat_xact_user_tables</strong></h4>
<p>和pg_stat_xact_all_tables一样，但只显示用户表。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>一个表的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个表所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个表的名称</td>
</tr>
<tr>
<td>seq_scan</td>
<td>bigint</td>
<td>在这个表上发起的顺序扫描的次数</td>
</tr>
<tr>
<td>seq_tup_read</td>
<td>bigint</td>
<td>被顺序扫描取得的活着的行的数量</td>
</tr>
<tr>
<td>idx_scan</td>
<td>bigint</td>
<td>在这个表上发起的索引扫描的次数</td>
</tr>
<tr>
<td>idx_tup_fetch</td>
<td>bigint</td>
<td>被索引扫描取得的活着的行的数量</td>
</tr>
<tr>
<td>n_tup_ins</td>
<td>bigint</td>
<td>被插入的行数</td>
</tr>
<tr>
<td>n_tup_upd</td>
<td>bigint</td>
<td>被更新的行数（包括 HOT 更新的行）</td>
</tr>
<tr>
<td>n_tup_del</td>
<td>bigint</td>
<td>被删除的行数</td>
</tr>
<tr>
<td>n_tup_hot_upd</td>
<td>bigint</td>
<td>被更新的 HOT 行数（即不要求独立索引更新的行更新）</td>
</tr>
</tbody>
</table>
<h4 id="pg_statio_all_indexes"><strong>pg_statio_all_indexes</strong></h4>
<p>pg_statio_all_indexes视图将为当前数据库中的每个索引包含一行，该行显示指定索引上有关 I/O 的统计信息。pg_statio_user_indexes和pg_statio_sys_indexes视图包含相同的信息，但是被过滤得分别只显示用户索引和系统索引。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>这个索引的基表的 OID</td>
</tr>
<tr>
<td>indexrelid</td>
<td>oid</td>
<td>这个索引的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个索引所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个索引的基表的名称</td>
</tr>
<tr>
<td>indexrelname</td>
<td>name</td>
<td>这个索引的名称</td>
</tr>
<tr>
<td>idx_blks_read</td>
<td>bigint</td>
<td>从这个索引读取的磁盘块数</td>
</tr>
<tr>
<td>idx_blks_hit</td>
<td>bigint</td>
<td>在这个索引中的缓冲区命中数量</td>
</tr>
</tbody>
</table>
<h4 id="pg_statio_all_sequences"><strong>pg_statio_all_sequences</strong></h4>
<p>pg_statio_all_sequences视图将为当前数据库中的每个序列包含一行，该行显示在指定序列上有关 I/O 的统计信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>一个序列的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个序列所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个序列的名称</td>
</tr>
<tr>
<td>blks_read</td>
<td>bigint</td>
<td>从这个序列中读取的磁盘块数</td>
</tr>
<tr>
<td>blks_hit</td>
<td>bigint</td>
<td>在这个序列中的缓冲区命中数量</td>
</tr>
</tbody>
</table>
<h4 id="pg_statio_all_tables"><strong>pg_statio_all_tables</strong></h4>
<p>pg_statio_all_tables视图将为当前数据库中的每个表（包括 TOAST 表）包含一行，该行显示指定表上有关 I/O 的统计信息。pg_statio_user_tables和pg_statio_sys_tables视图包含相同的信息，但是被过滤得分别只显示用户表和系统表。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>一个表的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个表所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个表的名称</td>
</tr>
<tr>
<td>heap_blks_read</td>
<td>bigint</td>
<td>从这个表读取的磁盘块数量</td>
</tr>
<tr>
<td>heap_blks_hit</td>
<td>bigint</td>
<td>在这个表中的缓冲区命中数量</td>
</tr>
<tr>
<td>idx_blks_read</td>
<td>bigint</td>
<td>从这个表上所有索引中读取的磁盘块数</td>
</tr>
<tr>
<td>idx_blks_hit</td>
<td>bigint</td>
<td>在这个表上的所有索引中的缓冲区命中数量</td>
</tr>
<tr>
<td>toast_blks_read</td>
<td>bigint</td>
<td>从这个表的 TOAST 表（如果有）读取的磁盘块数</td>
</tr>
<tr>
<td>toast_blks_hit</td>
<td>bigint</td>
<td>在这个表的 TOAST 表（如果有）中的缓冲区命中数量</td>
</tr>
<tr>
<td>tidx_blks_read</td>
<td>bigint</td>
<td>从这个表的 TOAST 表索引（如果有）中读取的磁盘块数</td>
</tr>
<tr>
<td>tidx_blks_hit</td>
<td>bigint</td>
<td>在这个表的 TOAST 表索引（如果有）中的缓冲区命中数量</td>
</tr>
</tbody>
</table>
<h4 id="pg_statio_sys_indexes"><strong>pg_statio_sys_indexes</strong></h4>
<p>和pg_statio_all_indexes一样，但只显示系统表上的索引。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>这个索引的基表的 OID</td>
</tr>
<tr>
<td>indexrelid</td>
<td>oid</td>
<td>这个索引的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个索引所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个索引的基表的名称</td>
</tr>
<tr>
<td>indexrelname</td>
<td>name</td>
<td>这个索引的名称</td>
</tr>
<tr>
<td>idx_blks_read</td>
<td>bigint</td>
<td>从这个索引读取的磁盘块数</td>
</tr>
<tr>
<td>idx_blks_hit</td>
<td>bigint</td>
<td>在这个索引中的缓冲区命中数量</td>
</tr>
</tbody>
</table>
<h4 id="pg_statio_sys_sequences"><strong>pg_statio_sys_sequences</strong></h4>
<p>和pg_statio_all_sequences一样，但只显示系统序列</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>一个序列的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个序列所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个序列的名称</td>
</tr>
<tr>
<td>blks_read</td>
<td>bigint</td>
<td>从这个序列中读取的磁盘块数</td>
</tr>
<tr>
<td>blks_hit</td>
<td>bigint</td>
<td>在这个序列中的缓冲区命中数量</td>
</tr>
</tbody>
</table>
<h4 id="pg_statio_sys_tables"><strong>pg_statio_sys_tables</strong></h4>
<p>和pg_statio_all_tables一样，但只显示系统表。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>一个表的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个表所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个表的名称</td>
</tr>
<tr>
<td>heap_blks_read</td>
<td>bigint</td>
<td>从这个表读取的磁盘块数量</td>
</tr>
<tr>
<td>heap_blks_hit</td>
<td>bigint</td>
<td>在这个表中的缓冲区命中数量</td>
</tr>
<tr>
<td>idx_blks_read</td>
<td>bigint</td>
<td>从这个表上所有索引中读取的磁盘块数</td>
</tr>
<tr>
<td>idx_blks_hit</td>
<td>bigint</td>
<td>在这个表上的所有索引中的缓冲区命中数量</td>
</tr>
<tr>
<td>toast_blks_read</td>
<td>bigint</td>
<td>从这个表的 TOAST 表（如果有）读取的磁盘块数</td>
</tr>
<tr>
<td>toast_blks_hit</td>
<td>bigint</td>
<td>在这个表的 TOAST 表（如果有）中的缓冲区命中数量</td>
</tr>
<tr>
<td>tidx_blks_read</td>
<td>bigint</td>
<td>从这个表的 TOAST 表索引（如果有）中读取的磁盘块数</td>
</tr>
<tr>
<td>tidx_blks_hit</td>
<td>bigint</td>
<td>在这个表的 TOAST 表索引（如果有）中的缓冲区命中数量</td>
</tr>
</tbody>
</table>
<h4 id="pg_statio_user_indexes"><strong>pg_statio_user_indexes</strong></h4>
<p>和pg_statio_all_indexes一样，但只显示用户表上的索引。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>这个索引的基表的 OID</td>
</tr>
<tr>
<td>indexrelid</td>
<td>oid</td>
<td>这个索引的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个索引所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个索引的基表的名称</td>
</tr>
<tr>
<td>indexrelname</td>
<td>name</td>
<td>这个索引的名称</td>
</tr>
<tr>
<td>idx_blks_read</td>
<td>bigint</td>
<td>从这个索引读取的磁盘块数</td>
</tr>
<tr>
<td>idx_blks_hit</td>
<td>bigint</td>
<td>在这个索引中的缓冲区命中数量</td>
</tr>
</tbody>
</table>
<h4 id="pg_statio_user_sequences"><strong>pg_statio_user_sequences</strong></h4>
<p>和pg_statio_all_sequences一样，但只显示用户序列。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>一个序列的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个序列所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个序列的名称</td>
</tr>
<tr>
<td>blks_read</td>
<td>bigint</td>
<td>从这个序列中读取的磁盘块数</td>
</tr>
<tr>
<td>blks_hit</td>
<td>bigint</td>
<td>在这个序列中的缓冲区命中数量</td>
</tr>
</tbody>
</table>
<p>​       </p>
<h4 id="pg_statio_user_tables"><strong>pg_statio_user_tables</strong></h4>
<p>和pg_statio_all_tables一样，但只显示用户表。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>relid</td>
<td>oid</td>
<td>一个表的 OID</td>
</tr>
<tr>
<td>schemaname</td>
<td>name</td>
<td>这个表所在的模式的名称</td>
</tr>
<tr>
<td>relname</td>
<td>name</td>
<td>这个表的名称</td>
</tr>
<tr>
<td>heap_blks_read</td>
<td>bigint</td>
<td>从这个表读取的磁盘块数量</td>
</tr>
<tr>
<td>heap_blks_hit</td>
<td>bigint</td>
<td>在这个表中的缓冲区命中数量</td>
</tr>
<tr>
<td>idx_blks_read</td>
<td>bigint</td>
<td>从这个表上所有索引中读取的磁盘块数</td>
</tr>
<tr>
<td>idx_blks_hit</td>
<td>bigint</td>
<td>在这个表上的所有索引中的缓冲区命中数量</td>
</tr>
<tr>
<td>toast_blks_read</td>
<td>bigint</td>
<td>从这个表的 TOAST 表（如果有）读取的磁盘块数</td>
</tr>
<tr>
<td>toast_blks_hit</td>
<td>bigint</td>
<td>在这个表的 TOAST 表（如果有）中的缓冲区命中数量</td>
</tr>
<tr>
<td>tidx_blks_read</td>
<td>bigint</td>
<td>从这个表的 TOAST 表索引（如果有）中读取的磁盘块数</td>
</tr>
<tr>
<td>tidx_blks_hit</td>
<td>bigint</td>
<td>在这个表的 TOAST 表索引（如果有）中的缓冲区命中数量</td>
</tr>
</tbody>
</table>
<h4 id="pg_statistic"><strong>pg_statistic</strong></h4>
<p>pg_statistic存储有关数据库内容的统计数据。其中的项由ANALYZE创建，查询规划器会使用这些数据来进行查询规划。注意所有的统计数据天然就是近似的，即使它刚刚被更新。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>starelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>被描述列所属的表或索引</td>
</tr>
<tr>
<td>staattnum</td>
<td>int2</td>
<td>pg_attribute.attnum</td>
<td>被描述列的编号</td>
</tr>
<tr>
<td>stainherit</td>
<td>bool</td>
<td></td>
<td>如果为真，统计包含了继承后代的列而不仅仅是指定关系的列</td>
</tr>
<tr>
<td>stanullfrac</td>
<td>float4</td>
<td></td>
<td>列的项为空的比例</td>
</tr>
<tr>
<td>stawidth</td>
<td>int4</td>
<td></td>
<td>非空项的平均存储宽度，以字节计</td>
</tr>
<tr>
<td>stadistinct</td>
<td>float4</td>
<td></td>
<td>列中非空唯一值的数目。一个大于零的值是唯一值的真正数目。一个小于零的值是表中行数的乘数的负值；例如，对于一个 80% 的值为非空且每个非空值平均出现两次的列，可以表示为stadistinct = -0.4。一个0值表示唯一值的数目未知。</td>
</tr>
<tr>
<td>stakindN</td>
<td>int2</td>
<td></td>
<td>一个代码，它表示存储在该pg_statistic行中第N个“槽位”的统计类型。</td>
</tr>
<tr>
<td>staopN</td>
<td>oid</td>
<td>pg_operator.oid</td>
<td>一个用于生成这些存储在第N个“槽位”的统计信息的操作符。 比如，一个柱面图槽位会用&lt;操作符，该操作符定义了该数据的排序顺序。</td>
</tr>
<tr>
<td>stanumbersN</td>
<td>float4[]</td>
<td></td>
<td>第N个“槽位”的类型的数值类型统计， 如果该槽位不涉及数值类型则为NULL</td>
</tr>
<tr>
<td>stavaluesN</td>
<td>anyarray</td>
<td></td>
<td>第N个“槽位”的类型的列值，如果该槽位类型不存储任何数据值则为 NULL。 每个数组的元素值实际上都是指定列的数据类型或者是一个相关类型（如数组元素类型）， 因此，除了把这些列的类型定义成anyarray之外别无他法。</td>
</tr>
</tbody>
</table>
<h4 id="pg_statistic_ext"><strong>pg_statistic_ext</strong></h4>
<p>pg_statistic_ext保持有扩展的规划器统计信息。每一行对应于一个用CREATE STATISTICS创建的统计信息对象。 </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>stxrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>包含这个对象所描述的列的表</td>
</tr>
<tr>
<td>stxname</td>
<td>name</td>
<td></td>
<td>统计信息对象的名称</td>
</tr>
<tr>
<td>stxnamespace</td>
<td>oid</td>
<td>pg_namespace.oid</td>
<td>包含这个统计信息对象的名字空间的OID</td>
</tr>
<tr>
<td>stxowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>统计信息对象的拥有者</td>
</tr>
<tr>
<td>stxkeys</td>
<td>int2vector</td>
<td>pg_attribute.attnum</td>
<td>一个属性编号的数组，表示哪些表列被这个统计信息对象覆盖。例如值1 3表示第一个和第三个表列被覆盖</td>
</tr>
<tr>
<td>stxkind</td>
<td>char[]</td>
<td></td>
<td>包含被启用统计类型代码的数组，可用的值有： d表示n-distinct统计信息， f表示函数依赖统计信息</td>
</tr>
<tr>
<td>stxndistinct</td>
<td>pg_ndistinct</td>
<td></td>
<td>N-distinct计数，序列化为pg_ndistinct类型</td>
</tr>
<tr>
<td>stxdependencies</td>
<td>pg_dependencies</td>
<td></td>
<td>函数依赖统计信息，序列化为pg_dependencies类型</td>
</tr>
</tbody>
</table>
<h4 id="pg_stats"><strong>pg_stats</strong></h4>
<p>视图pg_stats提供对存储在pg_statistic目录中信息的访问。此视图能访问pg_statistic行是有限制的，可访问行所对应的表必须是用户有读权限的。因此让所有用户都可以读此视图是安全的。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>schemaname</td>
<td>name</td>
<td>pg_namespace.nspname</td>
<td>包含表的模式名</td>
</tr>
<tr>
<td>tablename</td>
<td>name</td>
<td>pg_class.relname</td>
<td>表名</td>
</tr>
<tr>
<td>attname</td>
<td>name</td>
<td>pg_attribute.attname</td>
<td>被此行描述的列名</td>
</tr>
<tr>
<td>inherited</td>
<td>bool</td>
<td></td>
<td>如果为真，表示此行包括继承子列，不仅仅是指定表中的值</td>
</tr>
<tr>
<td>null_frac</td>
<td>real</td>
<td></td>
<td>列项中为空的比例</td>
</tr>
<tr>
<td>avg_width</td>
<td>integer</td>
<td></td>
<td>列项的平均字节宽度</td>
</tr>
<tr>
<td>n_distinct</td>
<td>real</td>
<td></td>
<td>如果大于零，表示列中可区分值的估计个数。如果小于零，是可区分值个数除以行数的负值（当ANALYZE认为可区分值的数量会随着表增长而增加时采用负值的形式，而如果认为列具有固定数量的可选值时采用正值的形式）。例如，-1表示一个唯一列，即其中可区分值的个数等于行数。</td>
</tr>
<tr>
<td>most_common_vals</td>
<td>anyarray</td>
<td></td>
<td>列中最常用值的一个列表（如果没有任何一个值看起来比其他值更常用，此列为空）</td>
</tr>
<tr>
<td>most_common_freqs</td>
<td>real[]</td>
<td></td>
<td>最常用值的频率列表，即每一个常用值的出现次数除以总行数（如果most_common_vals为空，则此列为空）</td>
</tr>
<tr>
<td>histogram_bounds</td>
<td>anyarray</td>
<td></td>
<td>将列值划分成大小接近的组的值列表。如果存在most_common_vals，其中的值会被直方图计算所忽略（如果列类型没有一个&lt;操作符或者most_common_vals等于整个值集合，则此列为空）</td>
</tr>
<tr>
<td>correlation</td>
<td>real</td>
<td></td>
<td>物理行顺序和列值逻辑顺序之间的统计关联。其范围从-1到+1。当值接近-1或+1时，在列上的一个索引扫描被认为比值接近0时的代价更低，因为这种情况减少了对磁盘的随机访问（如果列数据类型不具有一个&lt;操作符，则此列为空）</td>
</tr>
<tr>
<td>most_common_elems</td>
<td>anyarray</td>
<td></td>
<td>在列值中，最经常出现的非空元素列表（对标度类型为空）</td>
</tr>
<tr>
<td>most_common_elem_freqs</td>
<td>real[]</td>
<td></td>
<td>最常用元素值的频度列表，即含有至少一个给定值实例的行的分数。在每个元素的频度之后有二至三个附加值，它们是每个元素频度的最小和最大值，以及可选的空元素的频度（如果most_common_elems为空，则此列为空）</td>
</tr>
<tr>
<td>elem_count_histogram</td>
<td>real[]</td>
<td></td>
<td>在列值中可区分非空元素值计数的一个直方图，后面跟随可区分非空元素的平均数（对于标度类型为空）</td>
</tr>
</tbody>
</table>
<h4 id="pg_subscription"><strong>pg_subscription</strong></h4>
<p>pg_subscription包含所有现有的逻辑复制订阅。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择）</td>
</tr>
<tr>
<td>subdbid</td>
<td>oid</td>
<td>pg_database.oid</td>
<td>订阅所在的数据库的OID</td>
</tr>
<tr>
<td>subname</td>
<td>name</td>
<td></td>
<td>订阅的名称</td>
</tr>
<tr>
<td>subowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>订阅的拥有者</td>
</tr>
<tr>
<td>subenabled</td>
<td>bool</td>
<td></td>
<td>如果为真，订阅被启用并且应该被复制。</td>
</tr>
<tr>
<td>subsynccommit</td>
<td>text</td>
<td></td>
<td>包含订阅工作者的synchronous_commit设置的值。</td>
</tr>
<tr>
<td>subconninfo</td>
<td>text</td>
<td></td>
<td>到上游数据库的连接字符串</td>
</tr>
<tr>
<td>subslotname</td>
<td>name</td>
<td></td>
<td>上游数据库中的复制槽的名称。也被用于本地复制源名称。</td>
</tr>
<tr>
<td>subpublications</td>
<td>text[]</td>
<td></td>
<td>被订阅的publication名称的数组。这些引用的是发布者服务器上的publication。</td>
</tr>
</tbody>
</table>
<h4 id="pg_subscription_rel"><strong>pg_subscription_rel</strong></h4>
<p>pg_subscription_rel包含每个订阅中每个被复制关系的状态。这是一种多对多映射。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>srsubid</td>
<td>oid</td>
<td>pg_subscription.oid</td>
<td>对订阅的引用</td>
</tr>
<tr>
<td>srrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>对关系的引用</td>
</tr>
<tr>
<td>srsubstate</td>
<td>char</td>
<td></td>
<td>状态代码： i = 初始化， d = 数据正在被拷贝， s = 已同步， r = 准备好（普通复制）</td>
</tr>
<tr>
<td>srsublsn</td>
<td>pg_lsn</td>
<td></td>
<td>s和r状态的结束LSN。</td>
</tr>
</tbody>
</table>
<h4 id="pg_tables"><strong>pg_tables</strong></h4>
<p>视图pg_tables提供对数据库中每个表的信息的访问。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>schemaname</td>
<td>name</td>
<td>pg_namespace.nspname</td>
<td>包含表的模式名</td>
</tr>
<tr>
<td>tablename</td>
<td>name</td>
<td>pg_class.relname</td>
<td>表名</td>
</tr>
<tr>
<td>tableowner</td>
<td>name</td>
<td>pg_authid.rolname</td>
<td>表拥有者的名字</td>
</tr>
<tr>
<td>tablespace</td>
<td>name</td>
<td>pg_tablespace.spcname</td>
<td>包含表的表空间的名字（如果使用数据库的默认表空间，此列为空）</td>
</tr>
<tr>
<td>hasindexes</td>
<td>boolean</td>
<td>pg_class.relhasindex</td>
<td>如果表有（或最近有过）任何索引，此列为真</td>
</tr>
<tr>
<td>hasrules</td>
<td>boolean</td>
<td>pg_class.relhasrules</td>
<td>如果表有（或曾经有过）规则，此列为真</td>
</tr>
<tr>
<td>hastriggers</td>
<td>boolean</td>
<td>pg_class.relhastriggers</td>
<td>如果表有（或者曾经有过）触发器，此列为真</td>
</tr>
<tr>
<td>rowsecurity</td>
<td>boolean</td>
<td>pg_class.relrowsecurity</td>
<td>如果表上启用了行安全性则为真</td>
</tr>
</tbody>
</table>
<h4 id="pg_tablespace"><strong>pg_tablespace</strong></h4>
<p>pg_tablespace存储关于可用表空间的信息。表可以被放置在特定表空间中以实现磁盘布局的管理。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>spcname</td>
<td>name</td>
<td></td>
<td>表空间名</td>
</tr>
<tr>
<td>spcowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>表空间的拥有者，通常是创建它的用户</td>
</tr>
<tr>
<td>spcacl</td>
<td>aclitem[]</td>
<td></td>
<td>访问权限，详见GRANT和REVOKE</td>
</tr>
<tr>
<td>spcoptions</td>
<td>text[]</td>
<td></td>
<td>表空间级别的选项，形如“keyword=value”的字符串</td>
</tr>
</tbody>
</table>
<h4 id="pg_timezone_abbrevs"><strong>pg_timezone_abbrevs</strong></h4>
<p>视图pg_timezone_abbrevs提供了对当前被时间输入例程识别的时区缩写的列表。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>abbrev</td>
<td>text</td>
<td>时区缩写</td>
</tr>
<tr>
<td>utc_offset</td>
<td>interval</td>
<td>相对于UTC的偏移（正值表示格林威治东部）</td>
</tr>
<tr>
<td>is_dst</td>
<td>boolean</td>
<td>如果这是一个夏令时缩写，则为真</td>
</tr>
</tbody>
</table>
<h4 id="pg_timezone_names"><strong>pg_timezone_names</strong></h4>
<p>视图pg_timezone_names提供了一个被SET TIMEZONE识别的时区名字的列表，以及它们的相关缩写、UTC偏移和夏令时状态。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>text</td>
<td>时区名</td>
</tr>
<tr>
<td>abbrev</td>
<td>text</td>
<td>时区缩写</td>
</tr>
<tr>
<td>utc_offset</td>
<td>interval</td>
<td>相对于UTC的偏移（正值表示格林威治东部）</td>
</tr>
<tr>
<td>is_dst</td>
<td>boolean</td>
<td>如果当前保持为夏令时则为真</td>
</tr>
</tbody>
</table>
<h4 id="pg_transform"><strong>pg_transform</strong></h4>
<p>pg_transform存储有关转换的信息，转换是 一种让数据类型适应过程语言的机制。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>trftype</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>这个转换所针对的数据类型的 OID</td>
</tr>
<tr>
<td>trflang</td>
<td>oid</td>
<td>pg_language.oid</td>
<td>这个转换所针对的语言的 OID</td>
</tr>
<tr>
<td>trffromsql</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>一个函数的 OID，该函数用来将数据类型转换为过程语言的输入（例如 函数参数）。如果不支持这种操作，这里存储零。</td>
</tr>
<tr>
<td>trftosql</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>一个函数的 OID，该函数被用来转换过程语言的输出（例如返回值）为 该数据类型。如果不支持这种操作，这里存储零。</td>
</tr>
</tbody>
</table>
<h4 id="pg_trigger"><strong>pg_trigger</strong></h4>
<p>pg_trigger存储表和视图上的触发器</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>tgrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>触发器所在的表</td>
</tr>
<tr>
<td>tgname</td>
<td>name</td>
<td></td>
<td>触发器名（在同一个表的触发器中必须唯一）</td>
</tr>
<tr>
<td>tgfoid</td>
<td>oid</td>
<td>pg_proc.oid</td>
<td>要被触发器调用的函数</td>
</tr>
<tr>
<td>tgtype</td>
<td>int2</td>
<td></td>
<td>触发器触发条件的位掩码</td>
</tr>
<tr>
<td>tgenabled</td>
<td>char</td>
<td></td>
<td>控制触发器在session_replication_role模式中的触发。 O = 触发器在“origin”和“local”模式触发， D = 触发器被禁用， R = 触发器在“replica”模式触发， A = 触发器总是触发。</td>
</tr>
<tr>
<td>tgisinternal</td>
<td>bool</td>
<td></td>
<td>为真表示触发器是内部生成的（通常是为了强制由tgconstraint指定的约束）</td>
</tr>
<tr>
<td>tgconstrrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>被一个引用完整性约束引用的表</td>
</tr>
<tr>
<td>tgconstrindid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>支持一个唯一、主键、引用完整性约束或者排除约束的索引</td>
</tr>
<tr>
<td>tgconstraint</td>
<td>oid</td>
<td>pg_constraint.oid</td>
<td>可能存在的与触发器相关的pg_constraint项</td>
</tr>
<tr>
<td>tgdeferrable</td>
<td>bool</td>
<td></td>
<td>如果约束触发器可推迟则为真</td>
</tr>
<tr>
<td>tginitdeferred</td>
<td>bool</td>
<td></td>
<td>如果约束触发器初始可推迟则为真</td>
</tr>
<tr>
<td>tgnargs</td>
<td>int2</td>
<td></td>
<td>传递给触发器函数的参数字符串个数</td>
</tr>
<tr>
<td>tgattr</td>
<td>int2vector</td>
<td>pg_attribute.attnum</td>
<td>如果触发器是列限定的，这里存放列号；否则这是一个空数组</td>
</tr>
<tr>
<td>tgargs</td>
<td>bytea</td>
<td></td>
<td>传递给触发器的参数字符串，每一个都以NULL结尾</td>
</tr>
<tr>
<td>tgqual</td>
<td>pg_node_tree</td>
<td></td>
<td>触发器WHEN条件的表达式树（以nodeToString()的表现形式），如果没有则为空</td>
</tr>
<tr>
<td>tgoldtable</td>
<td>name</td>
<td></td>
<td>OLD TABLE的REFERENCING子句名称，如果没有则为空</td>
</tr>
<tr>
<td>tgnewtable</td>
<td>name</td>
<td></td>
<td>NEW TABLE的REFERENCING子句名称，如果没有则为空</td>
</tr>
</tbody>
</table>
<h4 id="pg_ts_config"><strong>pg_ts_config</strong></h4>
<p>pg_ts_config目录包含表示文本搜索配置的选项。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>cfgname</td>
<td>name</td>
<td></td>
<td>文本搜索配置名</td>
</tr>
<tr>
<td>cfgnamespace</td>
<td>oid</td>
<td>pg_namespace.oid</td>
<td>包含该配置的名字空间的OID</td>
</tr>
<tr>
<td>cfgowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>配置的拥有者</td>
</tr>
<tr>
<td>cfgparser</td>
<td>oid</td>
<td>pg_ts_parser.oid</td>
<td>该配置的文本搜索分析器的OID</td>
</tr>
</tbody>
</table>
<h4 id="pg_ts_config_map"><strong>pg_ts_config_map</strong></h4>
<p>pg_ts_config_map目录包含的项展示了对于每一个文本搜索配置的每一种输出记号类型，有哪些文本搜索字典可供查询以及以何种顺序。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>mapcfg</td>
<td>oid</td>
<td>pg_ts_config.oid</td>
<td>拥有该映射项的pg_ts_config项的OID</td>
</tr>
<tr>
<td>maptokentype</td>
<td>integer</td>
<td></td>
<td>一种由配置的分析器送出的记号类型</td>
</tr>
<tr>
<td>mapseqno</td>
<td>integer</td>
<td></td>
<td>查询该项的顺序（mapseqno值小的优先）</td>
</tr>
<tr>
<td>mapdict</td>
<td>oid</td>
<td>pg_ts_dict.oid</td>
<td>查询的文本搜索字典的OID</td>
</tr>
</tbody>
</table>
<h4 id="pg_ts_dict"><strong>pg_ts_dict</strong></h4>
<p>pg_ts_dict目录包含定义文本搜索字典的项。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>dictname</td>
<td>name</td>
<td></td>
<td>文本搜索字典名</td>
</tr>
<tr>
<td>dictnamespace</td>
<td>oid</td>
<td>pg_namespace.oid</td>
<td>包含该字典的名字空间OID</td>
</tr>
<tr>
<td>dictowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>字典的拥有者</td>
</tr>
<tr>
<td>dicttemplate</td>
<td>oid</td>
<td>pg_ts_template.oid</td>
<td>该字典的文本搜索模板的OID</td>
</tr>
<tr>
<td>dictinitoption</td>
<td>text</td>
<td></td>
<td>模板的初始化选项串</td>
</tr>
</tbody>
</table>
<h4 id="pg_ts_parser"><strong>pg_ts_parser</strong></h4>
<p>pg_ts_parser目录包含定义文本搜索分析器的项。一个分析器负责将输入文本分割成词位并为每一个词位分配一个记号类型。由于一个分析器必须用C语言级别的函数实现，创建新分析器的工作只限于数据库的超级用户。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>prsname</td>
<td>name</td>
<td></td>
<td>文本搜索分析器的名字</td>
</tr>
<tr>
<td>prsnamespace</td>
<td>oid</td>
<td>pg_namespace.oid</td>
<td>包含此分析器的名字空间的OID</td>
</tr>
<tr>
<td>prsstart</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>分析器启动函数的OID</td>
</tr>
<tr>
<td>prstoken</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>分析器的下一记号函数的OID</td>
</tr>
<tr>
<td>prsend</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>分析器的关闭函数的OID</td>
</tr>
<tr>
<td>prsheadline</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>分析器的大标题函数的OID</td>
</tr>
<tr>
<td>prslextype</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>分析器的词汇类型函数的OID</td>
</tr>
</tbody>
</table>
<h4 id="pg_ts_template"><strong>pg_ts_template</strong></h4>
<p>pg_ts_template目录包含定义文本搜索模板的项。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>tmplname</td>
<td>name</td>
<td></td>
<td>文本搜索模板的名字</td>
</tr>
<tr>
<td>tmplnamespace</td>
<td>oid</td>
<td>pg_namespace.oid</td>
<td>包含此模板的名字空间的OID</td>
</tr>
<tr>
<td>tmplinit</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>模板的初始化函数的OID</td>
</tr>
<tr>
<td>tmpllexize</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>模板的词汇化函数的OID</td>
</tr>
</tbody>
</table>
<h4 id="pg_type"><strong>pg_type</strong></h4>
<p>pg_type存储有关数据类型的信息。基类和枚举类型（标度类型）使用CREATE TYPE创建，而域使用CREATE DOMAIN创建。数据库中的每一个表都会有一个自动创建的组合类型，用于表示表的行结构。也可以使用CREATE TYPE AS创建组合类型。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>typname</td>
<td>name</td>
<td></td>
<td>数据类型的名字</td>
</tr>
<tr>
<td>typnamespace</td>
<td>oid</td>
<td>pg_namespace.oid</td>
<td>包含此类型的名字空间的OID</td>
</tr>
<tr>
<td>typowner</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>类型的拥有者</td>
</tr>
<tr>
<td>typlen</td>
<td>int2</td>
<td></td>
<td>对于一个固定尺寸的类型，typlen是该类型内部表示的字节数。对于一个变长类型，typlen为负值。-1表示一个“varlena”类型（具有长度字），-2表示一个以空值结尾的C字符串。</td>
</tr>
<tr>
<td>typbyval</td>
<td>bool</td>
<td></td>
<td>typbyval判断内部例程传递这个类型的数值时是通过传值还是传引用。如果typlen不是1、2或4（或者在Datum为8字节的机器上为8），因此typbyval最好是假。变长类型总是传引用。注意即使长度允许传值， typbyval也可以为假。</td>
</tr>
<tr>
<td>typtype</td>
<td>char</td>
<td></td>
<td>typtype可以是： b表示一个基类， c表示一个组合类型（例如一个表的行类型）， d表示一个域， e表示一个枚举类型， p表示一个伪类型，或 r表示一个范围类型。</td>
</tr>
<tr>
<td>typcategory</td>
<td>char</td>
<td></td>
<td>typcategory是一种任意的数据类型分类，它被分析器用来决定哪种隐式转换“更好”。参见下表。</td>
</tr>
<tr>
<td>typispreferred</td>
<td>bool</td>
<td></td>
<td>如果此类型在它的typcategory中是一个更好的转换目标，此列为真</td>
</tr>
<tr>
<td>typisdefined</td>
<td>bool</td>
<td></td>
<td>如果此类型已被定义则为真，如果此类型只是一个表示还未定义类型的占位符则为假。当typisdefined为假，除了类型名字、名字空间和OID之外什么都不能被依赖。</td>
</tr>
<tr>
<td>typdelim</td>
<td>char</td>
<td></td>
<td>在分析数组输入时，分隔两个此类型值的字符。注意该分隔符是与数组元素数据类型相关联的， 而不是和数组的数据类型关联。</td>
</tr>
<tr>
<td>typrelid</td>
<td>oid</td>
<td>pg_class.oid</td>
<td>如果这是一个复合类型， 那么这个列指向pg_class中定义对应表的项（对于自由存在的复合类型，pg_class项并不表示一个表，但不管怎样该类型的pg_attribute项需要链接到它）。对非复合类型此列为零。</td>
</tr>
<tr>
<td>typelem</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>如果typelem不为0，则它标识pg_type里面的另外一行。 当前类型可以被加上下标得到一个值为类型typelem的数组来描述。 一个“真的”数组类型是变长的（typlen = -1），但是一些定长的（typlen &gt; 0）类型也拥有非零的typelem，比如name和point。 如果一个定长类型拥有一个typelem， 则它的内部形式必须是某个typelem数据类型的值，不能有其它数据。变长数组类型有一个由该数组子例程定义的头。</td>
</tr>
<tr>
<td>typarray</td>
<td>oid</td>
<td>pg_type.oid</td>
<td>如果typarray不是0，则它标识pg_type中的另一行，这一行是一个将此类型作为元素的“真的”数组类型</td>
</tr>
<tr>
<td>typinput</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>输入转换函数（文本格式）</td>
</tr>
<tr>
<td>typoutput</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>输出转换函数（文本格式）</td>
</tr>
<tr>
<td>typreceive</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>输入转换函数（二进制格式），如果没有则为0</td>
</tr>
<tr>
<td>typsend</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>输出转换函数（二进制格式），如果没有则为0</td>
</tr>
<tr>
<td>typmodin</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>类型修改器输入函数，如果类型没有提供修改器则为0</td>
</tr>
<tr>
<td>typmodout</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>类型修改器输出函数，如果类型没有提供修改器则为0</td>
</tr>
<tr>
<td>typanalyze</td>
<td>regproc</td>
<td>pg_proc.oid</td>
<td>自定义ANALYZE函数，0表示使用标准函数</td>
</tr>
<tr>
<td>typalign</td>
<td>char</td>
<td></td>
<td>typalign是当存储此类型值时要求的对齐性质。它应用于磁盘存储以及该值在 PostgreSQL内部的大多数表现形式。 如果数值是连续存放的，比如在磁盘上的一个完整行，在这种类型的数据前会插入填充，这样它就可以按照指定边界存储。 对齐引用是该序列中第一个数据的开头。对齐引用是序列中第一个数据的开始。 可能的值有：c = char对齐，即不需要对齐。s = short对齐（在大部分机器上为2字节）。i = int对齐（在大部分机器上为4字节）。d = double对齐（在很多机器上为8字节，但绝不是全部）。</td>
</tr>
<tr>
<td>typstorage</td>
<td>char</td>
<td></td>
<td>如果一个变长类型（typlen = -1）可被TOAST，typstorage说明这种类型的列应采取的默认策略。可能的值是：p：值必须平面存储。e：值可以被存储在一个“二级”关系（如果有，见pg_class.reltoastrelid）。m：值可以被压缩线内存储。x：值可以被压缩线内存储或存储在“二级”存储。注意m列也可以被移动到二级存储，但只能是作为最后一种方案（e和x列会先被移动）。</td>
</tr>
<tr>
<td>typnotnull</td>
<td>bool</td>
<td></td>
<td>typnotnull表示类型上的一个非空约束。只用于域。</td>
</tr>
<tr>
<td>typbasetype</td>
<td>oid</td>
<td><a href="http://postgres.cn/docs/11/catalog-pg-type.html" title="52.62.?pg_type">pg_type</a>.oid</td>
<td>如果这是一个域，则typbasetype标识这个域基于的类。如果此类不是一个域则为0。</td>
</tr>
<tr>
<td>typtypmod</td>
<td>int4</td>
<td></td>
<td>域使用typtypmod来记录被应用于它们基类型的typmod（如果基类型不使用typmod，则为-1）。如果此类型不是一个域则为-1。</td>
</tr>
<tr>
<td>typndims</td>
<td>int4</td>
<td></td>
<td>对于一个数组上的域，typndims是数组维度数（即，typbasetype是一个数组类型）。除数组类型上的域之外的类型的此列为0。</td>
</tr>
<tr>
<td>typcollation</td>
<td>oid</td>
<td><a href="http://postgres.cn/docs/11/catalog-pg-collation.html" title="52.12.?pg_collation">pg_collation</a>.oid</td>
<td>typcollation指定此类型的排序规则。如果类型不支持排序规则，此列为0。一个支持排序规则的基类型此列值为DEFAULT_COLLATION_OID。如果一个可排序类型上的域被指定了一个排序规则，该域可能使用某些其他排序规则OID。</td>
</tr>
<tr>
<td>typdefaultbin</td>
<td>pg_node_tree</td>
<td></td>
<td>如果typdefaultbin为非空，那么它是 该类型默认表达式的nodeToString()表现形式。这个列只用于域。</td>
</tr>
<tr>
<td>typdefault</td>
<td>text</td>
<td></td>
<td>如果某类型没有相关默认值，那么typdefault为空。如果typdefaultbin不为空， 那么typdefault必须包含一个typdefaultbin所指的默认表达式的人类可读的版本。 如果typdefaultbin为空但typdefault不为空，则typdefault是该类型默认值的外部表现形式， 它可以被交给该类型的输入转换器来产生一个常量。</td>
</tr>
<tr>
<td>typacl</td>
<td>aclitem[]</td>
<td></td>
<td>访问权限，另请参阅<a href="http://postgres.cn/docs/11/sql-grant.html" title="GRANT">GRANT</a>和<a href="http://postgres.cn/docs/11/sql-revoke.html" title="REVOKE">REVOKE</a></td>
</tr>
</tbody>
</table>
<p>typcategory编码：</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>类别</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>数组类型</td>
</tr>
<tr>
<td>B</td>
<td>布尔类型</td>
</tr>
<tr>
<td>C</td>
<td>组合类型</td>
</tr>
<tr>
<td>D</td>
<td>日期/时间类型</td>
</tr>
<tr>
<td>E</td>
<td>枚举类型</td>
</tr>
<tr>
<td>G</td>
<td>几何类型</td>
</tr>
<tr>
<td>I</td>
<td>网络地址类型</td>
</tr>
<tr>
<td>N</td>
<td>数字类型</td>
</tr>
<tr>
<td>P</td>
<td>伪类型</td>
</tr>
<tr>
<td>R</td>
<td>范围类型</td>
</tr>
<tr>
<td>S</td>
<td>字符串类型</td>
</tr>
<tr>
<td>T</td>
<td>时间间隔类型</td>
</tr>
<tr>
<td>U</td>
<td>用户定义类型</td>
</tr>
<tr>
<td>V</td>
<td>位串类型</td>
</tr>
<tr>
<td>X</td>
<td>未知类型</td>
</tr>
</tbody>
</table>
<h4 id="pg_user"><strong>pg_user</strong></h4>
<p>视图pg_user提供关于数据库用户的信息。这是pg_shadow的一个公共可读的视图，它消除了口令域。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>usename</td>
<td>name</td>
<td>用户名</td>
</tr>
<tr>
<td>usesysid</td>
<td>oid</td>
<td>用户的ID</td>
</tr>
<tr>
<td>usecreatedb</td>
<td>bool</td>
<td>用户是否能创建数据库</td>
</tr>
<tr>
<td>usesuper</td>
<td>bool</td>
<td>用户是否为超级用户</td>
</tr>
<tr>
<td>userepl</td>
<td>bool</td>
<td>用户能否开启流复制以及将系统转入/转出备份模式。</td>
</tr>
<tr>
<td>usebypassrls</td>
<td>bool</td>
<td>用户能否绕过所有的行级安全性策略，详见 第 5.7 节。</td>
</tr>
<tr>
<td>passwd</td>
<td>text</td>
<td>不是口令（总是显示为）</td>
</tr>
<tr>
<td>valuntil</td>
<td>abstime</td>
<td>口令过期时间（只用于口令认证）</td>
</tr>
<tr>
<td>useconfig</td>
<td>text[]</td>
<td>运行时配置变量的会话默认值</td>
</tr>
</tbody>
</table>
<h4 id="pg_user_mapping"><strong>pg_user_mapping</strong></h4>
<p>pg_user_mapping存储从本地用户到远程的映射。对这个目录的访问对普通用户有限制，可使用视图pg_user_mappings替代。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>oid</td>
<td>oid</td>
<td></td>
<td>行标识符（隐藏属性，必须被显式选择才会显示）</td>
</tr>
<tr>
<td>umuser</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>将要被映射的本地角色的OID，如果用户映射是公共的则为0</td>
</tr>
<tr>
<td>umserver</td>
<td>oid</td>
<td>pg_foreign_server.oid</td>
<td>包含此映射的外部服务器的OID</td>
</tr>
<tr>
<td>umoptions</td>
<td>text[]</td>
<td></td>
<td>用户映射相关选项，以“keyword=value”字符串形式</td>
</tr>
</tbody>
</table>
<h4 id="pg_user_mappings"><strong>pg_user_mappings</strong></h4>
<p>视图pg_user_mappings提供有关用户映射的信息。这是pg_user_mapping的一个公共可读视图，它对无权使用的用户省去了选项域。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>umid</td>
<td>oid</td>
<td>pg_user_mapping.oid</td>
<td>用户映射的OID</td>
</tr>
<tr>
<td>srvid</td>
<td>oid</td>
<td>pg_foreign_server.oid</td>
<td>包含该映射的外部服务器的OID</td>
</tr>
<tr>
<td>srvname</td>
<td>name</td>
<td>pg_foreign_server.srvname</td>
<td>外部服务器名</td>
</tr>
<tr>
<td>umuser</td>
<td>oid</td>
<td>pg_authid.oid</td>
<td>将被映射的本地角色的OID，如果用户映射是公共的则为0</td>
</tr>
<tr>
<td>usename</td>
<td>name</td>
<td></td>
<td>将被映射的本地用户名</td>
</tr>
<tr>
<td>umoptions</td>
<td>text[]</td>
<td></td>
<td>用户映射指定选项，以“keyword=value”字符串的形式</td>
</tr>
</tbody>
</table>
<p>​              </p>
<h4 id="pg_views"><strong>pg_views</strong></h4>
<p>视图pg_views提供了数据库中每个视图的信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>引用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>schemaname</td>
<td>name</td>
<td>pg_namespace.nspname</td>
<td>包含视图的模式名</td>
</tr>
<tr>
<td>viewname</td>
<td>name</td>
<td>pg_class.relname</td>
<td>视图名称</td>
</tr>
<tr>
<td>viewowner</td>
<td>name</td>
<td>pg_authid.rolname</td>
<td>视图拥有者的名字</td>
</tr>
<tr>
<td>definition</td>
<td>text</td>
<td></td>
<td>视图定义（一个重构的SELECT查询）</td>
</tr>
</tbody>
</table>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      © 2024 贝格迈思
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.aecac24b.min.js"></script>
      
        <script src="../../javascripts/extra.js"></script>
      
    
  </body>
</html>